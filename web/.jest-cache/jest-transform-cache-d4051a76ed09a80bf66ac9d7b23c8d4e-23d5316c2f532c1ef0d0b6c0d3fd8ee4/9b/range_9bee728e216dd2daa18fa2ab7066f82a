1d6c071b0960a400397dd78831c816f3
/**
 * Range Voting Strategy
 * 
 * Implements range voting where voters rate each option on a scale.
 * Results show average ratings for each option, with the highest rated option winning.
 * 
 * Created: September 15, 2025
 * Updated: September 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RangeStrategy", {
    enumerable: true,
    get: function() {
        return RangeStrategy;
    }
});
const _logger = require("../../utils/logger");
class RangeStrategy {
    getVotingMethod() {
        return "range";
    }
    async validateVote(request, poll) {
        try {
            const voteData = request.voteData;
            // Validate ratings object exists
            if (!voteData.ratings || typeof voteData.ratings !== "object") {
                return {
                    valid: false,
                    isValid: false,
                    error: "Range voting requires ratings",
                    errors: [
                        "Range voting requires ratings"
                    ],
                    requiresAuthentication: false,
                    requiresTokens: false
                };
            }
            // Validate ratings are numbers within range
            const ratings = voteData.ratings;
            const minRating = poll.settings?.minRating || 0;
            const maxRating = poll.settings?.maxRating || 10;
            for (const [optionId, rating] of Object.entries(ratings)){
                if (typeof rating !== "number") {
                    return {
                        valid: false,
                        isValid: false,
                        error: "Ratings must be numbers",
                        errors: [
                            "Ratings must be numbers"
                        ],
                        requiresAuthentication: false,
                        requiresTokens: false
                    };
                }
                if (rating < minRating || rating > maxRating) {
                    return {
                        valid: false,
                        isValid: false,
                        error: `Ratings must be between ${minRating} and ${maxRating}`,
                        errors: [
                            `Ratings must be between ${minRating} and ${maxRating}`
                        ],
                        requiresAuthentication: false,
                        requiresTokens: false
                    };
                }
                // Check if option exists
                const optionExists = poll.options.some((option)=>option.id === optionId);
                if (!optionExists) {
                    return {
                        valid: false,
                        isValid: false,
                        error: "Invalid option selected",
                        errors: [
                            "Invalid option selected"
                        ],
                        requiresAuthentication: false,
                        requiresTokens: false
                    };
                }
            }
            (0, _logger.devLog)("Range vote validated successfully", {
                pollId: request.pollId,
                ratings: voteData.ratings,
                userId: request.userId
            });
            return {
                valid: true,
                isValid: true,
                requiresAuthentication: false,
                requiresTokens: false
            };
        } catch (error) {
            (0, _logger.devLog)("Range vote validation error:", error);
            return {
                valid: false,
                isValid: false,
                error: "Range vote validation failed",
                errors: [
                    "Range vote validation failed"
                ],
                requiresAuthentication: false,
                requiresTokens: false
            };
        }
    }
    async processVote(request, poll) {
        try {
            const voteData = request.voteData;
            // Create vote data for storage
            const voteRecord = {
                id: `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                pollId: request.pollId,
                userId: request.userId,
                voteData: {
                    ratings: voteData.ratings
                },
                timestamp: new Date().toISOString(),
                ipAddress: request.ipAddress,
                userAgent: request.userAgent
            };
            (0, _logger.devLog)("Range vote processed successfully", {
                pollId: request.pollId,
                userId: request.userId,
                ratings: voteData.ratings,
                voteId: voteRecord.id
            });
            return {
                success: true,
                voteId: voteRecord.id,
                message: "Vote recorded successfully",
                pollId: request.pollId
            };
        } catch (error) {
            (0, _logger.devLog)("Range vote processing error:", error);
            return {
                success: false,
                error: "Failed to process range vote",
                message: "Failed to process range vote",
                pollId: request.pollId
            };
        }
    }
    async calculateResults(poll, votes) {
        try {
            const startTime = Date.now();
            // Initialize tracking objects
            const totalRatings = {};
            const ratingCounts = {};
            const averageRatings = {};
            const optionVotes = {};
            const optionPercentages = {};
            // Initialize all options with zero scores
            poll.options.forEach((option)=>{
                totalRatings[option.id] = 0;
                ratingCounts[option.id] = 0;
                averageRatings[option.id] = 0;
                optionVotes[option.id] = 0;
                optionPercentages[option.id] = 0;
            });
            // Process each vote
            votes.forEach((vote)=>{
                if (vote.voteData.ratings) {
                    Object.entries(vote.voteData.ratings).forEach(([optionId, rating])=>{
                        if (typeof rating === "number") {
                            totalRatings[optionId] += rating;
                            ratingCounts[optionId]++;
                            optionVotes[optionId]++;
                        }
                    });
                }
            });
            // Calculate average ratings
            Object.keys(totalRatings).forEach((optionId)=>{
                if (ratingCounts[optionId] > 0) {
                    averageRatings[optionId] = totalRatings[optionId] / ratingCounts[optionId];
                }
            });
            const totalVotes = votes.length;
            // Calculate percentages
            if (totalVotes > 0) {
                Object.keys(optionVotes).forEach((optionId)=>{
                    const votes = optionVotes[optionId];
                    optionPercentages[optionId] = votes / totalVotes * 100;
                });
            }
            // Find winner (highest average rating)
            let winner;
            let winnerVotes = 0;
            let winnerPercentage = 0;
            if (totalVotes > 0) {
                Object.entries(averageRatings).forEach(([optionId, rating])=>{
                    if (rating > winnerVotes) {
                        winner = optionId;
                        winnerVotes = rating;
                        winnerPercentage = optionPercentages[optionId] || 0;
                    }
                });
            }
            const results = {
                winner,
                winnerVotes,
                winnerPercentage,
                optionVotes,
                optionPercentages,
                abstentions: 0,
                abstentionPercentage: 0
            };
            (0, _logger.devLog)("Range results calculated", {
                pollId: poll.id,
                totalVotes,
                winner,
                winnerVotes,
                winnerPercentage,
                calculationTime: Date.now() - startTime
            });
            return {
                pollId: poll.id,
                votingMethod: poll.votingMethod,
                totalVotes,
                participationRate: totalVotes / 100,
                results,
                calculatedAt: new Date().toISOString(),
                metadata: {
                    calculationTime: Date.now() - startTime,
                    method: "range"
                }
            };
        } catch (error) {
            (0, _logger.devLog)("Range results calculation error:", error);
            // Return empty results on error
            return {
                pollId: poll.id,
                votingMethod: poll.votingMethod,
                totalVotes: 0,
                participationRate: 0,
                results: {
                    winner: undefined,
                    winnerVotes: 0,
                    winnerPercentage: 0,
                    optionVotes: {},
                    optionPercentages: {},
                    abstentions: 0,
                    abstentionPercentage: 0
                },
                calculatedAt: new Date().toISOString(),
                metadata: {
                    calculationTime: 0,
                    error: error instanceof Error ? error.message : "Unknown error"
                }
            };
        }
    }
    getConfiguration() {
        return {
            method: "range",
            description: "Voters rate each option on a scale",
            allowsMultipleSelections: true,
            requiresRanking: false,
            maxSelections: "all options",
            ratingScale: "configurable"
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvdm90ZS9zdHJhdGVnaWVzL3JhbmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmFuZ2UgVm90aW5nIFN0cmF0ZWd5XG4gKiBcbiAqIEltcGxlbWVudHMgcmFuZ2Ugdm90aW5nIHdoZXJlIHZvdGVycyByYXRlIGVhY2ggb3B0aW9uIG9uIGEgc2NhbGUuXG4gKiBSZXN1bHRzIHNob3cgYXZlcmFnZSByYXRpbmdzIGZvciBlYWNoIG9wdGlvbiwgd2l0aCB0aGUgaGlnaGVzdCByYXRlZCBvcHRpb24gd2lubmluZy5cbiAqIFxuICogQ3JlYXRlZDogU2VwdGVtYmVyIDE1LCAyMDI1XG4gKiBVcGRhdGVkOiBTZXB0ZW1iZXIgMTUsIDIwMjVcbiAqL1xuXG5pbXBvcnQgeyBkZXZMb2cgfSBmcm9tICdAL2xpYi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgd2l0aE9wdGlvbmFsIH0gZnJvbSAnQC9saWIvdXRpbHMvb2JqZWN0cyc7XG5cbmltcG9ydCB0eXBlIHsgXG4gIFZvdGluZ1N0cmF0ZWd5LCBcbiAgVm90ZVJlcXVlc3QsIFxuICBWb3RlUmVzcG9uc2UsIFxuICBWb3RlVmFsaWRhdGlvbiwgXG4gIFBvbGxEYXRhLCBcbiAgVm90ZURhdGEsIFxuICBSZXN1bHRzRGF0YSxcbiAgVm90aW5nTWV0aG9kLFxuICBQb2xsUmVzdWx0c1xufSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBSYW5nZVN0cmF0ZWd5IGltcGxlbWVudHMgVm90aW5nU3RyYXRlZ3kge1xuICBcbiAgZ2V0Vm90aW5nTWV0aG9kKCk6IFZvdGluZ01ldGhvZCB7XG4gICAgcmV0dXJuICdyYW5nZSc7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVZvdGUocmVxdWVzdDogVm90ZVJlcXVlc3QsIHBvbGw6IFBvbGxEYXRhKTogUHJvbWlzZTxWb3RlVmFsaWRhdGlvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2b3RlRGF0YSA9IHJlcXVlc3Qudm90ZURhdGE7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHJhdGluZ3Mgb2JqZWN0IGV4aXN0c1xuICAgICAgaWYgKCF2b3RlRGF0YS5yYXRpbmdzIHx8IHR5cGVvZiB2b3RlRGF0YS5yYXRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1JhbmdlIHZvdGluZyByZXF1aXJlcyByYXRpbmdzJyxcbiAgICAgICAgICBlcnJvcnM6IFsnUmFuZ2Ugdm90aW5nIHJlcXVpcmVzIHJhdGluZ3MnXSxcbiAgICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgcmF0aW5ncyBhcmUgbnVtYmVycyB3aXRoaW4gcmFuZ2VcbiAgICAgIGNvbnN0IHJhdGluZ3MgPSB2b3RlRGF0YS5yYXRpbmdzO1xuICAgICAgY29uc3QgbWluUmF0aW5nID0gcG9sbC5zZXR0aW5ncz8ubWluUmF0aW5nIHx8IDA7XG4gICAgICBjb25zdCBtYXhSYXRpbmcgPSBwb2xsLnNldHRpbmdzPy5tYXhSYXRpbmcgfHwgMTA7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgW29wdGlvbklkLCByYXRpbmddIG9mIE9iamVjdC5lbnRyaWVzKHJhdGluZ3MpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmF0aW5nICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnUmF0aW5ncyBtdXN0IGJlIG51bWJlcnMnLFxuICAgICAgICAgICAgZXJyb3JzOiBbJ1JhdGluZ3MgbXVzdCBiZSBudW1iZXJzJ10sXG4gICAgICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVpcmVzVG9rZW5zOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyYXRpbmcgPCBtaW5SYXRpbmcgfHwgcmF0aW5nID4gbWF4UmF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGBSYXRpbmdzIG11c3QgYmUgYmV0d2VlbiAke21pblJhdGluZ30gYW5kICR7bWF4UmF0aW5nfWAsXG4gICAgICAgICAgICBlcnJvcnM6IFtgUmF0aW5ncyBtdXN0IGJlIGJldHdlZW4gJHttaW5SYXRpbmd9IGFuZCAke21heFJhdGluZ31gXSxcbiAgICAgICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgb3B0aW9uIGV4aXN0c1xuICAgICAgICBjb25zdCBvcHRpb25FeGlzdHMgPSBwb2xsLm9wdGlvbnMuc29tZShvcHRpb24gPT4gb3B0aW9uLmlkID09PSBvcHRpb25JZCk7XG4gICAgICAgIGlmICghb3B0aW9uRXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIG9wdGlvbiBzZWxlY3RlZCcsXG4gICAgICAgICAgICBlcnJvcnM6IFsnSW52YWxpZCBvcHRpb24gc2VsZWN0ZWQnXSxcbiAgICAgICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXZMb2coJ1JhbmdlIHZvdGUgdmFsaWRhdGVkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkOiByZXF1ZXN0LnBvbGxJZCxcbiAgICAgICAgcmF0aW5nczogdm90ZURhdGEucmF0aW5ncyxcbiAgICAgICAgdXNlcklkOiByZXF1ZXN0LnVzZXJJZFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnUmFuZ2Ugdm90ZSB2YWxpZGF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnUmFuZ2Ugdm90ZSB2YWxpZGF0aW9uIGZhaWxlZCcsXG4gICAgICAgIGVycm9yczogWydSYW5nZSB2b3RlIHZhbGlkYXRpb24gZmFpbGVkJ10sXG4gICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc1ZvdGUocmVxdWVzdDogVm90ZVJlcXVlc3QsIHBvbGw6IFBvbGxEYXRhKTogUHJvbWlzZTxWb3RlUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgdm90ZURhdGEgPSByZXF1ZXN0LnZvdGVEYXRhO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdm90ZSBkYXRhIGZvciBzdG9yYWdlXG4gICAgICBjb25zdCB2b3RlUmVjb3JkOiBWb3RlRGF0YSA9IHtcbiAgICAgICAgaWQ6IGB2b3RlXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcbiAgICAgICAgcG9sbElkOiByZXF1ZXN0LnBvbGxJZCxcbiAgICAgICAgdXNlcklkOiByZXF1ZXN0LnVzZXJJZCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICByYXRpbmdzOiB2b3RlRGF0YS5yYXRpbmdzXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBpcEFkZHJlc3M6IHJlcXVlc3QuaXBBZGRyZXNzLFxuICAgICAgICB1c2VyQWdlbnQ6IHJlcXVlc3QudXNlckFnZW50XG4gICAgICB9O1xuXG4gICAgICBkZXZMb2coJ1JhbmdlIHZvdGUgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkOiByZXF1ZXN0LnBvbGxJZCxcbiAgICAgICAgdXNlcklkOiByZXF1ZXN0LnVzZXJJZCxcbiAgICAgICAgcmF0aW5nczogdm90ZURhdGEucmF0aW5ncyxcbiAgICAgICAgdm90ZUlkOiB2b3RlUmVjb3JkLmlkXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdm90ZUlkOiB2b3RlUmVjb3JkLmlkLFxuICAgICAgICBtZXNzYWdlOiAnVm90ZSByZWNvcmRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgICBwb2xsSWQ6IHJlcXVlc3QucG9sbElkXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnUmFuZ2Ugdm90ZSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBwcm9jZXNzIHJhbmdlIHZvdGUnLFxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHByb2Nlc3MgcmFuZ2Ugdm90ZScsXG4gICAgICAgIHBvbGxJZDogcmVxdWVzdC5wb2xsSWRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY2FsY3VsYXRlUmVzdWx0cyhwb2xsOiBQb2xsRGF0YSwgdm90ZXM6IFZvdGVEYXRhW10pOiBQcm9taXNlPFJlc3VsdHNEYXRhPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgdHJhY2tpbmcgb2JqZWN0c1xuICAgICAgY29uc3QgdG90YWxSYXRpbmdzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBjb25zdCByYXRpbmdDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIGNvbnN0IGF2ZXJhZ2VSYXRpbmdzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBjb25zdCBvcHRpb25Wb3RlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgY29uc3Qgb3B0aW9uUGVyY2VudGFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgb3B0aW9ucyB3aXRoIHplcm8gc2NvcmVzXG4gICAgICBwb2xsLm9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICB0b3RhbFJhdGluZ3Nbb3B0aW9uLmlkXSA9IDA7XG4gICAgICAgIHJhdGluZ0NvdW50c1tvcHRpb24uaWRdID0gMDtcbiAgICAgICAgYXZlcmFnZVJhdGluZ3Nbb3B0aW9uLmlkXSA9IDA7XG4gICAgICAgIG9wdGlvblZvdGVzW29wdGlvbi5pZF0gPSAwO1xuICAgICAgICBvcHRpb25QZXJjZW50YWdlc1tvcHRpb24uaWRdID0gMDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggdm90ZVxuICAgICAgdm90ZXMuZm9yRWFjaCh2b3RlID0+IHtcbiAgICAgICAgaWYgKHZvdGUudm90ZURhdGEucmF0aW5ncykge1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZvdGUudm90ZURhdGEucmF0aW5ncykuZm9yRWFjaCgoW29wdGlvbklkLCByYXRpbmddKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhdGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdG90YWxSYXRpbmdzW29wdGlvbklkXSArPSByYXRpbmc7XG4gICAgICAgICAgICAgIHJhdGluZ0NvdW50c1tvcHRpb25JZF0rKztcbiAgICAgICAgICAgICAgb3B0aW9uVm90ZXNbb3B0aW9uSWRdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSByYXRpbmdzXG4gICAgICBPYmplY3Qua2V5cyh0b3RhbFJhdGluZ3MpLmZvckVhY2gob3B0aW9uSWQgPT4ge1xuICAgICAgICBpZiAocmF0aW5nQ291bnRzW29wdGlvbklkXSA+IDApIHtcbiAgICAgICAgICBhdmVyYWdlUmF0aW5nc1tvcHRpb25JZF0gPSB0b3RhbFJhdGluZ3Nbb3B0aW9uSWRdIC8gcmF0aW5nQ291bnRzW29wdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRvdGFsVm90ZXMgPSB2b3Rlcy5sZW5ndGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlc1xuICAgICAgaWYgKHRvdGFsVm90ZXMgPiAwKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvblZvdGVzKS5mb3JFYWNoKG9wdGlvbklkID0+IHtcbiAgICAgICAgICBjb25zdCB2b3RlcyA9IG9wdGlvblZvdGVzW29wdGlvbklkXTtcbiAgICAgICAgICBvcHRpb25QZXJjZW50YWdlc1tvcHRpb25JZF0gPSAodm90ZXMgLyB0b3RhbFZvdGVzKSAqIDEwMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgd2lubmVyIChoaWdoZXN0IGF2ZXJhZ2UgcmF0aW5nKVxuICAgICAgbGV0IHdpbm5lcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IHdpbm5lclZvdGVzID0gMDtcbiAgICAgIGxldCB3aW5uZXJQZXJjZW50YWdlID0gMDtcblxuICAgICAgaWYgKHRvdGFsVm90ZXMgPiAwKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGF2ZXJhZ2VSYXRpbmdzKS5mb3JFYWNoKChbb3B0aW9uSWQsIHJhdGluZ10pID0+IHtcbiAgICAgICAgICBpZiAocmF0aW5nID4gd2lubmVyVm90ZXMpIHtcbiAgICAgICAgICAgIHdpbm5lciA9IG9wdGlvbklkO1xuICAgICAgICAgICAgd2lubmVyVm90ZXMgPSByYXRpbmc7XG4gICAgICAgICAgICB3aW5uZXJQZXJjZW50YWdlID0gb3B0aW9uUGVyY2VudGFnZXNbb3B0aW9uSWRdIHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0czogUG9sbFJlc3VsdHMgPSB7XG4gICAgICAgIHdpbm5lcixcbiAgICAgICAgd2lubmVyVm90ZXMsXG4gICAgICAgIHdpbm5lclBlcmNlbnRhZ2UsXG4gICAgICAgIG9wdGlvblZvdGVzLFxuICAgICAgICBvcHRpb25QZXJjZW50YWdlcyxcbiAgICAgICAgYWJzdGVudGlvbnM6IDAsXG4gICAgICAgIGFic3RlbnRpb25QZXJjZW50YWdlOiAwXG4gICAgICB9O1xuXG4gICAgICBkZXZMb2coJ1JhbmdlIHJlc3VsdHMgY2FsY3VsYXRlZCcsIHtcbiAgICAgICAgcG9sbElkOiBwb2xsLmlkLFxuICAgICAgICB0b3RhbFZvdGVzLFxuICAgICAgICB3aW5uZXIsXG4gICAgICAgIHdpbm5lclZvdGVzLFxuICAgICAgICB3aW5uZXJQZXJjZW50YWdlLFxuICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2xsSWQ6IHBvbGwuaWQsXG4gICAgICAgIHZvdGluZ01ldGhvZDogcG9sbC52b3RpbmdNZXRob2QsXG4gICAgICAgIHRvdGFsVm90ZXMsXG4gICAgICAgIHBhcnRpY2lwYXRpb25SYXRlOiB0b3RhbFZvdGVzIC8gMTAwLCAvLyBNb2NrIHBhcnRpY2lwYXRpb24gcmF0ZVxuICAgICAgICByZXN1bHRzLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgbWV0aG9kOiAncmFuZ2UnXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2TG9nKCdSYW5nZSByZXN1bHRzIGNhbGN1bGF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGVtcHR5IHJlc3VsdHMgb24gZXJyb3JcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvbGxJZDogcG9sbC5pZCxcbiAgICAgICAgdm90aW5nTWV0aG9kOiBwb2xsLnZvdGluZ01ldGhvZCxcbiAgICAgICAgdG90YWxWb3RlczogMCxcbiAgICAgICAgcGFydGljaXBhdGlvblJhdGU6IDAsXG4gICAgICAgIHJlc3VsdHM6IHtcbiAgICAgICAgICB3aW5uZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3aW5uZXJWb3RlczogMCxcbiAgICAgICAgICB3aW5uZXJQZXJjZW50YWdlOiAwLFxuICAgICAgICAgIG9wdGlvblZvdGVzOiB7fSxcbiAgICAgICAgICBvcHRpb25QZXJjZW50YWdlczoge30sXG4gICAgICAgICAgYWJzdGVudGlvbnM6IDAsXG4gICAgICAgICAgYWJzdGVudGlvblBlcmNlbnRhZ2U6IDBcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY3VsYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY2FsY3VsYXRpb25UaW1lOiAwLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGdldENvbmZpZ3VyYXRpb24oKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6ICdyYW5nZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ1ZvdGVycyByYXRlIGVhY2ggb3B0aW9uIG9uIGEgc2NhbGUnLFxuICAgICAgYWxsb3dzTXVsdGlwbGVTZWxlY3Rpb25zOiB0cnVlLFxuICAgICAgcmVxdWlyZXNSYW5raW5nOiBmYWxzZSxcbiAgICAgIG1heFNlbGVjdGlvbnM6ICdhbGwgb3B0aW9ucycsXG4gICAgICByYXRpbmdTY2FsZTogJ2NvbmZpZ3VyYWJsZSdcbiAgICB9O1xuICB9XG59Il0sIm5hbWVzIjpbIlJhbmdlU3RyYXRlZ3kiLCJnZXRWb3RpbmdNZXRob2QiLCJ2YWxpZGF0ZVZvdGUiLCJyZXF1ZXN0IiwicG9sbCIsInZvdGVEYXRhIiwicmF0aW5ncyIsInZhbGlkIiwiaXNWYWxpZCIsImVycm9yIiwiZXJyb3JzIiwicmVxdWlyZXNBdXRoZW50aWNhdGlvbiIsInJlcXVpcmVzVG9rZW5zIiwibWluUmF0aW5nIiwic2V0dGluZ3MiLCJtYXhSYXRpbmciLCJvcHRpb25JZCIsInJhdGluZyIsIk9iamVjdCIsImVudHJpZXMiLCJvcHRpb25FeGlzdHMiLCJvcHRpb25zIiwic29tZSIsIm9wdGlvbiIsImlkIiwiZGV2TG9nIiwicG9sbElkIiwidXNlcklkIiwicHJvY2Vzc1ZvdGUiLCJ2b3RlUmVjb3JkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwiaXBBZGRyZXNzIiwidXNlckFnZW50Iiwidm90ZUlkIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjYWxjdWxhdGVSZXN1bHRzIiwidm90ZXMiLCJzdGFydFRpbWUiLCJ0b3RhbFJhdGluZ3MiLCJyYXRpbmdDb3VudHMiLCJhdmVyYWdlUmF0aW5ncyIsIm9wdGlvblZvdGVzIiwib3B0aW9uUGVyY2VudGFnZXMiLCJmb3JFYWNoIiwidm90ZSIsImtleXMiLCJ0b3RhbFZvdGVzIiwibGVuZ3RoIiwid2lubmVyIiwid2lubmVyVm90ZXMiLCJ3aW5uZXJQZXJjZW50YWdlIiwicmVzdWx0cyIsImFic3RlbnRpb25zIiwiYWJzdGVudGlvblBlcmNlbnRhZ2UiLCJjYWxjdWxhdGlvblRpbWUiLCJ2b3RpbmdNZXRob2QiLCJwYXJ0aWNpcGF0aW9uUmF0ZSIsImNhbGN1bGF0ZWRBdCIsIm1ldGFkYXRhIiwibWV0aG9kIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJnZXRDb25maWd1cmF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbGxvd3NNdWx0aXBsZVNlbGVjdGlvbnMiLCJyZXF1aXJlc1JhbmtpbmciLCJtYXhTZWxlY3Rpb25zIiwicmF0aW5nU2NhbGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7OytCQWlCWUE7OztlQUFBQTs7O3dCQWZVO0FBZWhCLE1BQU1BO0lBRVhDLGtCQUFnQztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxhQUFhQyxPQUFvQixFQUFFQyxJQUFjLEVBQTJCO1FBQ2hGLElBQUk7WUFDRixNQUFNQyxXQUFXRixRQUFRRSxRQUFRO1lBRWpDLGlDQUFpQztZQUNqQyxJQUFJLENBQUNBLFNBQVNDLE9BQU8sSUFBSSxPQUFPRCxTQUFTQyxPQUFPLEtBQUssVUFBVTtnQkFDN0QsT0FBTztvQkFDTEMsT0FBTztvQkFDUEMsU0FBUztvQkFDVEMsT0FBTztv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