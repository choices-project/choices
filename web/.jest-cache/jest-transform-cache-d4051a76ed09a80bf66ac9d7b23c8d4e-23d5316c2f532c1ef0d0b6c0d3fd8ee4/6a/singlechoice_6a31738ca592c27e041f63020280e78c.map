{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/strategies/single-choice.ts"],"sourcesContent":["/**\n * Single Choice Voting Strategy\n * \n * Implements single-choice voting where voters select exactly one option.\n * Results show the option with the most votes as the winner.\n * \n * Created: September 15, 2025\n * Updated: September 15, 2025\n */\n\nimport { devLog } from '@/lib/utils/logger';\nimport { withOptional } from '@/lib/utils/objects';\n\nimport type { \n  VotingStrategy, \n  VoteRequest, \n  VoteResponse, \n  VoteValidation, \n  PollData, \n  VoteData, \n  ResultsData,\n  VotingMethod,\n  PollResults\n} from '../types';\n\nexport class SingleChoiceStrategy implements VotingStrategy {\n  \n  getVotingMethod(): VotingMethod {\n    return 'single';\n  }\n\n  validateVote(request: VoteRequest, poll: PollData): VoteValidation {\n    try {\n      const { voteData } = request;\n      \n      // Check if choice is provided\n      if (voteData.choice === undefined || voteData.choice === null) {\n        return {\n          valid: false,\n          errors: ['Choice is required for single-choice voting'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Validate choice is a number\n      if (typeof voteData.choice !== 'number' || !Number.isInteger(voteData.choice)) {\n        return {\n          valid: false,\n          errors: ['Choice must be a valid integer'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Validate choice is within valid range\n      if (voteData.choice < 0 || voteData.choice >= poll.options.length) {\n        return {\n          valid: false,\n          errors: ['Invalid option selected'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Check if user has already voted (if not allowing multiple votes)\n      if (!poll.settings?.allowMultipleVotes && request.userId) {\n        // This would typically check the database, but for now we'll assume it's valid\n        // In a real implementation, you'd query the votes table here\n      }\n\n      devLog('Single choice vote validated successfully', {\n        pollId: request.pollId,\n        choice: voteData.choice,\n        userId: request.userId\n      });\n\n      return {\n        valid: true,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n\n    } catch (error) {\n      devLog('Single choice vote validation error:', error);\n      return {\n        valid: false,\n        errors: [error instanceof Error ? error.message : 'Validation failed'],\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n  }\n\n  processVote(request: VoteRequest, poll: PollData): VoteResponse {\n    try {\n      const { voteData, userId, pollId, privacyLevel } = request;\n      \n      // Generate vote ID\n      const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create audit receipt\n      const auditReceipt = `receipt_${voteId}_${Date.now()}`;\n\n      // In a real implementation, this would:\n      // 1. Store the vote in the database\n      // 2. Update poll vote counts\n      // 3. Trigger any necessary notifications\n      // 4. Log the vote for audit purposes\n\n      devLog('Single choice vote processed successfully', {\n        pollId,\n        voteId,\n        choice: voteData.choice,\n        userId,\n        auditReceipt\n      });\n\n      return {\n        success: true,\n        message: 'Vote submitted successfully',\n        pollId,\n        voteId,\n        auditReceipt,\n        responseTime: 0, // Will be set by the engine\n        timestamp: new Date().toISOString(),\n        metadata: {\n          votingMethod: 'single',\n          choice: voteData.choice,\n          optionText: poll.options[voteData.choice || 0]\n        },\n        privacyLevel\n      };\n\n    } catch (error) {\n      devLog('Single choice vote processing error:', error);\n      return withOptional(\n        {\n          success: false,\n          message: error instanceof Error ? error.message : 'Vote processing failed',\n          pollId: request.pollId,\n          responseTime: 0,\n          metadata: {\n            votingMethod: 'single',\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        },\n        {\n          voteId: undefined,\n          auditReceipt: undefined,\n          privacyLevel: request.privacyLevel\n        }\n      );\n    }\n  }\n\n  async calculateResults(poll: PollData, votes: VoteData[]): Promise<ResultsData> {\n    try {\n      const startTime = Date.now();\n      \n      // Count votes for each option\n      const optionVotes: Record<string, number> = {};\n      const optionPercentages: Record<string, number> = {};\n      \n      // Initialize vote counts\n      poll.options.forEach((_, index) => {\n        optionVotes[index.toString()] = 0;\n        optionPercentages[index.toString()] = 0;\n      });\n\n      // Count votes\n      let totalVotes = 0;\n      votes.forEach(vote => {\n        if (vote.choice !== undefined && vote.choice >= 0 && vote.choice < poll.options.length) {\n          const choiceKey = vote.choice.toString();\n          if (optionVotes[choiceKey] !== undefined) {\n            optionVotes[choiceKey]++;\n            totalVotes++;\n          }\n        }\n      });\n\n      // Calculate percentages\n      if (totalVotes > 0) {\n        Object.keys(optionVotes).forEach(optionIndex => {\n          const votes = optionVotes[optionIndex];\n          if (votes !== undefined) {\n            optionPercentages[optionIndex] = (votes / totalVotes) * 100;\n          }\n        });\n      }\n\n      // Find winner\n      let winner: string | undefined;\n      let winnerVotes = 0;\n      let winnerPercentage = 0;\n\n      if (totalVotes > 0) {\n        Object.entries(optionVotes).forEach(([optionIndex, votes]) => {\n          if (votes > winnerVotes) {\n            winner = optionIndex;\n            winnerVotes = votes;\n            winnerPercentage = optionPercentages[optionIndex] ?? 0;\n          }\n        });\n      }\n\n      const results: PollResults = {\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        optionVotes,\n        optionPercentages,\n        abstentions: 0,\n        abstentionPercentage: 0\n      };\n\n      const resultsData: ResultsData = {\n        pollId: poll.id,\n        votingMethod: 'single',\n        totalVotes,\n        participationRate: totalVotes > 0 ? 100 : 0, // This would be calculated based on eligible voters\n        results,\n        calculatedAt: new Date().toISOString(),\n        metadata: {\n          calculationTime: Date.now() - startTime,\n          hasWinner: winner !== undefined,\n          isTie: winnerVotes > 0 && Object.values(optionVotes).filter(v => v === winnerVotes).length > 1\n        }\n      };\n\n      devLog('Single choice results calculated', {\n        pollId: poll.id,\n        totalVotes,\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        calculationTime: Date.now() - startTime\n      });\n\n      return resultsData;\n\n    } catch (error) {\n      devLog('Single choice results calculation error:', error);\n      throw new Error(`Failed to calculate single choice results: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  getConfiguration(): Record<string, unknown> {\n    return {\n      name: 'Single Choice Voting',\n      description: 'Voters select exactly one option. The option with the most votes wins.',\n      minOptions: 2,\n      maxOptions: 100,\n      allowAbstention: false,\n      requiresRanking: false,\n      allowsMultipleSelections: false,\n      resultType: 'winner',\n      features: [\n        'Simple and intuitive',\n        'Fast to count',\n        'Clear winner determination',\n        'Suitable for binary decisions'\n      ],\n      limitations: [\n        'May not reflect true preferences',\n        'Can lead to vote splitting',\n        'No consideration of second choices'\n      ]\n    };\n  }\n}"],"names":["SingleChoiceStrategy","getVotingMethod","validateVote","request","poll","voteData","choice","undefined","valid","errors","requiresAuthentication","requiresTokens","Number","isInteger","options","length","settings","allowMultipleVotes","userId","devLog","pollId","error","Error","message","processVote","privacyLevel","voteId","Date","now","Math","random","toString","substr","auditReceipt","success","responseTime","timestamp","toISOString","metadata","votingMethod","optionText","withOptional","calculateResults","votes","startTime","optionVotes","optionPercentages","forEach","_","index","totalVotes","vote","choiceKey","Object","keys","optionIndex","winner","winnerVotes","winnerPercentage","entries","results","abstentions","abstentionPercentage","resultsData","id","participationRate","calculatedAt","calculationTime","hasWinner","isTie","values","filter","v","getConfiguration","name","description","minOptions","maxOptions","allowAbstention","requiresRanking","allowsMultipleSelections","resultType","features","limitations"],"mappings":"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"}