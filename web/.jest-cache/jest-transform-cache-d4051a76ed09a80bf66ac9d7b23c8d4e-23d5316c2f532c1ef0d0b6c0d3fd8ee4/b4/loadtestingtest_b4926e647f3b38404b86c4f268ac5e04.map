{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/tests/jest/unit/performance/load-testing.test.ts"],"sourcesContent":["/**\n * Load Testing - PHASE 3 COMPREHENSIVE TESTING\n * \n * Tests performance under load:\n * - High user load testing\n * - Database performance\n * - API response times\n * - System scalability validation\n * - Stress testing\n * - Peak load scenarios\n * - Resource exhaustion testing\n * - Recovery testing\n */\n\nimport { describe, it, expect, beforeEach, jest } from '@jest/globals';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { BrowserRouter } from 'react-router-dom';\n\n// Mock performance monitoring\nconst mockPerformance = {\n  now: jest.fn(() => Date.now()),\n  mark: jest.fn(),\n  measure: jest.fn(),\n  getEntriesByType: jest.fn(() => []),\n  getEntriesByName: jest.fn(() => [])\n};\n\nObject.defineProperty(window, 'performance', {\n  value: mockPerformance,\n  writable: true,\n});\n\n// Mock fetch with performance tracking\nconst mockFetch = jest.fn();\nglobal.fetch = mockFetch;\n\n// Mock Zustand stores for load testing\nconst mockFeedsStore = {\n  feeds: [],\n  isLoading: false,\n  error: null,\n  loadFeeds: jest.fn(),\n  refreshFeeds: jest.fn(),\n  loadMoreFeeds: jest.fn(),\n  setFilters: jest.fn()\n};\n\njest.mock('@/lib/stores', () => ({\n  useFeeds: () => mockFeedsStore.feeds,\n  useFeedsStore: (selector) => {\n    const state = mockFeedsStore;\n    return selector ? selector(state) : state;\n  },\n  useFeedsLoading: () => mockFeedsStore.isLoading,\n  useFeedsError: () => mockFeedsStore.error\n}));\n\ndescribe('Load Testing', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockFeedsStore.feeds = [];\n    mockFeedsStore.isLoading = false;\n    mockFeedsStore.error = null;\n  });\n\n  describe('High User Load Testing', () => {\n    it('should handle 1000 concurrent users', async () => {\n      const concurrentUsers = 1000;\n      const startTime = performance.now();\n      \n      // Simulate concurrent user requests\n      const userRequests = Array.from({ length: concurrentUsers }, (_, i) => ({\n        userId: `user-${i}`,\n        requestTime: performance.now(),\n        endpoint: '/api/feeds',\n        method: 'GET'\n      }));\n\n      // Mock API responses for concurrent users\n      mockFetch.mockImplementation((url) => {\n        return Promise.resolve({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve({ success: true, data: [] }),\n          headers: new Map()\n        });\n      });\n\n      // Process all requests\n      const responses = await Promise.all(\n        userRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            responseTime: performance.now() - request.requestTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageResponseTime = responses.reduce((sum, r) => sum + r.responseTime, 0) / responses.length;\n\n      // Performance assertions\n      expect(responses.length).toBe(concurrentUsers);\n      expect(totalTime).toBeLessThan(5000); // Should complete within 5 seconds\n      expect(averageResponseTime).toBeLessThan(100); // Average response time under 100ms\n      \n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.responseTime).toBeLessThan(500); // Individual response under 500ms\n      });\n    });\n\n    it('should handle 5000 concurrent feed requests', async () => {\n      const feedRequests = 5000;\n      const startTime = performance.now();\n      \n      // Generate mock feed data\n      const mockFeeds = Array.from({ length: 100 }, (_, i) => ({\n        id: `feed-${i}`,\n        title: `Feed Item ${i}`,\n        content: `Content for feed item ${i}`,\n        author: { id: `author-${i}`, name: `Author ${i}` },\n        publishedAt: new Date().toISOString(),\n        engagement: { likes: Math.floor(Math.random() * 100), comments: Math.floor(Math.random() * 50) }\n      }));\n\n      mockFetch.mockImplementation((url) => {\n        return Promise.resolve({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve(mockFeeds),\n          headers: new Map()\n        });\n      });\n\n      // Simulate concurrent feed requests\n      const requests = Array.from({ length: feedRequests }, (_, i) => ({\n        id: i,\n        startTime: performance.now(),\n        endpoint: '/api/feeds'\n      }));\n\n      const responses = await Promise.all(\n        requests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          const data = await response.json();\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            dataLength: data.length,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageResponseTime = responses.reduce((sum, r) => sum + r.responseTime, 0) / responses.length;\n\n      // Performance assertions\n      expect(responses.length).toBe(feedRequests);\n      expect(totalTime).toBeLessThan(10000); // Should complete within 10 seconds\n      expect(averageResponseTime).toBeLessThan(200); // Average response time under 200ms\n      \n      // All requests should succeed and return data\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.dataLength).toBe(100);\n        expect(response.responseTime).toBeLessThan(1000); // Individual response under 1 second\n      });\n    });\n\n    it('should handle mixed concurrent operations', async () => {\n      const operations = [\n        { type: 'feed_load', count: 1000, endpoint: '/api/feeds' },\n        { type: 'user_auth', count: 500, endpoint: '/api/auth/login' },\n        { type: 'vote_cast', count: 2000, endpoint: '/api/votes' },\n        { type: 'poll_create', count: 100, endpoint: '/api/polls' }\n      ];\n\n      const startTime = performance.now();\n      \n      // Mock different endpoints\n      mockFetch.mockImplementation((url) => {\n        if (url.includes('/api/feeds')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ feeds: [] }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/auth/login')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ token: 'auth-token' }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/votes')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ success: true }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/polls')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ pollId: 'poll-123' }),\n            headers: new Map()\n          });\n        }\n        return Promise.resolve({ ok: true, status: 200, json: () => Promise.resolve({}) });\n      });\n\n      // Execute all operations concurrently\n      const allRequests = operations.flatMap(op => \n        Array.from({ length: op.count }, (_, i) => ({\n          type: op.type,\n          id: i,\n          endpoint: op.endpoint,\n          startTime: performance.now()\n        }))\n      );\n\n      const responses = await Promise.all(\n        allRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Performance assertions\n      expect(responses.length).toBe(3600); // Total operations\n      expect(totalTime).toBeLessThan(15000); // Should complete within 15 seconds\n      \n      // Check performance by operation type\n      const operationStats = operations.map(op => {\n        const opResponses = responses.filter(r => r.type === op.type);\n        const avgResponseTime = opResponses.reduce((sum, r) => sum + r.responseTime, 0) / opResponses.length;\n        return { type: op.type, count: opResponses.length, avgResponseTime };\n      });\n\n      operationStats.forEach(stat => {\n        expect(stat.count).toBeGreaterThan(0);\n        expect(stat.avgResponseTime).toBeLessThan(500); // Each operation type under 500ms average\n      });\n    });\n  });\n\n  describe('Database Performance Testing', () => {\n    it('should handle large dataset queries efficiently', async () => {\n      const largeDataset = Array.from({ length: 10000 }, (_, i) => ({\n        id: `item-${i}`,\n        title: `Item ${i}`,\n        content: `Content for item ${i}`,\n        category: `category-${i % 10}`,\n        createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString()\n      }));\n\n      const startTime = performance.now();\n      \n      // Simulate database query\n      const queryDatabase = async (query: string, limit: number = 100) => {\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 10)); // Simulate DB delay\n        return largeDataset.slice(0, limit);\n      };\n\n      // Test different query scenarios\n      const queries = [\n        { name: 'recent_items', query: 'SELECT * FROM items ORDER BY createdAt DESC LIMIT 100' },\n        { name: 'category_items', query: 'SELECT * FROM items WHERE category = \"category-1\" LIMIT 100' },\n        { name: 'search_items', query: 'SELECT * FROM items WHERE title LIKE \"%Item%\" LIMIT 100' }\n      ];\n\n      const results = await Promise.all(\n        queries.map(async (q) => {\n          const start = performance.now();\n          const data = await queryDatabase(q.query);\n          const end = performance.now();\n          return {\n            name: q.name,\n            dataLength: data.length,\n            queryTime: end - start\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Performance assertions\n      expect(totalTime).toBeLessThan(1000); // All queries under 1 second\n      results.forEach(result => {\n        expect(result.dataLength).toBe(100);\n        expect(result.queryTime).toBeLessThan(200); // Individual query under 200ms\n      });\n    });\n\n    it('should handle concurrent database writes', async () => {\n      const writeOperations = 1000;\n      const startTime = performance.now();\n      \n      // Simulate database write operations\n      const writeToDatabase = async (data: any) => {\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 5)); // Simulate DB write delay\n        return { id: `new-${Date.now()}`, ...data };\n      };\n\n      const writeRequests = Array.from({ length: writeOperations }, (_, i) => ({\n        id: i,\n        data: { title: `New Item ${i}`, content: `Content ${i}` },\n        startTime: performance.now()\n      }));\n\n      const results = await Promise.all(\n        writeRequests.map(async (request) => {\n          const result = await writeToDatabase(request.data);\n          return {\n            ...request,\n            endTime: performance.now(),\n            writeTime: performance.now() - request.startTime,\n            result\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageWriteTime = results.reduce((sum, r) => sum + r.writeTime, 0) / results.length;\n\n      // Performance assertions\n      expect(results.length).toBe(writeOperations);\n      expect(totalTime).toBeLessThan(5000); // All writes under 5 seconds\n      expect(averageWriteTime).toBeLessThan(50); // Average write time under 50ms\n      \n      // All writes should succeed\n      results.forEach(result => {\n        expect(result.result.id).toBeDefined();\n        expect(result.writeTime).toBeLessThan(100); // Individual write under 100ms\n      });\n    });\n  });\n\n  describe('API Response Time Testing', () => {\n    it('should maintain fast API response times under load', async () => {\n      const apiEndpoints = [\n        '/api/feeds',\n        '/api/auth/status',\n        '/api/votes',\n        '/api/polls',\n        '/api/users/profile'\n      ];\n\n      const requestsPerEndpoint = 100;\n      const startTime = performance.now();\n      \n      // Mock API responses with realistic delays\n      mockFetch.mockImplementation((url) => {\n        const delay = Math.random() * 50 + 10; // 10-60ms delay\n        return new Promise(resolve => {\n          setTimeout(() => {\n            resolve({\n              ok: true,\n              status: 200,\n              json: () => Promise.resolve({ success: true, data: [] }),\n              headers: new Map()\n            });\n          }, delay);\n        });\n      });\n\n      // Test all endpoints concurrently\n      const allRequests = apiEndpoints.flatMap(endpoint =>\n        Array.from({ length: requestsPerEndpoint }, (_, i) => ({\n          endpoint,\n          id: i,\n          startTime: performance.now()\n        }))\n      );\n\n      const responses = await Promise.all(\n        allRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Calculate performance metrics\n      const endpointStats = apiEndpoints.map(endpoint => {\n        const endpointResponses = responses.filter(r => r.endpoint === endpoint);\n        const avgResponseTime = endpointResponses.reduce((sum, r) => sum + r.responseTime, 0) / endpointResponses.length;\n        const maxResponseTime = Math.max(...endpointResponses.map(r => r.responseTime));\n        const minResponseTime = Math.min(...endpointResponses.map(r => r.responseTime));\n        \n        return {\n          endpoint,\n          count: endpointResponses.length,\n          avgResponseTime,\n          maxResponseTime,\n          minResponseTime\n        };\n      });\n\n      // Performance assertions\n      expect(totalTime).toBeLessThan(10000); // All requests under 10 seconds\n      \n      endpointStats.forEach(stat => {\n        expect(stat.count).toBe(requestsPerEndpoint);\n        expect(stat.avgResponseTime).toBeLessThan(100); // Average under 100ms\n        expect(stat.maxResponseTime).toBeLessThan(200); // Max under 200ms\n        expect(stat.minResponseTime).toBeGreaterThan(0); // Min greater than 0\n      });\n    });\n  });\n\n  describe('Stress Testing', () => {\n    it('should handle resource exhaustion gracefully', async () => {\n      const maxConcurrentRequests = 10000;\n      const startTime = performance.now();\n      \n      // Simulate resource exhaustion scenario\n      let activeRequests = 0;\n      let maxActiveRequests = 0;\n      \n      const simulateRequest = async (requestId: number) => {\n        activeRequests++;\n        maxActiveRequests = Math.max(maxActiveRequests, activeRequests);\n        \n        try {\n          // Simulate processing time\n          await new Promise(resolve => setTimeout(resolve, Math.random() * 100));\n          \n          // Simulate occasional failures under stress\n          if (Math.random() < 0.1) { // 10% failure rate under stress\n            throw new Error('Resource exhausted');\n          }\n          \n          return { requestId, success: true };\n        } catch (error) {\n          return { requestId, success: false, error: error.message };\n        } finally {\n          activeRequests--;\n        }\n      };\n\n      // Execute stress test\n      const requests = Array.from({ length: maxConcurrentRequests }, (_, i) => i);\n      const results = await Promise.all(\n        requests.map(requestId => simulateRequest(requestId))\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      const successCount = results.filter(r => r.success).length;\n      const failureCount = results.filter(r => !r.success).length;\n      const successRate = successCount / results.length;\n\n      // Stress test assertions\n      expect(results.length).toBe(maxConcurrentRequests);\n      expect(maxActiveRequests).toBeGreaterThan(0);\n      expect(successRate).toBeGreaterThan(0.8); // At least 80% success rate\n      expect(totalTime).toBeLessThan(30000); // Complete within 30 seconds\n      \n      // System should handle stress gracefully\n      expect(failureCount).toBeLessThan(maxConcurrentRequests * 0.3); // Less than 30% failures\n    });\n\n    it('should recover from peak load scenarios', async () => {\n      const peakLoadDuration = 5000; // 5 seconds\n      const recoveryDuration = 2000; // 2 seconds\n      const startTime = performance.now();\n      \n      // Simulate peak load scenario\n      const simulatePeakLoad = async () => {\n        const requests = Array.from({ length: 1000 }, (_, i) => ({\n          id: i,\n          startTime: performance.now()\n        }));\n        \n        const results = await Promise.all(\n          requests.map(async (request) => {\n            try {\n              // Simulate processing\n              await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n              return { ...request, success: true, endTime: performance.now() };\n            } catch (error) {\n              return { ...request, success: false, error: error.message, endTime: performance.now() };\n            }\n          })\n        );\n        \n        return results;\n      };\n      \n      // Execute peak load\n      const peakResults = await simulatePeakLoad();\n      const peakEndTime = performance.now();\n      const peakDuration = peakEndTime - startTime;\n      \n      // Wait for recovery\n      await new Promise(resolve => setTimeout(resolve, recoveryDuration));\n      \n      // Test recovery\n      const recoveryStartTime = performance.now();\n      const recoveryResults = await simulatePeakLoad();\n      const recoveryEndTime = performance.now();\n      const actualRecoveryDuration = recoveryEndTime - recoveryStartTime;\n      \n      // Recovery assertions\n      expect(peakResults.length).toBe(1000);\n      expect(recoveryResults.length).toBe(1000);\n      \n      // System should recover and perform well after peak load\n      const peakSuccessRate = peakResults.filter(r => r.success).length / peakResults.length;\n      const recoverySuccessRate = recoveryResults.filter(r => r.success).length / recoveryResults.length;\n      \n      expect(peakSuccessRate).toBeGreaterThan(0.7); // At least 70% success during peak\n      expect(recoverySuccessRate).toBeGreaterThan(0.9); // At least 90% success after recovery\n      expect(actualRecoveryDuration).toBeLessThan(peakDuration * 1.5); // Recovery should be reasonably fast\n    });\n  });\n\n  describe('Memory and Resource Testing', () => {\n    it('should handle memory-intensive operations', async () => {\n      const largeDataSize = 1000000; // 1 million items\n      const startTime = performance.now();\n      \n      // Generate large dataset\n      const largeDataset = Array.from({ length: largeDataSize }, (_, i) => ({\n        id: i,\n        data: `Large data item ${i}`.repeat(100), // Each item ~1KB\n        timestamp: Date.now()\n      }));\n      \n      // Process large dataset\n      const processLargeDataset = (data: any[]) => {\n        return data\n          .filter(item => item.id % 2 === 0) // Filter even IDs\n          .map(item => ({ ...item, processed: true })) // Transform\n          .slice(0, 1000); // Limit results\n      };\n      \n      const processedData = processLargeDataset(largeDataset);\n      const endTime = performance.now();\n      const processingTime = endTime - startTime;\n      \n      // Memory and performance assertions\n      expect(processedData.length).toBe(1000);\n      expect(processingTime).toBeLessThan(5000); // Should process within 5 seconds\n      expect(processedData.every(item => item.processed)).toBe(true);\n    });\n\n    it('should handle concurrent memory operations', async () => {\n      const concurrentOperations = 100;\n      const dataSizePerOperation = 10000;\n      \n      const startTime = performance.now();\n      \n      // Simulate concurrent memory operations\n      const memoryOperations = Array.from({ length: concurrentOperations }, (_, i) => {\n        const data = Array.from({ length: dataSizePerOperation }, (_, j) => ({\n          id: `${i}-${j}`,\n          value: Math.random() * 1000,\n          timestamp: Date.now()\n        }));\n        \n        // Process data\n        const processed = data\n          .filter(item => item.value > 500)\n          .map(item => ({ ...item, processed: true }))\n          .sort((a, b) => b.value - a.value)\n          .slice(0, 100);\n        \n        return processed;\n      });\n      \n      const results = await Promise.all(memoryOperations);\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Performance assertions\n      expect(results.length).toBe(concurrentOperations);\n      expect(totalTime).toBeLessThan(10000); // All operations under 10 seconds\n      \n      results.forEach(result => {\n        expect(result.length).toBeLessThanOrEqual(100);\n        expect(result.every(item => item.processed)).toBe(true);\n      });\n    });\n  });\n});\n"],"names":["mockPerformance","now","jest","fn","Date","mark","measure","getEntriesByType","getEntriesByName","Object","defineProperty","window","value","writable","mockFetch","global","fetch","mockFeedsStore","feeds","isLoading","error","loadFeeds","refreshFeeds","loadMoreFeeds","setFilters","mock","useFeeds","useFeedsStore","selector","state","useFeedsLoading","useFeedsError","describe","beforeEach","clearAllMocks","it","concurrentUsers","startTime","performance","userRequests","Array","from","length","_","i","userId","requestTime","endpoint","method","mockImplementation","url","Promise","resolve","ok","status","json","success","data","headers","Map","responses","all","map","request","response","responseTime","endTime","totalTime","averageResponseTime","reduce","sum","r","expect","toBe","toBeLessThan","forEach","feedRequests","mockFeeds","id","title","content","author","name","publishedAt","toISOString","engagement","likes","Math","floor","random","comments","requests","dataLength","operations","type","count","includes","token","pollId","allRequests","flatMap","op","operationStats","opResponses","filter","avgResponseTime","stat","toBeGreaterThan","largeDataset","category","createdAt","queryDatabase","query","limit","setTimeout","slice","queries","results","q","start","end","queryTime","result","writeOperations","writeToDatabase","writeRequests","writeTime","averageWriteTime","toBeDefined","apiEndpoints","requestsPerEndpoint","delay","endpointStats","endpointResponses","maxResponseTime","max","minResponseTime","min","maxConcurrentRequests","activeRequests","maxActiveRequests","simulateRequest","requestId","Error","message","successCount","failureCount","successRate","peakLoadDuration","recoveryDuration","simulatePeakLoad","peakResults","peakEndTime","peakDuration","recoveryStartTime","recoveryResults","recoveryEndTime","actualRecoveryDuration","peakSuccessRate","recoverySuccessRate","largeDataSize","repeat","timestamp","processLargeDataset","item","processed","processedData","processingTime","every","concurrentOperations","dataSizePerOperation","memoryOperations","j","sort","a","b","toBeLessThanOrEqual"],"mappings":"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"}