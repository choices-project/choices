1bcb960a91155ad6ac83d3e8bb8533ce
/**
 * Load Testing - PHASE 3 COMPREHENSIVE TESTING
 * 
 * Tests performance under load:
 * - High user load testing
 * - Database performance
 * - API response times
 * - System scalability validation
 * - Stress testing
 * - Peak load scenarios
 * - Resource exhaustion testing
 * - Recovery testing
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock performance monitoring
const mockPerformance = {
    now: _globals.jest.fn(()=>Date.now()),
    mark: _globals.jest.fn(),
    measure: _globals.jest.fn(),
    getEntriesByType: _globals.jest.fn(()=>[]),
    getEntriesByName: _globals.jest.fn(()=>[])
};
Object.defineProperty(window, "performance", {
    value: mockPerformance,
    writable: true
});
// Mock fetch with performance tracking
const mockFetch = _globals.jest.fn();
global.fetch = mockFetch;
// Mock Zustand stores for load testing
const mockFeedsStore = {
    feeds: [],
    isLoading: false,
    error: null,
    loadFeeds: _globals.jest.fn(),
    refreshFeeds: _globals.jest.fn(),
    loadMoreFeeds: _globals.jest.fn(),
    setFilters: _globals.jest.fn()
};
_globals.jest.mock("@/lib/stores", ()=>({
        useFeeds: ()=>mockFeedsStore.feeds,
        useFeedsStore: (selector)=>{
            const state = mockFeedsStore;
            return selector ? selector(state) : state;
        },
        useFeedsLoading: ()=>mockFeedsStore.isLoading,
        useFeedsError: ()=>mockFeedsStore.error
    }));
(0, _globals.describe)("Load Testing", ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
        mockFeedsStore.feeds = [];
        mockFeedsStore.isLoading = false;
        mockFeedsStore.error = null;
    });
    (0, _globals.describe)("High User Load Testing", ()=>{
        (0, _globals.it)("should handle 1000 concurrent users", async ()=>{
            const concurrentUsers = 1000;
            const startTime = performance.now();
            // Simulate concurrent user requests
            const userRequests = Array.from({
                length: concurrentUsers
            }, (_, i)=>({
                    userId: `user-${i}`,
                    requestTime: performance.now(),
                    endpoint: "/api/feeds",
                    method: "GET"
                }));
            // Mock API responses for concurrent users
            mockFetch.mockImplementation((url)=>{
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({
                            success: true,
                            data: []
                        }),
                    headers: new Map()
                });
            });
            // Process all requests
            const responses = await Promise.all(userRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    responseTime: performance.now() - request.requestTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageResponseTime = responses.reduce((sum, r)=>sum + r.responseTime, 0) / responses.length;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(concurrentUsers);
            (0, _globals.expect)(totalTime).toBeLessThan(5000); // Should complete within 5 seconds
            (0, _globals.expect)(averageResponseTime).toBeLessThan(100); // Average response time under 100ms
            // All requests should succeed
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
                (0, _globals.expect)(response.responseTime).toBeLessThan(500); // Individual response under 500ms
            });
        });
        (0, _globals.it)("should handle 5000 concurrent feed requests", async ()=>{
            const feedRequests = 5000;
            const startTime = performance.now();
            // Generate mock feed data
            const mockFeeds = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `feed-${i}`,
                    title: `Feed Item ${i}`,
                    content: `Content for feed item ${i}`,
                    author: {
                        id: `author-${i}`,
                        name: `Author ${i}`
                    },
                    publishedAt: new Date().toISOString(),
                    engagement: {
                        likes: Math.floor(Math.random() * 100),
                        comments: Math.floor(Math.random() * 50)
                    }
                }));
            mockFetch.mockImplementation((url)=>{
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(mockFeeds),
                    headers: new Map()
                });
            });
            // Simulate concurrent feed requests
            const requests = Array.from({
                length: feedRequests
            }, (_, i)=>({
                    id: i,
                    startTime: performance.now(),
                    endpoint: "/api/feeds"
                }));
            const responses = await Promise.all(requests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                const data = await response.json();
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    dataLength: data.length,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageResponseTime = responses.reduce((sum, r)=>sum + r.responseTime, 0) / responses.length;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(feedRequests);
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // Should complete within 10 seconds
            (0, _globals.expect)(averageResponseTime).toBeLessThan(200); // Average response time under 200ms
            // All requests should succeed and return data
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
                (0, _globals.expect)(response.dataLength).toBe(100);
                (0, _globals.expect)(response.responseTime).toBeLessThan(1000); // Individual response under 1 second
            });
        });
        (0, _globals.it)("should handle mixed concurrent operations", async ()=>{
            const operations = [
                {
                    type: "feed_load",
                    count: 1000,
                    endpoint: "/api/feeds"
                },
                {
                    type: "user_auth",
                    count: 500,
                    endpoint: "/api/auth/login"
                },
                {
                    type: "vote_cast",
                    count: 2000,
                    endpoint: "/api/votes"
                },
                {
                    type: "poll_create",
                    count: 100,
                    endpoint: "/api/polls"
                }
            ];
            const startTime = performance.now();
            // Mock different endpoints
            mockFetch.mockImplementation((url)=>{
                if (url.includes("/api/feeds")) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                feeds: []
                            }),
                        headers: new Map()
                    });
                }
                if (url.includes("/api/auth/login")) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                token: "auth-token"
                            }),
                        headers: new Map()
                    });
                }
                if (url.includes("/api/votes")) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                success: true
                            }),
                        headers: new Map()
                    });
                }
                if (url.includes("/api/polls")) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                pollId: "poll-123"
                            }),
                        headers: new Map()
                    });
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({})
                });
            });
            // Execute all operations concurrently
            const allRequests = operations.flatMap((op)=>Array.from({
                    length: op.count
                }, (_, i)=>({
                        type: op.type,
                        id: i,
                        endpoint: op.endpoint,
                        startTime: performance.now()
                    })));
            const responses = await Promise.all(allRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(3600); // Total operations
            (0, _globals.expect)(totalTime).toBeLessThan(15000); // Should complete within 15 seconds
            // Check performance by operation type
            const operationStats = operations.map((op)=>{
                const opResponses = responses.filter((r)=>r.type === op.type);
                const avgResponseTime = opResponses.reduce((sum, r)=>sum + r.responseTime, 0) / opResponses.length;
                return {
                    type: op.type,
                    count: opResponses.length,
                    avgResponseTime
                };
            });
            operationStats.forEach((stat)=>{
                (0, _globals.expect)(stat.count).toBeGreaterThan(0);
                (0, _globals.expect)(stat.avgResponseTime).toBeLessThan(500); // Each operation type under 500ms average
            });
        });
    });
    (0, _globals.describe)("Database Performance Testing", ()=>{
        (0, _globals.it)("should handle large dataset queries efficiently", async ()=>{
            const largeDataset = Array.from({
                length: 10000
            }, (_, i)=>({
                    id: `item-${i}`,
                    title: `Item ${i}`,
                    content: `Content for item ${i}`,
                    category: `category-${i % 10}`,
                    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString()
                }));
            const startTime = performance.now();
            // Simulate database query
            const queryDatabase = async (query, limit = 100)=>{
                await new Promise((resolve)=>setTimeout(resolve, Math.random() * 10)); // Simulate DB delay
                return largeDataset.slice(0, limit);
            };
            // Test different query scenarios
            const queries = [
                {
                    name: "recent_items",
                    query: "SELECT * FROM items ORDER BY createdAt DESC LIMIT 100"
                },
                {
                    name: "category_items",
                    query: 'SELECT * FROM items WHERE category = "category-1" LIMIT 100'
                },
                {
                    name: "search_items",
                    query: 'SELECT * FROM items WHERE title LIKE "%Item%" LIMIT 100'
                }
            ];
            const results = await Promise.all(queries.map(async (q)=>{
                const start = performance.now();
                const data = await queryDatabase(q.query);
                const end = performance.now();
                return {
                    name: q.name,
                    dataLength: data.length,
                    queryTime: end - start
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(totalTime).toBeLessThan(1000); // All queries under 1 second
            results.forEach((result)=>{
                (0, _globals.expect)(result.dataLength).toBe(100);
                (0, _globals.expect)(result.queryTime).toBeLessThan(200); // Individual query under 200ms
            });
        });
        (0, _globals.it)("should handle concurrent database writes", async ()=>{
            const writeOperations = 1000;
            const startTime = performance.now();
            // Simulate database write operations
            const writeToDatabase = async (data)=>{
                await new Promise((resolve)=>setTimeout(resolve, Math.random() * 5)); // Simulate DB write delay
                return {
                    id: `new-${Date.now()}`,
                    ...data
                };
            };
            const writeRequests = Array.from({
                length: writeOperations
            }, (_, i)=>({
                    id: i,
                    data: {
                        title: `New Item ${i}`,
                        content: `Content ${i}`
                    },
                    startTime: performance.now()
                }));
            const results = await Promise.all(writeRequests.map(async (request)=>{
                const result = await writeToDatabase(request.data);
                return {
                    ...request,
                    endTime: performance.now(),
                    writeTime: performance.now() - request.startTime,
                    result
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageWriteTime = results.reduce((sum, r)=>sum + r.writeTime, 0) / results.length;
            // Performance assertions
            (0, _globals.expect)(results.length).toBe(writeOperations);
            (0, _globals.expect)(totalTime).toBeLessThan(5000); // All writes under 5 seconds
            (0, _globals.expect)(averageWriteTime).toBeLessThan(50); // Average write time under 50ms
            // All writes should succeed
            results.forEach((result)=>{
                (0, _globals.expect)(result.result.id).toBeDefined();
                (0, _globals.expect)(result.writeTime).toBeLessThan(100); // Individual write under 100ms
            });
        });
    });
    (0, _globals.describe)("API Response Time Testing", ()=>{
        (0, _globals.it)("should maintain fast API response times under load", async ()=>{
            const apiEndpoints = [
                "/api/feeds",
                "/api/auth/status",
                "/api/votes",
                "/api/polls",
                "/api/users/profile"
            ];
            const requestsPerEndpoint = 100;
            const startTime = performance.now();
            // Mock API responses with realistic delays
            mockFetch.mockImplementation((url)=>{
                const delay = Math.random() * 50 + 10; // 10-60ms delay
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        resolve({
                            ok: true,
                            status: 200,
                            json: ()=>Promise.resolve({
                                    success: true,
                                    data: []
                                }),
                            headers: new Map()
                        });
                    }, delay);
                });
            });
            // Test all endpoints concurrently
            const allRequests = apiEndpoints.flatMap((endpoint)=>Array.from({
                    length: requestsPerEndpoint
                }, (_, i)=>({
                        endpoint,
                        id: i,
                        startTime: performance.now()
                    })));
            const responses = await Promise.all(allRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Calculate performance metrics
            const endpointStats = apiEndpoints.map((endpoint)=>{
                const endpointResponses = responses.filter((r)=>r.endpoint === endpoint);
                const avgResponseTime = endpointResponses.reduce((sum, r)=>sum + r.responseTime, 0) / endpointResponses.length;
                const maxResponseTime = Math.max(...endpointResponses.map((r)=>r.responseTime));
                const minResponseTime = Math.min(...endpointResponses.map((r)=>r.responseTime));
                return {
                    endpoint,
                    count: endpointResponses.length,
                    avgResponseTime,
                    maxResponseTime,
                    minResponseTime
                };
            });
            // Performance assertions
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // All requests under 10 seconds
            endpointStats.forEach((stat)=>{
                (0, _globals.expect)(stat.count).toBe(requestsPerEndpoint);
                (0, _globals.expect)(stat.avgResponseTime).toBeLessThan(100); // Average under 100ms
                (0, _globals.expect)(stat.maxResponseTime).toBeLessThan(200); // Max under 200ms
                (0, _globals.expect)(stat.minResponseTime).toBeGreaterThan(0); // Min greater than 0
            });
        });
    });
    (0, _globals.describe)("Stress Testing", ()=>{
        (0, _globals.it)("should handle resource exhaustion gracefully", async ()=>{
            const maxConcurrentRequests = 10000;
            const startTime = performance.now();
            // Simulate resource exhaustion scenario
            let activeRequests = 0;
            let maxActiveRequests = 0;
            const simulateRequest = async (requestId)=>{
                activeRequests++;
                maxActiveRequests = Math.max(maxActiveRequests, activeRequests);
                try {
                    // Simulate processing time
                    await new Promise((resolve)=>setTimeout(resolve, Math.random() * 100));
                    // Simulate occasional failures under stress
                    if (Math.random() < 0.1) {
                        throw new Error("Resource exhausted");
                    }
                    return {
                        requestId,
                        success: true
                    };
                } catch (error) {
                    return {
                        requestId,
                        success: false,
                        error: error.message
                    };
                } finally{
                    activeRequests--;
                }
            };
            // Execute stress test
            const requests = Array.from({
                length: maxConcurrentRequests
            }, (_, i)=>i);
            const results = await Promise.all(requests.map((requestId)=>simulateRequest(requestId)));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const successCount = results.filter((r)=>r.success).length;
            const failureCount = results.filter((r)=>!r.success).length;
            const successRate = successCount / results.length;
            // Stress test assertions
            (0, _globals.expect)(results.length).toBe(maxConcurrentRequests);
            (0, _globals.expect)(maxActiveRequests).toBeGreaterThan(0);
            (0, _globals.expect)(successRate).toBeGreaterThan(0.8); // At least 80% success rate
            (0, _globals.expect)(totalTime).toBeLessThan(30000); // Complete within 30 seconds
            // System should handle stress gracefully
            (0, _globals.expect)(failureCount).toBeLessThan(maxConcurrentRequests * 0.3); // Less than 30% failures
        });
        (0, _globals.it)("should recover from peak load scenarios", async ()=>{
            const peakLoadDuration = 5000; // 5 seconds
            const recoveryDuration = 2000; // 2 seconds
            const startTime = performance.now();
            // Simulate peak load scenario
            const simulatePeakLoad = async ()=>{
                const requests = Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        startTime: performance.now()
                    }));
                const results = await Promise.all(requests.map(async (request)=>{
                    try {
                        // Simulate processing
                        await new Promise((resolve)=>setTimeout(resolve, Math.random() * 50));
                        return {
                            ...request,
                            success: true,
                            endTime: performance.now()
                        };
                    } catch (error) {
                        return {
                            ...request,
                            success: false,
                            error: error.message,
                            endTime: performance.now()
                        };
                    }
                }));
                return results;
            };
            // Execute peak load
            const peakResults = await simulatePeakLoad();
            const peakEndTime = performance.now();
            const peakDuration = peakEndTime - startTime;
            // Wait for recovery
            await new Promise((resolve)=>setTimeout(resolve, recoveryDuration));
            // Test recovery
            const recoveryStartTime = performance.now();
            const recoveryResults = await simulatePeakLoad();
            const recoveryEndTime = performance.now();
            const actualRecoveryDuration = recoveryEndTime - recoveryStartTime;
            // Recovery assertions
            (0, _globals.expect)(peakResults.length).toBe(1000);
            (0, _globals.expect)(recoveryResults.length).toBe(1000);
            // System should recover and perform well after peak load
            const peakSuccessRate = peakResults.filter((r)=>r.success).length / peakResults.length;
            const recoverySuccessRate = recoveryResults.filter((r)=>r.success).length / recoveryResults.length;
            (0, _globals.expect)(peakSuccessRate).toBeGreaterThan(0.7); // At least 70% success during peak
            (0, _globals.expect)(recoverySuccessRate).toBeGreaterThan(0.9); // At least 90% success after recovery
            (0, _globals.expect)(actualRecoveryDuration).toBeLessThan(peakDuration * 1.5); // Recovery should be reasonably fast
        });
    });
    (0, _globals.describe)("Memory and Resource Testing", ()=>{
        (0, _globals.it)("should handle memory-intensive operations", async ()=>{
            const largeDataSize = 1000000; // 1 million items
            const startTime = performance.now();
            // Generate large dataset
            const largeDataset = Array.from({
                length: largeDataSize
            }, (_, i)=>({
                    id: i,
                    data: `Large data item ${i}`.repeat(100),
                    timestamp: Date.now()
                }));
            // Process large dataset
            const processLargeDataset = (data)=>{
                return data.filter((item)=>item.id % 2 === 0) // Filter even IDs
                .map((item)=>({
                        ...item,
                        processed: true
                    })) // Transform
                .slice(0, 1000); // Limit results
            };
            const processedData = processLargeDataset(largeDataset);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Memory and performance assertions
            (0, _globals.expect)(processedData.length).toBe(1000);
            (0, _globals.expect)(processingTime).toBeLessThan(5000); // Should process within 5 seconds
            (0, _globals.expect)(processedData.every((item)=>item.processed)).toBe(true);
        });
        (0, _globals.it)("should handle concurrent memory operations", async ()=>{
            const concurrentOperations = 100;
            const dataSizePerOperation = 10000;
            const startTime = performance.now();
            // Simulate concurrent memory operations
            const memoryOperations = Array.from({
                length: concurrentOperations
            }, (_, i)=>{
                const data = Array.from({
                    length: dataSizePerOperation
                }, (_, j)=>({
                        id: `${i}-${j}`,
                        value: Math.random() * 1000,
                        timestamp: Date.now()
                    }));
                // Process data
                const processed = data.filter((item)=>item.value > 500).map((item)=>({
                        ...item,
                        processed: true
                    })).sort((a, b)=>b.value - a.value).slice(0, 100);
                return processed;
            });
            const results = await Promise.all(memoryOperations);
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(results.length).toBe(concurrentOperations);
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // All operations under 10 seconds
            results.forEach((result)=>{
                (0, _globals.expect)(result.length).toBeLessThanOrEqual(100);
                (0, _globals.expect)(result.every((item)=>item.processed)).toBe(true);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvcGVyZm9ybWFuY2UvbG9hZC10ZXN0aW5nLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2FkIFRlc3RpbmcgLSBQSEFTRSAzIENPTVBSRUhFTlNJVkUgVEVTVElOR1xuICogXG4gKiBUZXN0cyBwZXJmb3JtYW5jZSB1bmRlciBsb2FkOlxuICogLSBIaWdoIHVzZXIgbG9hZCB0ZXN0aW5nXG4gKiAtIERhdGFiYXNlIHBlcmZvcm1hbmNlXG4gKiAtIEFQSSByZXNwb25zZSB0aW1lc1xuICogLSBTeXN0ZW0gc2NhbGFiaWxpdHkgdmFsaWRhdGlvblxuICogLSBTdHJlc3MgdGVzdGluZ1xuICogLSBQZWFrIGxvYWQgc2NlbmFyaW9zXG4gKiAtIFJlc291cmNlIGV4aGF1c3Rpb24gdGVzdGluZ1xuICogLSBSZWNvdmVyeSB0ZXN0aW5nXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gTW9jayBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG5jb25zdCBtb2NrUGVyZm9ybWFuY2UgPSB7XG4gIG5vdzogamVzdC5mbigoKSA9PiBEYXRlLm5vdygpKSxcbiAgbWFyazogamVzdC5mbigpLFxuICBtZWFzdXJlOiBqZXN0LmZuKCksXG4gIGdldEVudHJpZXNCeVR5cGU6IGplc3QuZm4oKCkgPT4gW10pLFxuICBnZXRFbnRyaWVzQnlOYW1lOiBqZXN0LmZuKCgpID0+IFtdKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ3BlcmZvcm1hbmNlJywge1xuICB2YWx1ZTogbW9ja1BlcmZvcm1hbmNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBNb2NrIGZldGNoIHdpdGggcGVyZm9ybWFuY2UgdHJhY2tpbmdcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKTtcbmdsb2JhbC5mZXRjaCA9IG1vY2tGZXRjaDtcblxuLy8gTW9jayBadXN0YW5kIHN0b3JlcyBmb3IgbG9hZCB0ZXN0aW5nXG5jb25zdCBtb2NrRmVlZHNTdG9yZSA9IHtcbiAgZmVlZHM6IFtdLFxuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBlcnJvcjogbnVsbCxcbiAgbG9hZEZlZWRzOiBqZXN0LmZuKCksXG4gIHJlZnJlc2hGZWVkczogamVzdC5mbigpLFxuICBsb2FkTW9yZUZlZWRzOiBqZXN0LmZuKCksXG4gIHNldEZpbHRlcnM6IGplc3QuZm4oKVxufTtcblxuamVzdC5tb2NrKCdAL2xpYi9zdG9yZXMnLCAoKSA9PiAoe1xuICB1c2VGZWVkczogKCkgPT4gbW9ja0ZlZWRzU3RvcmUuZmVlZHMsXG4gIHVzZUZlZWRzU3RvcmU6IChzZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gbW9ja0ZlZWRzU3RvcmU7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gc2VsZWN0b3Ioc3RhdGUpIDogc3RhdGU7XG4gIH0sXG4gIHVzZUZlZWRzTG9hZGluZzogKCkgPT4gbW9ja0ZlZWRzU3RvcmUuaXNMb2FkaW5nLFxuICB1c2VGZWVkc0Vycm9yOiAoKSA9PiBtb2NrRmVlZHNTdG9yZS5lcnJvclxufSkpO1xuXG5kZXNjcmliZSgnTG9hZCBUZXN0aW5nJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBtb2NrRmVlZHNTdG9yZS5mZWVkcyA9IFtdO1xuICAgIG1vY2tGZWVkc1N0b3JlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgIG1vY2tGZWVkc1N0b3JlLmVycm9yID0gbnVsbDtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0hpZ2ggVXNlciBMb2FkIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgMTAwMCBjb25jdXJyZW50IHVzZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uY3VycmVudFVzZXJzID0gMTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBjb25jdXJyZW50IHVzZXIgcmVxdWVzdHNcbiAgICAgIGNvbnN0IHVzZXJSZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbmN1cnJlbnRVc2VycyB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgdXNlcklkOiBgdXNlci0ke2l9YCxcbiAgICAgICAgcmVxdWVzdFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICBlbmRwb2ludDogJy9hcGkvZmVlZHMnLFxuICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIE1vY2sgQVBJIHJlc3BvbnNlcyBmb3IgY29uY3VycmVudCB1c2Vyc1xuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pLFxuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm9jZXNzIGFsbCByZXF1ZXN0c1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHVzZXJSZXF1ZXN0cy5tYXAoYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QuZW5kcG9pbnQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3QucmVxdWVzdFRpbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZlcmFnZVJlc3BvbnNlVGltZSA9IHJlc3BvbnNlcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5yZXNwb25zZVRpbWUsIDApIC8gcmVzcG9uc2VzLmxlbmd0aDtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHJlc3BvbnNlcy5sZW5ndGgpLnRvQmUoY29uY3VycmVudFVzZXJzKTtcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1IHNlY29uZHNcbiAgICAgIGV4cGVjdChhdmVyYWdlUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gQXZlcmFnZSByZXNwb25zZSB0aW1lIHVuZGVyIDEwMG1zXG4gICAgICBcbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgc3VjY2VlZFxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5yZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbig1MDApOyAvLyBJbmRpdmlkdWFsIHJlc3BvbnNlIHVuZGVyIDUwMG1zXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIDUwMDAgY29uY3VycmVudCBmZWVkIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmVlZFJlcXVlc3RzID0gNTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBtb2NrIGZlZWQgZGF0YVxuICAgICAgY29uc3QgbW9ja0ZlZWRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGZlZWQtJHtpfWAsXG4gICAgICAgIHRpdGxlOiBgRmVlZCBJdGVtICR7aX1gLFxuICAgICAgICBjb250ZW50OiBgQ29udGVudCBmb3IgZmVlZCBpdGVtICR7aX1gLFxuICAgICAgICBhdXRob3I6IHsgaWQ6IGBhdXRob3ItJHtpfWAsIG5hbWU6IGBBdXRob3IgJHtpfWAgfSxcbiAgICAgICAgcHVibGlzaGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5nYWdlbWVudDogeyBsaWtlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSwgY29tbWVudHM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSB9XG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCkgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja0ZlZWRzKSxcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgY29uY3VycmVudCBmZWVkIHJlcXVlc3RzXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGZlZWRSZXF1ZXN0cyB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgIGVuZHBvaW50OiAnL2FwaS9mZWVkcydcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdC5lbmRwb2ludCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3Quc3RhcnRUaW1lLFxuICAgICAgICAgICAgZGF0YUxlbmd0aDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZlcmFnZVJlc3BvbnNlVGltZSA9IHJlc3BvbnNlcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5yZXNwb25zZVRpbWUsIDApIC8gcmVzcG9uc2VzLmxlbmd0aDtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHJlc3BvbnNlcy5sZW5ndGgpLnRvQmUoZmVlZFJlcXVlc3RzKTtcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTAgc2Vjb25kc1xuICAgICAgZXhwZWN0KGF2ZXJhZ2VSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigyMDApOyAvLyBBdmVyYWdlIHJlc3BvbnNlIHRpbWUgdW5kZXIgMjAwbXNcbiAgICAgIFxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBzdWNjZWVkIGFuZCByZXR1cm4gZGF0YVxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5kYXRhTGVuZ3RoKS50b0JlKDEwMCk7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5yZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gSW5kaXZpZHVhbCByZXNwb25zZSB1bmRlciAxIHNlY29uZFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXhlZCBjb25jdXJyZW50IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gW1xuICAgICAgICB7IHR5cGU6ICdmZWVkX2xvYWQnLCBjb3VudDogMTAwMCwgZW5kcG9pbnQ6ICcvYXBpL2ZlZWRzJyB9LFxuICAgICAgICB7IHR5cGU6ICd1c2VyX2F1dGgnLCBjb3VudDogNTAwLCBlbmRwb2ludDogJy9hcGkvYXV0aC9sb2dpbicgfSxcbiAgICAgICAgeyB0eXBlOiAndm90ZV9jYXN0JywgY291bnQ6IDIwMDAsIGVuZHBvaW50OiAnL2FwaS92b3RlcycgfSxcbiAgICAgICAgeyB0eXBlOiAncG9sbF9jcmVhdGUnLCBjb3VudDogMTAwLCBlbmRwb2ludDogJy9hcGkvcG9sbHMnIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIGRpZmZlcmVudCBlbmRwb2ludHNcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCkgPT4ge1xuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKCcvYXBpL2ZlZWRzJykpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBmZWVkczogW10gfSksXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKCcvYXBpL2F1dGgvbG9naW4nKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHRva2VuOiAnYXV0aC10b2tlbicgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKCcvYXBpL3ZvdGVzJykpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBzdWNjZXNzOiB0cnVlIH0pLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2FwaS9wb2xscycpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgcG9sbElkOiAncG9sbC0xMjMnIH0pLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IG9rOiB0cnVlLCBzdGF0dXM6IDIwMCwganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHt9KSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIGFsbCBvcGVyYXRpb25zIGNvbmN1cnJlbnRseVxuICAgICAgY29uc3QgYWxsUmVxdWVzdHMgPSBvcGVyYXRpb25zLmZsYXRNYXAob3AgPT4gXG4gICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IG9wLmNvdW50IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IG9wLnR5cGUsXG4gICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgZW5kcG9pbnQ6IG9wLmVuZHBvaW50LFxuICAgICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfSkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgYWxsUmVxdWVzdHMubWFwKGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LmVuZHBvaW50KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3Quc3RhcnRUaW1lLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHJlc3BvbnNlcy5sZW5ndGgpLnRvQmUoMzYwMCk7IC8vIFRvdGFsIG9wZXJhdGlvbnNcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxNTAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTUgc2Vjb25kc1xuICAgICAgXG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZSBieSBvcGVyYXRpb24gdHlwZVxuICAgICAgY29uc3Qgb3BlcmF0aW9uU3RhdHMgPSBvcGVyYXRpb25zLm1hcChvcCA9PiB7XG4gICAgICAgIGNvbnN0IG9wUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+IHIudHlwZSA9PT0gb3AudHlwZSk7XG4gICAgICAgIGNvbnN0IGF2Z1Jlc3BvbnNlVGltZSA9IG9wUmVzcG9uc2VzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLnJlc3BvbnNlVGltZSwgMCkgLyBvcFJlc3BvbnNlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IG9wLnR5cGUsIGNvdW50OiBvcFJlc3BvbnNlcy5sZW5ndGgsIGF2Z1Jlc3BvbnNlVGltZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIG9wZXJhdGlvblN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGV4cGVjdChzdGF0LmNvdW50KS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgIGV4cGVjdChzdGF0LmF2Z1Jlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7IC8vIEVhY2ggb3BlcmF0aW9uIHR5cGUgdW5kZXIgNTAwbXMgYXZlcmFnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBQZXJmb3JtYW5jZSBUZXN0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGRhdGFzZXQgcXVlcmllcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YXNldCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGl0ZW0tJHtpfWAsXG4gICAgICAgIHRpdGxlOiBgSXRlbSAke2l9YCxcbiAgICAgICAgY29udGVudDogYENvbnRlbnQgZm9yIGl0ZW0gJHtpfWAsXG4gICAgICAgIGNhdGVnb3J5OiBgY2F0ZWdvcnktJHtpICUgMTB9YCxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gTWF0aC5yYW5kb20oKSAqIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGRhdGFiYXNlIHF1ZXJ5XG4gICAgICBjb25zdCBxdWVyeURhdGFiYXNlID0gYXN5bmMgKHF1ZXJ5OiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMDApID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucmFuZG9tKCkgKiAxMCkpOyAvLyBTaW11bGF0ZSBEQiBkZWxheVxuICAgICAgICByZXR1cm4gbGFyZ2VEYXRhc2V0LnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFRlc3QgZGlmZmVyZW50IHF1ZXJ5IHNjZW5hcmlvc1xuICAgICAgY29uc3QgcXVlcmllcyA9IFtcbiAgICAgICAgeyBuYW1lOiAncmVjZW50X2l0ZW1zJywgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIGl0ZW1zIE9SREVSIEJZIGNyZWF0ZWRBdCBERVNDIExJTUlUIDEwMCcgfSxcbiAgICAgICAgeyBuYW1lOiAnY2F0ZWdvcnlfaXRlbXMnLCBxdWVyeTogJ1NFTEVDVCAqIEZST00gaXRlbXMgV0hFUkUgY2F0ZWdvcnkgPSBcImNhdGVnb3J5LTFcIiBMSU1JVCAxMDAnIH0sXG4gICAgICAgIHsgbmFtZTogJ3NlYXJjaF9pdGVtcycsIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBpdGVtcyBXSEVSRSB0aXRsZSBMSUtFIFwiJUl0ZW0lXCIgTElNSVQgMTAwJyB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHF1ZXJpZXMubWFwKGFzeW5jIChxKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnlEYXRhYmFzZShxLnF1ZXJ5KTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogcS5uYW1lLFxuICAgICAgICAgICAgZGF0YUxlbmd0aDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBxdWVyeVRpbWU6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gQWxsIHF1ZXJpZXMgdW5kZXIgMSBzZWNvbmRcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGFMZW5ndGgpLnRvQmUoMTAwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5xdWVyeVRpbWUpLnRvQmVMZXNzVGhhbigyMDApOyAvLyBJbmRpdmlkdWFsIHF1ZXJ5IHVuZGVyIDIwMG1zXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgZGF0YWJhc2Ugd3JpdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gMTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBkYXRhYmFzZSB3cml0ZSBvcGVyYXRpb25zXG4gICAgICBjb25zdCB3cml0ZVRvRGF0YWJhc2UgPSBhc3luYyAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogNSkpOyAvLyBTaW11bGF0ZSBEQiB3cml0ZSBkZWxheVxuICAgICAgICByZXR1cm4geyBpZDogYG5ldy0ke0RhdGUubm93KCl9YCwgLi4uZGF0YSB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgd3JpdGVSZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHdyaXRlT3BlcmF0aW9ucyB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIGRhdGE6IHsgdGl0bGU6IGBOZXcgSXRlbSAke2l9YCwgY29udGVudDogYENvbnRlbnQgJHtpfWAgfSxcbiAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHdyaXRlUmVxdWVzdHMubWFwKGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd3JpdGVUb0RhdGFiYXNlKHJlcXVlc3QuZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBlbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHdyaXRlVGltZTogcGVyZm9ybWFuY2Uubm93KCkgLSByZXF1ZXN0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZlcmFnZVdyaXRlVGltZSA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIud3JpdGVUaW1lLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuXG4gICAgICAvLyBQZXJmb3JtYW5jZSBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmUod3JpdGVPcGVyYXRpb25zKTtcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gQWxsIHdyaXRlcyB1bmRlciA1IHNlY29uZHNcbiAgICAgIGV4cGVjdChhdmVyYWdlV3JpdGVUaW1lKS50b0JlTGVzc1RoYW4oNTApOyAvLyBBdmVyYWdlIHdyaXRlIHRpbWUgdW5kZXIgNTBtc1xuICAgICAgXG4gICAgICAvLyBBbGwgd3JpdGVzIHNob3VsZCBzdWNjZWVkXG4gICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZXN1bHQuaWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQud3JpdGVUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gSW5kaXZpZHVhbCB3cml0ZSB1bmRlciAxMDBtc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBUEkgUmVzcG9uc2UgVGltZSBUZXN0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gZmFzdCBBUEkgcmVzcG9uc2UgdGltZXMgdW5kZXIgbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUVuZHBvaW50cyA9IFtcbiAgICAgICAgJy9hcGkvZmVlZHMnLFxuICAgICAgICAnL2FwaS9hdXRoL3N0YXR1cycsXG4gICAgICAgICcvYXBpL3ZvdGVzJyxcbiAgICAgICAgJy9hcGkvcG9sbHMnLFxuICAgICAgICAnL2FwaS91c2Vycy9wcm9maWxlJ1xuICAgICAgXTtcblxuICAgICAgY29uc3QgcmVxdWVzdHNQZXJFbmRwb2ludCA9IDEwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIEFQSSByZXNwb25zZXMgd2l0aCByZWFsaXN0aWMgZGVsYXlzXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwpID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogNTAgKyAxMDsgLy8gMTAtNjBtcyBkZWxheVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbXSB9KSxcbiAgICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3QgYWxsIGVuZHBvaW50cyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IGFsbFJlcXVlc3RzID0gYXBpRW5kcG9pbnRzLmZsYXRNYXAoZW5kcG9pbnQgPT5cbiAgICAgICAgQXJyYXkuZnJvbSh7IGxlbmd0aDogcmVxdWVzdHNQZXJFbmRwb2ludCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICBpZDogaSxcbiAgICAgICAgICBzdGFydFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIH0pKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGFsbFJlcXVlc3RzLm1hcChhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdC5lbmRwb2ludCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBlbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZTogcGVyZm9ybWFuY2Uubm93KCkgLSByZXF1ZXN0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgICBjb25zdCBlbmRwb2ludFN0YXRzID0gYXBpRW5kcG9pbnRzLm1hcChlbmRwb2ludCA9PiB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50UmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+IHIuZW5kcG9pbnQgPT09IGVuZHBvaW50KTtcbiAgICAgICAgY29uc3QgYXZnUmVzcG9uc2VUaW1lID0gZW5kcG9pbnRSZXNwb25zZXMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIucmVzcG9uc2VUaW1lLCAwKSAvIGVuZHBvaW50UmVzcG9uc2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4UmVzcG9uc2VUaW1lID0gTWF0aC5tYXgoLi4uZW5kcG9pbnRSZXNwb25zZXMubWFwKHIgPT4gci5yZXNwb25zZVRpbWUpKTtcbiAgICAgICAgY29uc3QgbWluUmVzcG9uc2VUaW1lID0gTWF0aC5taW4oLi4uZW5kcG9pbnRSZXNwb25zZXMubWFwKHIgPT4gci5yZXNwb25zZVRpbWUpKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgY291bnQ6IGVuZHBvaW50UmVzcG9uc2VzLmxlbmd0aCxcbiAgICAgICAgICBhdmdSZXNwb25zZVRpbWUsXG4gICAgICAgICAgbWF4UmVzcG9uc2VUaW1lLFxuICAgICAgICAgIG1pblJlc3BvbnNlVGltZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwMCk7IC8vIEFsbCByZXF1ZXN0cyB1bmRlciAxMCBzZWNvbmRzXG4gICAgICBcbiAgICAgIGVuZHBvaW50U3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgZXhwZWN0KHN0YXQuY291bnQpLnRvQmUocmVxdWVzdHNQZXJFbmRwb2ludCk7XG4gICAgICAgIGV4cGVjdChzdGF0LmF2Z1Jlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIEF2ZXJhZ2UgdW5kZXIgMTAwbXNcbiAgICAgICAgZXhwZWN0KHN0YXQubWF4UmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMjAwKTsgLy8gTWF4IHVuZGVyIDIwMG1zXG4gICAgICAgIGV4cGVjdChzdGF0Lm1pblJlc3BvbnNlVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApOyAvLyBNaW4gZ3JlYXRlciB0aGFuIDBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RyZXNzIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVzb3VyY2UgZXhoYXVzdGlvbiBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWF4Q29uY3VycmVudFJlcXVlc3RzID0gMTAwMDA7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcmVzb3VyY2UgZXhoYXVzdGlvbiBzY2VuYXJpb1xuICAgICAgbGV0IGFjdGl2ZVJlcXVlc3RzID0gMDtcbiAgICAgIGxldCBtYXhBY3RpdmVSZXF1ZXN0cyA9IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNpbXVsYXRlUmVxdWVzdCA9IGFzeW5jIChyZXF1ZXN0SWQ6IG51bWJlcikgPT4ge1xuICAgICAgICBhY3RpdmVSZXF1ZXN0cysrO1xuICAgICAgICBtYXhBY3RpdmVSZXF1ZXN0cyA9IE1hdGgubWF4KG1heEFjdGl2ZVJlcXVlc3RzLCBhY3RpdmVSZXF1ZXN0cyk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNpbXVsYXRlIHByb2Nlc3NpbmcgdGltZVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogMTAwKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2ltdWxhdGUgb2NjYXNpb25hbCBmYWlsdXJlcyB1bmRlciBzdHJlc3NcbiAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMSkgeyAvLyAxMCUgZmFpbHVyZSByYXRlIHVuZGVyIHN0cmVzc1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSBleGhhdXN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHsgcmVxdWVzdElkLCBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcmVxdWVzdElkLCBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVSZXF1ZXN0cy0tO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBFeGVjdXRlIHN0cmVzcyB0ZXN0XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG1heENvbmN1cnJlbnRSZXF1ZXN0cyB9LCAoXywgaSkgPT4gaSk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChyZXF1ZXN0SWQgPT4gc2ltdWxhdGVSZXF1ZXN0KHJlcXVlc3RJZCkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBjb25zdCBzdWNjZXNzQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3VjY2VzcykubGVuZ3RoO1xuICAgICAgY29uc3QgZmFpbHVyZUNvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKS5sZW5ndGg7XG4gICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NDb3VudCAvIHJlc3VsdHMubGVuZ3RoO1xuXG4gICAgICAvLyBTdHJlc3MgdGVzdCBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmUobWF4Q29uY3VycmVudFJlcXVlc3RzKTtcbiAgICAgIGV4cGVjdChtYXhBY3RpdmVSZXF1ZXN0cykudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN1Y2Nlc3NSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gQXQgbGVhc3QgODAlIHN1Y2Nlc3MgcmF0ZVxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDMwMDAwKTsgLy8gQ29tcGxldGUgd2l0aGluIDMwIHNlY29uZHNcbiAgICAgIFxuICAgICAgLy8gU3lzdGVtIHNob3VsZCBoYW5kbGUgc3RyZXNzIGdyYWNlZnVsbHlcbiAgICAgIGV4cGVjdChmYWlsdXJlQ291bnQpLnRvQmVMZXNzVGhhbihtYXhDb25jdXJyZW50UmVxdWVzdHMgKiAwLjMpOyAvLyBMZXNzIHRoYW4gMzAlIGZhaWx1cmVzXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlY292ZXIgZnJvbSBwZWFrIGxvYWQgc2NlbmFyaW9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGVha0xvYWREdXJhdGlvbiA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuICAgICAgY29uc3QgcmVjb3ZlcnlEdXJhdGlvbiA9IDIwMDA7IC8vIDIgc2Vjb25kc1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHBlYWsgbG9hZCBzY2VuYXJpb1xuICAgICAgY29uc3Qgc2ltdWxhdGVQZWFrTG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHJlcXVlc3RzLm1hcChhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yYW5kb20oKSAqIDUwKSk7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlcXVlc3QsIHN1Y2Nlc3M6IHRydWUsIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXF1ZXN0LCBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRXhlY3V0ZSBwZWFrIGxvYWRcbiAgICAgIGNvbnN0IHBlYWtSZXN1bHRzID0gYXdhaXQgc2ltdWxhdGVQZWFrTG9hZCgpO1xuICAgICAgY29uc3QgcGVha0VuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHBlYWtEdXJhdGlvbiA9IHBlYWtFbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciByZWNvdmVyeVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJlY292ZXJ5RHVyYXRpb24pKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCByZWNvdmVyeVxuICAgICAgY29uc3QgcmVjb3ZlcnlTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5UmVzdWx0cyA9IGF3YWl0IHNpbXVsYXRlUGVha0xvYWQoKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5RW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgYWN0dWFsUmVjb3ZlcnlEdXJhdGlvbiA9IHJlY292ZXJ5RW5kVGltZSAtIHJlY292ZXJ5U3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBSZWNvdmVyeSBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocGVha1Jlc3VsdHMubGVuZ3RoKS50b0JlKDEwMDApO1xuICAgICAgZXhwZWN0KHJlY292ZXJ5UmVzdWx0cy5sZW5ndGgpLnRvQmUoMTAwMCk7XG4gICAgICBcbiAgICAgIC8vIFN5c3RlbSBzaG91bGQgcmVjb3ZlciBhbmQgcGVyZm9ybSB3ZWxsIGFmdGVyIHBlYWsgbG9hZFxuICAgICAgY29uc3QgcGVha1N1Y2Nlc3NSYXRlID0gcGVha1Jlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKS5sZW5ndGggLyBwZWFrUmVzdWx0cy5sZW5ndGg7XG4gICAgICBjb25zdCByZWNvdmVyeVN1Y2Nlc3NSYXRlID0gcmVjb3ZlcnlSZXN1bHRzLmZpbHRlcihyID0+IHIuc3VjY2VzcykubGVuZ3RoIC8gcmVjb3ZlcnlSZXN1bHRzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgZXhwZWN0KHBlYWtTdWNjZXNzUmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuNyk7IC8vIEF0IGxlYXN0IDcwJSBzdWNjZXNzIGR1cmluZyBwZWFrXG4gICAgICBleHBlY3QocmVjb3ZlcnlTdWNjZXNzUmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDAuOSk7IC8vIEF0IGxlYXN0IDkwJSBzdWNjZXNzIGFmdGVyIHJlY292ZXJ5XG4gICAgICBleHBlY3QoYWN0dWFsUmVjb3ZlcnlEdXJhdGlvbikudG9CZUxlc3NUaGFuKHBlYWtEdXJhdGlvbiAqIDEuNSk7IC8vIFJlY292ZXJ5IHNob3VsZCBiZSByZWFzb25hYmx5IGZhc3RcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lbW9yeSBhbmQgUmVzb3VyY2UgVGVzdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnktaW50ZW5zaXZlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZURhdGFTaXplID0gMTAwMDAwMDsgLy8gMSBtaWxsaW9uIGl0ZW1zXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgbGFyZ2UgZGF0YXNldFxuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbGFyZ2VEYXRhU2l6ZSB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIGRhdGE6IGBMYXJnZSBkYXRhIGl0ZW0gJHtpfWAucmVwZWF0KDEwMCksIC8vIEVhY2ggaXRlbSB+MUtCXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGxhcmdlIGRhdGFzZXRcbiAgICAgIGNvbnN0IHByb2Nlc3NMYXJnZURhdGFzZXQgPSAoZGF0YTogYW55W10pID0+IHtcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAlIDIgPT09IDApIC8vIEZpbHRlciBldmVuIElEc1xuICAgICAgICAgIC5tYXAoaXRlbSA9PiAoeyAuLi5pdGVtLCBwcm9jZXNzZWQ6IHRydWUgfSkpIC8vIFRyYW5zZm9ybVxuICAgICAgICAgIC5zbGljZSgwLCAxMDAwKTsgLy8gTGltaXQgcmVzdWx0c1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHByb2Nlc3NMYXJnZURhdGFzZXQobGFyZ2VEYXRhc2V0KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGFuZCBwZXJmb3JtYW5jZSBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocHJvY2Vzc2VkRGF0YS5sZW5ndGgpLnRvQmUoMTAwMCk7XG4gICAgICBleHBlY3QocHJvY2Vzc2luZ1RpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIHByb2Nlc3Mgd2l0aGluIDUgc2Vjb25kc1xuICAgICAgZXhwZWN0KHByb2Nlc3NlZERhdGEuZXZlcnkoaXRlbSA9PiBpdGVtLnByb2Nlc3NlZCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IG1lbW9yeSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uY3VycmVudE9wZXJhdGlvbnMgPSAxMDA7XG4gICAgICBjb25zdCBkYXRhU2l6ZVBlck9wZXJhdGlvbiA9IDEwMDAwO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgY29uY3VycmVudCBtZW1vcnkgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgbWVtb3J5T3BlcmF0aW9ucyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbmN1cnJlbnRPcGVyYXRpb25zIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBkYXRhU2l6ZVBlck9wZXJhdGlvbiB9LCAoXywgaikgPT4gKHtcbiAgICAgICAgICBpZDogYCR7aX0tJHtqfWAsXG4gICAgICAgICAgdmFsdWU6IE1hdGgucmFuZG9tKCkgKiAxMDAwLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIGRhdGFcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGF0YVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnZhbHVlID4gNTAwKVxuICAgICAgICAgIC5tYXAoaXRlbSA9PiAoeyAuLi5pdGVtLCBwcm9jZXNzZWQ6IHRydWUgfSkpXG4gICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKVxuICAgICAgICAgIC5zbGljZSgwLCAxMDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwobWVtb3J5T3BlcmF0aW9ucyk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBQZXJmb3JtYW5jZSBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmUoY29uY3VycmVudE9wZXJhdGlvbnMpO1xuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDAwKTsgLy8gQWxsIG9wZXJhdGlvbnMgdW5kZXIgMTAgc2Vjb25kc1xuICAgICAgXG4gICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5sZW5ndGgpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMTAwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5ldmVyeShpdGVtID0+IGl0ZW0ucHJvY2Vzc2VkKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vY2tQZXJmb3JtYW5jZSIsIm5vdyIsImplc3QiLCJmbiIsIkRhdGUiLCJtYXJrIiwibWVhc3VyZSIsImdldEVudHJpZXNCeVR5cGUiLCJnZXRFbnRyaWVzQnlOYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ2YWx1ZSIsIndyaXRhYmxlIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJtb2NrRmVlZHNTdG9yZSIsImZlZWRzIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJsb2FkRmVlZHMiLCJyZWZyZXNoRmVlZHMiLCJsb2FkTW9yZUZlZWRzIiwic2V0RmlsdGVycyIsIm1vY2siLCJ1c2VGZWVkcyIsInVzZUZlZWRzU3RvcmUiLCJzZWxlY3RvciIsInN0YXRlIiwidXNlRmVlZHNMb2FkaW5nIiwidXNlRmVlZHNFcnJvciIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImNvbmN1cnJlbnRVc2VycyIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwidXNlclJlcXVlc3RzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ1c2VySWQiLCJyZXF1ZXN0VGltZSIsImVuZHBvaW50IiwibWV0aG9kIiwibW9ja0ltcGxlbWVudGF0aW9uIiwidXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvayIsInN0YXR1cyIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsImhlYWRlcnMiLCJNYXAiLCJyZXNwb25zZXMiLCJhbGwiLCJtYXAiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJyZXNwb25zZVRpbWUiLCJlbmRUaW1lIiwidG90YWxUaW1lIiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsInJlZHVjZSIsInN1bSIsInIiLCJleHBlY3QiLCJ0b0JlIiwidG9CZUxlc3NUaGFuIiwiZm9yRWFjaCIsImZlZWRSZXF1ZXN0cyIsIm1vY2tGZWVkcyIsImlkIiwidGl0bGUiLCJjb250ZW50IiwiYXV0aG9yIiwibmFtZSIsInB1Ymxpc2hlZEF0IiwidG9JU09TdHJpbmciLCJlbmdhZ2VtZW50IiwibGlrZXMiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJjb21tZW50cyIsInJlcXVlc3RzIiwiZGF0YUxlbmd0aCIsIm9wZXJhdGlvbnMiLCJ0eXBlIiwiY291bnQiLCJpbmNsdWRlcyIsInRva2VuIiwicG9sbElkIiwiYWxsUmVxdWVzdHMiLCJmbGF0TWFwIiwib3AiLCJvcGVyYXRpb25TdGF0cyIsIm9wUmVzcG9uc2VzIiwiZmlsdGVyIiwiYXZnUmVzcG9uc2VUaW1lIiwic3RhdCIsInRvQmVHcmVhdGVyVGhhbiIsImxhcmdlRGF0YXNldCIsImNhdGVnb3J5IiwiY3JlYXRlZEF0IiwicXVlcnlEYXRhYmFzZSIsInF1ZXJ5IiwibGltaXQiLCJzZXRUaW1lb3V0Iiwic2xpY2UiLCJxdWVyaWVzIiwicmVzdWx0cyIsInEiLCJzdGFydCIsImVuZCIsInF1ZXJ5VGltZSIsInJlc3VsdCIsIndyaXRlT3BlcmF0aW9ucyIsIndyaXRlVG9EYXRhYmFzZSIsIndyaXRlUmVxdWVzdHMiLCJ3cml0ZVRpbWUiLCJhdmVyYWdlV3JpdGVUaW1lIiwidG9CZURlZmluZWQiLCJhcGlFbmRwb2ludHMiLCJyZXF1ZXN0c1BlckVuZHBvaW50IiwiZGVsYXkiLCJlbmRwb2ludFN0YXRzIiwiZW5kcG9pbnRSZXNwb25zZXMiLCJtYXhSZXNwb25zZVRpbWUiLCJtYXgiLCJtaW5SZXNwb25zZVRpbWUiLCJtaW4iLCJtYXhDb25jdXJyZW50UmVxdWVzdHMiLCJhY3RpdmVSZXF1ZXN0cyIsIm1heEFjdGl2ZVJlcXVlc3RzIiwic2ltdWxhdGVSZXF1ZXN0IiwicmVxdWVzdElkIiwiRXJyb3IiLCJtZXNzYWdlIiwic3VjY2Vzc0NvdW50IiwiZmFpbHVyZUNvdW50Iiwic3VjY2Vzc1JhdGUiLCJwZWFrTG9hZER1cmF0aW9uIiwicmVjb3ZlcnlEdXJhdGlvbiIsInNpbXVsYXRlUGVha0xvYWQiLCJwZWFrUmVzdWx0cyIsInBlYWtFbmRUaW1lIiwicGVha0R1cmF0aW9uIiwicmVjb3ZlcnlTdGFydFRpbWUiLCJyZWNvdmVyeVJlc3VsdHMiLCJyZWNvdmVyeUVuZFRpbWUiLCJhY3R1YWxSZWNvdmVyeUR1cmF0aW9uIiwicGVha1N1Y2Nlc3NSYXRlIiwicmVjb3ZlcnlTdWNjZXNzUmF0ZSIsImxhcmdlRGF0YVNpemUiLCJyZXBlYXQiLCJ0aW1lc3RhbXAiLCJwcm9jZXNzTGFyZ2VEYXRhc2V0IiwiaXRlbSIsInByb2Nlc3NlZCIsInByb2Nlc3NlZERhdGEiLCJwcm9jZXNzaW5nVGltZSIsImV2ZXJ5IiwiY29uY3VycmVudE9wZXJhdGlvbnMiLCJkYXRhU2l6ZVBlck9wZXJhdGlvbiIsIm1lbW9yeU9wZXJhdGlvbnMiLCJqIiwic29ydCIsImEiLCJiIiwidG9CZUxlc3NUaGFuT3JFcXVhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztDQVlDOzs7O3lCQUVzRDtBQUl2RCw4QkFBOEI7QUFDOUIsTUFBTUEsa0JBQWtCO0lBQ3RCQyxLQUFLQyxhQUFJLENBQUNDLEVBQUUsQ0FBQyxJQUFNQyxLQUFLSCxHQUFHO0lBQzNCSSxNQUFNSCxhQUFJLENBQUNDLEVBQUU7SUFDYkcsU0FBU0osYUFBSSxDQUFDQyxFQUFFO0lBQ2hCSSxrQkFBa0JMLGFBQUksQ0FBQ0MsRUFBRSxDQUFDLElBQU0sRUFBRTtJQUNsQ0ssa0JBQWtCTixhQUFJLENBQUNDLEVBQUUsQ0FBQyxJQUFNLEVBQUU7QUFDcEM7QUFFQU0sT0FBT0MsY0FBYyxDQUFDQyxRQUFRLGVBQWU7SUFDM0NDLE9BQU9aO0lBQ1BhLFVBQVU7QUFDWjtBQUVBLHVDQUF1QztBQUN2QyxNQUFNQyxZQUFZWixhQUFJLENBQUNDLEVBQUU7QUFDekJZLE9BQU9DLEtBQUssR0FBR0Y7QUFFZix1Q0FBdUM7QUFDdkMsTUFBTUcsaUJBQWlCO0lBQ3JCQyxPQUFPLEVBQUU7SUFDVEMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLFdBQVduQixhQUFJLENBQUNDLEVBQUU7SUFDbEJtQixjQUFjcEIsYUFBSSxDQUFDQyxFQUFFO0lBQ3JCb0IsZUFBZXJCLGFBQUksQ0FBQ0MsRUFBRTtJQUN0QnFCLFlBQVl0QixhQUFJLENBQUNDLEVBQUU7QUFDckI7QUFFQUQsYUFBSSxDQUFDdUIsSUFBSSxDQUFDLGdCQUFnQixJQUFPLENBQUE7UUFDL0JDLFVBQVUsSUFBTVQsZUFBZUMsS0FB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