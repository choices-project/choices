4755824aa7e1ed2246cc99bd3ba589e1
/**
 * Voting System Integration Tests
 * 
 * Tests the complete voting system with real business logic
 * Focuses on actual functionality rather than heavy mocking
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _engine = require("../../../../../lib/vote/engine");
const _irvcalculator = require("../../../../../lib/vote/irv-calculator");
// Mock only the logger - everything else should be real
_globals.jest.mock("@/lib/utils/logger", ()=>({
        devLog: _globals.jest.fn()
    }));
(0, _globals.describe)("Voting System Integration", ()=>{
    let engine;
    let poll;
    let candidates;
    (0, _globals.beforeEach)(()=>{
        engine = new _engine.VoteEngine({
            maxVotesPerPoll: 1,
            allowMultipleVotes: false,
            requireAuthentication: true,
            minTrustTier: "basic",
            rateLimitPerUser: 10,
            rateLimitWindowMs: 60000
        });
        candidates = [
            {
                id: "candidate-1",
                name: "Alice",
                description: "Alice for Mayor"
            },
            {
                id: "candidate-2",
                name: "Bob",
                description: "Bob for Mayor"
            },
            {
                id: "candidate-3",
                name: "Charlie",
                description: "Charlie for Mayor"
            }
        ];
        poll = {
            id: "test-poll-id",
            title: "Mayor Election",
            description: "Choose your next mayor",
            votingMethod: "single-choice",
            options: candidates,
            status: "active",
            createdAt: new Date(),
            closeAt: new Date(Date.now() + 86400000),
            createdBy: "user-1",
            votingConfig: {
                allowMultipleVotes: false,
                requireAuthentication: true,
                anonymousVoting: false
            }
        };
    });
    (0, _globals.describe)("Single Choice Voting", ()=>{
        (0, _globals.it)("should process single choice votes correctly", async ()=>{
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    choice: 0,
                    selectedOptions: [
                        "candidate-1"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            // Test validation
            const validation = await engine.validateVote(voteRequest, poll);
            (0, _globals.expect)(validation.valid).toBe(true);
            // Test processing
            const response = await engine.processVote(voteRequest, poll);
            (0, _globals.expect)(response.success).toBe(true);
            (0, _globals.expect)(response.voteId).toBeDefined();
        });
        (0, _globals.it)("should reject votes for closed polls", async ()=>{
            const closedPoll = {
                ...poll,
                status: "closed"
            };
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [
                        "candidate-1"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const validation = await engine.validateVote(voteRequest, closedPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Poll is not active");
        });
        (0, _globals.it)("should reject votes with invalid options", async ()=>{
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    choice: 999,
                    selectedOptions: [
                        "invalid-candidate"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const validation = await engine.validateVote(voteRequest, poll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Invalid option selected");
        });
    });
    (0, _globals.describe)("Ranked Choice Voting", ()=>{
        (0, _globals.it)("should process ranked choice votes correctly", async ()=>{
            const rankedPoll = {
                ...poll,
                votingMethod: "ranked-choice"
            };
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [],
                    rankings: [
                        0,
                        1,
                        2
                    ],
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const validation = await engine.validateVote(voteRequest, rankedPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
            const response = await engine.processVote(voteRequest, rankedPoll);
            (0, _globals.expect)(response.success).toBe(true);
        });
        (0, _globals.it)("should calculate IRV results correctly", ()=>{
            const calculator = new _irvcalculator.IRVCalculator("test-poll", candidates);
            const userRankings = [
                {
                    userId: "user-1",
                    ranking: [
                        "candidate-1",
                        "candidate-2",
                        "candidate-3"
                    ]
                },
                {
                    userId: "user-2",
                    ranking: [
                        "candidate-1",
                        "candidate-2",
                        "candidate-3"
                    ]
                },
                {
                    userId: "user-3",
                    ranking: [
                        "candidate-2",
                        "candidate-1",
                        "candidate-3"
                    ]
                },
                {
                    userId: "user-4",
                    ranking: [
                        "candidate-2",
                        "candidate-1",
                        "candidate-3"
                    ]
                }
            ];
            const results = calculator.calculateResults(userRankings);
            (0, _globals.expect)(results.totalVotes).toBe(4);
            (0, _globals.expect)(results.winner).toBe("candidate-1");
            (0, _globals.expect)(results.rounds).toHaveLength(2) // IRV correctly takes 2 rounds to determine winner
            ;
        });
        (0, _globals.it)("should handle tie scenarios in IRV", ()=>{
            const calculator = new _irvcalculator.IRVCalculator("test-poll", candidates);
            const userRankings = [
                {
                    userId: "user-1",
                    ranking: [
                        "candidate-1",
                        "candidate-2",
                        "candidate-3"
                    ]
                },
                {
                    userId: "user-2",
                    ranking: [
                        "candidate-2",
                        "candidate-1",
                        "candidate-3"
                    ]
                }
            ];
            const results = calculator.calculateResults(userRankings);
            (0, _globals.expect)(results.totalVotes).toBe(2);
            (0, _globals.expect)(results.rounds.length).toBeGreaterThan(1);
        });
    });
    (0, _globals.describe)("Approval Voting", ()=>{
        (0, _globals.it)("should process approval votes correctly", async ()=>{
            const approvalPoll = {
                ...poll,
                votingMethod: "approval"
            };
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [
                        "candidate-1",
                        "candidate-2"
                    ],
                    approvals: [
                        0,
                        1
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const validation = await engine.validateVote(voteRequest, approvalPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
            const response = await engine.processVote(voteRequest, approvalPoll);
            (0, _globals.expect)(response.success).toBe(true);
        });
    });
    (0, _globals.describe)("Quadratic Voting", ()=>{
        (0, _globals.it)("should process quadratic votes correctly", async ()=>{
            const quadraticPoll = {
                ...poll,
                votingMethod: "quadratic"
            };
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [],
                    ranking: null,
                    allocations: {
                        "0": 2,
                        "1": 1
                    } // Allocate credits to first two candidates
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const validation = await engine.validateVote(voteRequest, quadraticPoll);
            if (!validation.valid) {
                console.log("Quadratic validation failed:", validation.errors);
            }
            (0, _globals.expect)(validation.valid).toBe(true);
            const response = await engine.processVote(voteRequest, quadraticPoll);
            (0, _globals.expect)(response.success).toBe(true);
        });
    });
    (0, _globals.describe)("Rate Limiting", ()=>{
        (0, _globals.it)("should enforce rate limits", async ()=>{
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    choice: 0,
                    selectedOptions: [
                        "candidate-1"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            // Make multiple requests to test rate limiting
            const responses = [];
            for(let i = 0; i < 15; i++){
                const response = await engine.processVote(voteRequest, poll);
                responses.push(response);
            }
            // Some requests should be rate limited
            const rateLimitedResponses = responses.filter((r)=>!r.success && r.error?.includes("Rate limit exceeded"));
            (0, _globals.expect)(rateLimitedResponses.length).toBeGreaterThan(0);
        });
    });
    (0, _globals.describe)("Results Calculation", ()=>{
        (0, _globals.it)("should calculate results for single choice votes", async ()=>{
            const votes = [
                {
                    id: "vote-1",
                    pollId: "test-poll-id",
                    userId: "user-1",
                    choice: 0,
                    privacyLevel: "public",
                    timestamp: new Date(),
                    auditReceipt: "receipt-1"
                },
                {
                    id: "vote-2",
                    pollId: "test-poll-id",
                    userId: "user-2",
                    choice: 0,
                    privacyLevel: "public",
                    timestamp: new Date(),
                    auditReceipt: "receipt-2"
                },
                {
                    id: "vote-3",
                    pollId: "test-poll-id",
                    userId: "user-3",
                    choice: 1,
                    privacyLevel: "public",
                    timestamp: new Date(),
                    auditReceipt: "receipt-3"
                }
            ];
            const results = await engine.calculateResults(poll, votes);
            (0, _globals.expect)(results.totalVotes).toBe(3);
            (0, _globals.expect)(results.results.winner).toBe("candidate-1") // Winner is the candidate ID
            ;
        });
        (0, _globals.it)("should handle empty vote sets", async ()=>{
            const results = await engine.calculateResults(poll, []);
            (0, _globals.expect)(results.totalVotes).toBe(0);
            (0, _globals.expect)(results.results.winner).toBeNull();
        });
    });
    (0, _globals.describe)("Error Handling", ()=>{
        (0, _globals.it)("should handle malformed vote data", async ()=>{
            const malformedRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: null,
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const response = await engine.processVote(malformedRequest, poll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
        (0, _globals.it)("should handle missing poll data", async ()=>{
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [
                        "candidate-1"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const response = await engine.processVote(voteRequest, null);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
    });
    (0, _globals.describe)("Performance", ()=>{
        (0, _globals.it)("should process votes within reasonable time", async ()=>{
            const voteRequest = {
                pollId: "test-poll-id",
                userId: "user-1",
                voteData: {
                    selectedOptions: [
                        "candidate-1"
                    ],
                    ranking: null,
                    weights: null
                },
                metadata: {
                    ipAddress: "192.168.1.1",
                    userAgent: "Mozilla/5.0",
                    timestamp: new Date()
                }
            };
            const startTime = performance.now();
            await engine.processVote(voteRequest, poll);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            (0, _globals.expect)(processingTime).toBeLessThan(100) // Should process within 100ms
            ;
        });
        (0, _globals.it)("should handle large vote sets efficiently", async ()=>{
            const largeVoteSet = Array.from({
                length: 1000
            }, (_, i)=>({
                    id: `vote-${i}`,
                    pollId: "test-poll-id",
                    userId: `user-${i}`,
                    choice: 0,
                    privacyLevel: "public",
                    timestamp: new Date(),
                    auditReceipt: `receipt-${i}`
                }));
            const startTime = performance.now();
            const results = await engine.calculateResults(poll, largeVoteSet);
            const endTime = performance.now();
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(1000);
            (0, _globals.expect)(endTime - startTime).toBeLessThan(1000) // Should process within 1 second
            ;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3ZvdGUvdm90aW5nLXN5c3RlbS1pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVm90aW5nIFN5c3RlbSBJbnRlZ3JhdGlvbiBUZXN0c1xuICogXG4gKiBUZXN0cyB0aGUgY29tcGxldGUgdm90aW5nIHN5c3RlbSB3aXRoIHJlYWwgYnVzaW5lc3MgbG9naWNcbiAqIEZvY3VzZXMgb24gYWN0dWFsIGZ1bmN0aW9uYWxpdHkgcmF0aGVyIHRoYW4gaGVhdnkgbW9ja2luZ1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscydcbmltcG9ydCB7IFZvdGVFbmdpbmUgfSBmcm9tICdAL2xpYi92b3RlL2VuZ2luZSdcbmltcG9ydCB7IElSVkNhbGN1bGF0b3IgfSBmcm9tICdAL2xpYi92b3RlL2lydi1jYWxjdWxhdG9yJ1xuaW1wb3J0IHR5cGUgeyBWb3RlUmVxdWVzdCwgUG9sbERhdGEsIFZvdGluZ01ldGhvZCwgQ2FuZGlkYXRlIH0gZnJvbSAnQC9saWIvdm90ZS90eXBlcydcblxuLy8gTW9jayBvbmx5IHRoZSBsb2dnZXIgLSBldmVyeXRoaW5nIGVsc2Ugc2hvdWxkIGJlIHJlYWxcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgZGV2TG9nOiBqZXN0LmZuKClcbn0pKVxuXG5kZXNjcmliZSgnVm90aW5nIFN5c3RlbSBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgbGV0IGVuZ2luZTogVm90ZUVuZ2luZVxuICBsZXQgcG9sbDogUG9sbERhdGFcbiAgbGV0IGNhbmRpZGF0ZXM6IENhbmRpZGF0ZVtdXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZW5naW5lID0gbmV3IFZvdGVFbmdpbmUoe1xuICAgICAgbWF4Vm90ZXNQZXJQb2xsOiAxLFxuICAgICAgYWxsb3dNdWx0aXBsZVZvdGVzOiBmYWxzZSxcbiAgICAgIHJlcXVpcmVBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgIG1pblRydXN0VGllcjogJ2Jhc2ljJyxcbiAgICAgIHJhdGVMaW1pdFBlclVzZXI6IDEwLFxuICAgICAgcmF0ZUxpbWl0V2luZG93TXM6IDYwMDAwXG4gICAgfSlcblxuICAgIGNhbmRpZGF0ZXMgPSBbXG4gICAgICB7IGlkOiAnY2FuZGlkYXRlLTEnLCBuYW1lOiAnQWxpY2UnLCBkZXNjcmlwdGlvbjogJ0FsaWNlIGZvciBNYXlvcicgfSxcbiAgICAgIHsgaWQ6ICdjYW5kaWRhdGUtMicsIG5hbWU6ICdCb2InLCBkZXNjcmlwdGlvbjogJ0JvYiBmb3IgTWF5b3InIH0sXG4gICAgICB7IGlkOiAnY2FuZGlkYXRlLTMnLCBuYW1lOiAnQ2hhcmxpZScsIGRlc2NyaXB0aW9uOiAnQ2hhcmxpZSBmb3IgTWF5b3InIH1cbiAgICBdXG5cbiAgICBwb2xsID0ge1xuICAgICAgaWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgdGl0bGU6ICdNYXlvciBFbGVjdGlvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Nob29zZSB5b3VyIG5leHQgbWF5b3InLFxuICAgICAgdm90aW5nTWV0aG9kOiAnc2luZ2xlLWNob2ljZScgYXMgVm90aW5nTWV0aG9kLFxuICAgICAgb3B0aW9uczogY2FuZGlkYXRlcyxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICBjbG9zZUF0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgODY0MDAwMDApLCAvLyAyNCBob3VycyBmcm9tIG5vd1xuICAgICAgY3JlYXRlZEJ5OiAndXNlci0xJyxcbiAgICAgIHZvdGluZ0NvbmZpZzoge1xuICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IGZhbHNlLFxuICAgICAgICByZXF1aXJlQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgIGFub255bW91c1ZvdGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1NpbmdsZSBDaG9pY2UgVm90aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBzaW5nbGUgY2hvaWNlIHZvdGVzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZvdGVSZXF1ZXN0OiBWb3RlUmVxdWVzdCA9IHtcbiAgICAgICAgcG9sbElkOiAndGVzdC1wb2xsLWlkJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IDAsIC8vIEZpcnN0IGNhbmRpZGF0ZVxuICAgICAgICAgIHNlbGVjdGVkT3B0aW9uczogWydjYW5kaWRhdGUtMSddLFxuICAgICAgICAgIHJhbmtpbmc6IG51bGwsXG4gICAgICAgICAgd2VpZ2h0czogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCB2YWxpZGF0aW9uXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZSh2b3RlUmVxdWVzdCwgcG9sbClcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpXG5cbiAgICAgIC8vIFRlc3QgcHJvY2Vzc2luZ1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUodm90ZVJlcXVlc3QsIHBvbGwpXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnZvdGVJZCkudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlcyBmb3IgY2xvc2VkIHBvbGxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2VkUG9sbCA9IHsgLi4ucG9sbCwgc3RhdHVzOiAnY2xvc2VkJyBhcyBjb25zdCB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZvdGVSZXF1ZXN0OiBWb3RlUmVxdWVzdCA9IHtcbiAgICAgICAgcG9sbElkOiAndGVzdC1wb2xsLWlkJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnM6IFsnY2FuZGlkYXRlLTEnXSxcbiAgICAgICAgICByYW5raW5nOiBudWxsLFxuICAgICAgICAgIHdlaWdodHM6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKHZvdGVSZXF1ZXN0LCBjbG9zZWRQb2xsKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcnMpLnRvQ29udGFpbignUG9sbCBpcyBub3QgYWN0aXZlJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZXMgd2l0aCBpbnZhbGlkIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgY2hvaWNlOiA5OTksIC8vIEludmFsaWQgY2hvaWNlXG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbJ2ludmFsaWQtY2FuZGlkYXRlJ10sXG4gICAgICAgICAgcmFua2luZzogbnVsbCxcbiAgICAgICAgICB3ZWlnaHRzOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZSh2b3RlUmVxdWVzdCwgcG9sbClcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0NvbnRhaW4oJ0ludmFsaWQgb3B0aW9uIHNlbGVjdGVkJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdSYW5rZWQgQ2hvaWNlIFZvdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgcmFua2VkIGNob2ljZSB2b3RlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByYW5rZWRQb2xsID0geyAuLi5wb2xsLCB2b3RpbmdNZXRob2Q6ICdyYW5rZWQtY2hvaWNlJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgXG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbXSxcbiAgICAgICAgICByYW5raW5nczogWzAsIDEsIDJdLCAvLyBJbmRpY2VzIG9mIGNhbmRpZGF0ZXMgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICAgICAgICAgIHdlaWdodHM6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKHZvdGVSZXF1ZXN0LCByYW5rZWRQb2xsKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSlcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUodm90ZVJlcXVlc3QsIHJhbmtlZFBvbGwpXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBJUlYgcmVzdWx0cyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxjdWxhdG9yID0gbmV3IElSVkNhbGN1bGF0b3IoJ3Rlc3QtcG9sbCcsIGNhbmRpZGF0ZXMpXG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJSYW5raW5ncyA9IFtcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTEnLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0zJ10gfSxcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTInLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0zJ10gfSxcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTMnLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0zJ10gfSxcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTQnLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0zJ10gfVxuICAgICAgXVxuXG4gICAgICBjb25zdCByZXN1bHRzID0gY2FsY3VsYXRvci5jYWxjdWxhdGVSZXN1bHRzKHVzZXJSYW5raW5ncylcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSg0KVxuICAgICAgZXhwZWN0KHJlc3VsdHMud2lubmVyKS50b0JlKCdjYW5kaWRhdGUtMScpXG4gICAgICBleHBlY3QocmVzdWx0cy5yb3VuZHMpLnRvSGF2ZUxlbmd0aCgyKSAvLyBJUlYgY29ycmVjdGx5IHRha2VzIDIgcm91bmRzIHRvIGRldGVybWluZSB3aW5uZXJcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdGllIHNjZW5hcmlvcyBpbiBJUlYnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxjdWxhdG9yID0gbmV3IElSVkNhbGN1bGF0b3IoJ3Rlc3QtcG9sbCcsIGNhbmRpZGF0ZXMpXG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJSYW5raW5ncyA9IFtcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTEnLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0zJ10gfSxcbiAgICAgICAgeyB1c2VySWQ6ICd1c2VyLTInLCByYW5raW5nOiBbJ2NhbmRpZGF0ZS0yJywgJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0zJ10gfVxuICAgICAgXVxuXG4gICAgICBjb25zdCByZXN1bHRzID0gY2FsY3VsYXRvci5jYWxjdWxhdGVSZXN1bHRzKHVzZXJSYW5raW5ncylcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSgyKVxuICAgICAgZXhwZWN0KHJlc3VsdHMucm91bmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDEpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQXBwcm92YWwgVm90aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBhcHByb3ZhbCB2b3RlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcHByb3ZhbFBvbGwgPSB7IC4uLnBvbGwsIHZvdGluZ01ldGhvZDogJ2FwcHJvdmFsJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgXG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbJ2NhbmRpZGF0ZS0xJywgJ2NhbmRpZGF0ZS0yJ10sXG4gICAgICAgICAgYXBwcm92YWxzOiBbMCwgMV0sIC8vIEFwcHJvdmUgZmlyc3QgdHdvIGNhbmRpZGF0ZXNcbiAgICAgICAgICByYW5raW5nOiBudWxsLFxuICAgICAgICAgIHdlaWdodHM6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKHZvdGVSZXF1ZXN0LCBhcHByb3ZhbFBvbGwpXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZSh2b3RlUmVxdWVzdCwgYXBwcm92YWxQb2xsKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN1Y2Nlc3MpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdRdWFkcmF0aWMgVm90aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBxdWFkcmF0aWMgdm90ZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcXVhZHJhdGljUG9sbCA9IHsgLi4ucG9sbCwgdm90aW5nTWV0aG9kOiAncXVhZHJhdGljJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgXG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbXSxcbiAgICAgICAgICByYW5raW5nOiBudWxsLFxuICAgICAgICAgIGFsbG9jYXRpb25zOiB7ICcwJzogMiwgJzEnOiAxIH0gLy8gQWxsb2NhdGUgY3JlZGl0cyB0byBmaXJzdCB0d28gY2FuZGlkYXRlc1xuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IGVuZ2luZS52YWxpZGF0ZVZvdGUodm90ZVJlcXVlc3QsIHF1YWRyYXRpY1BvbGwpXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1F1YWRyYXRpYyB2YWxpZGF0aW9uIGZhaWxlZDonLCB2YWxpZGF0aW9uLmVycm9ycylcbiAgICAgIH1cbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKHZvdGVSZXF1ZXN0LCBxdWFkcmF0aWNQb2xsKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN1Y2Nlc3MpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdSYXRlIExpbWl0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZW5mb3JjZSByYXRlIGxpbWl0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZvdGVSZXF1ZXN0OiBWb3RlUmVxdWVzdCA9IHtcbiAgICAgICAgcG9sbElkOiAndGVzdC1wb2xsLWlkJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IDAsIC8vIEZpcnN0IGNhbmRpZGF0ZVxuICAgICAgICAgIHNlbGVjdGVkT3B0aW9uczogWydjYW5kaWRhdGUtMSddLFxuICAgICAgICAgIHJhbmtpbmc6IG51bGwsXG4gICAgICAgICAgd2VpZ2h0czogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBtdWx0aXBsZSByZXF1ZXN0cyB0byB0ZXN0IHJhdGUgbGltaXRpbmdcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUodm90ZVJlcXVlc3QsIHBvbGwpXG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICAvLyBTb21lIHJlcXVlc3RzIHNob3VsZCBiZSByYXRlIGxpbWl0ZWRcbiAgICAgIGNvbnN0IHJhdGVMaW1pdGVkUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MgJiYgci5lcnJvcj8uaW5jbHVkZXMoJ1JhdGUgbGltaXQgZXhjZWVkZWQnKSlcbiAgICAgIGV4cGVjdChyYXRlTGltaXRlZFJlc3BvbnNlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1Jlc3VsdHMgQ2FsY3VsYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgcmVzdWx0cyBmb3Igc2luZ2xlIGNob2ljZSB2b3RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZvdGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd2b3RlLTEnLFxuICAgICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgICBjaG9pY2U6IDAsIC8vIEZpcnN0IGNhbmRpZGF0ZVxuICAgICAgICAgIHByaXZhY3lMZXZlbDogJ3B1YmxpYycsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGF1ZGl0UmVjZWlwdDogJ3JlY2VpcHQtMSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndm90ZS0yJyxcbiAgICAgICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgICAgIHVzZXJJZDogJ3VzZXItMicsXG4gICAgICAgICAgY2hvaWNlOiAwLCAvLyBGaXJzdCBjYW5kaWRhdGVcbiAgICAgICAgICBwcml2YWN5TGV2ZWw6ICdwdWJsaWMnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBhdWRpdFJlY2VpcHQ6ICdyZWNlaXB0LTInXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZvdGUtMycsXG4gICAgICAgICAgcG9sbElkOiAndGVzdC1wb2xsLWlkJyxcbiAgICAgICAgICB1c2VySWQ6ICd1c2VyLTMnLFxuICAgICAgICAgIGNob2ljZTogMSwgLy8gU2Vjb25kIGNhbmRpZGF0ZVxuICAgICAgICAgIHByaXZhY3lMZXZlbDogJ3B1YmxpYycsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGF1ZGl0UmVjZWlwdDogJ3JlY2VpcHQtMydcbiAgICAgICAgfVxuICAgICAgXVxuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZW5naW5lLmNhbGN1bGF0ZVJlc3VsdHMocG9sbCwgdm90ZXMpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzLnRvdGFsVm90ZXMpLnRvQmUoMylcbiAgICAgIGV4cGVjdChyZXN1bHRzLnJlc3VsdHMud2lubmVyKS50b0JlKCdjYW5kaWRhdGUtMScpIC8vIFdpbm5lciBpcyB0aGUgY2FuZGlkYXRlIElEXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHZvdGUgc2V0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhwb2xsLCBbXSlcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlc3VsdHMucmVzdWx0cy53aW5uZXIpLnRvQmVOdWxsKClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkUmVxdWVzdCA9IHtcbiAgICAgICAgcG9sbElkOiAndGVzdC1wb2xsLWlkJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgdm90ZURhdGE6IG51bGwsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnlcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUobWFsZm9ybWVkUmVxdWVzdCwgcG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzcG9uc2UuZXJyb3IpLnRvQmVEZWZpbmVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBwb2xsIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbJ2NhbmRpZGF0ZS0xJ10sXG4gICAgICAgICAgcmFua2luZzogbnVsbCxcbiAgICAgICAgICB3ZWlnaHRzOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZSh2b3RlUmVxdWVzdCwgbnVsbCBhcyBhbnkpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmVycm9yKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHZvdGVzIHdpdGhpbiByZWFzb25hYmxlIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2b3RlUmVxdWVzdDogVm90ZVJlcXVlc3QgPSB7XG4gICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbJ2NhbmRpZGF0ZS0xJ10sXG4gICAgICAgICAgcmFua2luZzogbnVsbCxcbiAgICAgICAgICB3ZWlnaHRzOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKHZvdGVSZXF1ZXN0LCBwb2xsKVxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgZXhwZWN0KHByb2Nlc3NpbmdUaW1lKS50b0JlTGVzc1RoYW4oMTAwKSAvLyBTaG91bGQgcHJvY2VzcyB3aXRoaW4gMTAwbXNcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2Ugdm90ZSBzZXRzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VWb3RlU2V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGB2b3RlLSR7aX1gLFxuICAgICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgICB1c2VySWQ6IGB1c2VyLSR7aX1gLFxuICAgICAgICBjaG9pY2U6IDAsIC8vIEZpcnN0IGNhbmRpZGF0ZVxuICAgICAgICBwcml2YWN5TGV2ZWw6ICdwdWJsaWMnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIGF1ZGl0UmVjZWlwdDogYHJlY2VpcHQtJHtpfWBcbiAgICAgIH0pKVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGVuZ2luZS5jYWxjdWxhdGVSZXN1bHRzKHBvbGwsIGxhcmdlVm90ZVNldClcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSgxMDAwKVxuICAgICAgZXhwZWN0KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKSAvLyBTaG91bGQgcHJvY2VzcyB3aXRoaW4gMSBzZWNvbmRcbiAgICB9KVxuICB9KVxufSlcblxuXG5cblxuXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkZXZMb2ciLCJmbiIsImRlc2NyaWJlIiwiZW5naW5lIiwicG9sbCIsImNhbmRpZGF0ZXMiLCJiZWZvcmVFYWNoIiwiVm90ZUVuZ2luZSIsIm1heFZvdGVzUGVyUG9sbCIsImFsbG93TXVsdGlwbGVWb3RlcyIsInJlcXVpcmVBdXRoZW50aWNhdGlvbiIsIm1pblRydXN0VGllciIsInJhdGVMaW1pdFBlclVzZXIiLCJyYXRlTGltaXRXaW5kb3dNcyIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJ2b3RpbmdNZXRob2QiLCJvcHRpb25zIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsImNsb3NlQXQiLCJub3ciLCJjcmVhdGVkQnkiLCJ2b3RpbmdDb25maWciLCJhbm9ueW1vdXNWb3RpbmciLCJpdCIsInZvdGVSZXF1ZXN0IiwicG9sbElkIiwidXNlcklkIiwidm90ZURhdGEiLCJjaG9pY2UiLCJzZWxlY3RlZE9wdGlvbnMiLCJyYW5raW5nIiwid2VpZ2h0cyIsIm1ldGFkYXRhIiwiaXBBZGRyZXNzIiwidXNlckFnZW50IiwidGltZXN0YW1wIiwidmFsaWRhdGlvbiIsInZhbGlkYXRlVm90ZSIsImV4cGVjdCIsInZhbGlkIiwidG9CZSIsInJlc3BvbnNlIiwicHJvY2Vzc1ZvdGUiLCJzdWNjZXNzIiwidm90ZUlkIiwidG9CZURlZmluZWQiLCJjbG9zZWRQb2xsIiwiZXJyb3JzIiwidG9Db250YWluIiwicmFua2VkUG9sbCIsInJhbmtpbmdzIiwiY2FsY3VsYXRvciIsIklSVkNhbGN1bGF0b3IiLCJ1c2VyUmFua2luZ3MiLCJyZXN1bHRzIiwiY2FsY3VsYXRlUmVzdWx0cyIsInRvdGFsVm90ZXMiLCJ3aW5uZXIiLCJyb3VuZHMiLCJ0b0hhdmVMZW5ndGgiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJhcHByb3ZhbFBvbGwiLCJhcHByb3ZhbHMiLCJxdWFkcmF0aWNQb2xsIiwiYWxsb2NhdGlvbnMiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2VzIiwiaSIsInB1c2giLCJyYXRlTGltaXRlZFJlc3BvbnNlcyIsImZpbHRlciIsInIiLCJlcnJvciIsImluY2x1ZGVzIiwidm90ZXMiLCJwcml2YWN5TGV2ZWwiLCJhdWRpdFJlY2VpcHQiLCJ0b0JlTnVsbCIsIm1hbGZvcm1lZFJlcXVlc3QiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImVuZFRpbWUiLCJwcm9jZXNz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