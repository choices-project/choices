c94a1500e69901b2137d5bf54540cb9b
/**
 * Comprehensive Vote Engine Tests
 * 
 * Tests the core voting engine with all voting strategies
 * Tests validation, processing, and results calculation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _engine = require("../../../../../lib/vote/engine");
// Mock the logger
_globals.jest.mock("@/lib/utils/logger", ()=>({
        devLog: _globals.jest.fn()
    }));
(0, _globals.describe)("VoteEngine", ()=>{
    let engine;
    let config;
    let mockPoll;
    let mockVoteRequest;
    (0, _globals.beforeEach)(()=>{
        config = {
            maxVotesPerPoll: 1,
            allowMultipleVotes: false,
            requireAuthentication: true,
            minTrustTier: "basic",
            rateLimitPerUser: 10,
            rateLimitWindowMs: 60000
        };
        engine = new _engine.VoteEngine(config);
        mockPoll = {
            id: "test-poll-id",
            title: "Test Poll",
            description: "A test poll",
            votingMethod: "single",
            options: [
                {
                    id: "option-1",
                    text: "Option 1"
                },
                {
                    id: "option-2",
                    text: "Option 2"
                }
            ],
            status: "active",
            createdAt: new Date(),
            closeAt: new Date(Date.now() + 86400000),
            createdBy: "user-1",
            settings: {
                allowMultipleVotes: false,
                requireAuthentication: true,
                anonymousVoting: false
            }
        };
        mockVoteRequest = {
            pollId: "test-poll-id",
            userId: "user-1",
            voteData: {
                choice: 0,
                approvals: null,
                rankings: null,
                allocations: null,
                ratings: null
            },
            metadata: {
                ipAddress: "192.168.1.1",
                userAgent: "Mozilla/5.0",
                timestamp: new Date()
            }
        };
    });
    (0, _globals.describe)("Initialization", ()=>{
        (0, _globals.it)("should initialize with provided configuration", ()=>{
            (0, _globals.expect)(engine).toBeDefined();
        });
        (0, _globals.it)("should use default configuration when none provided", ()=>{
            const defaultEngine = new _engine.VoteEngine();
            (0, _globals.expect)(defaultEngine).toBeDefined();
        });
    });
    (0, _globals.describe)("Vote Validation", ()=>{
        (0, _globals.it)("should validate single-choice votes correctly", async ()=>{
            const validation = await engine.validateVote(mockVoteRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
            (0, _globals.expect)(validation.errors).toHaveLength(0);
        });
        (0, _globals.it)("should reject votes with invalid poll ID", async ()=>{
            const invalidRequest = {
                ...mockVoteRequest,
                pollId: "invalid-poll"
            };
            const validation = await engine.validateVote(invalidRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Poll ID mismatch");
        });
        (0, _globals.it)("should reject votes for closed polls", async ()=>{
            const closedPoll = {
                ...mockPoll,
                status: "closed"
            };
            const validation = await engine.validateVote(mockVoteRequest, closedPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Poll is not active");
        });
        (0, _globals.it)("should reject votes with invalid options", async ()=>{
            const invalidRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: 999,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(invalidRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Invalid option selected");
        });
        (0, _globals.it)("should validate ranked-choice votes", async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: "ranked"
            };
            const rankedRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: [
                        0,
                        1
                    ],
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(rankedRequest, rankedPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
        (0, _globals.it)("should validate approval votes", async ()=>{
            const approvalPoll = {
                ...mockPoll,
                votingMethod: "approval"
            };
            const approvalRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: [
                        0,
                        1
                    ],
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(approvalRequest, approvalPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
        (0, _globals.it)("should validate quadratic votes", async ()=>{
            const quadraticPoll = {
                ...mockPoll,
                votingMethod: "quadratic"
            };
            const quadraticRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: null,
                    allocations: {
                        "option-1": 2,
                        "option-2": 1
                    },
                    ratings: null
                }
            };
            const validation = await engine.validateVote(quadraticRequest, quadraticPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
    });
    (0, _globals.describe)("Vote Processing", ()=>{
        (0, _globals.it)("should process single-choice votes successfully", async ()=>{
            const response = await engine.processVote(mockVoteRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(true);
            (0, _globals.expect)(response.voteId).toBeDefined();
            (0, _globals.expect)(response.timestamp).toBeDefined();
        });
        (0, _globals.it)("should process ranked-choice votes successfully", async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: "ranked-choice"
            };
            const rankedRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: [
                        0,
                        1
                    ],
                    allocations: null,
                    ratings: null
                }
            };
            const response = await engine.processVote(rankedRequest, rankedPoll);
            (0, _globals.expect)(response.success).toBe(true);
            (0, _globals.expect)(response.voteId).toBeDefined();
        });
        (0, _globals.it)("should handle vote processing errors gracefully", async ()=>{
            // Mock a processing error by creating a poll with invalid voting method
            const invalidPoll = {
                ...mockPoll,
                votingMethod: "invalid-method"
            };
            const response = await engine.processVote(mockVoteRequest, invalidPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
    });
    (0, _globals.describe)("Results Calculation", ()=>{
        (0, _globals.it)("should calculate single-choice results", async ()=>{
            const votes = [
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 1,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            ];
            const results = await engine.calculateResults(mockPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(3);
            (0, _globals.expect)(results.results.winner).toBe("option-1");
        });
        (0, _globals.it)("should calculate ranked-choice results", async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: "ranked-choice"
            };
            const votes = [
                {
                    choice: null,
                    approvals: null,
                    rankings: [
                        0,
                        1
                    ],
                    allocations: null,
                    ratings: null
                },
                {
                    choice: null,
                    approvals: null,
                    rankings: [
                        1,
                        0
                    ],
                    allocations: null,
                    ratings: null
                }
            ];
            const results = await engine.calculateResults(rankedPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(2);
        });
        (0, _globals.it)("should handle empty vote sets", async ()=>{
            const results = await engine.calculateResults(mockPoll, []);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(0);
            (0, _globals.expect)(results.results.winner).toBeNull();
        });
        (0, _globals.it)("should handle tie scenarios", async ()=>{
            const votes = [
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 1,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            ];
            const results = await engine.calculateResults(mockPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(2);
        // In a tie, the result should indicate no clear winner
        });
    });
    (0, _globals.describe)("Rate Limiting", ()=>{
        (0, _globals.it)("should enforce rate limits", async ()=>{
            // Create multiple requests from the same user
            const requests = Array.from({
                length: 15
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: "user-1",
                    metadata: {
                        ...mockVoteRequest.metadata,
                        timestamp: new Date(Date.now() + i * 1000)
                    }
                }));
            // Process requests and check rate limiting
            const responses = await Promise.all(requests.map((request)=>engine.processVote(request, mockPoll)));
            // Some requests should be rate limited
            const rateLimitedResponses = responses.filter((r)=>!r.success && r.error?.includes("Rate limit exceeded"));
            (0, _globals.expect)(rateLimitedResponses.length).toBeGreaterThan(0);
        });
        (0, _globals.it)("should allow requests within rate limit", async ()=>{
            const requests = Array.from({
                length: 5
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: "user-1",
                    metadata: {
                        ...mockVoteRequest.metadata,
                        timestamp: new Date(Date.now() + i * 1000)
                    }
                }));
            const responses = await Promise.all(requests.map((request)=>engine.processVote(request, mockPoll)));
            // All requests should succeed within rate limit
            const successfulResponses = responses.filter((r)=>r.success);
            (0, _globals.expect)(successfulResponses.length).toBe(5);
        });
    });
    (0, _globals.describe)("Authentication", ()=>{
        (0, _globals.it)("should require authentication when configured", async ()=>{
            const unauthenticatedRequest = {
                ...mockVoteRequest,
                userId: null
            };
            const validation = await engine.validateVote(unauthenticatedRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain("Authentication required to vote");
        });
        (0, _globals.it)("should allow anonymous voting when configured", async ()=>{
            const anonymousPoll = {
                ...mockPoll,
                settings: {
                    ...mockPoll.settings,
                    anonymousVoting: true
                }
            };
            const anonymousRequest = {
                ...mockVoteRequest,
                userId: null
            };
            const validation = await engine.validateVote(anonymousRequest, anonymousPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
    });
    (0, _globals.describe)("Error Handling", ()=>{
        (0, _globals.it)("should handle malformed vote data", async ()=>{
            const malformedRequest = {
                ...mockVoteRequest,
                voteData: null
            };
            const response = await engine.processVote(malformedRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
        (0, _globals.it)("should handle missing poll data", async ()=>{
            const response = await engine.processVote(mockVoteRequest, null);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
        (0, _globals.it)("should handle network errors gracefully", async ()=>{
            // Create a scenario that would cause a processing error
            const invalidRequest = {
                ...mockVoteRequest,
                voteData: null
            };
            const response = await engine.processVote(invalidRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
    });
    (0, _globals.describe)("Performance", ()=>{
        (0, _globals.it)("should process votes within reasonable time", async ()=>{
            const startTime = performance.now();
            await engine.processVote(mockVoteRequest, mockPoll);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Should process within 100ms
            (0, _globals.expect)(processingTime).toBeLessThan(100);
        });
        (0, _globals.it)("should handle large vote sets efficiently", async ()=>{
            const largeVoteSet = Array.from({
                length: 1000
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: `user-${i}`,
                    voteData: {
                        selectedOptions: [
                            "option-1"
                        ],
                        ranking: null,
                        weights: null
                    }
                }));
            const startTime = performance.now();
            const results = await engine.calculateResults(mockPoll, largeVoteSet);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(processingTime).toBeLessThan(1000) // Should process within 1 second
            ;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3ZvdGUvZW5naW5lLWNvbXByZWhlbnNpdmUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXByZWhlbnNpdmUgVm90ZSBFbmdpbmUgVGVzdHNcbiAqIFxuICogVGVzdHMgdGhlIGNvcmUgdm90aW5nIGVuZ2luZSB3aXRoIGFsbCB2b3Rpbmcgc3RyYXRlZ2llc1xuICogVGVzdHMgdmFsaWRhdGlvbiwgcHJvY2Vzc2luZywgYW5kIHJlc3VsdHMgY2FsY3VsYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlRWFjaCwgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnXG5pbXBvcnQgeyBWb3RlRW5naW5lLCB0eXBlIFZvdGVFbmdpbmVDb25maWcgfSBmcm9tICdAL2xpYi92b3RlL2VuZ2luZSdcbmltcG9ydCB0eXBlIHsgVm90ZVJlcXVlc3QsIFZvdGVSZXNwb25zZSwgUG9sbERhdGEsIFZvdGluZ01ldGhvZCB9IGZyb20gJ0AvbGliL3ZvdGUvdHlwZXMnXG5cbi8vIE1vY2sgdGhlIGxvZ2dlclxuamVzdC5tb2NrKCdAL2xpYi91dGlscy9sb2dnZXInLCAoKSA9PiAoe1xuICBkZXZMb2c6IGplc3QuZm4oKVxufSkpXG5cbmRlc2NyaWJlKCdWb3RlRW5naW5lJywgKCkgPT4ge1xuICBsZXQgZW5naW5lOiBWb3RlRW5naW5lXG4gIGxldCBjb25maWc6IFZvdGVFbmdpbmVDb25maWdcbiAgbGV0IG1vY2tQb2xsOiBQb2xsRGF0YVxuICBsZXQgbW9ja1ZvdGVSZXF1ZXN0OiBWb3RlUmVxdWVzdFxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIG1heFZvdGVzUGVyUG9sbDogMSxcbiAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogZmFsc2UsXG4gICAgICByZXF1aXJlQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICBtaW5UcnVzdFRpZXI6ICdiYXNpYycsXG4gICAgICByYXRlTGltaXRQZXJVc2VyOiAxMCxcbiAgICAgIHJhdGVMaW1pdFdpbmRvd01zOiA2MDAwMFxuICAgIH1cblxuICAgIGVuZ2luZSA9IG5ldyBWb3RlRW5naW5lKGNvbmZpZylcblxuICAgIG1vY2tQb2xsID0ge1xuICAgICAgaWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgICAgZGVzY3JpcHRpb246ICdBIHRlc3QgcG9sbCcsXG4gICAgICB2b3RpbmdNZXRob2Q6ICdzaW5nbGUnIGFzIFZvdGluZ01ldGhvZCxcbiAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgeyBpZDogJ29wdGlvbi0xJywgdGV4dDogJ09wdGlvbiAxJyB9LFxuICAgICAgICB7IGlkOiAnb3B0aW9uLTInLCB0ZXh0OiAnT3B0aW9uIDInIH1cbiAgICAgIF0sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgY2xvc2VBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDg2NDAwMDAwKSwgLy8gMjQgaG91cnMgZnJvbSBub3dcbiAgICAgIGNyZWF0ZWRCeTogJ3VzZXItMScsXG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IGZhbHNlLFxuICAgICAgICByZXF1aXJlQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgIGFub255bW91c1ZvdGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2NrVm90ZVJlcXVlc3QgPSB7XG4gICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgIGNob2ljZTogMCwgLy8gSW5kZXggb2Ygb3B0aW9uLTFcbiAgICAgICAgYXBwcm92YWxzOiBudWxsLFxuICAgICAgICByYW5raW5nczogbnVsbCxcbiAgICAgICAgYWxsb2NhdGlvbnM6IG51bGwsXG4gICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgIH0sXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGVuZ2luZSkudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gd2hlbiBub25lIHByb3ZpZGVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdEVuZ2luZSA9IG5ldyBWb3RlRW5naW5lKClcbiAgICAgIGV4cGVjdChkZWZhdWx0RW5naW5lKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVm90ZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgc2luZ2xlLWNob2ljZSB2b3RlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShtb2NrVm90ZVJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0hhdmVMZW5ndGgoMClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZXMgd2l0aCBpbnZhbGlkIHBvbGwgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkUmVxdWVzdCA9IHsgLi4ubW9ja1ZvdGVSZXF1ZXN0LCBwb2xsSWQ6ICdpbnZhbGlkLXBvbGwnIH1cbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IGVuZ2luZS52YWxpZGF0ZVZvdGUoaW52YWxpZFJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKCdQb2xsIElEIG1pc21hdGNoJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZXMgZm9yIGNsb3NlZCBwb2xscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsb3NlZFBvbGwgPSB7IC4uLm1vY2tQb2xsLCBzdGF0dXM6ICdjbG9zZWQnIGFzIGNvbnN0IH1cbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IGVuZ2luZS52YWxpZGF0ZVZvdGUobW9ja1ZvdGVSZXF1ZXN0LCBjbG9zZWRQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKCdQb2xsIGlzIG5vdCBhY3RpdmUnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlcyB3aXRoIGludmFsaWQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgY2hvaWNlOiA5OTksIC8vIEludmFsaWQgb3B0aW9uIGluZGV4XG4gICAgICAgICAgYXBwcm92YWxzOiBudWxsLFxuICAgICAgICAgIHJhbmtpbmdzOiBudWxsLFxuICAgICAgICAgIGFsbG9jYXRpb25zOiBudWxsLFxuICAgICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShpbnZhbGlkUmVxdWVzdCwgbW9ja1BvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0NvbnRhaW4oJ0ludmFsaWQgb3B0aW9uIHNlbGVjdGVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByYW5rZWQtY2hvaWNlIHZvdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmFua2VkUG9sbCA9IHsgLi4ubW9ja1BvbGwsIHZvdGluZ01ldGhvZDogJ3JhbmtlZCcgYXMgVm90aW5nTWV0aG9kIH1cbiAgICAgIGNvbnN0IHJhbmtlZFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IG51bGwsXG4gICAgICAgICAgYXBwcm92YWxzOiBudWxsLFxuICAgICAgICAgIHJhbmtpbmdzOiBbMCwgMV0sIC8vIFJhbmtpbmdzIGZvciBvcHRpb24tMSBhbmQgb3B0aW9uLTJcbiAgICAgICAgICBhbGxvY2F0aW9uczogbnVsbCxcbiAgICAgICAgICByYXRpbmdzOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IGVuZ2luZS52YWxpZGF0ZVZvdGUocmFua2VkUmVxdWVzdCwgcmFua2VkUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBhcHByb3ZhbCB2b3RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwcHJvdmFsUG9sbCA9IHsgLi4ubW9ja1BvbGwsIHZvdGluZ01ldGhvZDogJ2FwcHJvdmFsJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgY29uc3QgYXBwcm92YWxSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgY2hvaWNlOiBudWxsLFxuICAgICAgICAgIGFwcHJvdmFsczogWzAsIDFdLCAvLyBBcHByb3ZlIG9wdGlvbi0xIGFuZCBvcHRpb24tMlxuICAgICAgICAgIHJhbmtpbmdzOiBudWxsLFxuICAgICAgICAgIGFsbG9jYXRpb25zOiBudWxsLFxuICAgICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShhcHByb3ZhbFJlcXVlc3QsIGFwcHJvdmFsUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBxdWFkcmF0aWMgdm90ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBxdWFkcmF0aWNQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAncXVhZHJhdGljJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgY29uc3QgcXVhZHJhdGljUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0LFxuICAgICAgICB2b3RlRGF0YToge1xuICAgICAgICAgIGNob2ljZTogbnVsbCxcbiAgICAgICAgICBhcHByb3ZhbHM6IG51bGwsXG4gICAgICAgICAgcmFua2luZ3M6IG51bGwsXG4gICAgICAgICAgYWxsb2NhdGlvbnM6IHsgJ29wdGlvbi0xJzogMiwgJ29wdGlvbi0yJzogMSB9LFxuICAgICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShxdWFkcmF0aWNSZXF1ZXN0LCBxdWFkcmF0aWNQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1ZvdGUgUHJvY2Vzc2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3Mgc2luZ2xlLWNob2ljZSB2b3RlcyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZShtb2NrVm90ZVJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnZvdGVJZCkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnRpbWVzdGFtcCkudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgcmFua2VkLWNob2ljZSB2b3RlcyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByYW5rZWRQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAncmFua2VkLWNob2ljZScgYXMgVm90aW5nTWV0aG9kIH1cbiAgICAgIGNvbnN0IHJhbmtlZFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IG51bGwsXG4gICAgICAgICAgYXBwcm92YWxzOiBudWxsLFxuICAgICAgICAgIHJhbmtpbmdzOiBbMCwgMV0sIC8vIFJhbmsgb3B0aW9uLTEgZmlyc3QsIG9wdGlvbi0yIHNlY29uZFxuICAgICAgICAgIGFsbG9jYXRpb25zOiBudWxsLFxuICAgICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZShyYW5rZWRSZXF1ZXN0LCByYW5rZWRQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnZvdGVJZCkudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2b3RlIHByb2Nlc3NpbmcgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGEgcHJvY2Vzc2luZyBlcnJvciBieSBjcmVhdGluZyBhIHBvbGwgd2l0aCBpbnZhbGlkIHZvdGluZyBtZXRob2RcbiAgICAgIGNvbnN0IGludmFsaWRQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAnaW52YWxpZC1tZXRob2QnIGFzIGFueSB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKG1vY2tWb3RlUmVxdWVzdCwgaW52YWxpZFBvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmVycm9yKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmVzdWx0cyBDYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBzaW5nbGUtY2hvaWNlIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2b3RlcyA9IFtcbiAgICAgICAgeyBjaG9pY2U6IDAsIGFwcHJvdmFsczogbnVsbCwgcmFua2luZ3M6IG51bGwsIGFsbG9jYXRpb25zOiBudWxsLCByYXRpbmdzOiBudWxsIH0sXG4gICAgICAgIHsgY2hvaWNlOiAwLCBhcHByb3ZhbHM6IG51bGwsIHJhbmtpbmdzOiBudWxsLCBhbGxvY2F0aW9uczogbnVsbCwgcmF0aW5nczogbnVsbCB9LFxuICAgICAgICB7IGNob2ljZTogMSwgYXBwcm92YWxzOiBudWxsLCByYW5raW5nczogbnVsbCwgYWxsb2NhdGlvbnM6IG51bGwsIHJhdGluZ3M6IG51bGwgfVxuICAgICAgXVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZW5naW5lLmNhbGN1bGF0ZVJlc3VsdHMobW9ja1BvbGwsIHZvdGVzKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSgzKVxuICAgICAgZXhwZWN0KHJlc3VsdHMucmVzdWx0cy53aW5uZXIpLnRvQmUoJ29wdGlvbi0xJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgcmFua2VkLWNob2ljZSByZXN1bHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmFua2VkUG9sbCA9IHsgLi4ubW9ja1BvbGwsIHZvdGluZ01ldGhvZDogJ3JhbmtlZC1jaG9pY2UnIGFzIFZvdGluZ01ldGhvZCB9XG4gICAgICBjb25zdCB2b3RlcyA9IFtcbiAgICAgICAgeyBjaG9pY2U6IG51bGwsIGFwcHJvdmFsczogbnVsbCwgcmFua2luZ3M6IFswLCAxXSwgYWxsb2NhdGlvbnM6IG51bGwsIHJhdGluZ3M6IG51bGwgfSxcbiAgICAgICAgeyBjaG9pY2U6IG51bGwsIGFwcHJvdmFsczogbnVsbCwgcmFua2luZ3M6IFsxLCAwXSwgYWxsb2NhdGlvbnM6IG51bGwsIHJhdGluZ3M6IG51bGwgfVxuICAgICAgXVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZW5naW5lLmNhbGN1bGF0ZVJlc3VsdHMocmFua2VkUG9sbCwgdm90ZXMpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVzdWx0cy50b3RhbFZvdGVzKS50b0JlKDIpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHZvdGUgc2V0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhtb2NrUG9sbCwgW10pXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVzdWx0cy50b3RhbFZvdGVzKS50b0JlKDApXG4gICAgICBleHBlY3QocmVzdWx0cy5yZXN1bHRzLndpbm5lcikudG9CZU51bGwoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB0aWUgc2NlbmFyaW9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgdm90ZXMgPSBbXG4gICAgICAgIHsgY2hvaWNlOiAwLCBhcHByb3ZhbHM6IG51bGwsIHJhbmtpbmdzOiBudWxsLCBhbGxvY2F0aW9uczogbnVsbCwgcmF0aW5nczogbnVsbCB9LFxuICAgICAgICB7IGNob2ljZTogMSwgYXBwcm92YWxzOiBudWxsLCByYW5raW5nczogbnVsbCwgYWxsb2NhdGlvbnM6IG51bGwsIHJhdGluZ3M6IG51bGwgfVxuICAgICAgXVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZW5naW5lLmNhbGN1bGF0ZVJlc3VsdHMobW9ja1BvbGwsIHZvdGVzKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdHMudG90YWxWb3RlcykudG9CZSgyKVxuICAgICAgLy8gSW4gYSB0aWUsIHRoZSByZXN1bHQgc2hvdWxkIGluZGljYXRlIG5vIGNsZWFyIHdpbm5lclxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBlbmZvcmNlIHJhdGUgbGltaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIHJlcXVlc3RzIGZyb20gdGhlIHNhbWUgdXNlclxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNSB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0LFxuICAgICAgICB1c2VySWQ6ICd1c2VyLTEnLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdC5tZXRhZGF0YSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKERhdGUubm93KCkgKyBpICogMTAwMClcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgcmVxdWVzdHMgYW5kIGNoZWNrIHJhdGUgbGltaXRpbmdcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXF1ZXN0cy5tYXAocmVxdWVzdCA9PiBlbmdpbmUucHJvY2Vzc1ZvdGUocmVxdWVzdCwgbW9ja1BvbGwpKVxuICAgICAgKVxuICAgICAgXG4gICAgICAvLyBTb21lIHJlcXVlc3RzIHNob3VsZCBiZSByYXRlIGxpbWl0ZWRcbiAgICAgIGNvbnN0IHJhdGVMaW1pdGVkUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MgJiYgci5lcnJvcj8uaW5jbHVkZXMoJ1JhdGUgbGltaXQgZXhjZWVkZWQnKSlcbiAgICAgIGV4cGVjdChyYXRlTGltaXRlZFJlc3BvbnNlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGFsbG93IHJlcXVlc3RzIHdpdGhpbiByYXRlIGxpbWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0Lm1ldGFkYXRhLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGkgKiAxMDAwKVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChyZXF1ZXN0ID0+IGVuZ2luZS5wcm9jZXNzVm90ZShyZXF1ZXN0LCBtb2NrUG9sbCkpXG4gICAgICApXG4gICAgICBcbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgc3VjY2VlZCB3aXRoaW4gcmF0ZSBsaW1pdFxuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bFJlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpXG4gICAgICBleHBlY3Qoc3VjY2Vzc2Z1bFJlc3BvbnNlcy5sZW5ndGgpLnRvQmUoNSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlcXVpcmUgYXV0aGVudGljYXRpb24gd2hlbiBjb25maWd1cmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdW5hdXRoZW50aWNhdGVkUmVxdWVzdCA9IHsgLi4ubW9ja1ZvdGVSZXF1ZXN0LCB1c2VySWQ6IG51bGwgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZSh1bmF1dGhlbnRpY2F0ZWRSZXF1ZXN0LCBtb2NrUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcnMpLnRvQ29udGFpbignQXV0aGVudGljYXRpb24gcmVxdWlyZWQgdG8gdm90ZScpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgYWxsb3cgYW5vbnltb3VzIHZvdGluZyB3aGVuIGNvbmZpZ3VyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhbm9ueW1vdXNQb2xsID0ge1xuICAgICAgICAuLi5tb2NrUG9sbCxcbiAgICAgICAgc2V0dGluZ3M6IHsgLi4ubW9ja1BvbGwuc2V0dGluZ3MsIGFub255bW91c1ZvdGluZzogdHJ1ZSB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFub255bW91c1JlcXVlc3QgPSB7IC4uLm1vY2tWb3RlUmVxdWVzdCwgdXNlcklkOiBudWxsIH1cbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IGVuZ2luZS52YWxpZGF0ZVZvdGUoYW5vbnltb3VzUmVxdWVzdCwgYW5vbnltb3VzUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0LFxuICAgICAgICB2b3RlRGF0YTogbnVsbFxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZShtYWxmb3JtZWRSZXF1ZXN0LCBtb2NrUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzcG9uc2UuZXJyb3IpLnRvQmVEZWZpbmVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBwb2xsIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZShtb2NrVm90ZVJlcXVlc3QsIG51bGwgYXMgYW55KVxuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChyZXNwb25zZS5lcnJvcikudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgc2NlbmFyaW8gdGhhdCB3b3VsZCBjYXVzZSBhIHByb2Nlc3NpbmcgZXJyb3JcbiAgICAgIGNvbnN0IGludmFsaWRSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHZvdGVEYXRhOiBudWxsIGFzIGFueSAvLyBUaGlzIHNob3VsZCBjYXVzZSBhIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUoaW52YWxpZFJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChyZXNwb25zZS5lcnJvcikudG9CZURlZmluZWQoKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyB2b3RlcyB3aXRoaW4gcmVhc29uYWJsZSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKG1vY2tWb3RlUmVxdWVzdCwgbW9ja1BvbGwpXG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBwcm9jZXNzIHdpdGhpbiAxMDBtc1xuICAgICAgZXhwZWN0KHByb2Nlc3NpbmdUaW1lKS50b0JlTGVzc1RoYW4oMTAwKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSB2b3RlIHNldHMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZVZvdGVTZXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHVzZXJJZDogYHVzZXItJHtpfWAsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zOiBbJ29wdGlvbi0xJ10sXG4gICAgICAgICAgcmFua2luZzogbnVsbCxcbiAgICAgICAgICB3ZWlnaHRzOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZW5naW5lLmNhbGN1bGF0ZVJlc3VsdHMobW9ja1BvbGwsIGxhcmdlVm90ZVNldClcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChwcm9jZXNzaW5nVGltZSkudG9CZUxlc3NUaGFuKDEwMDApIC8vIFNob3VsZCBwcm9jZXNzIHdpdGhpbiAxIHNlY29uZFxuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZGV2TG9nIiwiZm4iLCJkZXNjcmliZSIsImVuZ2luZSIsImNvbmZpZyIsIm1vY2tQb2xsIiwibW9ja1ZvdGVSZXF1ZXN0IiwiYmVmb3JlRWFjaCIsIm1heFZvdGVzUGVyUG9sbCIsImFsbG93TXVsdGlwbGVWb3RlcyIsInJlcXVpcmVBdXRoZW50aWNhdGlvbiIsIm1pblRydXN0VGllciIsInJhdGVMaW1pdFBlclVzZXIiLCJyYXRlTGltaXRXaW5kb3dNcyIsIlZvdGVFbmdpbmUiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2b3RpbmdNZXRob2QiLCJvcHRpb25zIiwidGV4dCIsInN0YXR1cyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJjbG9zZUF0Iiwibm93IiwiY3JlYXRlZEJ5Iiwic2V0dGluZ3MiLCJhbm9ueW1vdXNWb3RpbmciLCJwb2xsSWQiLCJ1c2VySWQiLCJ2b3RlRGF0YSIsImNob2ljZSIsImFwcHJvdmFscyIsInJhbmtpbmdzIiwiYWxsb2NhdGlvbnMiLCJyYXRpbmdzIiwibWV0YWRhdGEiLCJpcEFkZHJlc3MiLCJ1c2VyQWdlbnQiLCJ0aW1lc3RhbXAiLCJpdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwiZGVmYXVsdEVuZ2luZSIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZVZvdGUiLCJ2YWxpZCIsInRvQmUiLCJlcnJvcnMiLCJ0b0hhdmVMZW5ndGgiLCJpbnZhbGlkUmVxdWVzdCIsInRvQ29udGFpbiIsImNsb3NlZFBvbGwiLCJyYW5rZWRQb2xsIiwicmFua2VkUmVxdWVzdCIsImFwcHJvdmFsUG9sbCIsImFwcHJvdmFsUmVxdWVzdCIsInF1YWRyYXRpY1BvbGwiLCJxdWFkcmF0aWNSZXF1ZXN0IiwicmVzcG9uc2UiLCJwcm9jZXNzVm90ZSIsInN1Y2Nlc3MiLCJ2b3RlSWQiLCJpbnZhbGlkUG9sbCIsImVycm9yIiwidm90ZXMiLCJyZXN1bHRzIiwiY2FsY3VsYXRlUmVzdWx0cyIsInRvdGFsVm90ZXMiLCJ3aW5uZXIiLCJ0b0JlTnVsbCIsInJlcXVlc3RzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJyZXNwb25zZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicmVxdWVzdCIsInJhdGVMaW1pdGVkUmVzcG9uc2VzIiwiZmlsdGVyIiwiciIsImluY2x1ZGVzIiwidG9CZUdyZWF0ZXJUaGFuIiwic3VjY2Vzc2Z1bFJlc3BvbnNlcyIsInVuYXV0aGVudGljYXRlZFJlcXVlc3QiLCJhbm9ueW1vdXNQb2xsIiwiYW5vbnltb3VzUmVxdWVzdCIsIm1hbGZvcm1lZFJlcXVlc3QiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImVuZFRpbWUiLCJwcm9jZXNzaW5nVGltZSIsInRvQmVMZXNzVGhhbiIsImxhcmdlVm90ZVNldCIsInNlbGVjdGVkT3B0aW9ucyIsInJhbmtpbmciLCJ3ZWlnaHRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFc0Q7d0JBQ0w7QUFHbEQsa0JBQWtCO0FBQ2xCQSxhQUFJLENBQUNDLElBQUksQ0FBQyxzQkFBc0IsSUFBTyxDQUFBO1FBQ3JDQyxRQUFRRixhQUFJLENBQUNHLEVBQUU7SUFDakIsQ0FBQTtBQUVBQyxJQUFBQSxpQkFBUSxFQUFDLGNBQWM7SUFDckIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsSUFBQUEsbUJBQVUsRUFBQztRQUNUSCxTQUFTO1lBQ1BJLGlCQUFpQjtZQUNqQkMsb0JBQW9CO1lBQ3BCQyx1QkFBdUI7WUFDdkJDLGNBQWM7WUFDZEMsa0JBQWtCO1lBQ2xCQyxtQkFBbUI7UUFDckI7UUFFQVYsU0FBUyxJQUFJVyxrQkFBVSxDQUFDVjtRQUV4QkMsV0FBVztZQUNUVSxJQUFJO1lBQ0pDLE9BQU87WUFDUEMsYUFBYTtZQUNiQyxjQUFjO1lBQ2RDLFNBQVM7Z0JBQ1A7b0JBQUVKLElBQUk7b0JBQVlLLE1BQU07Z0JBQVc7Z0JBQ25DO29CQUFFTCxJQUFJ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