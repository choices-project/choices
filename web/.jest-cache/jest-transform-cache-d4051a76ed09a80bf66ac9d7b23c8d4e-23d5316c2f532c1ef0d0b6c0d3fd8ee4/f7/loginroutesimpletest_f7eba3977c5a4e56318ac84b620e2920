4a4b81478d55e7309d9340af1526d5a9
/**
 * Simple Login API Route Tests
 * 
 * Tests the POST /api/auth/login endpoint with minimal mocking
 * Focuses on actual functionality rather than heavy mocks
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Test the actual API route structure
(0, _globals.describe)("Login API Route Structure", ()=>{
    (0, _globals.it)("should have proper route handler structure", async ()=>{
        // Test that the route file exists and can be imported
        const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../../../../app/api/auth/login/route")));
        (0, _globals.expect)(typeof POST).toBe("function");
    });
    (0, _globals.it)("should handle missing request body", async ()=>{
        const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../../../../app/api/auth/login/route")));
        // Create a request without body
        const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
            method: "POST",
            headers: {
                "content-type": "application/json"
            }
        });
        // Mock the required dependencies
        jest.doMock("@/lib/core/security/rate-limit", ()=>({
                rateLimiters: {
                    auth: {
                        check: jest.fn().mockResolvedValue({
                            allowed: true
                        })
                    }
                }
            }));
        jest.doMock("@/app/api/auth/_shared", ()=>({
                validateCsrfProtection: jest.fn().mockReturnValue(true),
                createCsrfErrorResponse: jest.fn().mockReturnValue(new Response("CSRF Error", {
                    status: 403
                }))
            }));
        jest.doMock("@/lib/utils/logger", ()=>({
                logger: {
                    warn: jest.fn(),
                    error: jest.fn(),
                    info: jest.fn()
                }
            }));
        // Mock Supabase to return an error for missing body
        jest.doMock("@/utils/supabase/server", ()=>({
                getSupabaseServerClient: jest.fn().mockResolvedValue({
                    auth: {
                        signInWithPassword: jest.fn().mockRejectedValue(new Error("Invalid credentials"))
                    }
                })
            }));
        try {
            const response = await POST(request);
            (0, _globals.expect)(response).toBeDefined();
        } catch (error) {
            // Expected to fail due to missing body
            (0, _globals.expect)(error).toBeDefined();
        }
    });
    (0, _globals.it)("should validate required fields", async ()=>{
        const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../../../../app/api/auth/login/route")));
        // Create a request with empty body
        const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
            method: "POST",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({})
        });
        // Mock dependencies
        jest.doMock("@/lib/core/security/rate-limit", ()=>({
                rateLimiters: {
                    auth: {
                        check: jest.fn().mockResolvedValue({
                            allowed: true
                        })
                    }
                }
            }));
        jest.doMock("@/app/api/auth/_shared", ()=>({
                validateCsrfProtection: jest.fn().mockReturnValue(true),
                createCsrfErrorResponse: jest.fn().mockReturnValue(new Response("CSRF Error", {
                    status: 403
                }))
            }));
        jest.doMock("@/lib/utils/logger", ()=>({
                logger: {
                    warn: jest.fn(),
                    error: jest.fn(),
                    info: jest.fn()
                }
            }));
        jest.doMock("@/utils/supabase/server", ()=>({
                getSupabaseServerClient: jest.fn().mockResolvedValue({
                    auth: {
                        signInWithPassword: jest.fn()
                    }
                })
            }));
        try {
            const response = await POST(request);
            (0, _globals.expect)(response).toBeDefined();
            if (response instanceof Response) {
                (0, _globals.expect)(response.status).toBe(400);
            }
        } catch (error) {
            // Expected behavior for validation errors
            (0, _globals.expect)(error).toBeDefined();
        }
    });
});
(0, _globals.describe)("Login API Route Integration", ()=>{
    (0, _globals.it)("should have proper error handling structure", ()=>{
        // Test that the route has proper error handling
        (0, _globals.expect)(true).toBe(true); // Placeholder for actual error handling tests
    });
    (0, _globals.it)("should have proper authentication flow", ()=>{
        // Test that the route has proper authentication flow
        (0, _globals.expect)(true).toBe(true); // Placeholder for actual auth flow tests
    });
    (0, _globals.it)("should have proper rate limiting integration", ()=>{
        // Test that the route has proper rate limiting
        (0, _globals.expect)(true).toBe(true); // Placeholder for actual rate limiting tests
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYXBpL2F1dGgvbG9naW4tcm91dGUtc2ltcGxlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaW1wbGUgTG9naW4gQVBJIFJvdXRlIFRlc3RzXG4gKiBcbiAqIFRlc3RzIHRoZSBQT1NUIC9hcGkvYXV0aC9sb2dpbiBlbmRwb2ludCB3aXRoIG1pbmltYWwgbW9ja2luZ1xuICogRm9jdXNlcyBvbiBhY3R1YWwgZnVuY3Rpb25hbGl0eSByYXRoZXIgdGhhbiBoZWF2eSBtb2Nrc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcblxuLy8gVGVzdCB0aGUgYWN0dWFsIEFQSSByb3V0ZSBzdHJ1Y3R1cmVcbmRlc2NyaWJlKCdMb2dpbiBBUEkgUm91dGUgU3RydWN0dXJlJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIGhhdmUgcHJvcGVyIHJvdXRlIGhhbmRsZXIgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRlc3QgdGhhdCB0aGUgcm91dGUgZmlsZSBleGlzdHMgYW5kIGNhbiBiZSBpbXBvcnRlZFxuICAgIGNvbnN0IHsgUE9TVCB9ID0gYXdhaXQgaW1wb3J0KCdAL2FwcC9hcGkvYXV0aC9sb2dpbi9yb3V0ZScpO1xuICAgIGV4cGVjdCh0eXBlb2YgUE9TVCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyByZXF1ZXN0IGJvZHknLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBQT1NUIH0gPSBhd2FpdCBpbXBvcnQoJ0AvYXBwL2FwaS9hdXRoL2xvZ2luL3JvdXRlJyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcmVxdWVzdCB3aXRob3V0IGJvZHlcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIHRoZSByZXF1aXJlZCBkZXBlbmRlbmNpZXNcbiAgICBqZXN0LmRvTW9jaygnQC9saWIvY29yZS9zZWN1cml0eS9yYXRlLWxpbWl0JywgKCkgPT4gKHtcbiAgICAgIHJhdGVMaW1pdGVyczoge1xuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgY2hlY2s6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGFsbG93ZWQ6IHRydWUgfSksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pKTtcblxuICAgIGplc3QuZG9Nb2NrKCdAL2FwcC9hcGkvYXV0aC9fc2hhcmVkJywgKCkgPT4gKHtcbiAgICAgIHZhbGlkYXRlQ3NyZlByb3RlY3Rpb246IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSksXG4gICAgICBjcmVhdGVDc3JmRXJyb3JSZXNwb25zZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShuZXcgUmVzcG9uc2UoJ0NTUkYgRXJyb3InLCB7IHN0YXR1czogNDAzIH0pKSxcbiAgICB9KSk7XG5cbiAgICBqZXN0LmRvTW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgICAgIGxvZ2dlcjoge1xuICAgICAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgICAgIGluZm86IGplc3QuZm4oKSxcbiAgICAgIH0sXG4gICAgfSkpO1xuXG4gICAgLy8gTW9jayBTdXBhYmFzZSB0byByZXR1cm4gYW4gZXJyb3IgZm9yIG1pc3NpbmcgYm9keVxuICAgIGplc3QuZG9Nb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gICAgICBnZXRTdXBhYmFzZVNlcnZlckNsaWVudDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscycpKSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIH0pKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBleHBlY3QocmVzcG9uc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEV4cGVjdGVkIHRvIGZhaWwgZHVlIHRvIG1pc3NpbmcgYm9keVxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBQT1NUIH0gPSBhd2FpdCBpbXBvcnQoJ0AvYXBwL2FwaS9hdXRoL2xvZ2luL3JvdXRlJyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcmVxdWVzdCB3aXRoIGVtcHR5IGJvZHlcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIGRlcGVuZGVuY2llc1xuICAgIGplc3QuZG9Nb2NrKCdAL2xpYi9jb3JlL3NlY3VyaXR5L3JhdGUtbGltaXQnLCAoKSA9PiAoe1xuICAgICAgcmF0ZUxpbWl0ZXJzOiB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBjaGVjazogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgYWxsb3dlZDogdHJ1ZSB9KSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSkpO1xuXG4gICAgamVzdC5kb01vY2soJ0AvYXBwL2FwaS9hdXRoL19zaGFyZWQnLCAoKSA9PiAoe1xuICAgICAgdmFsaWRhdGVDc3JmUHJvdGVjdGlvbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKSxcbiAgICAgIGNyZWF0ZUNzcmZFcnJvclJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG5ldyBSZXNwb25zZSgnQ1NSRiBFcnJvcicsIHsgc3RhdHVzOiA0MDMgfSkpLFxuICAgIH0pKTtcblxuICAgIGplc3QuZG9Nb2NrKCdAL2xpYi91dGlscy9sb2dnZXInLCAoKSA9PiAoe1xuICAgICAgbG9nZ2VyOiB7XG4gICAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICAgICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICAgICAgaW5mbzogamVzdC5mbigpLFxuICAgICAgfSxcbiAgICB9KSk7XG5cbiAgICBqZXN0LmRvTW9jaygnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInLCAoKSA9PiAoe1xuICAgICAgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBzaWduSW5XaXRoUGFzc3dvcmQ6IGplc3QuZm4oKSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIH0pKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBleHBlY3QocmVzcG9uc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEV4cGVjdGVkIGJlaGF2aW9yIGZvciB2YWxpZGF0aW9uIGVycm9yc1xuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0xvZ2luIEFQSSBSb3V0ZSBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBoYXZlIHByb3BlciBlcnJvciBoYW5kbGluZyBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCB0aGF0IHRoZSByb3V0ZSBoYXMgcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7IC8vIFBsYWNlaG9sZGVyIGZvciBhY3R1YWwgZXJyb3IgaGFuZGxpbmcgdGVzdHNcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYXZlIHByb3BlciBhdXRoZW50aWNhdGlvbiBmbG93JywgKCkgPT4ge1xuICAgIC8vIFRlc3QgdGhhdCB0aGUgcm91dGUgaGFzIHByb3BlciBhdXRoZW50aWNhdGlvbiBmbG93XG4gICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7IC8vIFBsYWNlaG9sZGVyIGZvciBhY3R1YWwgYXV0aCBmbG93IHRlc3RzXG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGF2ZSBwcm9wZXIgcmF0ZSBsaW1pdGluZyBpbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICAvLyBUZXN0IHRoYXQgdGhlIHJvdXRlIGhhcyBwcm9wZXIgcmF0ZSBsaW1pdGluZ1xuICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpOyAvLyBQbGFjZWhvbGRlciBmb3IgYWN0dWFsIHJhdGUgbGltaXRpbmcgdGVzdHNcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiUE9TVCIsImV4cGVjdCIsInRvQmUiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiamVzdCIsImRvTW9jayIsInJhdGVMaW1pdGVycyIsImF1dGgiLCJjaGVjayIsImZuIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJhbGxvd2VkIiwidmFsaWRhdGVDc3JmUHJvdGVjdGlvbiIsIm1vY2tSZXR1cm5WYWx1ZSIsImNyZWF0ZUNzcmZFcnJvclJlc3BvbnNlIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJsb2dnZXIiLCJ3YXJuIiwiZXJyb3IiLCJpbmZvIiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwicmVzcG9uc2UiLCJ0b0JlRGVmaW5lZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFZ0Q7d0JBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFNUIsc0NBQXNDO0FBQ3RDQSxJQUFBQSxpQkFBUSxFQUFDLDZCQUE2QjtJQUNwQ0MsSUFBQUEsV0FBRSxFQUFDLDhDQUE4QztRQUMvQyxzREFBc0Q7UUFDdEQsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNLG1FQUFBLFFBQU87UUFDOUJDLElBQUFBLGVBQU0sRUFBQyxPQUFPRCxNQUFNRSxJQUFJLENBQUM7SUFDM0I7SUFFQUgsSUFBQUEsV0FBRSxFQUFDLHNDQUFzQztRQUN2QyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLE1BQU0sbUVBQUEsUUFBTztRQUU5QixnQ0FBZ0M7UUFDaEMsTUFBTUcsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdDQUF3QztZQUN0RUMsUUFBUTtZQUNSQyxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDQyxLQUFLQyxNQUFNLENBQUMsa0NBQWtDLElBQU8sQ0FBQTtnQkFD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