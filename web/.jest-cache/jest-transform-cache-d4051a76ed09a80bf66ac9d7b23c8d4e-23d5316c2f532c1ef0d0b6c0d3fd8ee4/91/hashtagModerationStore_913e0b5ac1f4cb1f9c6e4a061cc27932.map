{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/stores/hashtagModerationStore.ts"],"sourcesContent":["/**\n * Hashtag Moderation Store - Zustand Implementation\n * \n * Manages hashtag moderation state including flagging interface,\n * moderation queue, and form state management.\n * \n * Created: January 15, 2025\n * Status: âœ… ACTIVE\n */\n\nimport { create } from 'zustand';\nimport { devtools } from 'zustand/middleware';\nimport { persist } from 'zustand/middleware';\nimport { immer } from 'zustand/middleware/immer';\nimport { shallow } from 'zustand/shallow';\n\nimport type { BaseStore } from './types';\n\n// Hashtag moderation types\nexport type HashtagFlagType = 'inappropriate' | 'spam' | 'misleading' | 'harassment' | 'other';\n\nexport type HashtagModerationStatus = 'pending' | 'approved' | 'rejected' | 'under_review';\n\nexport interface HashtagFlag {\n  id: string;\n  hashtagId: string;\n  flagType: HashtagFlagType;\n  reason: string;\n  userId: string;\n  timestamp: string;\n  status: HashtagModerationStatus;\n}\n\nexport interface HashtagModeration {\n  id: string;\n  hashtagId: string;\n  status: HashtagModerationStatus;\n  flags: HashtagFlag[];\n  moderatorId?: string;\n  moderatorNotes?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Store state interface\ntype HashtagModerationStore = {\n  // Modal state\n  isOpen: boolean;\n  \n  // Form state\n  flagType: HashtagFlagType;\n  reason: string;\n  \n  // Submission state\n  isSubmitting: boolean;\n  error: string | null;\n  \n  // Moderation queue\n  moderationQueue: HashtagModeration[];\n  selectedModeration: HashtagModeration | null;\n  \n  // Actions - Modal\n  setIsOpen: (open: boolean) => void;\n  \n  // Actions - Form\n  setFlagType: (type: HashtagFlagType) => void;\n  setReason: (reason: string) => void;\n  resetForm: () => void;\n  \n  // Actions - Submission\n  setIsSubmitting: (submitting: boolean) => void;\n  setError: (error: string | null) => void;\n  \n  // Actions - Moderation\n  setModerationQueue: (queue: HashtagModeration[]) => void;\n  setSelectedModeration: (moderation: HashtagModeration | null) => void;\n  addModeration: (moderation: HashtagModeration) => void;\n  updateModeration: (id: string, updates: Partial<HashtagModeration>) => void;\n  removeModeration: (id: string) => void;\n  \n  // Actions - Flags\n  submitFlag: (hashtagId: string) => Promise<void>;\n  approveFlag: (flagId: string) => Promise<void>;\n  rejectFlag: (flagId: string) => Promise<void>;\n  \n  // Actions - Queue management\n  loadModerationQueue: () => Promise<void>;\n  refreshQueue: () => Promise<void>;\n} & BaseStore;\n\n// Create hashtag moderation store with middleware\nexport const useHashtagModerationStore = create<HashtagModerationStore>()(\n  devtools(\n    persist(\n      immer((set, _get) => ({\n        // Initial state\n        isOpen: false,\n        flagType: 'inappropriate',\n        reason: '',\n        isSubmitting: false,\n        error: null,\n        moderationQueue: [],\n        selectedModeration: null,\n        isLoading: false,\n        \n        // Base store actions\n        setLoading: (loading) => set((state) => {\n          state.isLoading = loading;\n        }),\n        \n        setError: (error) => set((state) => {\n          state.error = error;\n        }),\n        \n        clearError: () => set((state) => {\n          state.error = null;\n        }),\n        \n        // Modal actions\n        setIsOpen: (open) => set((state) => {\n          state.isOpen = open;\n          \n          // Reset form when opening\n          if (open) {\n            state.flagType = 'inappropriate';\n            state.reason = '';\n            state.error = null;\n          }\n        }),\n        \n        // Form actions\n        setFlagType: (type) => set((state) => {\n          state.flagType = type;\n        }),\n        \n        setReason: (reason) => set((state) => {\n          state.reason = reason;\n        }),\n        \n        resetForm: () => set((state) => {\n          state.flagType = 'inappropriate';\n          state.reason = '';\n          state.isSubmitting = false;\n          state.error = null;\n        }),\n        \n        // Submission actions\n        setIsSubmitting: (submitting) => set((state) => {\n          state.isSubmitting = submitting;\n        }),\n        \n        // Moderation actions\n        setModerationQueue: (queue) => set((state) => {\n          state.moderationQueue = queue;\n        }),\n        \n        setSelectedModeration: (moderation) => set((state) => {\n          state.selectedModeration = moderation;\n        }),\n        \n        addModeration: (moderation) => set((state) => {\n          state.moderationQueue.unshift(moderation);\n        }),\n        \n        updateModeration: (id, updates) => set((state) => {\n          const index = state.moderationQueue.findIndex(m => m.id === id);\n          if (index !== -1) {\n            const existing = state.moderationQueue[index];\n            if (existing) {\n              state.moderationQueue[index] = {\n                ...existing,\n                ...updates,\n                updatedAt: new Date().toISOString(),\n              };\n            }\n          }\n        }),\n        \n        removeModeration: (id) => set((state) => {\n          state.moderationQueue = state.moderationQueue.filter(m => m.id !== id);\n        }),\n        \n        // Flag actions\n        submitFlag: async (hashtagId) => {\n          const state = _get();\n          if (!state.reason.trim()) {\n            set((state) => {\n              state.error = 'Please provide a reason for flagging';\n            });\n            return;\n          }\n          \n          set((state) => {\n            state.isSubmitting = true;\n            state.error = null;\n          });\n          \n          try {\n            // Get user ID from user store\n            const { useUserStore } = await import('@/lib/stores/userStore');\n            const userStore = useUserStore.getState();\n            const userId = userStore.user?.id || 'anonymous';\n            \n            const flag: HashtagFlag = {\n              id: crypto.randomUUID(),\n              hashtagId,\n              flagType: state.flagType,\n              reason: state.reason,\n              userId,\n              timestamp: new Date().toISOString(),\n              status: 'pending',\n            };\n            \n            // Submit flag to API\n            const response = await fetch('/api/hashtags/flags', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify(flag),\n            });\n            \n            if (!response.ok) {\n              throw new Error(`Failed to submit flag: ${response.statusText}`);\n            }\n            \n            // Reset form after successful submission\n            set((state) => {\n              state.isSubmitting = false;\n              state.isOpen = false;\n              state.flagType = 'inappropriate';\n              state.reason = '';\n            });\n            \n            logger.info('Flag submitted', { flag });\n          } catch (error) {\n            set((state) => {\n              state.isSubmitting = false;\n              state.error = error instanceof Error ? error.message : 'Failed to submit flag';\n            });\n          }\n        },\n        \n        approveFlag: async (flagId) => {\n          set((state) => {\n            state.isLoading = true;\n          });\n          \n          try {\n            // Approve flag via API\n            const response = await fetch(`/api/hashtags/flags/${flagId}/approve`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            });\n            \n            if (!response.ok) {\n              throw new Error(`Failed to approve flag: ${response.statusText}`);\n            }\n            \n            set((state) => {\n              const flagIndex = state.moderationQueue.findIndex(m => \n                m.flags?.some(f => f.id === flagId)\n              );\n              if (flagIndex !== -1) {\n                const moderation = state.moderationQueue[flagIndex];\n                if (moderation) {\n                  const flag = moderation.flags?.find(f => f.id === flagId);\n                  if (flag) {\n                    flag.status = 'approved';\n                  }\n                }\n              }\n              state.isLoading = false;\n            });\n            \n            // Flag approved successfully\n          } catch (error) {\n            set((state) => {\n              state.isLoading = false;\n              state.error = error instanceof Error ? error.message : 'Failed to approve flag';\n            });\n          }\n        },\n        \n        rejectFlag: async (flagId) => {\n          set((state) => {\n            state.isLoading = true;\n          });\n          \n          try {\n            // Reject flag via API\n            const response = await fetch(`/api/hashtags/flags/${flagId}/reject`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            });\n            \n            if (!response.ok) {\n              throw new Error(`Failed to reject flag: ${response.statusText}`);\n            }\n            \n            set((state) => {\n              const flagIndex = state.moderationQueue.findIndex(m => \n                m.flags?.some(f => f.id === flagId)\n              );\n              if (flagIndex !== -1) {\n                const moderation = state.moderationQueue[flagIndex];\n                if (moderation) {\n                  const flag = moderation.flags?.find(f => f.id === flagId);\n                  if (flag) {\n                    flag.status = 'rejected';\n                  }\n                }\n              }\n              state.isLoading = false;\n            });\n            \n            // Flag rejected successfully\n          } catch (error) {\n            set((state) => {\n              state.isLoading = false;\n              state.error = error instanceof Error ? error.message : 'Failed to reject flag';\n            });\n          }\n        },\n        \n        // Queue management actions\n        loadModerationQueue: async () => {\n          set((state) => {\n            state.isLoading = true;\n          });\n          \n          try {\n            // Load moderation queue from API\n            const response = await fetch('/api/hashtags/moderation/queue', {\n              method: 'GET',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            });\n            \n            if (!response.ok) {\n              throw new Error(`Failed to load moderation queue: ${response.statusText}`);\n            }\n            \n            const moderationQueue = await response.json();\n            \n            set((state) => {\n              state.moderationQueue = moderationQueue;\n              state.isLoading = false;\n            });\n          } catch (error) {\n            set((state) => {\n              state.isLoading = false;\n              state.error = error instanceof Error ? error.message : 'Failed to load moderation queue';\n            });\n          }\n        },\n        \n        refreshQueue: async () => {\n          const { loadModerationQueue } = _get();\n          await loadModerationQueue();\n        },\n      })),\n      {\n        name: 'hashtag-moderation-store',\n        partialize: (state) => ({\n          flagType: state.flagType,\n          reason: state.reason,\n        }),\n      }\n    ),\n    { name: 'hashtag-moderation-store' }\n  )\n);\n\n// Store selectors for optimized re-renders\nexport const useModerationModal = () => useHashtagModerationStore(state => state.isOpen);\nexport const useModerationForm = () => useHashtagModerationStore(\n  state => ({\n    flagType: state.flagType,\n    reason: state.reason,\n    isSubmitting: state.isSubmitting,\n    error: state.error,\n  })\n);\n\nexport const useModerationQueue = () => useHashtagModerationStore(state => state.moderationQueue);\nexport const useSelectedModeration = () => useHashtagModerationStore(state => state.selectedModeration);\nexport const useModerationLoading = () => useHashtagModerationStore(state => state.isLoading);\nexport const useModerationError = () => useHashtagModerationStore(state => state.error);\n\n// Action selectors\nexport const useModerationActions = () => useHashtagModerationStore(state => ({\n  setIsOpen: state.setIsOpen,\n  setFlagType: state.setFlagType,\n  setReason: state.setReason,\n  resetForm: state.resetForm,\n  setIsSubmitting: state.setIsSubmitting,\n  setError: state.setError,\n  setModerationQueue: state.setModerationQueue,\n  setSelectedModeration: state.setSelectedModeration,\n  addModeration: state.addModeration,\n  updateModeration: state.updateModeration,\n  removeModeration: state.removeModeration,\n  submitFlag: state.submitFlag,\n  approveFlag: state.approveFlag,\n  rejectFlag: state.rejectFlag,\n  loadModerationQueue: state.loadModerationQueue,\n  refreshQueue: state.refreshQueue,\n}));\n\n// Computed selectors\nexport const useModerationStats = () => useHashtagModerationStore(state => {\n  const queue = state.moderationQueue;\n  return {\n    total: queue.length,\n    pending: queue.filter(m => m.status === 'pending').length,\n    approved: queue.filter(m => m.status === 'approved').length,\n    rejected: queue.filter(m => m.status === 'rejected').length,\n    underReview: queue.filter(m => m.status === 'under_review').length,\n  };\n});\n\nexport const usePendingFlags = () => useHashtagModerationStore(state => \n  state.moderationQueue.flatMap(m => m.flags.filter(f => f.status === 'pending'))\n);\n\n// Store utilities\nexport const moderationStoreUtils = {\n  getFlagTypeLabel: (type: HashtagFlagType): string => {\n    const labels = {\n      inappropriate: 'Inappropriate Content',\n      spam: 'Spam',\n      misleading: 'Misleading',\n      harassment: 'Harassment',\n      other: 'Other',\n    };\n    return labels[type];\n  },\n  \n  getStatusColor: (status: HashtagModerationStatus): string => {\n    const colors = {\n      pending: 'yellow',\n      approved: 'green',\n      rejected: 'red',\n      under_review: 'blue',\n    };\n    return colors[status];\n  },\n  \n  canSubmitFlag: (reason: string): boolean => {\n    return reason.trim().length > 0;\n  },\n};\n\n// Store subscriptions\nexport const useModerationSubscription = () => {\n  const store = useHashtagModerationStore();\n  \n  return {\n    subscribe: (callback: (state: HashtagModerationStore) => void) => {\n      return useHashtagModerationStore.subscribe(callback);\n    },\n  };\n};\n\n// Store debugging\nexport const useModerationDebug = () => {\n  const state = useHashtagModerationStore();\n  \n  return {\n    state,\n    actions: useModerationActions(),\n    stats: useModerationStats(),\n  };\n};\n"],"names":["moderationStoreUtils","useHashtagModerationStore","useModerationActions","useModerationDebug","useModerationError","useModerationForm","useModerationLoading","useModerationModal","useModerationQueue","useModerationStats","useModerationSubscription","usePendingFlags","useSelectedModeration","create","devtools","persist","immer","set","_get","isOpen","flagType","reason","isSubmitting","error","moderationQueue","selectedModeration","isLoading","setLoading","loading","state","setError","clearError","setIsOpen","open","setFlagType","type","setReason","resetForm","setIsSubmitting","submitting","setModerationQueue","queue","setSelectedModeration","moderation","addModeration","unshift","updateModeration","id","updates","index","findIndex","m","existing","updatedAt","Date","toISOString","removeModeration","filter","submitFlag","hashtagId","trim","useUserStore","userStore","getState","userId","user","flag","crypto","randomUUID","timestamp","status","response","fetch","method","headers","body","JSON","stringify","ok","Error","statusText","logger","info","message","approveFlag","flagId","flagIndex","flags","some","f","find","rejectFlag","loadModerationQueue","json","refreshQueue","name","partialize","total","length","pending","approved","rejected","underReview","flatMap","getFlagTypeLabel","labels","inappropriate","spam","misleading","harassment","other","getStatusColor","colors","under_review","canSubmitFlag","store","subscribe","callback","actions","stats"],"mappings":"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"}