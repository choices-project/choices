0289b2da223f76cc9b78e77ea35ebaba
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _logger = require("../../../../../lib/utils/logger");
// Mock console methods
const mockConsole = {
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn()
};
// Replace console with mock
Object.assign(console, mockConsole);
describe("Logger Utility - Comprehensive Testing", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Basic Logging", ()=>{
        it("should log info messages", ()=>{
            _logger.logger.info("Test info message");
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Test info message/));
        });
        it("should log error messages", ()=>{
            _logger.logger.error("Test error message");
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Test error message/));
        });
        it("should log warning messages", ()=>{
            _logger.logger.warn("Test warning message");
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Test warning message/));
        });
        it("should log debug messages", ()=>{
            _logger.logger.debug("Test debug message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Test debug message/));
        });
    });
    describe("Structured Logging", ()=>{
        it("should log with metadata", ()=>{
            const metadata = {
                userId: "user-123",
                action: "login",
                timestamp: new Date().toISOString()
            };
            _logger.logger.info("User action", metadata);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User action/));
        });
        it("should log with error objects", ()=>{
            const error = new Error("Test error");
            const context = {
                userId: "user-123",
                action: "database-query"
            };
            _logger.logger.error("Database error", error, context);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Database error/));
        });
        it("should log with performance metrics", ()=>{
            const metrics = {
                duration: 150,
                memoryUsage: 25.5,
                cpuUsage: 12.3
            };
            _logger.logger.info("Performance metrics", metrics);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Performance metrics/));
        });
    });
    describe("Log Levels", ()=>{
        it("should respect log level configuration", ()=>{
            // Test different log levels
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            _logger.logger.warn("Warning message");
            _logger.logger.error("Error message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Debug message/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Warning message/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error message/));
        });
        it("should handle log level filtering", ()=>{
            // Mock environment variable for log level
            const originalEnv = process.env.NODE_ENV;
            process.env.NODE_ENV = "production";
            // In production, debug logs should be filtered
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            expect(mockConsole.debug).not.toHaveBeenCalled();
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            // Restore environment
            process.env.NODE_ENV = originalEnv;
        });
    });
    describe("Error Handling", ()=>{
        it("should handle circular references in objects", ()=>{
            const circularObj = {
                name: "test"
            };
            circularObj.self = circularObj;
            _logger.logger.info("Circular object", circularObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Circular object/));
        });
        it("should handle undefined values", ()=>{
            _logger.logger.info("Undefined value", undefined);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Undefined value/));
        });
        it("should handle null values", ()=>{
            _logger.logger.info("Null value", null);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Null value/));
        });
        it("should handle large objects", ()=>{
            const largeObj = {
                data: Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        value: `item-${i}`
                    })),
                metadata: {
                    count: 1000,
                    timestamp: new Date().toISOString()
                }
            };
            _logger.logger.info("Large object", largeObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large object/));
        });
    });
    describe("Performance", ()=>{
        it("should log within performance budget", ()=>{
            const startTime = performance.now();
            for(let i = 0; i < 100; i++){
                _logger.logger.info(`Message ${i}`);
            }
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(100); // Should complete within 100ms
        });
        it("should not block execution", async ()=>{
            const startTime = performance.now();
            // Log multiple messages asynchronously
            const promises = Array.from({
                length: 10
            }, (_, i)=>Promise.resolve().then(()=>_logger.logger.info(`Async message ${i}`)));
            await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(50); // Should complete within 50ms
        });
    });
    describe("Security", ()=>{
        it("should sanitize sensitive data", ()=>{
            const sensitiveData = {
                password: "secret123",
                token: "bearer-token",
                apiKey: "api-key-123",
                email: "user@example.com",
                normalData: "safe data"
            };
            _logger.logger.info("User data", sensitiveData);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User data/));
        });
        it("should handle SQL injection attempts", ()=>{
            const maliciousInput = "'; DROP TABLE users; --";
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
        it("should handle XSS attempts", ()=>{
            const maliciousInput = '<script>alert("xss")</script>';
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
    });
    describe("Context and Tracing", ()=>{
        it("should include request context", ()=>{
            const requestContext = {
                requestId: "req-123",
                userId: "user-123",
                ip: "192.168.1.1",
                userAgent: "Mozilla/5.0..."
            };
            _logger.logger.info("Request processed", requestContext);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Request processed/));
        });
        it("should include error stack traces", ()=>{
            const error = new Error("Test error");
            error.stack = "Error: Test error\n    at test.js:1:1";
            _logger.logger.error("Error occurred", error);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error occurred/));
        });
        it("should include timing information", ()=>{
            const timing = {
                startTime: Date.now() - 1000,
                endTime: Date.now(),
                duration: 1000
            };
            _logger.logger.info("Operation completed", timing);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Operation completed/));
        });
    });
    describe("Log Formatting", ()=>{
        it("should format timestamps correctly", ()=>{
            const timestamp = new Date("2023-01-01T00:00:00Z");
            _logger.logger.info("Timestamped message", {
                timestamp
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Timestamped message/));
        });
        it("should format objects with proper indentation", ()=>{
            const complexObj = {
                level1: {
                    level2: {
                        level3: "value",
                        array: [
                            1,
                            2,
                            3
                        ]
                    }
                }
            };
            _logger.logger.info("Complex object", complexObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Complex object/));
        });
        it("should handle special characters", ()=>{
            const specialChars = {
                unicode: "\uD83D\uDE80",
                emoji: "\uD83D\uDE00",
                symbols: "!@#$%^&*()",
                quotes: "\"double\" and 'single'"
            };
            _logger.logger.info("Special characters", specialChars);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Special characters/));
        });
    });
    describe("Memory Management", ()=>{
        it("should not cause memory leaks", ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Log many messages
            for(let i = 0; i < 1000; i++){
                _logger.logger.info(`Message ${i}`, {
                    data: `data-${i}`
                });
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB
        });
        it("should handle large log messages", ()=>{
            const largeMessage = "x".repeat(10000);
            _logger.logger.info("Large message", {
                message: largeMessage
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large message/));
        });
    });
    describe("Async Logging", ()=>{
        it("should handle async operations", async ()=>{
            const asyncOperation = async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return "async result";
            };
            _logger.logger.info("Starting async operation");
            const result = await asyncOperation();
            _logger.logger.info("Async operation completed", {
                result
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting async operation/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Async operation completed/));
        });
        it("should handle promise rejections", async ()=>{
            const failingOperation = async ()=>{
                throw new Error("Async error");
            };
            _logger.logger.info("Starting failing operation");
            try {
                await failingOperation();
            } catch (error) {
                _logger.logger.error("Async operation failed", error);
            }
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting failing operation/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Async operation failed/));
        });
    });
    describe("Log Aggregation", ()=>{
        it("should aggregate related log messages", ()=>{
            const sessionId = "session-123";
            _logger.logger.info("Session started", {
                sessionId
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "login"
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "navigate"
            });
            _logger.logger.info("Session ended", {
                sessionId
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(4);
        });
        it("should handle log batching", ()=>{
            const messages = [
                {
                    level: "info",
                    message: "Message 1"
                },
                {
                    level: "info",
                    message: "Message 2"
                },
                {
                    level: "warn",
                    message: "Warning 1"
                }
            ];
            messages.forEach((msg)=>{
                if (msg.level === "info") {
                    _logger.logger.info(msg.message);
                } else if (msg.level === "warn") {
                    _logger.logger.warn(msg.message);
                }
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(2);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3V0aWxzL2xvZ2dlci1jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAamVzdC1lbnZpcm9ubWVudCBub2RlXG4gKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQC9saWIvdXRpbHMvbG9nZ2VyJztcblxuLy8gTW9jayBjb25zb2xlIG1ldGhvZHNcbmNvbnN0IG1vY2tDb25zb2xlID0ge1xuICBsb2c6IGplc3QuZm4oKSxcbiAgZXJyb3I6IGplc3QuZm4oKSxcbiAgd2FybjogamVzdC5mbigpLFxuICBpbmZvOiBqZXN0LmZuKCksXG4gIGRlYnVnOiBqZXN0LmZuKCksXG59O1xuXG4vLyBSZXBsYWNlIGNvbnNvbGUgd2l0aCBtb2NrXG5PYmplY3QuYXNzaWduKGNvbnNvbGUsIG1vY2tDb25zb2xlKTtcblxuZGVzY3JpYmUoJ0xvZ2dlciBVdGlsaXR5IC0gQ29tcHJlaGVuc2l2ZSBUZXN0aW5nJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBsb2cgaW5mbyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdUZXN0IGluZm8gbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUZXN0IGluZm8gbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIGVycm9yIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdUZXN0IGVycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBUZXN0IGVycm9yIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3YXJuaW5nIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oJ1Rlc3Qgd2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIFdBUk46IFRlc3Qgd2FybmluZyBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgZGVidWcgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1Rlc3QgZGVidWcgbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gREVCVUc6IFRlc3QgZGVidWcgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0cnVjdHVyZWQgTG9nZ2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgYWN0aW9uOiAnbG9naW4nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIG1ldGFkYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBhY3Rpb24vKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIGVycm9yIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBhY3Rpb246ICdkYXRhYmFzZS1xdWVyeScsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFiYXNlIGVycm9yJywgZXJyb3IsIGNvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IERhdGFiYXNlIGVycm9yLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aCBwZXJmb3JtYW5jZSBtZXRyaWNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljcyA9IHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgbWVtb3J5VXNhZ2U6IDI1LjUsXG4gICAgICAgIGNwdVVzYWdlOiAxMi4zLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1BlcmZvcm1hbmNlIG1ldHJpY3MnLCBtZXRyaWNzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogUGVyZm9ybWFuY2UgbWV0cmljcy8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBMZXZlbHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IGxvZyBsZXZlbCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBkaWZmZXJlbnQgbG9nIGxldmVsc1xuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIud2FybignV2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIERFQlVHOiBEZWJ1ZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogSW5mbyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gV0FSTjogV2FybmluZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBFcnJvciBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9nIGxldmVsIGZpbHRlcmluZycsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIGxvZyBsZXZlbFxuICAgICAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gJ3Byb2R1Y3Rpb24nO1xuICAgICAgXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCBkZWJ1ZyBsb2dzIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1Zykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEluZm8gbWVzc2FnZS8pKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBlbnZpcm9ubWVudFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBvcmlnaW5hbEVudjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gb2JqZWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNpcmN1bGFyT2JqOiBhbnkgPSB7IG5hbWU6ICd0ZXN0JyB9O1xuICAgICAgY2lyY3VsYXJPYmouc2VsZiA9IGNpcmN1bGFyT2JqO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnQ2lyY3VsYXIgb2JqZWN0JywgY2lyY3VsYXJPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBDaXJjdWxhciBvYmplY3QvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmRlZmluZWQgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ1VuZGVmaW5lZCB2YWx1ZScsIHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVuZGVmaW5lZCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ051bGwgdmFsdWUnLCBudWxsKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTnVsbCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU9iaiA9IHtcbiAgICAgICAgZGF0YTogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMCB9LCAoXywgaSkgPT4gKHsgaWQ6IGksIHZhbHVlOiBgaXRlbS0ke2l9YCB9KSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY291bnQ6IDEwMDAsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnTGFyZ2Ugb2JqZWN0JywgbGFyZ2VPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBMYXJnZSBvYmplY3QvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoaW4gcGVyZm9ybWFuY2UgYnVkZ2V0JywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTAwbXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGJsb2NrIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBMb2cgbXVsdGlwbGUgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHlcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGxvZ2dlci5pbmZvKGBBc3luYyBtZXNzYWdlICR7aX1gKSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNTBtc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBzZW5zaXRpdmUgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbnNpdGl2ZURhdGEgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAnc2VjcmV0MTIzJyxcbiAgICAgICAgdG9rZW46ICdiZWFyZXItdG9rZW4nLFxuICAgICAgICBhcGlLZXk6ICdhcGkta2V5LTEyMycsXG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIG5vcm1hbERhdGE6ICdzYWZlIGRhdGEnLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgZGF0YScsIHNlbnNpdGl2ZURhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBVc2VyIGRhdGEvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBTUUwgaW5qZWN0aW9uIGF0dGVtcHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXQgPSBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCI7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGlucHV0JywgeyBpbnB1dDogbWFsaWNpb3VzSW5wdXQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVzZXIgaW5wdXQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBYU1MgYXR0ZW1wdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNJbnB1dCA9ICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+JztcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgaW5wdXQnLCB7IGlucHV0OiBtYWxpY2lvdXNJbnB1dCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBpbnB1dC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnRleHQgYW5kIFRyYWNpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHJlcXVlc3QgY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0ge1xuICAgICAgICByZXF1ZXN0SWQ6ICdyZXEtMTIzJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBpcDogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAuLi4nLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1JlcXVlc3QgcHJvY2Vzc2VkJywgcmVxdWVzdENvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBSZXF1ZXN0IHByb2Nlc3NlZC8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBlcnJvciBzdGFjayB0cmFjZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSAnRXJyb3I6IFRlc3QgZXJyb3JcXG4gICAgYXQgdGVzdC5qczoxOjEnO1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG9jY3VycmVkJywgZXJyb3IpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IEVycm9yIG9jY3VycmVkLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHRpbWluZyBpbmZvcm1hdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWluZyA9IHtcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpIC0gMTAwMCxcbiAgICAgICAgZW5kVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnT3BlcmF0aW9uIGNvbXBsZXRlZCcsIHRpbWluZyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IE9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2cgRm9ybWF0dGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZvcm1hdCB0aW1lc3RhbXBzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCcyMDIzLTAxLTAxVDAwOjAwOjAwWicpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVGltZXN0YW1wZWQgbWVzc2FnZScsIHsgdGltZXN0YW1wIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUaW1lc3RhbXBlZCBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmb3JtYXQgb2JqZWN0cyB3aXRoIHByb3BlciBpbmRlbnRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXhPYmogPSB7XG4gICAgICAgIGxldmVsMToge1xuICAgICAgICAgIGxldmVsMjoge1xuICAgICAgICAgICAgbGV2ZWwzOiAndmFsdWUnLFxuICAgICAgICAgICAgYXJyYXk6IFsxLCAyLCAzXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0NvbXBsZXggb2JqZWN0JywgY29tcGxleE9iaik7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IENvbXBsZXggb2JqZWN0LykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbENoYXJzID0ge1xuICAgICAgICB1bmljb2RlOiAn8J+agCcsXG4gICAgICAgIGVtb2ppOiAn8J+YgCcsXG4gICAgICAgIHN5bWJvbHM6ICchQCMkJV4mKigpJyxcbiAgICAgICAgcXVvdGVzOiAnXCJkb3VibGVcIiBhbmQgXFwnc2luZ2xlXFwnJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTcGVjaWFsIGNoYXJhY3RlcnMnLCBzcGVjaWFsQ2hhcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTcGVjaWFsIGNoYXJhY3RlcnMvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBjYXVzZSBtZW1vcnkgbGVha3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgXG4gICAgICAvLyBMb2cgbWFueSBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWAsIHsgZGF0YTogYGRhdGEtJHtpfWAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgICBcbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxME1CXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBsb2cgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU1lc3NhZ2UgPSAneCcucmVwZWF0KDEwMDAwKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0xhcmdlIG1lc3NhZ2UnLCB7IG1lc3NhZ2U6IGxhcmdlTWVzc2FnZSB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTGFyZ2UgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FzeW5jIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFzeW5jT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgcmV0dXJuICdhc3luYyByZXN1bHQnO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXN5bmNPcGVyYXRpb24oKTtcbiAgICAgIGxvZ2dlci5pbmZvKCdBc3luYyBvcGVyYXRpb24gY29tcGxldGVkJywgeyByZXN1bHQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFN0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEFzeW5jIG9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwcm9taXNlIHJlamVjdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmYWlsaW5nT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FzeW5jIGVycm9yJyk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgZmFpbGluZyBvcGVyYXRpb24nKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmFpbGluZ09wZXJhdGlvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdBc3luYyBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTdGFydGluZyBmYWlsaW5nIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBFUlJPUjogQXN5bmMgb3BlcmF0aW9uIGZhaWxlZC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBBZ2dyZWdhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFnZ3JlZ2F0ZSByZWxhdGVkIGxvZyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTZXNzaW9uIHN0YXJ0ZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIHsgc2Vzc2lvbklkLCBhY3Rpb246ICdsb2dpbicgfSk7XG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBhY3Rpb24nLCB7IHNlc3Npb25JZCwgYWN0aW9uOiAnbmF2aWdhdGUnIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oJ1Nlc3Npb24gZW5kZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvZyBiYXRjaGluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW1xuICAgICAgICB7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdNZXNzYWdlIDEnIH0sXG4gICAgICAgIHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZTogJ01lc3NhZ2UgMicgfSxcbiAgICAgICAgeyBsZXZlbDogJ3dhcm4nLCBtZXNzYWdlOiAnV2FybmluZyAxJyB9LFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICBpZiAobXNnLmxldmVsID09PSAnaW5mbycpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhtc2cubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobXNnLmxldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihtc2cubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuIl0sIm5hbWVzIjpbIm1vY2tDb25zb2xlIiwibG9nIiwiamVzdCIsImZuIiwiZXJyb3IiLCJ3YXJuIiwiaW5mbyIsImRlYnVnIiwiT2JqZWN0IiwiYXNzaWduIiwiY29uc29sZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImxvZ2dlciIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nTWF0Y2hpbmciLCJtZXRhZGF0YSIsInVzZXJJZCIsImFjdGlvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIkVycm9yIiwiY29udGV4dCIsIm1ldHJpY3MiLCJkdXJhdGlvbiIsIm1lbW9yeVVzYWdlIiwiY3B1VXNhZ2UiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjaXJjdWxhck9iaiIsIm5hbWUiLCJzZWxmIiwidW5kZWZpbmVkIiwibGFyZ2VPYmoiLCJkYXRhIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJpZCIsInZhbHVlIiwiY291bnQiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJwcm9taXNlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImFsbCIsInNlbnNpdGl2ZURhdGEiLCJwYXNzd29yZCIsInRva2VuIiwiYXBpS2V5IiwiZW1haWwiLCJub3JtYWxEYXRhIiwibWFsaWNpb3VzSW5wdXQiLCJpbnB1dCIsInJlcXVlc3RDb250ZXh0IiwicmVxdWVzdElkIiwiaXAiLCJ1c2VyQWdlbnQiLCJzdGFjayIsInRpbWluZyIsImNvbXBsZXhPYmoiLCJsZXZlbDEiLCJsZXZlbDIiLCJsZXZlbDMiLCJhcnJheSIsInNwZWNpYWxDaGFycyIsInVuaWNvZGUiLCJlbW9qaSIsInN5bWJvbHMiLCJxdW90ZXMiLCJpbml0aWFsTWVtb3J5IiwiaGVhcFVzZWQiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwibGFyZ2VNZXNzYWdlIiwicmVwZWF0IiwibWVzc2FnZSIsImFzeW5jT3BlcmF0aW9uIiwic2V0VGltZW91dCIsInJlc3VsdCIsImZhaWxpbmdPcGVyYXRpb24iLCJzZXNzaW9uSWQiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJtZXNzYWdlcyIsImxldmVsIiwiZm9yRWFjaCIsIm1zZyJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7d0JBRXNCO0FBRXZCLHVCQUF1QjtBQUN2QixNQUFNQSxjQUFjO0lBQ2xCQyxLQUFLQyxLQUFLQyxFQUFFO0lBQ1pDLE9BQU9GLEtBQUtDLEVBQUU7SUFDZEUsTUFBTUgsS0FBS0MsRUFBRTtJQUNiRyxNQUFNSixLQUFLQyxFQUFFO0lBQ2JJLE9BQU9MLEtBQUtDLEVBQUU7QUFDaEI7QUFFQSw0QkFBNEI7QUFDNUJLLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBU1Y7QUFFdkJXLFNBQVMsMENBQTBDO0lBQ2pEQyxXQUFXO1FBQ1RWLEtBQUtXLGFBQWE7SUFDcEI7SUFFQUYsU0FBUyxpQkFBaUI7UUFDeEJHLEdBQUcsNEJBQTRCO1lBQzdCQyxjQUFNLENBQUNULElBQUksQ0FBQztZQUVaVSxPQUFPaEIsWUFBWU0sSUFBSSxFQUFF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