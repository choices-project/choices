{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/strategies/ranked.ts"],"sourcesContent":["/**\n * Ranked Choice Voting Strategy\n * \n * Implements ranked choice voting (Instant Runoff Voting) where voters rank options\n * in order of preference. Results are calculated using multiple rounds of elimination.\n * \n * Created: September 15, 2025\n * Updated: September 15, 2025\n */\n\nimport { devLog } from '@/lib/utils/logger';\nimport { withOptional } from '@/lib/utils/objects';\n\nimport type { \n  VotingStrategy, \n  VoteRequest, \n  VoteResponse, \n  VoteValidation, \n  PollData, \n  VoteData, \n  ResultsData,\n  VotingMethod,\n  PollResults,\n  InstantRunoffRound\n} from '../types';\n\nexport class RankedStrategy implements VotingStrategy {\n  \n  getVotingMethod(): VotingMethod {\n    return 'ranked';\n  }\n\n  async validateVote(request: VoteRequest, poll: PollData): Promise<VoteValidation> {\n    try {\n      const { voteData } = request;\n      \n      // Check if rankings array is provided\n      if (!voteData.rankings || !Array.isArray(voteData.rankings)) {\n        return {\n          valid: false,\n          errors: ['Rankings array is required for ranked choice voting'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Validate rankings array is not empty\n      if (voteData.rankings.length === 0) {\n        return {\n          valid: false,\n          errors: ['At least one option must be ranked'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Validate all rankings are valid integers\n      for (const ranking of voteData.rankings) {\n        if (typeof ranking !== 'number' || !Number.isInteger(ranking)) {\n          return {\n            valid: false,\n            errors: ['All rankings must be valid integers'],\n            requiresAuthentication: true,\n            requiresTokens: false\n          };\n        }\n\n        if (ranking < 0 || ranking >= poll.options.length) {\n          return {\n            valid: false,\n            errors: ['Invalid option selected'],\n            requiresAuthentication: true,\n            requiresTokens: false\n          };\n        }\n      }\n\n      // Check for duplicate rankings\n      const uniqueRankings = new Set(voteData.rankings);\n      if (uniqueRankings.size !== voteData.rankings.length) {\n        return {\n          valid: false,\n          errors: ['Duplicate rankings are not allowed'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Validate ranking completeness (all options must be ranked)\n      if (voteData.rankings.length !== poll.options.length) {\n        return {\n          valid: false,\n          errors: ['All options must be ranked'],\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      devLog('Ranked vote validated successfully', {\n        pollId: request.pollId,\n        rankings: voteData.rankings,\n        userId: request.userId\n      });\n\n      return {\n        valid: true,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n\n    } catch (error) {\n      devLog('Ranked vote validation error:', error);\n      return {\n        valid: false,\n        errors: [error instanceof Error ? error.message : 'Validation failed'],\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n  }\n\n  async processVote(request: VoteRequest, poll: PollData): Promise<VoteResponse> {\n    try {\n      const { voteData, userId, pollId, privacyLevel } = request;\n      \n      // Generate vote ID\n      const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create audit receipt\n      const auditReceipt = `receipt_${voteId}_${Date.now()}`;\n\n      // In a real implementation, this would:\n      // 1. Store the vote in the database\n      // 2. Update poll vote counts\n      // 3. Trigger any necessary notifications\n      // 4. Log the vote for audit purposes\n\n      devLog('Ranked vote processed successfully', {\n        pollId,\n        voteId,\n        rankings: voteData.rankings,\n        userId,\n        auditReceipt\n      });\n\n      return withOptional(\n        {\n          success: true,\n          message: 'Vote submitted successfully',\n          pollId,\n          voteId,\n          auditReceipt,\n          responseTime: 0, // Will be set by the engine\n          metadata: {\n            votingMethod: 'ranked',\n            rankings: voteData.rankings,\n            rankedOptions: voteData.rankings?.map((rank, index) => ({\n              rank: index + 1,\n              option: poll.options[rank]?.text\n            })) || []\n          }\n        },\n        {\n          privacyLevel\n        }\n      );\n\n    } catch (error) {\n      devLog('Ranked vote processing error:', error);\n      return withOptional(\n        {\n          success: false,\n          message: error instanceof Error ? error.message : 'Vote processing failed',\n          pollId: request.pollId,\n          responseTime: 0,\n          metadata: {\n            votingMethod: 'ranked',\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        },\n        {\n          voteId: undefined,\n          auditReceipt: undefined,\n          privacyLevel: request.privacyLevel\n        }\n      );\n    }\n  }\n\n  async calculateResults(poll: PollData, votes: VoteData[]): Promise<ResultsData> {\n    try {\n      const startTime = Date.now();\n      \n      // Run instant runoff voting\n      const runoffRounds = this.runInstantRunoff(poll, votes);\n      \n      // Calculate Borda scores\n      const bordaScores = this.calculateBordaScores(poll, votes);\n      \n      // Find winner from final round\n      const finalRound = runoffRounds[runoffRounds.length - 1];\n      let winner: string | undefined;\n      let winnerVotes = 0;\n      let winnerPercentage = 0;\n\n      if (finalRound && Object.keys(finalRound.votes).length > 0) {\n        const entries = Object.entries(finalRound.votes);\n        const maxEntry = entries.reduce((max, current) => \n          current[1] > max[1] ? current : max\n        );\n        \n        winner = maxEntry[0];\n        winnerVotes = maxEntry[1];\n        winnerPercentage = finalRound.percentages[winner] || 0;\n      }\n\n      // Calculate option votes and percentages\n      const optionVotes: Record<string, number> = {};\n      const optionPercentages: Record<string, number> = {};\n      \n      poll.options.forEach((_, index) => {\n        optionVotes[index.toString()] = 0;\n        optionPercentages[index.toString()] = 0;\n      });\n\n      // Count first-choice votes\n      votes.forEach(vote => {\n        if (vote.rankings && vote.rankings.length > 0) {\n          const firstRanking = vote.rankings[0];\n          if (firstRanking !== undefined) {\n            const firstChoice = firstRanking.toString();\n            if (optionVotes[firstChoice] !== undefined) {\n              optionVotes[firstChoice]++;\n            }\n          }\n        }\n      });\n\n      const totalVotes = votes.length;\n      if (totalVotes > 0) {\n        Object.keys(optionVotes).forEach(optionIndex => {\n          const votes = optionVotes[optionIndex];\n          if (votes !== undefined) {\n            optionPercentages[optionIndex] = (votes / totalVotes) * 100;\n          }\n        });\n      }\n\n      const results: PollResults = withOptional(\n        {\n          winnerVotes,\n          winnerPercentage,\n          bordaScores,\n          instantRunoffRounds: runoffRounds,\n          optionVotes,\n          optionPercentages,\n          abstentions: 0,\n          abstentionPercentage: 0\n        },\n        {\n          winner\n        }\n      );\n\n      const resultsData: ResultsData = {\n        pollId: poll.id,\n        votingMethod: 'ranked',\n        totalVotes,\n        participationRate: totalVotes > 0 ? 100 : 0, // This would be calculated based on eligible voters\n        results,\n        calculatedAt: new Date().toISOString(),\n        metadata: {\n          calculationTime: Date.now() - startTime,\n          hasWinner: winner !== undefined,\n          totalRounds: runoffRounds.length,\n          isTie: winnerVotes > 0 && Object.values(finalRound?.votes || {}).filter(v => v === winnerVotes).length > 1\n        }\n      };\n\n      devLog('Ranked results calculated', {\n        pollId: poll.id,\n        totalVotes,\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        totalRounds: runoffRounds.length,\n        calculationTime: Date.now() - startTime\n      });\n\n      return resultsData;\n\n    } catch (error) {\n      devLog('Ranked results calculation error:', error);\n      throw new Error(`Failed to calculate ranked results: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private runInstantRunoff(poll: PollData, votes: VoteData[]): InstantRunoffRound[] {\n    const rounds: InstantRunoffRound[] = [];\n    const remainingOptions = new Set(poll.options.map((_, index) => index.toString()));\n    const currentVotes = [...votes];\n\n    let round = 1;\n    while (remainingOptions.size > 1) {\n      // Count first-choice votes for remaining options\n      const roundVotes: Record<string, number> = {};\n      remainingOptions.forEach(option => {\n        roundVotes[option] = 0;\n      });\n\n      currentVotes.forEach(vote => {\n        if (vote.rankings && vote.rankings.length > 0) {\n          // Find the highest-ranked remaining option\n          for (const ranking of vote.rankings) {\n            if (ranking !== undefined) {\n              const optionIndex = ranking.toString();\n              if (remainingOptions.has(optionIndex)) {\n                roundVotes[optionIndex] = (roundVotes[optionIndex] ?? 0) + 1;\n                break;\n              }\n            }\n          }\n        }\n      });\n\n      // Calculate percentages\n      const totalVotes = Object.values(roundVotes).reduce((sum, count) => sum + count, 0);\n      const roundPercentages: Record<string, number> = {};\n      Object.keys(roundVotes).forEach(option => {\n        const votes = roundVotes[option];\n        if (votes !== undefined) {\n          roundPercentages[option] = totalVotes > 0 ? (votes / totalVotes) * 100 : 0;\n        }\n      });\n\n      // Check for majority winner\n      const majorityThreshold = totalVotes / 2;\n      const winner = Object.entries(roundVotes).find(([_, votes]) => votes > majorityThreshold);\n      \n      if (winner) {\n        // We have a majority winner\n        rounds.push({\n          round,\n          votes: roundVotes,\n          percentages: roundPercentages\n        });\n        break;\n      }\n\n      // Find option with fewest votes to eliminate\n      const minVotes = Math.min(...Object.values(roundVotes));\n      const eliminatedOptions = Object.entries(roundVotes)\n        .filter(([_, votes]) => votes === minVotes)\n        .map(([option, _]) => option);\n\n      // If there's a tie for elimination, eliminate the first one\n      const eliminated = eliminatedOptions[0];\n      if (!eliminated) {\n        throw new Error('No options to eliminate');\n      }\n      remainingOptions.delete(eliminated);\n\n      rounds.push(withOptional(\n        {\n          round,\n          votes: roundVotes,\n          percentages: roundPercentages\n        },\n        {\n          eliminated\n        }\n      ));\n\n      round++;\n    }\n\n    return rounds;\n  }\n\n  private calculateBordaScores(poll: PollData, votes: VoteData[]): Record<string, number> {\n    const bordaScores: Record<string, number> = {};\n    \n    // Initialize scores\n    poll.options.forEach((_, index) => {\n      bordaScores[index.toString()] = 0;\n    });\n\n    // Calculate Borda scores\n    votes.forEach(vote => {\n      if (vote.rankings && vote.rankings.length > 0) {\n        vote.rankings.forEach((optionIndex, rank) => {\n          const score = poll.options.length - rank - 1; // Higher rank = higher score\n          const optionKey = optionIndex.toString();\n          if (bordaScores[optionKey] !== undefined) {\n            bordaScores[optionKey] += score;\n          }\n        });\n      }\n    });\n\n    return bordaScores;\n  }\n\n  getConfiguration(): Record<string, unknown> {\n    return {\n      name: 'Ranked Choice Voting',\n      description: 'Voters rank options in order of preference. Results use instant runoff voting.',\n      minOptions: 3,\n      maxOptions: 20,\n      allowAbstention: false,\n      requiresRanking: true,\n      allowsMultipleSelections: false,\n      resultType: 'instant_runoff',\n      features: [\n        'Eliminates vote splitting',\n        'Reflects true preferences',\n        'Majority winner guaranteed',\n        'No wasted votes'\n      ],\n      limitations: [\n        'More complex to understand',\n        'Requires complete ranking',\n        'Can be time-consuming to count',\n        'May not satisfy Condorcet criterion'\n      ]\n    };\n  }\n}"],"names":["RankedStrategy","getVotingMethod","validateVote","request","poll","voteData","rankings","Array","isArray","valid","errors","requiresAuthentication","requiresTokens","length","ranking","Number","isInteger","options","uniqueRankings","Set","size","devLog","pollId","userId","error","Error","message","processVote","privacyLevel","voteId","Date","now","Math","random","toString","substr","auditReceipt","withOptional","success","responseTime","metadata","votingMethod","rankedOptions","map","rank","index","option","text","undefined","calculateResults","votes","startTime","runoffRounds","runInstantRunoff","bordaScores","calculateBordaScores","finalRound","winner","winnerVotes","winnerPercentage","Object","keys","entries","maxEntry","reduce","max","current","percentages","optionVotes","optionPercentages","forEach","_","vote","firstRanking","firstChoice","totalVotes","optionIndex","results","instantRunoffRounds","abstentions","abstentionPercentage","resultsData","id","participationRate","calculatedAt","toISOString","calculationTime","hasWinner","totalRounds","isTie","values","filter","v","rounds","remainingOptions","currentVotes","round","roundVotes","has","sum","count","roundPercentages","majorityThreshold","find","push","minVotes","min","eliminatedOptions","eliminated","delete","score","optionKey","getConfiguration","name","description","minOptions","maxOptions","allowAbstention","requiresRanking","allowsMultipleSelections","resultType","features","limitations"],"mappings":"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"}