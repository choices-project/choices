a40c07f40935ab0571eade7c87c02008
/**
 * Polls CRUD API Tests - SIMPLE VERSION
 * 
 * This is a simplified test that focuses on the core functionality
 * without complex mocking. We'll start here and evolve the tests.
 */ "use strict";
// Mock the Supabase server client
jest.mock("@/utils/supabase/server", ()=>({
        getSupabaseServerClient: jest.fn(()=>Promise.resolve(mockSupabaseClient))
    }));
// Mock authentication middleware
jest.mock("@/lib/core/auth/middleware", ()=>({
        getUser: jest.fn(()=>Promise.resolve({
                id: "user-123",
                email: "test@example.com",
                role: "user"
            }))
    }));
// Mock logger
jest.mock("@/lib/utils/logger", ()=>({
        devLog: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _route = require("../../../../../app/api/polls/route");
// Simple mock that just returns what we need
const mockSupabaseClient = {
    from: jest.fn(()=>({
            select: jest.fn(()=>({
                    eq: jest.fn(()=>({
                            limit: jest.fn().mockResolvedValue({
                                data: [
                                    {
                                        id: "poll-1",
                                        title: "Test Poll 1",
                                        total_votes: 10,
                                        options: [
                                            {
                                                id: "opt-1",
                                                text: "Option 1",
                                                votes: 6
                                            },
                                            {
                                                id: "opt-2",
                                                text: "Option 2",
                                                votes: 4
                                            }
                                        ],
                                        status: "active"
                                    }
                                ],
                                error: null
                            })
                        }))
                })),
            insert: jest.fn(()=>({
                    select: jest.fn().mockResolvedValue({
                        data: [
                            {
                                id: "poll-123",
                                title: "New Test Poll",
                                total_votes: 0,
                                options: [
                                    {
                                        id: "opt-new-1",
                                        text: "New Option 1",
                                        votes: 0
                                    },
                                    {
                                        id: "opt-new-2",
                                        text: "New Option 2",
                                        votes: 0
                                    }
                                ],
                                status: "active"
                            }
                        ],
                        error: null
                    })
                }))
        }))
};
(0, _globals.describe)("Polls CRUD API - SIMPLE", ()=>{
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        jest.restoreAllMocks();
    });
    (0, _globals.describe)("GET /api/polls - List Polls", ()=>{
        (0, _globals.it)("should return list of polls", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/polls");
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            // Debug: Let's see what we actually get
            console.log("Response status:", response.status);
            console.log("Response data:", responseData);
            // For now, just check that we get a response
            // We'll evolve this to check the exact structure later
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData).toHaveProperty("success");
            (0, _globals.expect)(responseData).toHaveProperty("polls");
        });
        (0, _globals.it)("should handle errors gracefully", async ()=>{
            // Mock an error
            mockSupabaseClient.from().select().eq().limit.mockResolvedValueOnce({
                data: null,
                error: {
                    message: "Database error"
                }
            });
            const request = new _server.NextRequest("http://localhost:3000/api/polls");
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(responseData.error).toBe("Failed to fetch polls");
        });
    });
    (0, _globals.describe)("POST /api/polls - Create Poll", ()=>{
        (0, _globals.beforeEach)(()=>{
            // Mock user profile check
            mockSupabaseClient.from().select().eq().single.mockResolvedValue({
                data: {
                    is_active: true
                },
                error: null
            });
        });
        (0, _globals.it)("should create a new poll with valid data", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/polls", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    title: "New Test Poll",
                    options: [
                        {
                            text: "New Option 1"
                        },
                        {
                            text: "New Option 2"
                        }
                    ]
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            // For now, just check that we get a response
            // We'll evolve this to check the exact structure later
            (0, _globals.expect)(response.status).toBe(201);
            (0, _globals.expect)(responseData).toHaveProperty("poll");
        });
        (0, _globals.it)("should reject poll creation without authentication", async ()=>{
            // Mock no authentication
            const { getUser } = require("@/lib/core/auth/middleware");
            getUser.mockResolvedValueOnce(null);
            const request = new _server.NextRequest("http://localhost:3000/api/polls", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    title: "Unauthorized Poll",
                    options: [
                        {
                            text: "Option 1"
                        },
                        {
                            text: "Option 2"
                        }
                    ]
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(responseData.error).toBe("Authentication required to create polls");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYXBpL2NvcmUvcG9sbHMtY3J1ZC1zaW1wbGUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvbGxzIENSVUQgQVBJIFRlc3RzIC0gU0lNUExFIFZFUlNJT05cbiAqIFxuICogVGhpcyBpcyBhIHNpbXBsaWZpZWQgdGVzdCB0aGF0IGZvY3VzZXMgb24gdGhlIGNvcmUgZnVuY3Rpb25hbGl0eVxuICogd2l0aG91dCBjb21wbGV4IG1vY2tpbmcuIFdlJ2xsIHN0YXJ0IGhlcmUgYW5kIGV2b2x2ZSB0aGUgdGVzdHMuXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBHRVQsIFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvcG9sbHMvcm91dGUnO1xuXG4vLyBTaW1wbGUgbW9jayB0aGF0IGp1c3QgcmV0dXJucyB3aGF0IHdlIG5lZWRcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgbGltaXQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogJ3BvbGwtMScsXG4gICAgICAgICAgICAgIHRpdGxlOiAnVGVzdCBQb2xsIDEnLFxuICAgICAgICAgICAgICB0b3RhbF92b3RlczogMTAsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7IGlkOiAnb3B0LTEnLCB0ZXh0OiAnT3B0aW9uIDEnLCB2b3RlczogNiB9LFxuICAgICAgICAgICAgICAgIHsgaWQ6ICdvcHQtMicsIHRleHQ6ICdPcHRpb24gMicsIHZvdGVzOiA0IH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pLFxuICAgICAgfSkpLFxuICAgIH0pKSxcbiAgICBpbnNlcnQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgXG4gICAgICAgICAgaWQ6ICdwb2xsLTEyMycsIFxuICAgICAgICAgIHRpdGxlOiAnTmV3IFRlc3QgUG9sbCcsXG4gICAgICAgICAgdG90YWxfdm90ZXM6IDAsXG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyBpZDogJ29wdC1uZXctMScsIHRleHQ6ICdOZXcgT3B0aW9uIDEnLCB2b3RlczogMCB9LFxuICAgICAgICAgICAgeyBpZDogJ29wdC1uZXctMicsIHRleHQ6ICdOZXcgT3B0aW9uIDInLCB2b3RlczogMCB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnXG4gICAgICAgIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pLFxuICAgIH0pKSxcbiAgfSkpLFxufTtcblxuLy8gTW9jayB0aGUgU3VwYWJhc2Ugc2VydmVyIGNsaWVudFxuamVzdC5tb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlU2VydmVyQ2xpZW50OiBqZXN0LmZuKCgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VwYWJhc2VDbGllbnQpKSxcbn0pKTtcblxuLy8gTW9jayBhdXRoZW50aWNhdGlvbiBtaWRkbGV3YXJlXG5qZXN0Lm1vY2soJ0AvbGliL2NvcmUvYXV0aC9taWRkbGV3YXJlJywgKCkgPT4gKHtcbiAgZ2V0VXNlcjogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoe1xuICAgIGlkOiAndXNlci0xMjMnLFxuICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgcm9sZTogJ3VzZXInXG4gIH0pKSxcbn0pKTtcblxuLy8gTW9jayBsb2dnZXJcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgZGV2TG9nOiBqZXN0LmZuKCksXG59KSk7XG5cbmRlc2NyaWJlKCdQb2xscyBDUlVEIEFQSSAtIFNJTVBMRScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dFVCAvYXBpL3BvbGxzIC0gTGlzdCBQb2xscycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBsaXN0IG9mIHBvbGxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gRGVidWc6IExldCdzIHNlZSB3aGF0IHdlIGFjdHVhbGx5IGdldFxuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGRhdGE6JywgcmVzcG9uc2VEYXRhKTtcblxuICAgICAgLy8gRm9yIG5vdywganVzdCBjaGVjayB0aGF0IHdlIGdldCBhIHJlc3BvbnNlXG4gICAgICAvLyBXZSdsbCBldm9sdmUgdGhpcyB0byBjaGVjayB0aGUgZXhhY3Qgc3RydWN0dXJlIGxhdGVyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhKS50b0hhdmVQcm9wZXJ0eSgnc3VjY2VzcycpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YSkudG9IYXZlUHJvcGVydHkoJ3BvbGxzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgYW4gZXJyb3JcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tKCkuc2VsZWN0KCkuZXEoKS5saW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgZXJyb3InIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5lcnJvcikudG9CZSgnRmFpbGVkIHRvIGZldGNoIHBvbGxzJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvcG9sbHMgLSBDcmVhdGUgUG9sbCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBwcm9maWxlIGNoZWNrXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbSgpLnNlbGVjdCgpLmVxKCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpc19hY3RpdmU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHBvbGwgd2l0aCB2YWxpZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGl0bGU6ICdOZXcgVGVzdCBQb2xsJyxcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHRleHQ6ICdOZXcgT3B0aW9uIDEnIH0sXG4gICAgICAgICAgICB7IHRleHQ6ICdOZXcgT3B0aW9uIDInIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gRm9yIG5vdywganVzdCBjaGVjayB0aGF0IHdlIGdldCBhIHJlc3BvbnNlXG4gICAgICAvLyBXZSdsbCBldm9sdmUgdGhpcyB0byBjaGVjayB0aGUgZXhhY3Qgc3RydWN0dXJlIGxhdGVyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhKS50b0hhdmVQcm9wZXJ0eSgncG9sbCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgcG9sbCBjcmVhdGlvbiB3aXRob3V0IGF1dGhlbnRpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBubyBhdXRoZW50aWNhdGlvblxuICAgICAgY29uc3QgeyBnZXRVc2VyIH0gPSByZXF1aXJlKCdAL2xpYi9jb3JlL2F1dGgvbWlkZGxld2FyZScpO1xuICAgICAgZ2V0VXNlci5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcG9sbHMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHRpdGxlOiAnVW5hdXRob3JpemVkIFBvbGwnLFxuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgdGV4dDogJ09wdGlvbiAxJyB9LFxuICAgICAgICAgICAgeyB0ZXh0OiAnT3B0aW9uIDInIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5lcnJvcikudG9CZSgnQXV0aGVudGljYXRpb24gcmVxdWlyZWQgdG8gY3JlYXRlIHBvbGxzJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJnZXRTdXBhYmFzZVNlcnZlckNsaWVudCIsImZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJnZXRVc2VyIiwiaWQiLCJlbWFpbCIsInJvbGUiLCJkZXZMb2ciLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJsaW1pdCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsInRpdGxlIiwidG90YWxfdm90ZXMiLCJvcHRpb25zIiwidGV4dCIsInZvdGVzIiwic3RhdHVzIiwiZXJyb3IiLCJpbnNlcnQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZUFsbE1vY2tzIiwiaXQiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJyZXNwb25zZSIsIkdFVCIsInJlc3BvbnNlRGF0YSIsImpzb24iLCJjb25zb2xlIiwibG9nIiwiZXhwZWN0IiwidG9CZSIsInRvSGF2ZVByb3BlcnR5IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwibWVzc2FnZSIsInNpbmdsZSIsImlzX2FjdGl2ZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIlBPU1QiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQztBQThDRCxrQ0FBa0M7QUFDbENBLEtBQUtDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDQyx5QkFBeUJGLEtBQUtHLEVBQUUsQ0FBQyxJQUFNQyxRQUFRQyxPQUFPLENBQUNDO0lBQ3pELENBQUE7QUFFQSxpQ0FBaUM7QUFDakNOLEtBQUtDLElBQUksQ0FBQyw4QkFBOEIsSUFBTyxDQUFBO1FBQzdDTSxTQUFTUCxLQUFLRyxFQUFFLENBQUMsSUFBTUMsUUFBUUMsT0FBTyxDQUFDO2dCQUNyQ0csSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtZQUNSO0lBQ0YsQ0FBQTtBQUVBLGNBQWM7QUFDZFYsS0FBS0MsSUFBSSxDQUFDLHNCQUFzQixJQUFPLENBQUE7UUFDckNVLFFBQVFYLEtB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