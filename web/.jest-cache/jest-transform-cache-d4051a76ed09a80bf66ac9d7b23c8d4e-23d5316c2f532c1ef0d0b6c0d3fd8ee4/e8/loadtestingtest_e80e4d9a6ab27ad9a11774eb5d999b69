017e1b9a3df413adbfe50673ba6cb047
/**
 * Load Testing - PHASE 3 COMPREHENSIVE TESTING
 * 
 * Tests performance under load:
 * - High user load testing
 * - Database performance
 * - API response times
 * - System scalability validation
 * - Stress testing
 * - Peak load scenarios
 * - Resource exhaustion testing
 * - Recovery testing
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock performance monitoring with proper high-resolution timing
let mockTime = 0;
const mockPerformance = {
    now: _globals.jest.fn(()=>{
        mockTime += Math.random() * 10; // Simulate realistic timing increments
        return mockTime;
    }),
    mark: _globals.jest.fn(),
    measure: _globals.jest.fn(),
    getEntriesByType: _globals.jest.fn(()=>[]),
    getEntriesByName: _globals.jest.fn(()=>[])
};
Object.defineProperty(window, "performance", {
    value: mockPerformance,
    writable: true
});
// Mock fetch with performance tracking
const mockFetch = _globals.jest.fn();
global.fetch = mockFetch;
// Mock Zustand stores for load testing
const mockFeedsStore = {
    feeds: [],
    isLoading: false,
    error: null,
    loadFeeds: _globals.jest.fn(),
    refreshFeeds: _globals.jest.fn(),
    loadMoreFeeds: _globals.jest.fn(),
    setFilters: _globals.jest.fn()
};
_globals.jest.mock("@/lib/stores", ()=>({
        useFeeds: ()=>mockFeedsStore.feeds,
        useFeedsStore: (selector)=>{
            const state = mockFeedsStore;
            return selector ? selector(state) : state;
        },
        useFeedsLoading: ()=>mockFeedsStore.isLoading,
        useFeedsError: ()=>mockFeedsStore.error
    }));
(0, _globals.describe)("Load Testing", ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
        mockFeedsStore.feeds = [];
        mockFeedsStore.isLoading = false;
        mockFeedsStore.error = null;
        mockTime = 0; // Reset mock time for each test
    });
    (0, _globals.describe)("High User Load Testing", ()=>{
        (0, _globals.it)("should handle 1000 concurrent users", async ()=>{
            const concurrentUsers = 1000;
            const startTime = performance.now();
            // Simulate concurrent user requests
            const userRequests = Array.from({
                length: concurrentUsers
            }, (_, i)=>({
                    userId: `user-${i}`,
                    requestTime: startTime,
                    endpoint: "/api/feeds",
                    method: "GET"
                }));
            // Mock API responses for concurrent users with realistic delay
            mockFetch.mockImplementation((url)=>{
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        resolve({
                            ok: true,
                            status: 200,
                            json: ()=>Promise.resolve({
                                    success: true,
                                    data: []
                                }),
                            headers: new Map()
                        });
                    }, Math.random() * 10); // Random delay 0-10ms to simulate real network
                });
            });
            // Process all requests
            const responses = await Promise.all(userRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    responseTime: performance.now() - request.requestTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageResponseTime = responses.reduce((sum, r)=>sum + r.responseTime, 0) / responses.length;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(concurrentUsers);
            (0, _globals.expect)(totalTime).toBeLessThan(5000); // Should complete within 5 seconds
            (0, _globals.expect)(averageResponseTime).toBeLessThan(100); // Average response time under 100ms
            // All requests should succeed
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
                (0, _globals.expect)(response.responseTime).toBeLessThan(500); // Individual response under 500ms
            });
        });
        (0, _globals.it)("should handle 5000 concurrent feed requests", async ()=>{
            const feedRequests = 5000;
            const startTime = performance.now();
            // Generate mock feed data
            const mockFeeds = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `feed-${i}`,
                    title: `Feed Item ${i}`,
                    content: `Content for feed item ${i}`,
                    author: {
                        id: `author-${i}`,
                        name: `Author ${i}`
                    },
                    publishedAt: new Date().toISOString(),
                    engagement: {
                        likes: Math.floor(Math.random() * 100),
                        comments: Math.floor(Math.random() * 50)
                    }
                }));
            mockFetch.mockImplementation((url)=>{
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        resolve({
                            ok: true,
                            status: 200,
                            json: ()=>Promise.resolve(mockFeeds),
                            headers: new Map()
                        });
                    }, Math.random() * 15); // Random delay 0-15ms
                });
            });
            // Simulate concurrent feed requests
            const requests = Array.from({
                length: feedRequests
            }, (_, i)=>({
                    id: i,
                    startTime: performance.now(),
                    endpoint: "/api/feeds"
                }));
            const responses = await Promise.all(requests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                const data = await response.json();
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    dataLength: data.length,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageResponseTime = responses.reduce((sum, r)=>sum + r.responseTime, 0) / responses.length;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(feedRequests);
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // Should complete within 10 seconds
            (0, _globals.expect)(averageResponseTime).toBeLessThan(200); // Average response time under 200ms
            // All requests should succeed and return data
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
                (0, _globals.expect)(response.dataLength).toBe(100);
                (0, _globals.expect)(response.responseTime).toBeLessThan(1000); // Individual response under 1 second
            });
        });
        (0, _globals.it)("should handle mixed concurrent operations", async ()=>{
            const operations = [
                {
                    type: "feed_load",
                    count: 1000,
                    endpoint: "/api/feeds"
                },
                {
                    type: "user_auth",
                    count: 500,
                    endpoint: "/api/auth/login"
                },
                {
                    type: "vote_cast",
                    count: 2000,
                    endpoint: "/api/votes"
                },
                {
                    type: "poll_create",
                    count: 100,
                    endpoint: "/api/polls"
                }
            ];
            const startTime = performance.now();
            // Mock different endpoints
            mockFetch.mockImplementation((url)=>{
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        if (url.includes("/api/feeds")) {
                            resolve({
                                ok: true,
                                status: 200,
                                json: ()=>Promise.resolve({
                                        feeds: []
                                    }),
                                headers: new Map()
                            });
                        } else if (url.includes("/api/auth/login")) {
                            resolve({
                                ok: true,
                                status: 200,
                                json: ()=>Promise.resolve({
                                        token: "auth-token"
                                    }),
                                headers: new Map()
                            });
                        } else if (url.includes("/api/votes")) {
                            resolve({
                                ok: true,
                                status: 200,
                                json: ()=>Promise.resolve({
                                        success: true
                                    }),
                                headers: new Map()
                            });
                        } else if (url.includes("/api/polls")) {
                            resolve({
                                ok: true,
                                status: 200,
                                json: ()=>Promise.resolve({
                                        pollId: "poll-123"
                                    }),
                                headers: new Map()
                            });
                        } else {
                            resolve({
                                ok: true,
                                status: 200,
                                json: ()=>Promise.resolve({})
                            });
                        }
                    }, Math.random() * 20); // Random delay 0-20ms
                });
            });
            // Execute all operations concurrently
            const allRequests = operations.flatMap((op)=>Array.from({
                    length: op.count
                }, (_, i)=>({
                        type: op.type,
                        id: i,
                        endpoint: op.endpoint,
                        startTime: performance.now()
                    })));
            const responses = await Promise.all(allRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(responses.length).toBe(3600); // Total operations
            (0, _globals.expect)(totalTime).toBeLessThan(15000); // Should complete within 15 seconds
            // Check performance by operation type
            const operationStats = operations.map((op)=>{
                const opResponses = responses.filter((r)=>r.type === op.type);
                const avgResponseTime = opResponses.reduce((sum, r)=>sum + r.responseTime, 0) / opResponses.length;
                return {
                    type: op.type,
                    count: opResponses.length,
                    avgResponseTime
                };
            });
            operationStats.forEach((stat)=>{
                (0, _globals.expect)(stat.count).toBeGreaterThan(0);
                (0, _globals.expect)(stat.avgResponseTime).toBeLessThan(500); // Each operation type under 500ms average
            });
        });
    });
    (0, _globals.describe)("Database Performance Testing", ()=>{
        (0, _globals.it)("should handle large dataset queries efficiently", async ()=>{
            const largeDataset = Array.from({
                length: 10000
            }, (_, i)=>({
                    id: `item-${i}`,
                    title: `Item ${i}`,
                    content: `Content for item ${i}`,
                    category: `category-${i % 10}`,
                    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString()
                }));
            const startTime = performance.now();
            // Simulate database query
            const queryDatabase = async (query, limit = 100)=>{
                await new Promise((resolve)=>setTimeout(resolve, Math.random() * 10)); // Simulate DB delay
                return largeDataset.slice(0, limit);
            };
            // Test different query scenarios
            const queries = [
                {
                    name: "recent_items",
                    query: "SELECT * FROM items ORDER BY createdAt DESC LIMIT 100"
                },
                {
                    name: "category_items",
                    query: 'SELECT * FROM items WHERE category = "category-1" LIMIT 100'
                },
                {
                    name: "search_items",
                    query: 'SELECT * FROM items WHERE title LIKE "%Item%" LIMIT 100'
                }
            ];
            const results = await Promise.all(queries.map(async (q)=>{
                const start = performance.now();
                const data = await queryDatabase(q.query);
                const end = performance.now();
                return {
                    name: q.name,
                    dataLength: data.length,
                    queryTime: end - start
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(totalTime).toBeLessThan(1000); // All queries under 1 second
            results.forEach((result)=>{
                (0, _globals.expect)(result.dataLength).toBe(100);
                (0, _globals.expect)(result.queryTime).toBeLessThan(200); // Individual query under 200ms
            });
        });
        (0, _globals.it)("should handle concurrent database writes", async ()=>{
            const writeOperations = 1000;
            const startTime = performance.now();
            // Simulate database write operations
            const writeToDatabase = async (data)=>{
                await new Promise((resolve)=>setTimeout(resolve, Math.random() * 5)); // Simulate DB write delay
                return {
                    id: `new-${Date.now()}`,
                    ...data
                };
            };
            const writeRequests = Array.from({
                length: writeOperations
            }, (_, i)=>({
                    id: i,
                    data: {
                        title: `New Item ${i}`,
                        content: `Content ${i}`
                    },
                    startTime: performance.now()
                }));
            const results = await Promise.all(writeRequests.map(async (request)=>{
                const result = await writeToDatabase(request.data);
                return {
                    ...request,
                    endTime: performance.now(),
                    writeTime: performance.now() - request.startTime,
                    result
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const averageWriteTime = results.reduce((sum, r)=>sum + r.writeTime, 0) / results.length;
            // Performance assertions
            (0, _globals.expect)(results.length).toBe(writeOperations);
            (0, _globals.expect)(totalTime).toBeLessThan(5000); // All writes under 5 seconds
            (0, _globals.expect)(averageWriteTime).toBeLessThan(50); // Average write time under 50ms
            // All writes should succeed
            results.forEach((result)=>{
                (0, _globals.expect)(result.result.id).toBeDefined();
                (0, _globals.expect)(result.writeTime).toBeLessThan(100); // Individual write under 100ms
            });
        });
    });
    (0, _globals.describe)("API Response Time Testing", ()=>{
        (0, _globals.it)("should maintain fast API response times under load", async ()=>{
            const apiEndpoints = [
                "/api/feeds",
                "/api/auth/status",
                "/api/votes",
                "/api/polls",
                "/api/users/profile"
            ];
            const requestsPerEndpoint = 100;
            const startTime = performance.now();
            // Mock API responses with realistic delays
            mockFetch.mockImplementation((url)=>{
                const delay = Math.random() * 50 + 10; // 10-60ms delay
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        resolve({
                            ok: true,
                            status: 200,
                            json: ()=>Promise.resolve({
                                    success: true,
                                    data: []
                                }),
                            headers: new Map()
                        });
                    }, delay);
                });
            });
            // Test all endpoints concurrently
            const allRequests = apiEndpoints.flatMap((endpoint)=>Array.from({
                    length: requestsPerEndpoint
                }, (_, i)=>({
                        endpoint,
                        id: i,
                        startTime: performance.now()
                    })));
            const responses = await Promise.all(allRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    endTime: performance.now(),
                    responseTime: performance.now() - request.startTime,
                    status: response.status
                };
            }));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Calculate performance metrics
            const endpointStats = apiEndpoints.map((endpoint)=>{
                const endpointResponses = responses.filter((r)=>r.endpoint === endpoint);
                const avgResponseTime = endpointResponses.reduce((sum, r)=>sum + r.responseTime, 0) / endpointResponses.length;
                const maxResponseTime = Math.max(...endpointResponses.map((r)=>r.responseTime));
                const minResponseTime = Math.min(...endpointResponses.map((r)=>r.responseTime));
                return {
                    endpoint,
                    count: endpointResponses.length,
                    avgResponseTime,
                    maxResponseTime,
                    minResponseTime
                };
            });
            // Performance assertions
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // All requests under 10 seconds
            endpointStats.forEach((stat)=>{
                (0, _globals.expect)(stat.count).toBe(requestsPerEndpoint);
                (0, _globals.expect)(stat.avgResponseTime).toBeLessThan(100); // Average under 100ms
                (0, _globals.expect)(stat.maxResponseTime).toBeLessThan(200); // Max under 200ms
                (0, _globals.expect)(stat.minResponseTime).toBeGreaterThan(0); // Min greater than 0
            });
        });
    });
    (0, _globals.describe)("Stress Testing", ()=>{
        (0, _globals.it)("should handle resource exhaustion gracefully", async ()=>{
            const maxConcurrentRequests = 10000;
            const startTime = performance.now();
            // Simulate resource exhaustion scenario
            let activeRequests = 0;
            let maxActiveRequests = 0;
            const simulateRequest = async (requestId)=>{
                activeRequests++;
                maxActiveRequests = Math.max(maxActiveRequests, activeRequests);
                try {
                    // Simulate processing time
                    await new Promise((resolve)=>setTimeout(resolve, Math.random() * 100));
                    // Simulate occasional failures under stress
                    if (Math.random() < 0.1) {
                        throw new Error("Resource exhausted");
                    }
                    return {
                        requestId,
                        success: true
                    };
                } catch (error) {
                    return {
                        requestId,
                        success: false,
                        error: error.message
                    };
                } finally{
                    activeRequests--;
                }
            };
            // Execute stress test
            const requests = Array.from({
                length: maxConcurrentRequests
            }, (_, i)=>i);
            const results = await Promise.all(requests.map((requestId)=>simulateRequest(requestId)));
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const successCount = results.filter((r)=>r.success).length;
            const failureCount = results.filter((r)=>!r.success).length;
            const successRate = successCount / results.length;
            // Stress test assertions
            (0, _globals.expect)(results.length).toBe(maxConcurrentRequests);
            (0, _globals.expect)(maxActiveRequests).toBeGreaterThan(0);
            (0, _globals.expect)(successRate).toBeGreaterThan(0.8); // At least 80% success rate
            (0, _globals.expect)(totalTime).toBeLessThan(30000); // Complete within 30 seconds
            // System should handle stress gracefully
            (0, _globals.expect)(failureCount).toBeLessThan(maxConcurrentRequests * 0.3); // Less than 30% failures
        });
        (0, _globals.it)("should recover from peak load scenarios", async ()=>{
            const peakLoadDuration = 5000; // 5 seconds
            const recoveryDuration = 2000; // 2 seconds
            const startTime = performance.now();
            // Simulate peak load scenario
            const simulatePeakLoad = async ()=>{
                const requests = Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        startTime: performance.now()
                    }));
                const results = await Promise.all(requests.map(async (request)=>{
                    try {
                        // Simulate processing
                        await new Promise((resolve)=>setTimeout(resolve, Math.random() * 50));
                        return {
                            ...request,
                            success: true,
                            endTime: performance.now()
                        };
                    } catch (error) {
                        return {
                            ...request,
                            success: false,
                            error: error.message,
                            endTime: performance.now()
                        };
                    }
                }));
                return results;
            };
            // Execute peak load
            const peakResults = await simulatePeakLoad();
            const peakEndTime = performance.now();
            const peakDuration = peakEndTime - startTime;
            // Wait for recovery
            await new Promise((resolve)=>setTimeout(resolve, recoveryDuration));
            // Test recovery
            const recoveryStartTime = performance.now();
            const recoveryResults = await simulatePeakLoad();
            const recoveryEndTime = performance.now();
            const actualRecoveryDuration = recoveryEndTime - recoveryStartTime;
            // Recovery assertions
            (0, _globals.expect)(peakResults.length).toBe(1000);
            (0, _globals.expect)(recoveryResults.length).toBe(1000);
            // System should recover and perform well after peak load
            const peakSuccessRate = peakResults.filter((r)=>r.success).length / peakResults.length;
            const recoverySuccessRate = recoveryResults.filter((r)=>r.success).length / recoveryResults.length;
            (0, _globals.expect)(peakSuccessRate).toBeGreaterThan(0.7); // At least 70% success during peak
            (0, _globals.expect)(recoverySuccessRate).toBeGreaterThan(0.9); // At least 90% success after recovery
            (0, _globals.expect)(actualRecoveryDuration).toBeLessThan(peakDuration * 1.5); // Recovery should be reasonably fast
        });
    });
    (0, _globals.describe)("Memory and Resource Testing", ()=>{
        (0, _globals.it)("should handle memory-intensive operations", async ()=>{
            const largeDataSize = 1000000; // 1 million items
            const startTime = performance.now();
            // Generate large dataset
            const largeDataset = Array.from({
                length: largeDataSize
            }, (_, i)=>({
                    id: i,
                    data: `Large data item ${i}`.repeat(100),
                    timestamp: Date.now()
                }));
            // Process large dataset
            const processLargeDataset = (data)=>{
                return data.filter((item)=>item.id % 2 === 0) // Filter even IDs
                .map((item)=>({
                        ...item,
                        processed: true
                    })) // Transform
                .slice(0, 1000); // Limit results
            };
            const processedData = processLargeDataset(largeDataset);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Memory and performance assertions
            (0, _globals.expect)(processedData.length).toBe(1000);
            (0, _globals.expect)(processingTime).toBeLessThan(5000); // Should process within 5 seconds
            (0, _globals.expect)(processedData.every((item)=>item.processed)).toBe(true);
        });
        (0, _globals.it)("should handle concurrent memory operations", async ()=>{
            const concurrentOperations = 100;
            const dataSizePerOperation = 10000;
            const startTime = performance.now();
            // Simulate concurrent memory operations
            const memoryOperations = Array.from({
                length: concurrentOperations
            }, (_, i)=>{
                const data = Array.from({
                    length: dataSizePerOperation
                }, (_, j)=>({
                        id: `${i}-${j}`,
                        value: Math.random() * 1000,
                        timestamp: Date.now()
                    }));
                // Process data
                const processed = data.filter((item)=>item.value > 500).map((item)=>({
                        ...item,
                        processed: true
                    })).sort((a, b)=>b.value - a.value).slice(0, 100);
                return processed;
            });
            const results = await Promise.all(memoryOperations);
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Performance assertions
            (0, _globals.expect)(results.length).toBe(concurrentOperations);
            (0, _globals.expect)(totalTime).toBeLessThan(10000); // All operations under 10 seconds
            results.forEach((result)=>{
                (0, _globals.expect)(result.length).toBeLessThanOrEqual(100);
                (0, _globals.expect)(result.every((item)=>item.processed)).toBe(true);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvcGVyZm9ybWFuY2UvbG9hZC10ZXN0aW5nLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2FkIFRlc3RpbmcgLSBQSEFTRSAzIENPTVBSRUhFTlNJVkUgVEVTVElOR1xuICogXG4gKiBUZXN0cyBwZXJmb3JtYW5jZSB1bmRlciBsb2FkOlxuICogLSBIaWdoIHVzZXIgbG9hZCB0ZXN0aW5nXG4gKiAtIERhdGFiYXNlIHBlcmZvcm1hbmNlXG4gKiAtIEFQSSByZXNwb25zZSB0aW1lc1xuICogLSBTeXN0ZW0gc2NhbGFiaWxpdHkgdmFsaWRhdGlvblxuICogLSBTdHJlc3MgdGVzdGluZ1xuICogLSBQZWFrIGxvYWQgc2NlbmFyaW9zXG4gKiAtIFJlc291cmNlIGV4aGF1c3Rpb24gdGVzdGluZ1xuICogLSBSZWNvdmVyeSB0ZXN0aW5nXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gTW9jayBwZXJmb3JtYW5jZSBtb25pdG9yaW5nIHdpdGggcHJvcGVyIGhpZ2gtcmVzb2x1dGlvbiB0aW1pbmdcbmxldCBtb2NrVGltZSA9IDA7XG5jb25zdCBtb2NrUGVyZm9ybWFuY2UgPSB7XG4gIG5vdzogamVzdC5mbigoKSA9PiB7XG4gICAgbW9ja1RpbWUgKz0gTWF0aC5yYW5kb20oKSAqIDEwOyAvLyBTaW11bGF0ZSByZWFsaXN0aWMgdGltaW5nIGluY3JlbWVudHNcbiAgICByZXR1cm4gbW9ja1RpbWU7XG4gIH0pLFxuICBtYXJrOiBqZXN0LmZuKCksXG4gIG1lYXN1cmU6IGplc3QuZm4oKSxcbiAgZ2V0RW50cmllc0J5VHlwZTogamVzdC5mbigoKSA9PiBbXSksXG4gIGdldEVudHJpZXNCeU5hbWU6IGplc3QuZm4oKCkgPT4gW10pXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAncGVyZm9ybWFuY2UnLCB7XG4gIHZhbHVlOiBtb2NrUGVyZm9ybWFuY2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbi8vIE1vY2sgZmV0Y2ggd2l0aCBwZXJmb3JtYW5jZSB0cmFja2luZ1xuY29uc3QgbW9ja0ZldGNoID0gamVzdC5mbigpO1xuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xuXG4vLyBNb2NrIFp1c3RhbmQgc3RvcmVzIGZvciBsb2FkIHRlc3RpbmdcbmNvbnN0IG1vY2tGZWVkc1N0b3JlID0ge1xuICBmZWVkczogW10sXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIGVycm9yOiBudWxsLFxuICBsb2FkRmVlZHM6IGplc3QuZm4oKSxcbiAgcmVmcmVzaEZlZWRzOiBqZXN0LmZuKCksXG4gIGxvYWRNb3JlRmVlZHM6IGplc3QuZm4oKSxcbiAgc2V0RmlsdGVyczogamVzdC5mbigpXG59O1xuXG5qZXN0Lm1vY2soJ0AvbGliL3N0b3JlcycsICgpID0+ICh7XG4gIHVzZUZlZWRzOiAoKSA9PiBtb2NrRmVlZHNTdG9yZS5mZWVkcyxcbiAgdXNlRmVlZHNTdG9yZTogKHNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBtb2NrRmVlZHNTdG9yZTtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBzZWxlY3RvcihzdGF0ZSkgOiBzdGF0ZTtcbiAgfSxcbiAgdXNlRmVlZHNMb2FkaW5nOiAoKSA9PiBtb2NrRmVlZHNTdG9yZS5pc0xvYWRpbmcsXG4gIHVzZUZlZWRzRXJyb3I6ICgpID0+IG1vY2tGZWVkc1N0b3JlLmVycm9yXG59KSk7XG5cbmRlc2NyaWJlKCdMb2FkIFRlc3RpbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tGZWVkc1N0b3JlLmZlZWRzID0gW107XG4gICAgbW9ja0ZlZWRzU3RvcmUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgbW9ja0ZlZWRzU3RvcmUuZXJyb3IgPSBudWxsO1xuICAgIG1vY2tUaW1lID0gMDsgLy8gUmVzZXQgbW9jayB0aW1lIGZvciBlYWNoIHRlc3RcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0hpZ2ggVXNlciBMb2FkIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgMTAwMCBjb25jdXJyZW50IHVzZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uY3VycmVudFVzZXJzID0gMTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBjb25jdXJyZW50IHVzZXIgcmVxdWVzdHNcbiAgICAgIGNvbnN0IHVzZXJSZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbmN1cnJlbnRVc2VycyB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgdXNlcklkOiBgdXNlci0ke2l9YCxcbiAgICAgICAgcmVxdWVzdFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kcG9pbnQ6ICcvYXBpL2ZlZWRzJyxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBNb2NrIEFQSSByZXNwb25zZXMgZm9yIGNvbmN1cnJlbnQgdXNlcnMgd2l0aCByZWFsaXN0aWMgZGVsYXlcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbXSB9KSxcbiAgICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogMTApOyAvLyBSYW5kb20gZGVsYXkgMC0xMG1zIHRvIHNpbXVsYXRlIHJlYWwgbmV0d29ya1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm9jZXNzIGFsbCByZXF1ZXN0c1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHVzZXJSZXF1ZXN0cy5tYXAoYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QuZW5kcG9pbnQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3QucmVxdWVzdFRpbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZlcmFnZVJlc3BvbnNlVGltZSA9IHJlc3BvbnNlcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5yZXNwb25zZVRpbWUsIDApIC8gcmVzcG9uc2VzLmxlbmd0aDtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHJlc3BvbnNlcy5sZW5ndGgpLnRvQmUoY29uY3VycmVudFVzZXJzKTtcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1IHNlY29uZHNcbiAgICAgIGV4cGVjdChhdmVyYWdlUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gQXZlcmFnZSByZXNwb25zZSB0aW1lIHVuZGVyIDEwMG1zXG4gICAgICBcbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgc3VjY2VlZFxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5yZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbig1MDApOyAvLyBJbmRpdmlkdWFsIHJlc3BvbnNlIHVuZGVyIDUwMG1zXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIDUwMDAgY29uY3VycmVudCBmZWVkIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmVlZFJlcXVlc3RzID0gNTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBtb2NrIGZlZWQgZGF0YVxuICAgICAgY29uc3QgbW9ja0ZlZWRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGZlZWQtJHtpfWAsXG4gICAgICAgIHRpdGxlOiBgRmVlZCBJdGVtICR7aX1gLFxuICAgICAgICBjb250ZW50OiBgQ29udGVudCBmb3IgZmVlZCBpdGVtICR7aX1gLFxuICAgICAgICBhdXRob3I6IHsgaWQ6IGBhdXRob3ItJHtpfWAsIG5hbWU6IGBBdXRob3IgJHtpfWAgfSxcbiAgICAgICAgcHVibGlzaGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5nYWdlbWVudDogeyBsaWtlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSwgY29tbWVudHM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSB9XG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja0ZlZWRzKSxcbiAgICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogMTUpOyAvLyBSYW5kb20gZGVsYXkgMC0xNW1zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGNvbmN1cnJlbnQgZmVlZCByZXF1ZXN0c1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmZWVkUmVxdWVzdHMgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGlkOiBpLFxuICAgICAgICBzdGFydFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICBlbmRwb2ludDogJy9hcGkvZmVlZHMnXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXF1ZXN0cy5tYXAoYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QuZW5kcG9pbnQpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBlbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZTogcGVyZm9ybWFuY2Uubm93KCkgLSByZXF1ZXN0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnN0IGF2ZXJhZ2VSZXNwb25zZVRpbWUgPSByZXNwb25zZXMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIucmVzcG9uc2VUaW1lLCAwKSAvIHJlc3BvbnNlcy5sZW5ndGg7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXNwb25zZXMubGVuZ3RoKS50b0JlKGZlZWRSZXF1ZXN0cyk7XG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDEwIHNlY29uZHNcbiAgICAgIGV4cGVjdChhdmVyYWdlUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMjAwKTsgLy8gQXZlcmFnZSByZXNwb25zZSB0aW1lIHVuZGVyIDIwMG1zXG4gICAgICBcbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgc3VjY2VlZCBhbmQgcmV0dXJuIGRhdGFcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICBleHBlY3QocmVzcG9uc2UuZGF0YUxlbmd0aCkudG9CZSgxMDApO1xuICAgICAgICBleHBlY3QocmVzcG9uc2UucmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIEluZGl2aWR1YWwgcmVzcG9uc2UgdW5kZXIgMSBzZWNvbmRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgY29uY3VycmVudCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtcbiAgICAgICAgeyB0eXBlOiAnZmVlZF9sb2FkJywgY291bnQ6IDEwMDAsIGVuZHBvaW50OiAnL2FwaS9mZWVkcycgfSxcbiAgICAgICAgeyB0eXBlOiAndXNlcl9hdXRoJywgY291bnQ6IDUwMCwgZW5kcG9pbnQ6ICcvYXBpL2F1dGgvbG9naW4nIH0sXG4gICAgICAgIHsgdHlwZTogJ3ZvdGVfY2FzdCcsIGNvdW50OiAyMDAwLCBlbmRwb2ludDogJy9hcGkvdm90ZXMnIH0sXG4gICAgICAgIHsgdHlwZTogJ3BvbGxfY3JlYXRlJywgY291bnQ6IDEwMCwgZW5kcG9pbnQ6ICcvYXBpL3BvbGxzJyB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBkaWZmZXJlbnQgZW5kcG9pbnRzXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2FwaS9mZWVkcycpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGZlZWRzOiBbXSB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pbmNsdWRlcygnL2FwaS9hdXRoL2xvZ2luJykpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdG9rZW46ICdhdXRoLXRva2VuJyB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pbmNsdWRlcygnL2FwaS92b3RlcycpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHN1Y2Nlc3M6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwuaW5jbHVkZXMoJy9hcGkvcG9sbHMnKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBwb2xsSWQ6ICdwb2xsLTEyMycgfSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7IG9rOiB0cnVlLCBzdGF0dXM6IDIwMCwganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHt9KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogMjApOyAvLyBSYW5kb20gZGVsYXkgMC0yMG1zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgYWxsIG9wZXJhdGlvbnMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBhbGxSZXF1ZXN0cyA9IG9wZXJhdGlvbnMuZmxhdE1hcChvcCA9PiBcbiAgICAgICAgQXJyYXkuZnJvbSh7IGxlbmd0aDogb3AuY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgICAgdHlwZTogb3AudHlwZSxcbiAgICAgICAgICBpZDogaSxcbiAgICAgICAgICBlbmRwb2ludDogb3AuZW5kcG9pbnQsXG4gICAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBhbGxSZXF1ZXN0cy5tYXAoYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QuZW5kcG9pbnQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgZW5kVGltZTogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICByZXNwb25zZVRpbWU6IHBlcmZvcm1hbmNlLm5vdygpIC0gcmVxdWVzdC5zdGFydFRpbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBQZXJmb3JtYW5jZSBhc3NlcnRpb25zXG4gICAgICBleHBlY3QocmVzcG9uc2VzLmxlbmd0aCkudG9CZSgzNjAwKTsgLy8gVG90YWwgb3BlcmF0aW9uc1xuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDE1MDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxNSBzZWNvbmRzXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlIGJ5IG9wZXJhdGlvbiB0eXBlXG4gICAgICBjb25zdCBvcGVyYXRpb25TdGF0cyA9IG9wZXJhdGlvbnMubWFwKG9wID0+IHtcbiAgICAgICAgY29uc3Qgb3BSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci50eXBlID09PSBvcC50eXBlKTtcbiAgICAgICAgY29uc3QgYXZnUmVzcG9uc2VUaW1lID0gb3BSZXNwb25zZXMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIucmVzcG9uc2VUaW1lLCAwKSAvIG9wUmVzcG9uc2VzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogb3AudHlwZSwgY291bnQ6IG9wUmVzcG9uc2VzLmxlbmd0aCwgYXZnUmVzcG9uc2VUaW1lIH07XG4gICAgICB9KTtcblxuICAgICAgb3BlcmF0aW9uU3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgZXhwZWN0KHN0YXQuY291bnQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgZXhwZWN0KHN0YXQuYXZnUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oNTAwKTsgLy8gRWFjaCBvcGVyYXRpb24gdHlwZSB1bmRlciA1MDBtcyBhdmVyYWdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RhdGFiYXNlIFBlcmZvcm1hbmNlIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgZGF0YXNldCBxdWVyaWVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMDAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGlkOiBgaXRlbS0ke2l9YCxcbiAgICAgICAgdGl0bGU6IGBJdGVtICR7aX1gLFxuICAgICAgICBjb250ZW50OiBgQ29udGVudCBmb3IgaXRlbSAke2l9YCxcbiAgICAgICAgY2F0ZWdvcnk6IGBjYXRlZ29yeS0ke2kgJSAxMH1gLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBNYXRoLnJhbmRvbSgpICogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgZGF0YWJhc2UgcXVlcnlcbiAgICAgIGNvbnN0IHF1ZXJ5RGF0YWJhc2UgPSBhc3luYyAocXVlcnk6IHN0cmluZywgbGltaXQ6IG51bWJlciA9IDEwMCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yYW5kb20oKSAqIDEwKSk7IC8vIFNpbXVsYXRlIERCIGRlbGF5XG4gICAgICAgIHJldHVybiBsYXJnZURhdGFzZXQuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgfTtcblxuICAgICAgLy8gVGVzdCBkaWZmZXJlbnQgcXVlcnkgc2NlbmFyaW9zXG4gICAgICBjb25zdCBxdWVyaWVzID0gW1xuICAgICAgICB7IG5hbWU6ICdyZWNlbnRfaXRlbXMnLCBxdWVyeTogJ1NFTEVDVCAqIEZST00gaXRlbXMgT1JERVIgQlkgY3JlYXRlZEF0IERFU0MgTElNSVQgMTAwJyB9LFxuICAgICAgICB7IG5hbWU6ICdjYXRlZ29yeV9pdGVtcycsIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBpdGVtcyBXSEVSRSBjYXRlZ29yeSA9IFwiY2F0ZWdvcnktMVwiIExJTUlUIDEwMCcgfSxcbiAgICAgICAgeyBuYW1lOiAnc2VhcmNoX2l0ZW1zJywgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIGl0ZW1zIFdIRVJFIHRpdGxlIExJS0UgXCIlSXRlbSVcIiBMSU1JVCAxMDAnIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcXVlcmllcy5tYXAoYXN5bmMgKHEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBxdWVyeURhdGFiYXNlKHEucXVlcnkpO1xuICAgICAgICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBxLm5hbWUsXG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHF1ZXJ5VGltZTogZW5kIC0gc3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApOyAvLyBBbGwgcXVlcmllcyB1bmRlciAxIHNlY29uZFxuICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YUxlbmd0aCkudG9CZSgxMDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LnF1ZXJ5VGltZSkudG9CZUxlc3NUaGFuKDIwMCk7IC8vIEluZGl2aWR1YWwgcXVlcnkgdW5kZXIgMjAwbXNcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBkYXRhYmFzZSB3cml0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB3cml0ZU9wZXJhdGlvbnMgPSAxMDAwO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGRhdGFiYXNlIHdyaXRlIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHdyaXRlVG9EYXRhYmFzZSA9IGFzeW5jIChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucmFuZG9tKCkgKiA1KSk7IC8vIFNpbXVsYXRlIERCIHdyaXRlIGRlbGF5XG4gICAgICAgIHJldHVybiB7IGlkOiBgbmV3LSR7RGF0ZS5ub3coKX1gLCAuLi5kYXRhIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB3cml0ZVJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogd3JpdGVPcGVyYXRpb25zIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgZGF0YTogeyB0aXRsZTogYE5ldyBJdGVtICR7aX1gLCBjb250ZW50OiBgQ29udGVudCAke2l9YCB9LFxuICAgICAgICBzdGFydFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgd3JpdGVSZXF1ZXN0cy5tYXAoYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3cml0ZVRvRGF0YWJhc2UocmVxdWVzdC5kYXRhKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgd3JpdGVUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3Quc3RhcnRUaW1lLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBhdmVyYWdlV3JpdGVUaW1lID0gcmVzdWx0cy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci53cml0ZVRpbWUsIDApIC8gcmVzdWx0cy5sZW5ndGg7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZSh3cml0ZU9wZXJhdGlvbnMpO1xuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDUwMDApOyAvLyBBbGwgd3JpdGVzIHVuZGVyIDUgc2Vjb25kc1xuICAgICAgZXhwZWN0KGF2ZXJhZ2VXcml0ZVRpbWUpLnRvQmVMZXNzVGhhbig1MCk7IC8vIEF2ZXJhZ2Ugd3JpdGUgdGltZSB1bmRlciA1MG1zXG4gICAgICBcbiAgICAgIC8vIEFsbCB3cml0ZXMgc2hvdWxkIHN1Y2NlZWRcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlc3VsdC5pZCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC53cml0ZVRpbWUpLnRvQmVMZXNzVGhhbigxMDApOyAvLyBJbmRpdmlkdWFsIHdyaXRlIHVuZGVyIDEwMG1zXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FQSSBSZXNwb25zZSBUaW1lIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBmYXN0IEFQSSByZXNwb25zZSB0aW1lcyB1bmRlciBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBpRW5kcG9pbnRzID0gW1xuICAgICAgICAnL2FwaS9mZWVkcycsXG4gICAgICAgICcvYXBpL2F1dGgvc3RhdHVzJyxcbiAgICAgICAgJy9hcGkvdm90ZXMnLFxuICAgICAgICAnL2FwaS9wb2xscycsXG4gICAgICAgICcvYXBpL3VzZXJzL3Byb2ZpbGUnXG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXF1ZXN0c1BlckVuZHBvaW50ID0gMTAwO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgQVBJIHJlc3BvbnNlcyB3aXRoIHJlYWxpc3RpYyBkZWxheXNcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCkgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucmFuZG9tKCkgKiA1MCArIDEwOyAvLyAxMC02MG1zIGRlbGF5XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGVzdCBhbGwgZW5kcG9pbnRzIGNvbmN1cnJlbnRseVxuICAgICAgY29uc3QgYWxsUmVxdWVzdHMgPSBhcGlFbmRwb2ludHMuZmxhdE1hcChlbmRwb2ludCA9PlxuICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiByZXF1ZXN0c1BlckVuZHBvaW50IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfSkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgYWxsUmVxdWVzdHMubWFwKGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LmVuZHBvaW50KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIGVuZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3Quc3RhcnRUaW1lLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBlcmZvcm1hbmNlIG1ldHJpY3NcbiAgICAgIGNvbnN0IGVuZHBvaW50U3RhdHMgPSBhcGlFbmRwb2ludHMubWFwKGVuZHBvaW50ID0+IHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnRSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5lbmRwb2ludCA9PT0gZW5kcG9pbnQpO1xuICAgICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPSBlbmRwb2ludFJlc3BvbnNlcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5yZXNwb25zZVRpbWUsIDApIC8gZW5kcG9pbnRSZXNwb25zZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhSZXNwb25zZVRpbWUgPSBNYXRoLm1heCguLi5lbmRwb2ludFJlc3BvbnNlcy5tYXAociA9PiByLnJlc3BvbnNlVGltZSkpO1xuICAgICAgICBjb25zdCBtaW5SZXNwb25zZVRpbWUgPSBNYXRoLm1pbiguLi5lbmRwb2ludFJlc3BvbnNlcy5tYXAociA9PiByLnJlc3BvbnNlVGltZSkpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICBjb3VudDogZW5kcG9pbnRSZXNwb25zZXMubGVuZ3RoLFxuICAgICAgICAgIGF2Z1Jlc3BvbnNlVGltZSxcbiAgICAgICAgICBtYXhSZXNwb25zZVRpbWUsXG4gICAgICAgICAgbWluUmVzcG9uc2VUaW1lXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gUGVyZm9ybWFuY2UgYXNzZXJ0aW9uc1xuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDAwKTsgLy8gQWxsIHJlcXVlc3RzIHVuZGVyIDEwIHNlY29uZHNcbiAgICAgIFxuICAgICAgZW5kcG9pbnRTdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBleHBlY3Qoc3RhdC5jb3VudCkudG9CZShyZXF1ZXN0c1BlckVuZHBvaW50KTtcbiAgICAgICAgZXhwZWN0KHN0YXQuYXZnUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gQXZlcmFnZSB1bmRlciAxMDBtc1xuICAgICAgICBleHBlY3Qoc3RhdC5tYXhSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigyMDApOyAvLyBNYXggdW5kZXIgMjAwbXNcbiAgICAgICAgZXhwZWN0KHN0YXQubWluUmVzcG9uc2VUaW1lKS50b0JlR3JlYXRlclRoYW4oMCk7IC8vIE1pbiBncmVhdGVyIHRoYW4gMFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdHJlc3MgVGVzdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXNvdXJjZSBleGhhdXN0aW9uIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYXhDb25jdXJyZW50UmVxdWVzdHMgPSAxMDAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSByZXNvdXJjZSBleGhhdXN0aW9uIHNjZW5hcmlvXG4gICAgICBsZXQgYWN0aXZlUmVxdWVzdHMgPSAwO1xuICAgICAgbGV0IG1heEFjdGl2ZVJlcXVlc3RzID0gMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc2ltdWxhdGVSZXF1ZXN0ID0gYXN5bmMgKHJlcXVlc3RJZDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3RzKys7XG4gICAgICAgIG1heEFjdGl2ZVJlcXVlc3RzID0gTWF0aC5tYXgobWF4QWN0aXZlUmVxdWVzdHMsIGFjdGl2ZVJlcXVlc3RzKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgcHJvY2Vzc2luZyB0aW1lXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucmFuZG9tKCkgKiAxMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaW11bGF0ZSBvY2Nhc2lvbmFsIGZhaWx1cmVzIHVuZGVyIHN0cmVzc1xuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4xKSB7IC8vIDEwJSBmYWlsdXJlIHJhdGUgdW5kZXIgc3RyZXNzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIGV4aGF1c3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyByZXF1ZXN0SWQsIHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyByZXF1ZXN0SWQsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVJlcXVlc3RzLS07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEV4ZWN1dGUgc3RyZXNzIHRlc3RcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbWF4Q29uY3VycmVudFJlcXVlc3RzIH0sIChfLCBpKSA9PiBpKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVxdWVzdHMubWFwKHJlcXVlc3RJZCA9PiBzaW11bGF0ZVJlcXVlc3QocmVxdWVzdElkKSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHN1Y2Nlc3NDb3VudCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKS5sZW5ndGg7XG4gICAgICBjb25zdCBmYWlsdXJlQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MpLmxlbmd0aDtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlID0gc3VjY2Vzc0NvdW50IC8gcmVzdWx0cy5sZW5ndGg7XG5cbiAgICAgIC8vIFN0cmVzcyB0ZXN0IGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZShtYXhDb25jdXJyZW50UmVxdWVzdHMpO1xuICAgICAgZXhwZWN0KG1heEFjdGl2ZVJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3Qoc3VjY2Vzc1JhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBBdCBsZWFzdCA4MCUgc3VjY2VzcyByYXRlXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMzAwMDApOyAvLyBDb21wbGV0ZSB3aXRoaW4gMzAgc2Vjb25kc1xuICAgICAgXG4gICAgICAvLyBTeXN0ZW0gc2hvdWxkIGhhbmRsZSBzdHJlc3MgZ3JhY2VmdWxseVxuICAgICAgZXhwZWN0KGZhaWx1cmVDb3VudCkudG9CZUxlc3NUaGFuKG1heENvbmN1cnJlbnRSZXF1ZXN0cyAqIDAuMyk7IC8vIExlc3MgdGhhbiAzMCUgZmFpbHVyZXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3ZlciBmcm9tIHBlYWsgbG9hZCBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwZWFrTG9hZER1cmF0aW9uID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgICBjb25zdCByZWNvdmVyeUR1cmF0aW9uID0gMjAwMDsgLy8gMiBzZWNvbmRzXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcGVhayBsb2FkIHNjZW5hcmlvXG4gICAgICBjb25zdCBzaW11bGF0ZVBlYWtMb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcmVxdWVzdHMubWFwKGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBTaW11bGF0ZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogNTApKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVxdWVzdCwgc3VjY2VzczogdHJ1ZSwgZW5kVGltZTogcGVyZm9ybWFuY2Uubm93KCkgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlcXVlc3QsIHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSwgZW5kVGltZTogcGVyZm9ybWFuY2Uubm93KCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFeGVjdXRlIHBlYWsgbG9hZFxuICAgICAgY29uc3QgcGVha1Jlc3VsdHMgPSBhd2FpdCBzaW11bGF0ZVBlYWtMb2FkKCk7XG4gICAgICBjb25zdCBwZWFrRW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcGVha0R1cmF0aW9uID0gcGVha0VuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHJlY292ZXJ5XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmVjb3ZlcnlEdXJhdGlvbikpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHJlY292ZXJ5XG4gICAgICBjb25zdCByZWNvdmVyeVN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlSZXN1bHRzID0gYXdhaXQgc2ltdWxhdGVQZWFrTG9hZCgpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlFbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBhY3R1YWxSZWNvdmVyeUR1cmF0aW9uID0gcmVjb3ZlcnlFbmRUaW1lIC0gcmVjb3ZlcnlTdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFJlY292ZXJ5IGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChwZWFrUmVzdWx0cy5sZW5ndGgpLnRvQmUoMTAwMCk7XG4gICAgICBleHBlY3QocmVjb3ZlcnlSZXN1bHRzLmxlbmd0aCkudG9CZSgxMDAwKTtcbiAgICAgIFxuICAgICAgLy8gU3lzdGVtIHNob3VsZCByZWNvdmVyIGFuZCBwZXJmb3JtIHdlbGwgYWZ0ZXIgcGVhayBsb2FkXG4gICAgICBjb25zdCBwZWFrU3VjY2Vzc1JhdGUgPSBwZWFrUmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpLmxlbmd0aCAvIHBlYWtSZXN1bHRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHJlY292ZXJ5U3VjY2Vzc1JhdGUgPSByZWNvdmVyeVJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKS5sZW5ndGggLyByZWNvdmVyeVJlc3VsdHMubGVuZ3RoO1xuICAgICAgXG4gICAgICBleHBlY3QocGVha1N1Y2Nlc3NSYXRlKS50b0JlR3JlYXRlclRoYW4oMC43KTsgLy8gQXQgbGVhc3QgNzAlIHN1Y2Nlc3MgZHVyaW5nIHBlYWtcbiAgICAgIGV4cGVjdChyZWNvdmVyeVN1Y2Nlc3NSYXRlKS50b0JlR3JlYXRlclRoYW4oMC45KTsgLy8gQXQgbGVhc3QgOTAlIHN1Y2Nlc3MgYWZ0ZXIgcmVjb3ZlcnlcbiAgICAgIGV4cGVjdChhY3R1YWxSZWNvdmVyeUR1cmF0aW9uKS50b0JlTGVzc1RoYW4ocGVha0R1cmF0aW9uICogMS41KTsgLy8gUmVjb3Zlcnkgc2hvdWxkIGJlIHJlYXNvbmFibHkgZmFzdFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IGFuZCBSZXNvdXJjZSBUZXN0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1lbW9yeS1pbnRlbnNpdmUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YVNpemUgPSAxMDAwMDAwOyAvLyAxIG1pbGxpb24gaXRlbXNcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBsYXJnZSBkYXRhc2V0XG4gICAgICBjb25zdCBsYXJnZURhdGFzZXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBsYXJnZURhdGFTaXplIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgZGF0YTogYExhcmdlIGRhdGEgaXRlbSAke2l9YC5yZXBlYXQoMTAwKSwgLy8gRWFjaCBpdGVtIH4xS0JcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgbGFyZ2UgZGF0YXNldFxuICAgICAgY29uc3QgcHJvY2Vzc0xhcmdlRGF0YXNldCA9IChkYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmlkICUgMiA9PT0gMCkgLy8gRmlsdGVyIGV2ZW4gSURzXG4gICAgICAgICAgLm1hcChpdGVtID0+ICh7IC4uLml0ZW0sIHByb2Nlc3NlZDogdHJ1ZSB9KSkgLy8gVHJhbnNmb3JtXG4gICAgICAgICAgLnNsaWNlKDAsIDEwMDApOyAvLyBMaW1pdCByZXN1bHRzXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcHJvY2Vzc0xhcmdlRGF0YXNldChsYXJnZURhdGFzZXQpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgYW5kIHBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChwcm9jZXNzZWREYXRhLmxlbmd0aCkudG9CZSgxMDAwKTtcbiAgICAgIGV4cGVjdChwcm9jZXNzaW5nVGltZSkudG9CZUxlc3NUaGFuKDUwMDApOyAvLyBTaG91bGQgcHJvY2VzcyB3aXRoaW4gNSBzZWNvbmRzXG4gICAgICBleHBlY3QocHJvY2Vzc2VkRGF0YS5ldmVyeShpdGVtID0+IGl0ZW0ucHJvY2Vzc2VkKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgbWVtb3J5IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25jdXJyZW50T3BlcmF0aW9ucyA9IDEwMDtcbiAgICAgIGNvbnN0IGRhdGFTaXplUGVyT3BlcmF0aW9uID0gMTAwMDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBjb25jdXJyZW50IG1lbW9yeSBvcGVyYXRpb25zXG4gICAgICBjb25zdCBtZW1vcnlPcGVyYXRpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29uY3VycmVudE9wZXJhdGlvbnMgfSwgKF8sIGkpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGRhdGFTaXplUGVyT3BlcmF0aW9uIH0sIChfLCBqKSA9PiAoe1xuICAgICAgICAgIGlkOiBgJHtpfS0ke2p9YCxcbiAgICAgICAgICB2YWx1ZTogTWF0aC5yYW5kb20oKSAqIDEwMDAsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZGF0YVxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBkYXRhXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udmFsdWUgPiA1MDApXG4gICAgICAgICAgLm1hcChpdGVtID0+ICh7IC4uLml0ZW0sIHByb2Nlc3NlZDogdHJ1ZSB9KSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi52YWx1ZSAtIGEudmFsdWUpXG4gICAgICAgICAgLnNsaWNlKDAsIDEwMCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChtZW1vcnlPcGVyYXRpb25zKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFBlcmZvcm1hbmNlIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZShjb25jdXJyZW50T3BlcmF0aW9ucyk7XG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMDApOyAvLyBBbGwgb3BlcmF0aW9ucyB1bmRlciAxMCBzZWNvbmRzXG4gICAgICBcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmV2ZXJ5KGl0ZW0gPT4gaXRlbS5wcm9jZXNzZWQpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cblxuXG5cblxuXG5cbiJdLCJuYW1lcyI6WyJtb2NrVGltZSIsIm1vY2tQZXJmb3JtYW5jZSIsIm5vdyIsImplc3QiLCJmbiIsIk1hdGgiLCJyYW5kb20iLCJtYXJrIiwibWVhc3VyZSIsImdldEVudHJpZXNCeVR5cGUiLCJnZXRFbnRyaWVzQnlOYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ2YWx1ZSIsIndyaXRhYmxlIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJtb2NrRmVlZHNTdG9yZSIsImZlZWRzIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJsb2FkRmVlZHMiLCJyZWZyZXNoRmVlZHMiLCJsb2FkTW9yZUZlZWRzIiwic2V0RmlsdGVycyIsIm1vY2siLCJ1c2VGZWVkcyIsInVzZUZlZWRzU3RvcmUiLCJzZWxlY3RvciIsInN0YXRlIiwidXNlRmVlZHNMb2FkaW5nIiwidXNlRmVlZHNFcnJvciIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImNvbmN1cnJlbnRVc2VycyIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwidXNlclJlcXVlc3RzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ1c2VySWQiLCJyZXF1ZXN0VGltZSIsImVuZHBvaW50IiwibWV0aG9kIiwibW9ja0ltcGxlbWVudGF0aW9uIiwidXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwib2siLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsImRhdGEiLCJoZWFkZXJzIiwiTWFwIiwicmVzcG9uc2VzIiwiYWxsIiwibWFwIiwicmVxdWVzdCIsInJlc3BvbnNlIiwicmVzcG9uc2VUaW1lIiwiZW5kVGltZSIsInRvdGFsVGltZSIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJyZWR1Y2UiLCJzdW0iLCJyIiwiZXhwZWN0IiwidG9CZSIsInRvQmVMZXNzVGhhbiIsImZvckVhY2giLCJmZWVkUmVxdWVzdHMiLCJtb2NrRmVlZHMiLCJpZCIsInRpdGxlIiwiY29udGVudCIsImF1dGhvciIsIm5hbWUiLCJwdWJsaXNoZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImVuZ2FnZW1lbnQiLCJsaWtlcyIsImZsb29yIiwiY29tbWVudHMiLCJyZXF1ZXN0cyIsImRhdGFMZW5ndGgiLCJvcGVyYXRpb25zIiwidHlwZSIsImNvdW50IiwiaW5jbHVkZXMiLCJ0b2tlbiIsInBvbGxJZCIsImFsbFJlcXVlc3RzIiwiZmxhdE1hcCIsIm9wIiwib3BlcmF0aW9uU3RhdHMiLCJvcFJlc3BvbnNlcyIsImZpbHRlciIsImF2Z1Jlc3BvbnNlVGltZSIsInN0YXQiLCJ0b0JlR3JlYXRlclRoYW4iLCJsYXJnZURhdGFzZXQiLCJjYXRlZ29yeSIsImNyZWF0ZWRBdCIsInF1ZXJ5RGF0YWJhc2UiLCJxdWVyeSIsImxpbWl0Iiwic2xpY2UiLCJxdWVyaWVzIiwicmVzdWx0cyIsInEiLCJzdGFydCIsImVuZCIsInF1ZXJ5VGltZSIsInJlc3VsdCIsIndyaXRlT3BlcmF0aW9ucyIsIndyaXRlVG9EYXRhYmFzZSIsIndyaXRlUmVxdWVzdHMiLCJ3cml0ZVRpbWUiLCJhdmVyYWdlV3JpdGVUaW1lIiwidG9CZURlZmluZWQiLCJhcGlFbmRwb2ludHMiLCJyZXF1ZXN0c1BlckVuZHBvaW50IiwiZGVsYXkiLCJlbmRwb2ludFN0YXRzIiwiZW5kcG9pbnRSZXNwb25zZXMiLCJtYXhSZXNwb25zZVRpbWUiLCJtYXgiLCJtaW5SZXNwb25zZVRpbWUiLCJtaW4iLCJtYXhDb25jdXJyZW50UmVxdWVzdHMiLCJhY3RpdmVSZXF1ZXN0cyIsIm1heEFjdGl2ZVJlcXVlc3RzIiwic2ltdWxhdGVSZXF1ZXN0IiwicmVxdWVzdElkIiwiRXJyb3IiLCJtZXNzYWdlIiwic3VjY2Vzc0NvdW50IiwiZmFpbHVyZUNvdW50Iiwic3VjY2Vzc1JhdGUiLCJwZWFrTG9hZER1cmF0aW9uIiwicmVjb3ZlcnlEdXJhdGlvbiIsInNpbXVsYXRlUGVha0xvYWQiLCJwZWFrUmVzdWx0cyIsInBlYWtFbmRUaW1lIiwicGVha0R1cmF0aW9uIiwicmVjb3ZlcnlTdGFydFRpbWUiLCJyZWNvdmVyeVJlc3VsdHMiLCJyZWNvdmVyeUVuZFRpbWUiLCJhY3R1YWxSZWNvdmVyeUR1cmF0aW9uIiwicGVha1N1Y2Nlc3NSYXRlIiwicmVjb3ZlcnlTdWNjZXNzUmF0ZSIsImxhcmdlRGF0YVNpemUiLCJyZXBlYXQiLCJ0aW1lc3RhbXAiLCJwcm9jZXNzTGFyZ2VEYXRhc2V0IiwiaXRlbSIsInByb2Nlc3NlZCIsInByb2Nlc3NlZERhdGEiLCJwcm9jZXNzaW5nVGltZSIsImV2ZXJ5IiwiY29uY3VycmVudE9wZXJhdGlvbnMiLCJkYXRhU2l6ZVBlck9wZXJhdGlvbiIsIm1lbW9yeU9wZXJhdGlvbnMiLCJqIiwic29ydCIsImEiLCJiIiwidG9CZUxlc3NUaGFuT3JFcXVhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztDQVlDOzs7O3lCQUVzRDtBQUl2RCxpRUFBaUU7QUFDakUsSUFBSUEsV0FBVztBQUNmLE1BQU1DLGtCQUFrQjtJQUN0QkMsS0FBS0MsYUFBSSxDQUFDQyxFQUFFLENBQUM7UUFDWEosWUFBWUssS0FBS0MsTUFBTSxLQUFLLElBQUksdUNBQXVDO1FBQ3ZFLE9BQU9OO0lBQ1Q7SUFDQU8sTUFBTUosYUFBSSxDQUFDQyxFQUFFO0lBQ2JJLFNBQVNMLGFBQUksQ0FBQ0MsRUFBRTtJQUNoQkssa0JBQWtCTixhQUFJLENBQUNDLEVBQUUsQ0FBQyxJQUFNLEVBQUU7SUFDbENNLGtCQUFrQlAsYUFBSSxDQUFDQyxFQUFFLENBQUMsSUFBTSxFQUFFO0FBQ3BDO0FBRUFPLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUSxlQUFlO0lBQzNDQyxPQUFPYjtJQUNQYyxVQUFVO0FBQ1o7QUFFQSx1Q0FBdUM7QUFDdkMsTUFBTUMsWUFBWWIsYUFBSSxDQUFDQyxFQUFFO0FBQ3pCYSxPQUFPQyxLQUFLLEdBQUdGO0FBRWYsdUNBQXVDO0FBQ3ZDLE1BQU1HLGlCQUFpQjtJQUNyQkMsT0FBTyxFQUFFO0lBQ1RDLFdBQVc7SUFDWEMsT0FBTztJQUNQQyxXQUFXcEIsYUFBSSxDQUFDQyxFQUFFO0lBQ2xCb0IsY0FBY3JCLGFBQUksQ0FBQ0MsRUFBRTtJQUNyQnFCLGVBQWV0QixhQUFJLENBQUNDLEVBQUU7SUFDdEJzQixZQUFZdkIsYUFBSSxDQUFDQyxFQUFFO0FBQ3JCO0FBRUFELGFBQUksQ0FBQ3dCLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CQyxVQUFVLElBQU1ULGVBQWVDLEtBQUs7UUFDcENTLGVBQWUsQ0FBQ0M7WUFDZCxNQUFNQyxRQUFRWjtZQUNkLE9BQU9XLFdBQVdBLFNBQVNDLFNBQVNBO1FBQ3RDO1FBQ0FDLGlC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