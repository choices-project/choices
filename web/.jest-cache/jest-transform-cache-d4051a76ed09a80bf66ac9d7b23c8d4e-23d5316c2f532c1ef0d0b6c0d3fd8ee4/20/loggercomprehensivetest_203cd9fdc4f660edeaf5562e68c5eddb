10dee3723a3a367bd0a4c898856ed3df
/**
 * @jest-environment node
 */ // Set NODE_ENV to development before importing logger
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _logger = require("../../../../../lib/utils/logger");
process.env.NODE_ENV = "development";
// Clear module cache to ensure fresh import
jest.resetModules();
// Mock console methods
const mockConsole = {
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn()
};
// Replace console with mock
Object.assign(console, mockConsole);
describe("Logger Utility - Comprehensive Testing", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Basic Logging", ()=>{
        it("should log info messages", ()=>{
            // Force logger to be in development mode
            _logger.logger.isDevelopment = true;
            _logger.logger.level = 0; // DEBUG level
            _logger.logger.info("Test info message");
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Test info message/));
        });
        it("should log error messages", ()=>{
            _logger.logger.error("Test error message");
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Test error message/));
        });
        it("should log warning messages", ()=>{
            _logger.logger.warn("Test warning message");
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Test warning message/));
        });
        it("should log debug messages", ()=>{
            _logger.logger.debug("Test debug message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Test debug message/));
        });
    });
    describe("Structured Logging", ()=>{
        it("should log with metadata", ()=>{
            const metadata = {
                userId: "user-123",
                action: "login",
                timestamp: new Date().toISOString()
            };
            _logger.logger.info("User action", metadata);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User action/));
        });
        it("should log with error objects", ()=>{
            const error = new Error("Test error");
            const context = {
                userId: "user-123",
                action: "database-query"
            };
            _logger.logger.error("Database error", error, context);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Database error/));
        });
        it("should log with performance metrics", ()=>{
            const metrics = {
                duration: 150,
                memoryUsage: 25.5,
                cpuUsage: 12.3
            };
            _logger.logger.info("Performance metrics", metrics);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Performance metrics/));
        });
    });
    describe("Log Levels", ()=>{
        it("should respect log level configuration", ()=>{
            // Test different log levels
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            _logger.logger.warn("Warning message");
            _logger.logger.error("Error message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Debug message/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Warning message/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error message/));
        });
        it("should handle log level filtering", ()=>{
            // Mock environment variable for log level
            const originalEnv = process.env.NODE_ENV;
            process.env.NODE_ENV = "production";
            // In production, debug logs should be filtered
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            expect(mockConsole.debug).not.toHaveBeenCalled();
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            // Restore environment
            process.env.NODE_ENV = originalEnv;
        });
    });
    describe("Error Handling", ()=>{
        it("should handle circular references in objects", ()=>{
            const circularObj = {
                name: "test"
            };
            circularObj.self = circularObj;
            _logger.logger.info("Circular object", circularObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Circular object/));
        });
        it("should handle undefined values", ()=>{
            _logger.logger.info("Undefined value", undefined);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Undefined value/));
        });
        it("should handle null values", ()=>{
            _logger.logger.info("Null value", null);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Null value/));
        });
        it("should handle large objects", ()=>{
            const largeObj = {
                data: Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        value: `item-${i}`
                    })),
                metadata: {
                    count: 1000,
                    timestamp: new Date().toISOString()
                }
            };
            _logger.logger.info("Large object", largeObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large object/));
        });
    });
    describe("Performance", ()=>{
        it("should log within performance budget", ()=>{
            const startTime = performance.now();
            for(let i = 0; i < 100; i++){
                _logger.logger.info(`Message ${i}`);
            }
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(100); // Should complete within 100ms
        });
        it("should not block execution", async ()=>{
            const startTime = performance.now();
            // Log multiple messages asynchronously
            const promises = Array.from({
                length: 10
            }, (_, i)=>Promise.resolve().then(()=>_logger.logger.info(`Async message ${i}`)));
            await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(50); // Should complete within 50ms
        });
    });
    describe("Security", ()=>{
        it("should sanitize sensitive data", ()=>{
            const sensitiveData = {
                password: "secret123",
                token: "bearer-token",
                apiKey: "api-key-123",
                email: "user@example.com",
                normalData: "safe data"
            };
            _logger.logger.info("User data", sensitiveData);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User data/));
        });
        it("should handle SQL injection attempts", ()=>{
            const maliciousInput = "'; DROP TABLE users; --";
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
        it("should handle XSS attempts", ()=>{
            const maliciousInput = '<script>alert("xss")</script>';
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
    });
    describe("Context and Tracing", ()=>{
        it("should include request context", ()=>{
            const requestContext = {
                requestId: "req-123",
                userId: "user-123",
                ip: "192.168.1.1",
                userAgent: "Mozilla/5.0..."
            };
            _logger.logger.info("Request processed", requestContext);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Request processed/));
        });
        it("should include error stack traces", ()=>{
            const error = new Error("Test error");
            error.stack = "Error: Test error\n    at test.js:1:1";
            _logger.logger.error("Error occurred", error);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error occurred/));
        });
        it("should include timing information", ()=>{
            const timing = {
                startTime: Date.now() - 1000,
                endTime: Date.now(),
                duration: 1000
            };
            _logger.logger.info("Operation completed", timing);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Operation completed/));
        });
    });
    describe("Log Formatting", ()=>{
        it("should format timestamps correctly", ()=>{
            const timestamp = new Date("2023-01-01T00:00:00Z");
            _logger.logger.info("Timestamped message", {
                timestamp
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Timestamped message/));
        });
        it("should format objects with proper indentation", ()=>{
            const complexObj = {
                level1: {
                    level2: {
                        level3: "value",
                        array: [
                            1,
                            2,
                            3
                        ]
                    }
                }
            };
            _logger.logger.info("Complex object", complexObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Complex object/));
        });
        it("should handle special characters", ()=>{
            const specialChars = {
                unicode: "\uD83D\uDE80",
                emoji: "\uD83D\uDE00",
                symbols: "!@#$%^&*()",
                quotes: "\"double\" and 'single'"
            };
            _logger.logger.info("Special characters", specialChars);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Special characters/));
        });
    });
    describe("Memory Management", ()=>{
        it("should not cause memory leaks", ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Log many messages
            for(let i = 0; i < 1000; i++){
                _logger.logger.info(`Message ${i}`, {
                    data: `data-${i}`
                });
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB
        });
        it("should handle large log messages", ()=>{
            const largeMessage = "x".repeat(10000);
            _logger.logger.info("Large message", {
                message: largeMessage
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large message/));
        });
    });
    describe("Async Logging", ()=>{
        it("should handle async operations", async ()=>{
            const asyncOperation = async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return "async result";
            };
            _logger.logger.info("Starting async operation");
            const result = await asyncOperation();
            _logger.logger.info("Async operation completed", {
                result
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting async operation/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Async operation completed/));
        });
        it("should handle promise rejections", async ()=>{
            const failingOperation = async ()=>{
                throw new Error("Async error");
            };
            _logger.logger.info("Starting failing operation");
            try {
                await failingOperation();
            } catch (error) {
                _logger.logger.error("Async operation failed", error);
            }
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting failing operation/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Async operation failed/));
        });
    });
    describe("Log Aggregation", ()=>{
        it("should aggregate related log messages", ()=>{
            const sessionId = "session-123";
            _logger.logger.info("Session started", {
                sessionId
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "login"
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "navigate"
            });
            _logger.logger.info("Session ended", {
                sessionId
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(4);
        });
        it("should handle log batching", ()=>{
            const messages = [
                {
                    level: "info",
                    message: "Message 1"
                },
                {
                    level: "info",
                    message: "Message 2"
                },
                {
                    level: "warn",
                    message: "Warning 1"
                }
            ];
            messages.forEach((msg)=>{
                if (msg.level === "info") {
                    _logger.logger.info(msg.message);
                } else if (msg.level === "warn") {
                    _logger.logger.warn(msg.message);
                }
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(2);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3V0aWxzL2xvZ2dlci1jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAamVzdC1lbnZpcm9ubWVudCBub2RlXG4gKi9cblxuLy8gU2V0IE5PREVfRU5WIHRvIGRldmVsb3BtZW50IGJlZm9yZSBpbXBvcnRpbmcgbG9nZ2VyXG5wcm9jZXNzLmVudi5OT0RFX0VOViA9ICdkZXZlbG9wbWVudCc7XG5cbi8vIENsZWFyIG1vZHVsZSBjYWNoZSB0byBlbnN1cmUgZnJlc2ggaW1wb3J0XG5qZXN0LnJlc2V0TW9kdWxlcygpO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2xpYi91dGlscy9sb2dnZXInO1xuXG4vLyBNb2NrIGNvbnNvbGUgbWV0aG9kc1xuY29uc3QgbW9ja0NvbnNvbGUgPSB7XG4gIGxvZzogamVzdC5mbigpLFxuICBlcnJvcjogamVzdC5mbigpLFxuICB3YXJuOiBqZXN0LmZuKCksXG4gIGluZm86IGplc3QuZm4oKSxcbiAgZGVidWc6IGplc3QuZm4oKSxcbn07XG5cbi8vIFJlcGxhY2UgY29uc29sZSB3aXRoIG1vY2tcbk9iamVjdC5hc3NpZ24oY29uc29sZSwgbW9ja0NvbnNvbGUpO1xuXG5kZXNjcmliZSgnTG9nZ2VyIFV0aWxpdHkgLSBDb21wcmVoZW5zaXZlIFRlc3RpbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgTG9nZ2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyBpbmZvIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgLy8gRm9yY2UgbG9nZ2VyIHRvIGJlIGluIGRldmVsb3BtZW50IG1vZGVcbiAgICAgIChsb2dnZXIgYXMgYW55KS5pc0RldmVsb3BtZW50ID0gdHJ1ZTtcbiAgICAgIChsb2dnZXIgYXMgYW55KS5sZXZlbCA9IDA7IC8vIERFQlVHIGxldmVsXG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdUZXN0IGluZm8gbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUZXN0IGluZm8gbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIGVycm9yIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdUZXN0IGVycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBUZXN0IGVycm9yIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3YXJuaW5nIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oJ1Rlc3Qgd2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIFdBUk46IFRlc3Qgd2FybmluZyBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgZGVidWcgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1Rlc3QgZGVidWcgbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gREVCVUc6IFRlc3QgZGVidWcgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0cnVjdHVyZWQgTG9nZ2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgYWN0aW9uOiAnbG9naW4nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIG1ldGFkYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBhY3Rpb24vKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIGVycm9yIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBhY3Rpb246ICdkYXRhYmFzZS1xdWVyeScsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFiYXNlIGVycm9yJywgZXJyb3IsIGNvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IERhdGFiYXNlIGVycm9yLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aCBwZXJmb3JtYW5jZSBtZXRyaWNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljcyA9IHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgbWVtb3J5VXNhZ2U6IDI1LjUsXG4gICAgICAgIGNwdVVzYWdlOiAxMi4zLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1BlcmZvcm1hbmNlIG1ldHJpY3MnLCBtZXRyaWNzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogUGVyZm9ybWFuY2UgbWV0cmljcy8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBMZXZlbHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IGxvZyBsZXZlbCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBkaWZmZXJlbnQgbG9nIGxldmVsc1xuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIud2FybignV2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIERFQlVHOiBEZWJ1ZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogSW5mbyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gV0FSTjogV2FybmluZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBFcnJvciBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9nIGxldmVsIGZpbHRlcmluZycsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIGxvZyBsZXZlbFxuICAgICAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gJ3Byb2R1Y3Rpb24nO1xuICAgICAgXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCBkZWJ1ZyBsb2dzIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1Zykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEluZm8gbWVzc2FnZS8pKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBlbnZpcm9ubWVudFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBvcmlnaW5hbEVudjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gb2JqZWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNpcmN1bGFyT2JqOiBhbnkgPSB7IG5hbWU6ICd0ZXN0JyB9O1xuICAgICAgY2lyY3VsYXJPYmouc2VsZiA9IGNpcmN1bGFyT2JqO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnQ2lyY3VsYXIgb2JqZWN0JywgY2lyY3VsYXJPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBDaXJjdWxhciBvYmplY3QvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmRlZmluZWQgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ1VuZGVmaW5lZCB2YWx1ZScsIHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVuZGVmaW5lZCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ051bGwgdmFsdWUnLCBudWxsKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTnVsbCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU9iaiA9IHtcbiAgICAgICAgZGF0YTogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMCB9LCAoXywgaSkgPT4gKHsgaWQ6IGksIHZhbHVlOiBgaXRlbS0ke2l9YCB9KSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY291bnQ6IDEwMDAsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnTGFyZ2Ugb2JqZWN0JywgbGFyZ2VPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBMYXJnZSBvYmplY3QvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoaW4gcGVyZm9ybWFuY2UgYnVkZ2V0JywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTAwbXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGJsb2NrIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBMb2cgbXVsdGlwbGUgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHlcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGxvZ2dlci5pbmZvKGBBc3luYyBtZXNzYWdlICR7aX1gKSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNTBtc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBzZW5zaXRpdmUgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbnNpdGl2ZURhdGEgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAnc2VjcmV0MTIzJyxcbiAgICAgICAgdG9rZW46ICdiZWFyZXItdG9rZW4nLFxuICAgICAgICBhcGlLZXk6ICdhcGkta2V5LTEyMycsXG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIG5vcm1hbERhdGE6ICdzYWZlIGRhdGEnLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgZGF0YScsIHNlbnNpdGl2ZURhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBVc2VyIGRhdGEvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBTUUwgaW5qZWN0aW9uIGF0dGVtcHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXQgPSBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCI7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGlucHV0JywgeyBpbnB1dDogbWFsaWNpb3VzSW5wdXQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVzZXIgaW5wdXQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBYU1MgYXR0ZW1wdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNJbnB1dCA9ICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+JztcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgaW5wdXQnLCB7IGlucHV0OiBtYWxpY2lvdXNJbnB1dCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBpbnB1dC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnRleHQgYW5kIFRyYWNpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHJlcXVlc3QgY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0ge1xuICAgICAgICByZXF1ZXN0SWQ6ICdyZXEtMTIzJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBpcDogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAuLi4nLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1JlcXVlc3QgcHJvY2Vzc2VkJywgcmVxdWVzdENvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBSZXF1ZXN0IHByb2Nlc3NlZC8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBlcnJvciBzdGFjayB0cmFjZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSAnRXJyb3I6IFRlc3QgZXJyb3JcXG4gICAgYXQgdGVzdC5qczoxOjEnO1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG9jY3VycmVkJywgZXJyb3IpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IEVycm9yIG9jY3VycmVkLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHRpbWluZyBpbmZvcm1hdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWluZyA9IHtcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpIC0gMTAwMCxcbiAgICAgICAgZW5kVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnT3BlcmF0aW9uIGNvbXBsZXRlZCcsIHRpbWluZyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IE9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2cgRm9ybWF0dGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZvcm1hdCB0aW1lc3RhbXBzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCcyMDIzLTAxLTAxVDAwOjAwOjAwWicpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVGltZXN0YW1wZWQgbWVzc2FnZScsIHsgdGltZXN0YW1wIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUaW1lc3RhbXBlZCBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmb3JtYXQgb2JqZWN0cyB3aXRoIHByb3BlciBpbmRlbnRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXhPYmogPSB7XG4gICAgICAgIGxldmVsMToge1xuICAgICAgICAgIGxldmVsMjoge1xuICAgICAgICAgICAgbGV2ZWwzOiAndmFsdWUnLFxuICAgICAgICAgICAgYXJyYXk6IFsxLCAyLCAzXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0NvbXBsZXggb2JqZWN0JywgY29tcGxleE9iaik7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IENvbXBsZXggb2JqZWN0LykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbENoYXJzID0ge1xuICAgICAgICB1bmljb2RlOiAn8J+agCcsXG4gICAgICAgIGVtb2ppOiAn8J+YgCcsXG4gICAgICAgIHN5bWJvbHM6ICchQCMkJV4mKigpJyxcbiAgICAgICAgcXVvdGVzOiAnXCJkb3VibGVcIiBhbmQgXFwnc2luZ2xlXFwnJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTcGVjaWFsIGNoYXJhY3RlcnMnLCBzcGVjaWFsQ2hhcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTcGVjaWFsIGNoYXJhY3RlcnMvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBjYXVzZSBtZW1vcnkgbGVha3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgXG4gICAgICAvLyBMb2cgbWFueSBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWAsIHsgZGF0YTogYGRhdGEtJHtpfWAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgICBcbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxME1CXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBsb2cgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU1lc3NhZ2UgPSAneCcucmVwZWF0KDEwMDAwKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0xhcmdlIG1lc3NhZ2UnLCB7IG1lc3NhZ2U6IGxhcmdlTWVzc2FnZSB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTGFyZ2UgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FzeW5jIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFzeW5jT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgcmV0dXJuICdhc3luYyByZXN1bHQnO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXN5bmNPcGVyYXRpb24oKTtcbiAgICAgIGxvZ2dlci5pbmZvKCdBc3luYyBvcGVyYXRpb24gY29tcGxldGVkJywgeyByZXN1bHQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFN0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEFzeW5jIG9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwcm9taXNlIHJlamVjdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmYWlsaW5nT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FzeW5jIGVycm9yJyk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgZmFpbGluZyBvcGVyYXRpb24nKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmFpbGluZ09wZXJhdGlvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdBc3luYyBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTdGFydGluZyBmYWlsaW5nIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBFUlJPUjogQXN5bmMgb3BlcmF0aW9uIGZhaWxlZC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBBZ2dyZWdhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFnZ3JlZ2F0ZSByZWxhdGVkIGxvZyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTZXNzaW9uIHN0YXJ0ZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIHsgc2Vzc2lvbklkLCBhY3Rpb246ICdsb2dpbicgfSk7XG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBhY3Rpb24nLCB7IHNlc3Npb25JZCwgYWN0aW9uOiAnbmF2aWdhdGUnIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oJ1Nlc3Npb24gZW5kZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvZyBiYXRjaGluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW1xuICAgICAgICB7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdNZXNzYWdlIDEnIH0sXG4gICAgICAgIHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZTogJ01lc3NhZ2UgMicgfSxcbiAgICAgICAgeyBsZXZlbDogJ3dhcm4nLCBtZXNzYWdlOiAnV2FybmluZyAxJyB9LFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICBpZiAobXNnLmxldmVsID09PSAnaW5mbycpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhtc2cubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobXNnLmxldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihtc2cubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImplc3QiLCJyZXNldE1vZHVsZXMiLCJtb2NrQ29uc29sZSIsImxvZyIsImZuIiwiZXJyb3IiLCJ3YXJuIiwiaW5mbyIsImRlYnVnIiwiT2JqZWN0IiwiYXNzaWduIiwiY29uc29sZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImxvZ2dlciIsImlzRGV2ZWxvcG1lbnQiLCJsZXZlbCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nTWF0Y2hpbmciLCJtZXRhZGF0YSIsInVzZXJJZCIsImFjdGlvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIkVycm9yIiwiY29udGV4dCIsIm1ldHJpY3MiLCJkdXJhdGlvbiIsIm1lbW9yeVVzYWdlIiwiY3B1VXNhZ2UiLCJvcmlnaW5hbEVudiIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjaXJjdWxhck9iaiIsIm5hbWUiLCJzZWxmIiwidW5kZWZpbmVkIiwibGFyZ2VPYmoiLCJkYXRhIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJpZCIsInZhbHVlIiwiY291bnQiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJwcm9taXNlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImFsbCIsInNlbnNpdGl2ZURhdGEiLCJwYXNzd29yZCIsInRva2VuIiwiYXBpS2V5IiwiZW1haWwiLCJub3JtYWxEYXRhIiwibWFsaWNpb3VzSW5wdXQiLCJpbnB1dCIsInJlcXVlc3RDb250ZXh0IiwicmVxdWVzdElkIiwiaXAiLCJ1c2VyQWdlbnQiLCJzdGFjayIsInRpbWluZyIsImNvbXBsZXhPYmoiLCJsZXZlbDEiLCJsZXZlbDIiLCJsZXZlbDMiLCJhcnJheSIsInNwZWNpYWxDaGFycyIsInVuaWNvZGUiLCJlbW9qaSIsInN5bWJvbHMiLCJxdW90ZXMiLCJpbml0aWFsTWVtb3J5IiwiaGVhcFVzZWQiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwibGFyZ2VNZXNzYWdlIiwicmVwZWF0IiwibWVzc2FnZSIsImFzeW5jT3BlcmF0aW9uIiwic2V0VGltZW91dCIsInJlc3VsdCIsImZhaWxpbmdPcGVyYXRpb24iLCJzZXNzaW9uSWQiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJtZXNzYWdlcyIsImZvckVhY2giLCJtc2ciXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdB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