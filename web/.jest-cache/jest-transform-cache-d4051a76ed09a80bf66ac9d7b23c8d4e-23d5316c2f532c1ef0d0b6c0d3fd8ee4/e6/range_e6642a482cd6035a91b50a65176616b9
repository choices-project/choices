df2334b3543f82a73771bfb7c6f3486b
/**
 * Range Voting Strategy
 * 
 * Implements range voting where voters rate each option on a scale.
 * Results show the average rating for each option, with the highest average winning.
 * 
 * Created: September 15, 2025
 * Updated: September 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RangeStrategy", {
    enumerable: true,
    get: function() {
        return RangeStrategy;
    }
});
const _logger = require("../../utils/logger");
const _objects = require("../../utils/objects");
class RangeStrategy {
    getVotingMethod() {
        return "range";
    }
    async validateVote(request, poll) {
        try {
            const { voteData } = request;
            // Check if ratings object is provided
            if (!voteData.ratings || typeof voteData.ratings !== "object") {
                return {
                    isValid: false,
                    error: "Ratings object is required for range voting",
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            const ratings = voteData.ratings;
            const rangeMin = poll.votingConfig.rangeMin || 0;
            const rangeMax = poll.votingConfig.rangeMax || 10;
            // Validate all ratings are within range
            for (const [optionIndex, rating] of Object.entries(ratings)){
                if (typeof rating !== "number" || isNaN(rating)) {
                    return {
                        isValid: false,
                        error: "All ratings must be valid numbers",
                        requiresAuthentication: true,
                        requiresTokens: false
                    };
                }
                if (rating < rangeMin || rating > rangeMax) {
                    return {
                        isValid: false,
                        error: `Rating must be between ${rangeMin} and ${rangeMax}`,
                        requiresAuthentication: true,
                        requiresTokens: false
                    };
                }
                // Validate option index is valid
                const optionIdx = parseInt(optionIndex);
                if (optionIdx < 0 || optionIdx >= poll.options.length) {
                    return {
                        isValid: false,
                        error: `Invalid option index: ${optionIndex}`,
                        requiresAuthentication: true,
                        requiresTokens: false
                    };
                }
            }
            // Check if all options are rated
            if (Object.keys(ratings).length !== poll.options.length) {
                return {
                    isValid: false,
                    error: "All options must be rated",
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Check if at least one option has a non-zero rating
            const hasNonZeroRating = Object.values(ratings).some((rating)=>rating > rangeMin);
            if (!hasNonZeroRating) {
                return {
                    isValid: false,
                    error: "At least one option must have a rating above the minimum",
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            (0, _logger.devLog)("Range vote validated successfully", {
                pollId: request.pollId,
                ratings,
                rangeMin,
                rangeMax,
                userId: request.userId
            });
            return {
                isValid: true,
                requiresAuthentication: true,
                requiresTokens: false
            };
        } catch (error) {
            (0, _logger.devLog)("Range vote validation error:", error);
            return {
                isValid: false,
                error: error instanceof Error ? error.message : "Validation failed",
                requiresAuthentication: true,
                requiresTokens: false
            };
        }
    }
    async processVote(request, poll) {
        try {
            const { voteData, userId, pollId, privacyLevel } = request;
            // Generate vote ID
            const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            // Create audit receipt
            const auditReceipt = `receipt_${voteId}_${Date.now()}`;
            // Calculate total score for audit
            const ratings = voteData.ratings || {};
            const totalScore = Object.values(ratings).reduce((sum, rating)=>sum + rating, 0);
            const averageScore = Object.keys(ratings).length > 0 ? totalScore / Object.keys(ratings).length : 0;
            // In a real implementation, this would:
            // 1. Store the vote in the database
            // 2. Update poll vote counts
            // 3. Trigger any necessary notifications
            // 4. Log the vote for audit purposes
            (0, _logger.devLog)("Range vote processed successfully", {
                pollId,
                voteId,
                ratings,
                totalScore,
                averageScore,
                userId,
                auditReceipt
            });
            return (0, _objects.withOptional)({
                success: true,
                message: "Vote submitted successfully",
                pollId,
                voteId,
                auditReceipt,
                responseTime: 0,
                metadata: {
                    votingMethod: "range",
                    ratings,
                    totalScore,
                    averageScore,
                    rangeMin: poll.votingConfig.rangeMin || 0,
                    rangeMax: poll.votingConfig.rangeMax || 10
                }
            }, {
                privacyLevel
            });
        } catch (error) {
            (0, _logger.devLog)("Range vote processing error:", error);
            return (0, _objects.withOptional)({
                success: false,
                message: error instanceof Error ? error.message : "Vote processing failed",
                pollId: request.pollId,
                responseTime: 0,
                metadata: {
                    votingMethod: "range",
                    error: error instanceof Error ? error.message : "Unknown error"
                }
            }, {
                voteId: undefined,
                auditReceipt: undefined,
                privacyLevel: request.privacyLevel
            });
        }
    }
    async calculateResults(poll, votes) {
        try {
            const startTime = Date.now();
            // Calculate range scores and averages for each option
            const rangeScores = {};
            const rangeAverages = {};
            const optionVotes = {};
            const optionPercentages = {};
            const ratingCounts = {};
            // Initialize scores
            poll.options.forEach((_, index)=>{
                rangeScores[index.toString()] = 0;
                rangeAverages[index.toString()] = 0;
                optionVotes[index.toString()] = 0;
                optionPercentages[index.toString()] = 0;
                ratingCounts[index.toString()] = 0;
            });
            // Calculate scores from votes
            let totalVotes = 0;
            votes.forEach((vote)=>{
                if (vote.ratings && typeof vote.ratings === "object") {
                    totalVotes++;
                    Object.entries(vote.ratings).forEach(([optionIndex, rating])=>{
                        const ratingNum = rating;
                        const optionIdx = optionIndex.toString();
                        // Ensure the option exists in our tracking objects
                        if (rangeScores[optionIdx] !== undefined && ratingCounts[optionIdx] !== undefined && optionVotes[optionIdx] !== undefined) {
                            rangeScores[optionIdx] += ratingNum;
                            ratingCounts[optionIdx]++;
                            optionVotes[optionIdx]++;
                        }
                    });
                }
            });
            // Calculate averages
            Object.keys(rangeScores).forEach((optionIndex)=>{
                const count = ratingCounts[optionIndex];
                const score = rangeScores[optionIndex];
                if (count !== undefined && score !== undefined && count > 0) {
                    rangeAverages[optionIndex] = score / count;
                }
            });
            // Calculate percentages (based on vote count)
            if (totalVotes > 0) {
                Object.keys(optionVotes).forEach((optionIndex)=>{
                    const votes = optionVotes[optionIndex];
                    if (votes !== undefined) {
                        optionPercentages[optionIndex] = votes / totalVotes * 100;
                    }
                });
            }
            // Find winner (highest average rating)
            let winner;
            let winnerVotes = 0;
            let winnerPercentage = 0;
            if (totalVotes > 0) {
                Object.entries(rangeAverages).forEach(([optionIndex, average])=>{
                    if (average > winnerVotes) {
                        winner = optionIndex;
                        winnerVotes = average;
                        winnerPercentage = optionPercentages[optionIndex] ?? 0;
                    }
                });
            }
            const results = (0, _objects.withOptional)({
                winnerVotes,
                winnerPercentage,
                rangeScores,
                rangeAverages,
                optionVotes,
                optionPercentages,
                abstentions: 0,
                abstentionPercentage: 0
            }, {
                winner
            });
            const resultsData = {
                pollId: poll.id,
                votingMethod: "range",
                totalVotes,
                participationRate: totalVotes > 0 ? 100 : 0,
                results,
                calculatedAt: new Date().toISOString(),
                metadata: {
                    calculationTime: Date.now() - startTime,
                    hasWinner: winner !== undefined,
                    isTie: winnerVotes > 0 && Object.values(rangeAverages).filter((a)=>a === winnerVotes).length > 1,
                    averageRating: totalVotes > 0 ? Object.values(rangeScores).reduce((sum, score)=>sum + score, 0) / (Object.values(ratingCounts).reduce((sum, count)=>sum + count, 0) || 1) : 0,
                    rangeMin: poll.votingConfig.rangeMin || 0,
                    rangeMax: poll.votingConfig.rangeMax || 10
                }
            };
            (0, _logger.devLog)("Range results calculated", {
                pollId: poll.id,
                totalVotes,
                winner,
                winnerVotes,
                winnerPercentage,
                calculationTime: Date.now() - startTime
            });
            return resultsData;
        } catch (error) {
            (0, _logger.devLog)("Range results calculation error:", error);
            throw new Error(`Failed to calculate range results: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    getConfiguration() {
        return {
            name: "Range Voting",
            description: "Voters rate each option on a scale. The option with the highest average rating wins.",
            minOptions: 2,
            maxOptions: 20,
            allowAbstention: false,
            requiresRanking: false,
            allowsMultipleSelections: true,
            resultType: "highest_average",
            features: [
                "Captures intensity of preference",
                "Allows nuanced expression",
                "Good for satisfaction surveys",
                "Provides detailed feedback"
            ],
            limitations: [
                "Requires rating all options",
                "Can be time-consuming",
                "May not reflect true preferences",
                "Susceptible to strategic voting"
            ],
            defaultRangeMin: 0,
            defaultRangeMax: 10,
            allowDecimals: true
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvdm90ZS9zdHJhdGVnaWVzL3JhbmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmFuZ2UgVm90aW5nIFN0cmF0ZWd5XG4gKiBcbiAqIEltcGxlbWVudHMgcmFuZ2Ugdm90aW5nIHdoZXJlIHZvdGVycyByYXRlIGVhY2ggb3B0aW9uIG9uIGEgc2NhbGUuXG4gKiBSZXN1bHRzIHNob3cgdGhlIGF2ZXJhZ2UgcmF0aW5nIGZvciBlYWNoIG9wdGlvbiwgd2l0aCB0aGUgaGlnaGVzdCBhdmVyYWdlIHdpbm5pbmcuXG4gKiBcbiAqIENyZWF0ZWQ6IFNlcHRlbWJlciAxNSwgMjAyNVxuICogVXBkYXRlZDogU2VwdGVtYmVyIDE1LCAyMDI1XG4gKi9cblxuaW1wb3J0IHsgZGV2TG9nIH0gZnJvbSAnQC9saWIvdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IHdpdGhPcHRpb25hbCB9IGZyb20gJ0AvbGliL3V0aWxzL29iamVjdHMnO1xuXG5pbXBvcnQgdHlwZSB7IFxuICBWb3RpbmdTdHJhdGVneSwgXG4gIFZvdGVSZXF1ZXN0LCBcbiAgVm90ZVJlc3BvbnNlLCBcbiAgVm90ZVZhbGlkYXRpb24sIFxuICBQb2xsRGF0YSwgXG4gIFZvdGVEYXRhLCBcbiAgUmVzdWx0c0RhdGEsXG4gIFZvdGluZ01ldGhvZCxcbiAgUG9sbFJlc3VsdHNcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUmFuZ2VTdHJhdGVneSBpbXBsZW1lbnRzIFZvdGluZ1N0cmF0ZWd5IHtcbiAgXG4gIGdldFZvdGluZ01ldGhvZCgpOiBWb3RpbmdNZXRob2Qge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVWb3RlKHJlcXVlc3Q6IFZvdGVSZXF1ZXN0LCBwb2xsOiBQb2xsRGF0YSk6IFByb21pc2U8Vm90ZVZhbGlkYXRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2b3RlRGF0YSB9ID0gcmVxdWVzdDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgcmF0aW5ncyBvYmplY3QgaXMgcHJvdmlkZWRcbiAgICAgIGlmICghdm90ZURhdGEucmF0aW5ncyB8fCB0eXBlb2Ygdm90ZURhdGEucmF0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1JhdGluZ3Mgb2JqZWN0IGlzIHJlcXVpcmVkIGZvciByYW5nZSB2b3RpbmcnLFxuICAgICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJhdGluZ3MgPSB2b3RlRGF0YS5yYXRpbmdzO1xuICAgICAgY29uc3QgcmFuZ2VNaW4gPSBwb2xsLnZvdGluZ0NvbmZpZy5yYW5nZU1pbiB8fCAwO1xuICAgICAgY29uc3QgcmFuZ2VNYXggPSBwb2xsLnZvdGluZ0NvbmZpZy5yYW5nZU1heCB8fCAxMDtcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgYWxsIHJhdGluZ3MgYXJlIHdpdGhpbiByYW5nZVxuICAgICAgZm9yIChjb25zdCBbb3B0aW9uSW5kZXgsIHJhdGluZ10gb2YgT2JqZWN0LmVudHJpZXMocmF0aW5ncykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByYXRpbmcgIT09ICdudW1iZXInIHx8IGlzTmFOKHJhdGluZykpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0FsbCByYXRpbmdzIG11c3QgYmUgdmFsaWQgbnVtYmVycycsXG4gICAgICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYXRpbmcgPCByYW5nZU1pbiB8fCByYXRpbmcgPiByYW5nZU1heCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBgUmF0aW5nIG11c3QgYmUgYmV0d2VlbiAke3JhbmdlTWlufSBhbmQgJHtyYW5nZU1heH1gLFxuICAgICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVzVG9rZW5zOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBvcHRpb24gaW5kZXggaXMgdmFsaWRcbiAgICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gcGFyc2VJbnQob3B0aW9uSW5kZXgpO1xuICAgICAgICBpZiAob3B0aW9uSWR4IDwgMCB8fCBvcHRpb25JZHggPj0gcG9sbC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBgSW52YWxpZCBvcHRpb24gaW5kZXg6ICR7b3B0aW9uSW5kZXh9YCxcbiAgICAgICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFsbCBvcHRpb25zIGFyZSByYXRlZFxuICAgICAgaWYgKE9iamVjdC5rZXlzKHJhdGluZ3MpLmxlbmd0aCAhPT0gcG9sbC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAnQWxsIG9wdGlvbnMgbXVzdCBiZSByYXRlZCcsXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYXQgbGVhc3Qgb25lIG9wdGlvbiBoYXMgYSBub24temVybyByYXRpbmdcbiAgICAgIGNvbnN0IGhhc05vblplcm9SYXRpbmcgPSBPYmplY3QudmFsdWVzKHJhdGluZ3MpLnNvbWUocmF0aW5nID0+IChyYXRpbmcpID4gcmFuZ2VNaW4pO1xuICAgICAgaWYgKCFoYXNOb25aZXJvUmF0aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdBdCBsZWFzdCBvbmUgb3B0aW9uIG11c3QgaGF2ZSBhIHJhdGluZyBhYm92ZSB0aGUgbWluaW11bScsXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZGV2TG9nKCdSYW5nZSB2b3RlIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHknLCB7XG4gICAgICAgIHBvbGxJZDogcmVxdWVzdC5wb2xsSWQsXG4gICAgICAgIHJhdGluZ3MsXG4gICAgICAgIHJhbmdlTWluLFxuICAgICAgICByYW5nZU1heCxcbiAgICAgICAgdXNlcklkOiByZXF1ZXN0LnVzZXJJZFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgIHJlcXVpcmVzVG9rZW5zOiBmYWxzZVxuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZXZMb2coJ1JhbmdlIHZvdGUgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NWb3RlKHJlcXVlc3Q6IFZvdGVSZXF1ZXN0LCBwb2xsOiBQb2xsRGF0YSk6IFByb21pc2U8Vm90ZVJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdm90ZURhdGEsIHVzZXJJZCwgcG9sbElkLCBwcml2YWN5TGV2ZWwgfSA9IHJlcXVlc3Q7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIHZvdGUgSURcbiAgICAgIGNvbnN0IHZvdGVJZCA9IGB2b3RlXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGF1ZGl0IHJlY2VpcHRcbiAgICAgIGNvbnN0IGF1ZGl0UmVjZWlwdCA9IGByZWNlaXB0XyR7dm90ZUlkfV8ke0RhdGUubm93KCl9YDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHNjb3JlIGZvciBhdWRpdFxuICAgICAgY29uc3QgcmF0aW5ncyA9IHZvdGVEYXRhLnJhdGluZ3MgfHwge307XG4gICAgICBjb25zdCB0b3RhbFNjb3JlID0gT2JqZWN0LnZhbHVlcyhyYXRpbmdzKS5yZWR1Y2UoKHN1bTogbnVtYmVyLCByYXRpbmcpID0+IHN1bSArIChyYXRpbmcpLCAwKTtcbiAgICAgIGNvbnN0IGF2ZXJhZ2VTY29yZSA9IE9iamVjdC5rZXlzKHJhdGluZ3MpLmxlbmd0aCA+IDAgPyAodG90YWxTY29yZSkgLyBPYmplY3Qua2V5cyhyYXRpbmdzKS5sZW5ndGggOiAwO1xuXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQ6XG4gICAgICAvLyAxLiBTdG9yZSB0aGUgdm90ZSBpbiB0aGUgZGF0YWJhc2VcbiAgICAgIC8vIDIuIFVwZGF0ZSBwb2xsIHZvdGUgY291bnRzXG4gICAgICAvLyAzLiBUcmlnZ2VyIGFueSBuZWNlc3Nhcnkgbm90aWZpY2F0aW9uc1xuICAgICAgLy8gNC4gTG9nIHRoZSB2b3RlIGZvciBhdWRpdCBwdXJwb3Nlc1xuXG4gICAgICBkZXZMb2coJ1JhbmdlIHZvdGUgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkLFxuICAgICAgICB2b3RlSWQsXG4gICAgICAgIHJhdGluZ3MsXG4gICAgICAgIHRvdGFsU2NvcmUsXG4gICAgICAgIGF2ZXJhZ2VTY29yZSxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBhdWRpdFJlY2VpcHRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gd2l0aE9wdGlvbmFsKFxuICAgICAgICB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiAnVm90ZSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgICBwb2xsSWQsXG4gICAgICAgICAgdm90ZUlkLFxuICAgICAgICAgIGF1ZGl0UmVjZWlwdCxcbiAgICAgICAgICByZXNwb25zZVRpbWU6IDAsIC8vIFdpbGwgYmUgc2V0IGJ5IHRoZSBlbmdpbmVcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdm90aW5nTWV0aG9kOiAncmFuZ2UnLFxuICAgICAgICAgICAgcmF0aW5ncyxcbiAgICAgICAgICAgIHRvdGFsU2NvcmUsXG4gICAgICAgICAgICBhdmVyYWdlU2NvcmUsXG4gICAgICAgICAgICByYW5nZU1pbjogcG9sbC52b3RpbmdDb25maWcucmFuZ2VNaW4gfHwgMCxcbiAgICAgICAgICAgIHJhbmdlTWF4OiBwb2xsLnZvdGluZ0NvbmZpZy5yYW5nZU1heCB8fCAxMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByaXZhY3lMZXZlbFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnUmFuZ2Ugdm90ZSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB3aXRoT3B0aW9uYWwoXG4gICAgICAgIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdWb3RlIHByb2Nlc3NpbmcgZmFpbGVkJyxcbiAgICAgICAgICBwb2xsSWQ6IHJlcXVlc3QucG9sbElkLFxuICAgICAgICAgIHJlc3BvbnNlVGltZTogMCxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdm90aW5nTWV0aG9kOiAncmFuZ2UnLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdm90ZUlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgYXVkaXRSZWNlaXB0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcHJpdmFjeUxldmVsOiByZXF1ZXN0LnByaXZhY3lMZXZlbFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbGN1bGF0ZVJlc3VsdHMocG9sbDogUG9sbERhdGEsIHZvdGVzOiBWb3RlRGF0YVtdKTogUHJvbWlzZTxSZXN1bHRzRGF0YT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgcmFuZ2Ugc2NvcmVzIGFuZCBhdmVyYWdlcyBmb3IgZWFjaCBvcHRpb25cbiAgICAgIGNvbnN0IHJhbmdlU2NvcmVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBjb25zdCByYW5nZUF2ZXJhZ2VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBjb25zdCBvcHRpb25Wb3RlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgY29uc3Qgb3B0aW9uUGVyY2VudGFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIGNvbnN0IHJhdGluZ0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIHNjb3Jlc1xuICAgICAgcG9sbC5vcHRpb25zLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIHJhbmdlU2NvcmVzW2luZGV4LnRvU3RyaW5nKCldID0gMDtcbiAgICAgICAgcmFuZ2VBdmVyYWdlc1tpbmRleC50b1N0cmluZygpXSA9IDA7XG4gICAgICAgIG9wdGlvblZvdGVzW2luZGV4LnRvU3RyaW5nKCldID0gMDtcbiAgICAgICAgb3B0aW9uUGVyY2VudGFnZXNbaW5kZXgudG9TdHJpbmcoKV0gPSAwO1xuICAgICAgICByYXRpbmdDb3VudHNbaW5kZXgudG9TdHJpbmcoKV0gPSAwO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzY29yZXMgZnJvbSB2b3Rlc1xuICAgICAgbGV0IHRvdGFsVm90ZXMgPSAwO1xuICAgICAgdm90ZXMuZm9yRWFjaCh2b3RlID0+IHtcbiAgICAgICAgaWYgKHZvdGUucmF0aW5ncyAmJiB0eXBlb2Ygdm90ZS5yYXRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRvdGFsVm90ZXMrKztcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh2b3RlLnJhdGluZ3MpLmZvckVhY2goKFtvcHRpb25JbmRleCwgcmF0aW5nXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF0aW5nTnVtID0gcmF0aW5nO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gb3B0aW9uSW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgb3B0aW9uIGV4aXN0cyBpbiBvdXIgdHJhY2tpbmcgb2JqZWN0c1xuICAgICAgICAgICAgaWYgKHJhbmdlU2NvcmVzW29wdGlvbklkeF0gIT09IHVuZGVmaW5lZCAmJiBcbiAgICAgICAgICAgICAgICByYXRpbmdDb3VudHNbb3B0aW9uSWR4XSAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICAgICAgICAgIG9wdGlvblZvdGVzW29wdGlvbklkeF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByYW5nZVNjb3Jlc1tvcHRpb25JZHhdICs9IHJhdGluZ051bTtcbiAgICAgICAgICAgICAgcmF0aW5nQ291bnRzW29wdGlvbklkeF0rKztcbiAgICAgICAgICAgICAgb3B0aW9uVm90ZXNbb3B0aW9uSWR4XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2VzXG4gICAgICBPYmplY3Qua2V5cyhyYW5nZVNjb3JlcykuZm9yRWFjaChvcHRpb25JbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gcmF0aW5nQ291bnRzW29wdGlvbkluZGV4XTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSByYW5nZVNjb3Jlc1tvcHRpb25JbmRleF07XG4gICAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSB1bmRlZmluZWQgJiYgY291bnQgPiAwKSB7XG4gICAgICAgICAgcmFuZ2VBdmVyYWdlc1tvcHRpb25JbmRleF0gPSBzY29yZSAvIGNvdW50O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2VzIChiYXNlZCBvbiB2b3RlIGNvdW50KVxuICAgICAgaWYgKHRvdGFsVm90ZXMgPiAwKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvblZvdGVzKS5mb3JFYWNoKG9wdGlvbkluZGV4ID0+IHtcbiAgICAgICAgICBjb25zdCB2b3RlcyA9IG9wdGlvblZvdGVzW29wdGlvbkluZGV4XTtcbiAgICAgICAgICBpZiAodm90ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uUGVyY2VudGFnZXNbb3B0aW9uSW5kZXhdID0gKHZvdGVzIC8gdG90YWxWb3RlcykgKiAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB3aW5uZXIgKGhpZ2hlc3QgYXZlcmFnZSByYXRpbmcpXG4gICAgICBsZXQgd2lubmVyOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgd2lubmVyVm90ZXMgPSAwO1xuICAgICAgbGV0IHdpbm5lclBlcmNlbnRhZ2UgPSAwO1xuXG4gICAgICBpZiAodG90YWxWb3RlcyA+IDApIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocmFuZ2VBdmVyYWdlcykuZm9yRWFjaCgoW29wdGlvbkluZGV4LCBhdmVyYWdlXSkgPT4ge1xuICAgICAgICAgIGlmIChhdmVyYWdlID4gd2lubmVyVm90ZXMpIHtcbiAgICAgICAgICAgIHdpbm5lciA9IG9wdGlvbkluZGV4O1xuICAgICAgICAgICAgd2lubmVyVm90ZXMgPSBhdmVyYWdlO1xuICAgICAgICAgICAgd2lubmVyUGVyY2VudGFnZSA9IG9wdGlvblBlcmNlbnRhZ2VzW29wdGlvbkluZGV4XSA/PyAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdHM6IFBvbGxSZXN1bHRzID0gd2l0aE9wdGlvbmFsKFxuICAgICAgICB7XG4gICAgICAgICAgd2lubmVyVm90ZXMsXG4gICAgICAgICAgd2lubmVyUGVyY2VudGFnZSxcbiAgICAgICAgICByYW5nZVNjb3JlcyxcbiAgICAgICAgICByYW5nZUF2ZXJhZ2VzLFxuICAgICAgICAgIG9wdGlvblZvdGVzLFxuICAgICAgICAgIG9wdGlvblBlcmNlbnRhZ2VzLFxuICAgICAgICAgIGFic3RlbnRpb25zOiAwLFxuICAgICAgICAgIGFic3RlbnRpb25QZXJjZW50YWdlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB3aW5uZXJcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0c0RhdGE6IFJlc3VsdHNEYXRhID0ge1xuICAgICAgICBwb2xsSWQ6IHBvbGwuaWQsXG4gICAgICAgIHZvdGluZ01ldGhvZDogJ3JhbmdlJyxcbiAgICAgICAgdG90YWxWb3RlcyxcbiAgICAgICAgcGFydGljaXBhdGlvblJhdGU6IHRvdGFsVm90ZXMgPiAwID8gMTAwIDogMCwgLy8gVGhpcyB3b3VsZCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIGVsaWdpYmxlIHZvdGVyc1xuICAgICAgICByZXN1bHRzLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgaGFzV2lubmVyOiB3aW5uZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc1RpZTogd2lubmVyVm90ZXMgPiAwICYmIE9iamVjdC52YWx1ZXMocmFuZ2VBdmVyYWdlcykuZmlsdGVyKGEgPT4gYSA9PT0gd2lubmVyVm90ZXMpLmxlbmd0aCA+IDEsXG4gICAgICAgICAgYXZlcmFnZVJhdGluZzogdG90YWxWb3RlcyA+IDAgPyBPYmplY3QudmFsdWVzKHJhbmdlU2NvcmVzKS5yZWR1Y2UoKHN1bSwgc2NvcmUpID0+IHN1bSArIHNjb3JlLCAwKSAvIChPYmplY3QudmFsdWVzKHJhdGluZ0NvdW50cykucmVkdWNlKChzdW0sIGNvdW50KSA9PiBzdW0gKyBjb3VudCwgMCkgfHwgMSkgOiAwLFxuICAgICAgICAgIHJhbmdlTWluOiBwb2xsLnZvdGluZ0NvbmZpZy5yYW5nZU1pbiB8fCAwLFxuICAgICAgICAgIHJhbmdlTWF4OiBwb2xsLnZvdGluZ0NvbmZpZy5yYW5nZU1heCB8fCAxMFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBkZXZMb2coJ1JhbmdlIHJlc3VsdHMgY2FsY3VsYXRlZCcsIHtcbiAgICAgICAgcG9sbElkOiBwb2xsLmlkLFxuICAgICAgICB0b3RhbFZvdGVzLFxuICAgICAgICB3aW5uZXIsXG4gICAgICAgIHdpbm5lclZvdGVzLFxuICAgICAgICB3aW5uZXJQZXJjZW50YWdlLFxuICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0c0RhdGE7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2TG9nKCdSYW5nZSByZXN1bHRzIGNhbGN1bGF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNhbGN1bGF0ZSByYW5nZSByZXN1bHRzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldENvbmZpZ3VyYXRpb24oKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnUmFuZ2UgVm90aW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVm90ZXJzIHJhdGUgZWFjaCBvcHRpb24gb24gYSBzY2FsZS4gVGhlIG9wdGlvbiB3aXRoIHRoZSBoaWdoZXN0IGF2ZXJhZ2UgcmF0aW5nIHdpbnMuJyxcbiAgICAgIG1pbk9wdGlvbnM6IDIsXG4gICAgICBtYXhPcHRpb25zOiAyMCxcbiAgICAgIGFsbG93QWJzdGVudGlvbjogZmFsc2UsXG4gICAgICByZXF1aXJlc1Jhbmtpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dzTXVsdGlwbGVTZWxlY3Rpb25zOiB0cnVlLFxuICAgICAgcmVzdWx0VHlwZTogJ2hpZ2hlc3RfYXZlcmFnZScsXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAnQ2FwdHVyZXMgaW50ZW5zaXR5IG9mIHByZWZlcmVuY2UnLFxuICAgICAgICAnQWxsb3dzIG51YW5jZWQgZXhwcmVzc2lvbicsXG4gICAgICAgICdHb29kIGZvciBzYXRpc2ZhY3Rpb24gc3VydmV5cycsXG4gICAgICAgICdQcm92aWRlcyBkZXRhaWxlZCBmZWVkYmFjaydcbiAgICAgIF0sXG4gICAgICBsaW1pdGF0aW9uczogW1xuICAgICAgICAnUmVxdWlyZXMgcmF0aW5nIGFsbCBvcHRpb25zJyxcbiAgICAgICAgJ0NhbiBiZSB0aW1lLWNvbnN1bWluZycsXG4gICAgICAgICdNYXkgbm90IHJlZmxlY3QgdHJ1ZSBwcmVmZXJlbmNlcycsXG4gICAgICAgICdTdXNjZXB0aWJsZSB0byBzdHJhdGVnaWMgdm90aW5nJ1xuICAgICAgXSxcbiAgICAgIGRlZmF1bHRSYW5nZU1pbjogMCxcbiAgICAgIGRlZmF1bHRSYW5nZU1heDogMTAsXG4gICAgICBhbGxvd0RlY2ltYWxzOiB0cnVlXG4gICAgfTtcbiAgfVxufSJdLCJuYW1lcyI6WyJSYW5nZVN0cmF0ZWd5IiwiZ2V0Vm90aW5nTWV0aG9kIiwidmFsaWRhdGVWb3RlIiwicmVxdWVzdCIsInBvbGwiLCJ2b3RlRGF0YSIsInJhdGluZ3MiLCJpc1ZhbGlkIiwiZXJyb3IiLCJyZXF1aXJlc0F1dGhlbnRpY2F0aW9uIiwicmVxdWlyZXNUb2tlbnMiLCJyYW5nZU1pbiIsInZvdGluZ0NvbmZpZyIsInJhbmdlTWF4Iiwib3B0aW9uSW5kZXgiLCJyYXRpbmciLCJPYmplY3QiLCJlbnRyaWVzIiwiaXNOYU4iLCJvcHRpb25JZHgiLCJwYXJzZUludCIsIm9wdGlvbnMiLCJsZW5ndGgiLCJrZXlzIiwiaGFzTm9uWmVyb1JhdGluZyIsInZhbHVlcyIsInNvbWUiLCJkZXZMb2ciLCJwb2xsSWQiLCJ1c2VySWQiLCJFcnJvciIsIm1lc3NhZ2UiLCJwcm9jZXNzVm90ZSIsInByaXZhY3lMZXZlbCIsInZvdGVJZCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJhdWRpdFJlY2VpcHQiLCJ0b3RhbFNjb3JlIiwicmVkdWNlIiwic3VtIiwiYXZlcmFnZVNjb3JlIiwid2l0aE9wdGlvbmFsIiwic3VjY2VzcyIsInJlc3BvbnNlVGltZSIsIm1ldGFkYXRhIiwidm90aW5nTWV0aG9kIiwidW5kZWZpbmVkIiwiY2FsY3VsYXRlUmVzdWx0cyIsInZvdGVzIiwic3RhcnRUaW1lIiwicmFuZ2VTY29yZXMiLCJyYW5nZUF2ZXJhZ2VzIiwib3B0aW9uVm90ZXMiLCJvcHRpb25QZXJjZW50YWdlcyIsInJhdGluZ0NvdW50cyIsImZvckVhY2giLCJfIiwiaW5kZXgiLCJ0b3RhbFZvdGVzIiwidm90ZSIsInJhdGluZ051bSIsImNvdW50Iiwic2NvcmUiLCJ3aW5uZXIiLCJ3aW5uZXJWb3RlcyIsIndpbm5lclBlcmNlbnRhZ2UiLCJhdmVyYWdlIiwicmVzdWx0cyIsImFic3RlbnRpb25zIiwiYWJzdGVudGlvblBlcmNlbnRhZ2UiLCJyZXN1bHRzRGF0YSIsImlkIiwicGFydGljaXBhdGlvblJhdGUiLCJjYWxjdWxhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImNhbGN1bGF0aW9uVGltZSIsImhhc1dpbm5lciIsImlzVGllIiwiZmlsdGVyIiwiYSIsImF2ZXJhZ2VSYXRpbmciLCJnZXRDb25maWd1cmF0aW9uIiwibmFtZSIsImRlc2NyaXB0aW9uIiwibWluT3B0aW9ucyIsIm1heE9wdGlvbnMiLCJhbGxvd0Fic3RlbnRpb24iLCJyZXF1aXJlc1JhbmtpbmciLCJhbGxvd3NNdWx0aXBsZVNlbGVjdGlvbnMiLCJyZXN1bHRUeXBlIiwiZmVhdHVyZXMiLCJsaW1pdGF0aW9ucyIsImRlZmF1bHRSYW5nZU1pbiIsImRlZmF1bHRSYW5nZU1heCIsImFsbG93RGVjaW1hbHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7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