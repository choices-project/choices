34c6d40c38100880994c92f6a6e6d47a
/**
 * Single Choice Voting Strategy
 * 
 * Implements single-choice voting where voters select exactly one option.
 * Results show the option with the most votes as the winner.
 * 
 * Created: September 15, 2025
 * Updated: September 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SingleChoiceStrategy", {
    enumerable: true,
    get: function() {
        return SingleChoiceStrategy;
    }
});
const _logger = require("../../utils/logger");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class SingleChoiceStrategy {
    getVotingMethod() {
        return "single";
    }
    async validateVote(request, poll) {
        try {
            const { voteData } = request;
            // Check if choice is provided
            if (voteData.choice === undefined || voteData.choice === null) {
                return {
                    valid: false,
                    errors: [
                        "Choice is required for single-choice voting"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Validate choice is a number
            if (typeof voteData.choice !== "number" || !Number.isInteger(voteData.choice)) {
                return {
                    valid: false,
                    errors: [
                        "Choice must be a valid integer"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Validate choice is within valid range
            if (voteData.choice < 0 || voteData.choice >= poll.options.length) {
                return {
                    valid: false,
                    errors: [
                        "Invalid option selected"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Check if user has already voted (if not allowing multiple votes)
            if (!poll.allowMultipleVotes && request.userId) {
            // This would typically check the database, but for now we'll assume it's valid
            // In a real implementation, you'd query the votes table here
            }
            (0, _logger.devLog)("Single choice vote validated successfully", {
                pollId: request.pollId,
                choice: voteData.choice,
                userId: request.userId
            });
            return {
                valid: true,
                requiresAuthentication: true,
                requiresTokens: false
            };
        } catch (error) {
            (0, _logger.devLog)("Single choice vote validation error:", error);
            return {
                valid: false,
                errors: [
                    error instanceof Error ? error.message : "Validation failed"
                ],
                requiresAuthentication: true,
                requiresTokens: false
            };
        }
    }
    async processVote(request, poll) {
        try {
            const { voteData, userId, pollId, privacyLevel } = request;
            // Generate vote ID
            const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            // Create audit receipt
            const auditReceipt = `receipt_${voteId}_${Date.now()}`;
            // Store the vote in the database
            await this.saveVoteToDatabase({
                pollId,
                voteId,
                userId,
                voteData,
                auditReceipt,
                privacyLevel
            });
            (0, _logger.devLog)("Single choice vote processed successfully", {
                pollId,
                voteId,
                choice: voteData.choice,
                userId,
                auditReceipt
            });
            return {
                success: true,
                message: "Vote submitted successfully",
                pollId,
                voteId,
                auditReceipt,
                responseTime: 0,
                metadata: {
                    votingMethod: "single",
                    choice: voteData.choice,
                    optionText: poll.options[voteData.choice || 0]
                },
                privacyLevel
            };
        } catch (error) {
            (0, _logger.devLog)("Single choice vote processing error:", error);
            return {
                success: false,
                message: error instanceof Error ? error.message : "Vote processing failed",
                pollId: request.pollId,
                responseTime: 0,
                metadata: {
                    votingMethod: "single",
                    error: error instanceof Error ? error.message : "Unknown error"
                },
                privacyLevel: request.privacyLevel
            };
        }
    }
    async calculateResults(poll, votes) {
        try {
            const startTime = Date.now();
            // Count votes for each option
            const optionVotes = {};
            const optionPercentages = {};
            // Initialize vote counts
            poll.options.forEach((_, index)=>{
                optionVotes[index.toString()] = 0;
                optionPercentages[index.toString()] = 0;
            });
            // Count votes
            let totalVotes = 0;
            votes.forEach((vote)=>{
                if (vote.choice !== undefined && vote.choice >= 0 && vote.choice < poll.options.length) {
                    const choiceKey = vote.choice.toString();
                    if (optionVotes[choiceKey] !== undefined) {
                        optionVotes[choiceKey]++;
                        totalVotes++;
                    }
                }
            });
            // Calculate percentages
            if (totalVotes > 0) {
                Object.keys(optionVotes).forEach((optionIndex)=>{
                    const votes = optionVotes[optionIndex];
                    if (votes !== undefined) {
                        optionPercentages[optionIndex] = votes / totalVotes * 100;
                    }
                });
            }
            // Find winner
            let winner;
            let winnerVotes = 0;
            let winnerPercentage = 0;
            if (totalVotes > 0) {
                Object.entries(optionVotes).forEach(([optionIndex, votes])=>{
                    if (votes > winnerVotes) {
                        winner = poll.options[parseInt(optionIndex)]?.id || optionIndex;
                        winnerVotes = votes;
                        winnerPercentage = optionPercentages[optionIndex] ?? 0;
                    }
                });
            }
            const results = {
                winner,
                winnerVotes,
                winnerPercentage,
                optionVotes,
                optionPercentages,
                abstentions: 0,
                abstentionPercentage: 0
            };
            const resultsData = {
                pollId: poll.id,
                votingMethod: "single",
                totalVotes,
                participationRate: totalVotes > 0 ? 100 : 0,
                results,
                calculatedAt: new Date().toISOString(),
                metadata: {
                    calculationTime: Date.now() - startTime,
                    hasWinner: winner !== undefined,
                    isTie: winnerVotes > 0 && Object.values(optionVotes).filter((v)=>v === winnerVotes).length > 1
                }
            };
            (0, _logger.devLog)("Single choice results calculated", {
                pollId: poll.id,
                totalVotes,
                winner,
                winnerVotes,
                winnerPercentage,
                calculationTime: Date.now() - startTime
            });
            return resultsData;
        } catch (error) {
            (0, _logger.devLog)("Single choice results calculation error:", error);
            throw new Error(`Failed to calculate single choice results: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    getConfiguration() {
        return {
            name: "Single Choice Voting",
            description: "Voters select exactly one option. The option with the most votes wins.",
            minOptions: 2,
            maxOptions: 100,
            allowAbstention: false,
            requiresRanking: false,
            allowsMultipleSelections: false,
            resultType: "winner",
            features: [
                "Simple and intuitive",
                "Fast to count",
                "Clear winner determination",
                "Suitable for binary decisions"
            ],
            limitations: [
                "May not reflect true preferences",
                "Can lead to vote splitting",
                "No consideration of second choices"
            ]
        };
    }
    async saveVoteToDatabase(voteData) {
        try {
            // Import the VoteEngine to use its saveVote method
            const { VoteEngine } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../engine")));
            const engine = new VoteEngine();
            // Use the engine's saveVote method to persist the vote
            await engine.saveVote(voteData.voteData, {
                pollId: voteData.pollId,
                voteId: voteData.voteId,
                userId: voteData.userId,
                auditReceipt: voteData.auditReceipt,
                privacyLevel: voteData.privacyLevel
            });
            (0, _logger.devLog)("Vote saved to database successfully", {
                pollId: voteData.pollId,
                voteId: voteData.voteId,
                userId: voteData.userId
            });
        } catch (error) {
            (0, _logger.devLog)("Failed to save vote to database:", error);
            throw new Error(`Database save failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvdm90ZS9zdHJhdGVnaWVzL3NpbmdsZS1jaG9pY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaW5nbGUgQ2hvaWNlIFZvdGluZyBTdHJhdGVneVxuICogXG4gKiBJbXBsZW1lbnRzIHNpbmdsZS1jaG9pY2Ugdm90aW5nIHdoZXJlIHZvdGVycyBzZWxlY3QgZXhhY3RseSBvbmUgb3B0aW9uLlxuICogUmVzdWx0cyBzaG93IHRoZSBvcHRpb24gd2l0aCB0aGUgbW9zdCB2b3RlcyBhcyB0aGUgd2lubmVyLlxuICogXG4gKiBDcmVhdGVkOiBTZXB0ZW1iZXIgMTUsIDIwMjVcbiAqIFVwZGF0ZWQ6IFNlcHRlbWJlciAxNSwgMjAyNVxuICovXG5cbmltcG9ydCB7IGRldkxvZyB9IGZyb20gJ0AvbGliL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyB3aXRoT3B0aW9uYWwgfSBmcm9tICdAL2xpYi91dGlscy9vYmplY3RzJztcblxuaW1wb3J0IHR5cGUgeyBcbiAgVm90aW5nU3RyYXRlZ3ksIFxuICBWb3RlUmVxdWVzdCwgXG4gIFZvdGVSZXNwb25zZSwgXG4gIFZvdGVWYWxpZGF0aW9uLCBcbiAgUG9sbERhdGEsIFxuICBWb3RlRGF0YSwgXG4gIFJlc3VsdHNEYXRhLFxuICBWb3RpbmdNZXRob2QsXG4gIFBvbGxSZXN1bHRzXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFNpbmdsZUNob2ljZVN0cmF0ZWd5IGltcGxlbWVudHMgVm90aW5nU3RyYXRlZ3kge1xuICBcbiAgZ2V0Vm90aW5nTWV0aG9kKCk6IFZvdGluZ01ldGhvZCB7XG4gICAgcmV0dXJuICdzaW5nbGUnO1xuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVWb3RlKHJlcXVlc3Q6IFZvdGVSZXF1ZXN0LCBwb2xsOiBQb2xsRGF0YSk6IFByb21pc2U8Vm90ZVZhbGlkYXRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2b3RlRGF0YSB9ID0gcmVxdWVzdDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY2hvaWNlIGlzIHByb3ZpZGVkXG4gICAgICBpZiAodm90ZURhdGEuY2hvaWNlID09PSB1bmRlZmluZWQgfHwgdm90ZURhdGEuY2hvaWNlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogWydDaG9pY2UgaXMgcmVxdWlyZWQgZm9yIHNpbmdsZS1jaG9pY2Ugdm90aW5nJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgY2hvaWNlIGlzIGEgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIHZvdGVEYXRhLmNob2ljZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodm90ZURhdGEuY2hvaWNlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFsnQ2hvaWNlIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgY2hvaWNlIGlzIHdpdGhpbiB2YWxpZCByYW5nZVxuICAgICAgaWYgKHZvdGVEYXRhLmNob2ljZSA8IDAgfHwgdm90ZURhdGEuY2hvaWNlID49IHBvbGwub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiBbJ0ludmFsaWQgb3B0aW9uIHNlbGVjdGVkJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgYWxyZWFkeSB2b3RlZCAoaWYgbm90IGFsbG93aW5nIG11bHRpcGxlIHZvdGVzKVxuICAgICAgaWYgKCFwb2xsLmFsbG93TXVsdGlwbGVWb3RlcyAmJiByZXF1ZXN0LnVzZXJJZCkge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBjaGVjayB0aGUgZGF0YWJhc2UsIGJ1dCBmb3Igbm93IHdlJ2xsIGFzc3VtZSBpdCdzIHZhbGlkXG4gICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91J2QgcXVlcnkgdGhlIHZvdGVzIHRhYmxlIGhlcmVcbiAgICAgIH1cblxuICAgICAgZGV2TG9nKCdTaW5nbGUgY2hvaWNlIHZvdGUgdmFsaWRhdGVkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkOiByZXF1ZXN0LnBvbGxJZCxcbiAgICAgICAgY2hvaWNlOiB2b3RlRGF0YS5jaG9pY2UsXG4gICAgICAgIHVzZXJJZDogcmVxdWVzdC51c2VySWRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnU2luZ2xlIGNob2ljZSB2b3RlIHZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdWYWxpZGF0aW9uIGZhaWxlZCddLFxuICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiB0cnVlLFxuICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc1ZvdGUocmVxdWVzdDogVm90ZVJlcXVlc3QsIHBvbGw6IFBvbGxEYXRhKTogUHJvbWlzZTxWb3RlUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2b3RlRGF0YSwgdXNlcklkLCBwb2xsSWQsIHByaXZhY3lMZXZlbCB9ID0gcmVxdWVzdDtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgdm90ZSBJRFxuICAgICAgY29uc3Qgdm90ZUlkID0gYHZvdGVfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYXVkaXQgcmVjZWlwdFxuICAgICAgY29uc3QgYXVkaXRSZWNlaXB0ID0gYHJlY2VpcHRfJHt2b3RlSWR9XyR7RGF0ZS5ub3coKX1gO1xuXG4gICAgICAvLyBTdG9yZSB0aGUgdm90ZSBpbiB0aGUgZGF0YWJhc2VcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVZvdGVUb0RhdGFiYXNlKHtcbiAgICAgICAgcG9sbElkLFxuICAgICAgICB2b3RlSWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgdm90ZURhdGEsXG4gICAgICAgIGF1ZGl0UmVjZWlwdCxcbiAgICAgICAgcHJpdmFjeUxldmVsXG4gICAgICB9KTtcblxuICAgICAgZGV2TG9nKCdTaW5nbGUgY2hvaWNlIHZvdGUgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkLFxuICAgICAgICB2b3RlSWQsXG4gICAgICAgIGNob2ljZTogdm90ZURhdGEuY2hvaWNlLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIGF1ZGl0UmVjZWlwdFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6ICdWb3RlIHN1Ym1pdHRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgICBwb2xsSWQsXG4gICAgICAgIHZvdGVJZCxcbiAgICAgICAgYXVkaXRSZWNlaXB0LFxuICAgICAgICByZXNwb25zZVRpbWU6IDAsIC8vIFdpbGwgYmUgc2V0IGJ5IHRoZSBlbmdpbmVcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB2b3RpbmdNZXRob2Q6ICdzaW5nbGUnLFxuICAgICAgICAgIGNob2ljZTogdm90ZURhdGEuY2hvaWNlLFxuICAgICAgICAgIG9wdGlvblRleHQ6IHBvbGwub3B0aW9uc1t2b3RlRGF0YS5jaG9pY2UgfHwgMF1cbiAgICAgICAgfSxcbiAgICAgICAgcHJpdmFjeUxldmVsXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnU2luZ2xlIGNob2ljZSB2b3RlIHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1ZvdGUgcHJvY2Vzc2luZyBmYWlsZWQnLFxuICAgICAgICBwb2xsSWQ6IHJlcXVlc3QucG9sbElkLFxuICAgICAgICByZXNwb25zZVRpbWU6IDAsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdm90aW5nTWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgfSxcbiAgICAgICAgcHJpdmFjeUxldmVsOiByZXF1ZXN0LnByaXZhY3lMZXZlbFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVSZXN1bHRzKHBvbGw6IFBvbGxEYXRhLCB2b3RlczogVm90ZURhdGFbXSk6IFByb21pc2U8UmVzdWx0c0RhdGE+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gQ291bnQgdm90ZXMgZm9yIGVhY2ggb3B0aW9uXG4gICAgICBjb25zdCBvcHRpb25Wb3RlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgY29uc3Qgb3B0aW9uUGVyY2VudGFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSB2b3RlIGNvdW50c1xuICAgICAgcG9sbC5vcHRpb25zLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIG9wdGlvblZvdGVzW2luZGV4LnRvU3RyaW5nKCldID0gMDtcbiAgICAgICAgb3B0aW9uUGVyY2VudGFnZXNbaW5kZXgudG9TdHJpbmcoKV0gPSAwO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENvdW50IHZvdGVzXG4gICAgICBsZXQgdG90YWxWb3RlcyA9IDA7XG4gICAgICB2b3Rlcy5mb3JFYWNoKHZvdGUgPT4ge1xuICAgICAgICBpZiAodm90ZS5jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB2b3RlLmNob2ljZSA+PSAwICYmIHZvdGUuY2hvaWNlIDwgcG9sbC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGNob2ljZUtleSA9IHZvdGUuY2hvaWNlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKG9wdGlvblZvdGVzW2Nob2ljZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uVm90ZXNbY2hvaWNlS2V5XSsrO1xuICAgICAgICAgICAgdG90YWxWb3RlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlc1xuICAgICAgaWYgKHRvdGFsVm90ZXMgPiAwKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvblZvdGVzKS5mb3JFYWNoKG9wdGlvbkluZGV4ID0+IHtcbiAgICAgICAgICBjb25zdCB2b3RlcyA9IG9wdGlvblZvdGVzW29wdGlvbkluZGV4XTtcbiAgICAgICAgICBpZiAodm90ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uUGVyY2VudGFnZXNbb3B0aW9uSW5kZXhdID0gKHZvdGVzIC8gdG90YWxWb3RlcykgKiAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB3aW5uZXJcbiAgICAgIGxldCB3aW5uZXI6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgIGxldCB3aW5uZXJWb3RlcyA9IDA7XG4gICAgICBsZXQgd2lubmVyUGVyY2VudGFnZSA9IDA7XG5cbiAgICAgIGlmICh0b3RhbFZvdGVzID4gMCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25Wb3RlcykuZm9yRWFjaCgoW29wdGlvbkluZGV4LCB2b3Rlc10pID0+IHtcbiAgICAgICAgICBpZiAodm90ZXMgPiB3aW5uZXJWb3Rlcykge1xuICAgICAgICAgICAgd2lubmVyID0gcG9sbC5vcHRpb25zW3BhcnNlSW50KG9wdGlvbkluZGV4KV0/LmlkIHx8IG9wdGlvbkluZGV4O1xuICAgICAgICAgICAgd2lubmVyVm90ZXMgPSB2b3RlcztcbiAgICAgICAgICAgIHdpbm5lclBlcmNlbnRhZ2UgPSBvcHRpb25QZXJjZW50YWdlc1tvcHRpb25JbmRleF0gPz8gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHRzOiBQb2xsUmVzdWx0cyA9IHtcbiAgICAgICAgd2lubmVyLFxuICAgICAgICB3aW5uZXJWb3RlcyxcbiAgICAgICAgd2lubmVyUGVyY2VudGFnZSxcbiAgICAgICAgb3B0aW9uVm90ZXMsXG4gICAgICAgIG9wdGlvblBlcmNlbnRhZ2VzLFxuICAgICAgICBhYnN0ZW50aW9uczogMCxcbiAgICAgICAgYWJzdGVudGlvblBlcmNlbnRhZ2U6IDBcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHNEYXRhOiBSZXN1bHRzRGF0YSA9IHtcbiAgICAgICAgcG9sbElkOiBwb2xsLmlkLFxuICAgICAgICB2b3RpbmdNZXRob2Q6ICdzaW5nbGUnLFxuICAgICAgICB0b3RhbFZvdGVzLFxuICAgICAgICBwYXJ0aWNpcGF0aW9uUmF0ZTogdG90YWxWb3RlcyA+IDAgPyAxMDAgOiAwLCAvLyBUaGlzIHdvdWxkIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gZWxpZ2libGUgdm90ZXJzXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIGNhbGN1bGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNhbGN1bGF0aW9uVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICBoYXNXaW5uZXI6IHdpbm5lciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIGlzVGllOiB3aW5uZXJWb3RlcyA+IDAgJiYgT2JqZWN0LnZhbHVlcyhvcHRpb25Wb3RlcykuZmlsdGVyKHYgPT4gdiA9PT0gd2lubmVyVm90ZXMpLmxlbmd0aCA+IDFcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZGV2TG9nKCdTaW5nbGUgY2hvaWNlIHJlc3VsdHMgY2FsY3VsYXRlZCcsIHtcbiAgICAgICAgcG9sbElkOiBwb2xsLmlkLFxuICAgICAgICB0b3RhbFZvdGVzLFxuICAgICAgICB3aW5uZXIsXG4gICAgICAgIHdpbm5lclZvdGVzLFxuICAgICAgICB3aW5uZXJQZXJjZW50YWdlLFxuICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0c0RhdGE7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2TG9nKCdTaW5nbGUgY2hvaWNlIHJlc3VsdHMgY2FsY3VsYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2FsY3VsYXRlIHNpbmdsZSBjaG9pY2UgcmVzdWx0czogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICBnZXRDb25maWd1cmF0aW9uKCk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1NpbmdsZSBDaG9pY2UgVm90aW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVm90ZXJzIHNlbGVjdCBleGFjdGx5IG9uZSBvcHRpb24uIFRoZSBvcHRpb24gd2l0aCB0aGUgbW9zdCB2b3RlcyB3aW5zLicsXG4gICAgICBtaW5PcHRpb25zOiAyLFxuICAgICAgbWF4T3B0aW9uczogMTAwLFxuICAgICAgYWxsb3dBYnN0ZW50aW9uOiBmYWxzZSxcbiAgICAgIHJlcXVpcmVzUmFua2luZzogZmFsc2UsXG4gICAgICBhbGxvd3NNdWx0aXBsZVNlbGVjdGlvbnM6IGZhbHNlLFxuICAgICAgcmVzdWx0VHlwZTogJ3dpbm5lcicsXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAnU2ltcGxlIGFuZCBpbnR1aXRpdmUnLFxuICAgICAgICAnRmFzdCB0byBjb3VudCcsXG4gICAgICAgICdDbGVhciB3aW5uZXIgZGV0ZXJtaW5hdGlvbicsXG4gICAgICAgICdTdWl0YWJsZSBmb3IgYmluYXJ5IGRlY2lzaW9ucydcbiAgICAgIF0sXG4gICAgICBsaW1pdGF0aW9uczogW1xuICAgICAgICAnTWF5IG5vdCByZWZsZWN0IHRydWUgcHJlZmVyZW5jZXMnLFxuICAgICAgICAnQ2FuIGxlYWQgdG8gdm90ZSBzcGxpdHRpbmcnLFxuICAgICAgICAnTm8gY29uc2lkZXJhdGlvbiBvZiBzZWNvbmQgY2hvaWNlcydcbiAgICAgIF1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlVm90ZVRvRGF0YWJhc2Uodm90ZURhdGE6IHtcbiAgICBwb2xsSWQ6IHN0cmluZztcbiAgICB2b3RlSWQ6IHN0cmluZztcbiAgICB1c2VySWQ/OiBzdHJpbmc7XG4gICAgdm90ZURhdGE6IGFueTtcbiAgICBhdWRpdFJlY2VpcHQ6IHN0cmluZztcbiAgICBwcml2YWN5TGV2ZWw/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW1wb3J0IHRoZSBWb3RlRW5naW5lIHRvIHVzZSBpdHMgc2F2ZVZvdGUgbWV0aG9kXG4gICAgICBjb25zdCB7IFZvdGVFbmdpbmUgfSA9IGF3YWl0IGltcG9ydCgnLi4vZW5naW5lJyk7XG4gICAgICBjb25zdCBlbmdpbmUgPSBuZXcgVm90ZUVuZ2luZSgpO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGVuZ2luZSdzIHNhdmVWb3RlIG1ldGhvZCB0byBwZXJzaXN0IHRoZSB2b3RlXG4gICAgICBhd2FpdCBlbmdpbmUuc2F2ZVZvdGUodm90ZURhdGEudm90ZURhdGEsIHtcbiAgICAgICAgcG9sbElkOiB2b3RlRGF0YS5wb2xsSWQsXG4gICAgICAgIHZvdGVJZDogdm90ZURhdGEudm90ZUlkLFxuICAgICAgICB1c2VySWQ6IHZvdGVEYXRhLnVzZXJJZCxcbiAgICAgICAgYXVkaXRSZWNlaXB0OiB2b3RlRGF0YS5hdWRpdFJlY2VpcHQsXG4gICAgICAgIHByaXZhY3lMZXZlbDogdm90ZURhdGEucHJpdmFjeUxldmVsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZGV2TG9nKCdWb3RlIHNhdmVkIHRvIGRhdGFiYXNlIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkOiB2b3RlRGF0YS5wb2xsSWQsXG4gICAgICAgIHZvdGVJZDogdm90ZURhdGEudm90ZUlkLFxuICAgICAgICB1c2VySWQ6IHZvdGVEYXRhLnVzZXJJZFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnRmFpbGVkIHRvIHNhdmUgdm90ZSB0byBkYXRhYmFzZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIHNhdmUgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJTaW5nbGVDaG9pY2VTdHJhdGVneSIsImdldFZvdGluZ01ldGhvZCIsInZhbGlkYXRlVm90ZSIsInJlcXVlc3QiLCJwb2xsIiwidm90ZURhdGEiLCJjaG9pY2UiLCJ1bmRlZmluZWQiLCJ2YWxpZCIsImVycm9ycyIsInJlcXVpcmVzQXV0aGVudGljYXRpb24iLCJyZXF1aXJlc1Rva2VucyIsIk51bWJlciIsImlzSW50ZWdlciIsIm9wdGlvbnMiLCJsZW5ndGgiLCJhbGxvd011bHRpcGxlVm90ZXMiLCJ1c2VySWQiLCJkZXZMb2ciLCJwb2xsSWQiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsInByb2Nlc3NWb3RlIiwicHJpdmFjeUxldmVsIiwidm90ZUlkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImF1ZGl0UmVjZWlwdCIsInNhdmVWb3RlVG9EYXRhYmFzZSIsInN1Y2Nlc3MiLCJyZXNwb25zZVRpbWUiLCJtZXRhZGF0YSIsInZvdGluZ01ldGhvZCIsIm9wdGlvblRleHQiLCJjYWxjdWxhdGVSZXN1bHRzIiwidm90ZXMiLCJzdGFydFRpbWUiLCJvcHRpb25Wb3RlcyIsIm9wdGlvblBlcmNlbnRhZ2VzIiwiZm9yRWFjaCIsIl8iLCJpbmRleCIsInRvdGFsVm90ZXMiLCJ2b3RlIiwiY2hvaWNlS2V5IiwiT2JqZWN0Iiwia2V5cyIsIm9wdGlvbkluZGV4Iiwid2lubmVyIiwid2lubmVyVm90ZXMiLCJ3aW5uZXJQZXJjZW50YWdlIiwiZW50cmllcyIsInBhcnNlSW50IiwiaWQiLCJyZXN1bHRzIiwiYWJzdGVudGlvbnMiLCJhYnN0ZW50aW9uUGVyY2VudGFnZSIsInJlc3VsdHNEYXRhIiwicGFydGljaXBhdGlvblJhdGUiLCJjYWxjdWxhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImNhbGN1bGF0aW9uVGltZSIsImhhc1dpbm5lciIsImlzVGllIiwidmFsdWVzIiwiZmlsdGVyIiwidiIsImdldENvbmZpZ3VyYXRpb24iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJtaW5PcHRpb25zIiwibWF4T3B0aW9ucyIsImFsbG93QWJzdGVudGlvbiIsInJlcXVpcmVzUmFua2luZyIsImFsbG93c011bHRpcGxlU2VsZWN0aW9ucyIsInJlc3VsdFR5cGUiLCJmZWF0dXJlcyIsImxpbWl0YXRpb25zIiwiVm90ZUVuZ2luZSIsImVuZ2luZSIsInNhdmVWb3RlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQzs7OzsrQkFpQllBOzs7ZUFBQUE7Ozt3QkFmVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZWhCLE1BQU1BO0lBRVhDLGtCQUFnQztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxhQUFhQyxPQUFvQixFQUFFQyxJQUFjLEVBQTJCO1FBQ2hGLElBQUk7WUFDRixNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtZQUVyQiw4QkFBOEI7WUFDOUIsSUFBSUUsU0FBU0MsTUFBTSxLQUFLQyxhQUFhRixTQUFTQyxNQUFNLEtBQUssTUFBTTtnQkFDN0QsT0FBTztvQkFDTEUsT0FBTztvQkFDUEMsUUFBUTt3QkFBQztxQkFBOEM7b0JBQ3ZEQyx3QkFBd0I7b0JBQ3hCQyxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSSxPQUFPTixTQUFTQyxNQUFNLEtBQUssWUFBWSxDQUFDTSxPQUFPQyxTQUFTLENBQUNSLFNBQVNDLE1BQU0sR0FBRztnQkFDN0UsT0FBTztvQkFDTEUsT0FBTztvQkFDUEMsUUFBUTt3QkFBQztxQkFBaUM7b0JBQzFDQyx3QkFBd0I7b0JBQ3hCQyxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSx3Q0FBd0M7WUFDeEMsSUFBSU4sU0FBU0MsTUFBTSxHQUFHLEtBQUtELFNBQVNDLE1BQU0sSUFBSUYsS0FBS1UsT0FBTyxDQUFDQyxNQUFNLEVBQUU7Z0JBQ2pFLE9BQU87b0JBQ0xQLE9BQU87b0JBQ1BDLFFBQVE7d0JBQUM7cUJBQTBCO29CQUNuQ0Msd0JBQXdCO29CQUN4QkMsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsbUVBQW1FO1lBQ25FLElBQUksQ0FBQ1AsS0FBS1ksa0JBQWtCLElBQUliLFFBQVFjLE1BQU0sRUFBRTtZQUM5QywrRUFBK0U7WUFDL0UsNkRBQTZEO1lBQy9EO1lBRUFDLElBQUFBLGNBQU0sRUFBQyw2Q0FBNkM7Z0JBQ2xEQyxRQUFRaEIsUUFBUWdCLE1BQU07Z0JBQ3RCYixRQUFRRCxTQUFTQyxNQUFNO2dCQUN2QlcsUUFBUWQsUUFBUWMsTUFBTTtZQUN4QjtZQUVBLE9BQU87Z0JBQ0xULE9BQU87Z0JBQ1BFLHdCQUF3QjtnQkFDeEJDLGdCQUFnQjtZQUNsQjtRQUVGLEVBQUUsT0FBT1MsT0FBTztZQUNkRixJQUFBQSxjQUFNLEVBQUMsd0NBQXdDRTtZQUMvQyxPQUFPO2dCQUNMWixPQUFPO2dCQUNQQyxRQUFRO29CQUFDVyxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRztpQkFBb0I7Z0JBQ3RFWix3QkFBd0I7Z0JBQ3hCQyxnQkFBZ0I7WUFDbEI7UUFDRjtJQUNGO0lBRUEsTUFBTVksWUFBWXBCLE9BQW9CLEVBQUVDLElBQWMsRUFBeUI7UUFDN0UsSUFBSTtZQUNGLE1BQU0sRUFBRUMsUUFBUSxFQUFFWSxNQUFNLEVBQUVFLE1BQU0sRUFBRUssWUFBWSxFQUFFLEdBQUdyQjtZQUVuRCxtQkFBbUI7WUFDbkIsTUFBTXNCLFNBQVMsQ0FBQyxLQUFLLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVDLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUU5RSx1QkFBdUI7WUFDdkIsTUFBTUMsZUFBZSxDQUFDLFFBQVEsRUFBRVAsT0FBTyxDQUFDLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDO1lBRXRELGlDQUFpQztZQUNqQyxNQUFNLElBQUksQ0FBQ00sa0JBQWtCLENBQUM7Z0JBQzVCZDtnQkFDQU07Z0JBQ0FSO2dCQUNBWjtnQkFDQTJCO2dCQUNBUjtZQUNGO1lBRUFOLElBQUFBLGNBQU0sRUFBQyw2Q0FBNkM7Z0JBQ2xEQztnQkFDQU07Z0JBQ0FuQixRQUFRRCxTQUFTQyxNQUFNO2dCQUN2Qlc7Z0JBQ0FlO1lBQ0Y7WUFFQSxPQUFPO2dCQUNMRSxTQUFTO2dCQUNUWixTQUFTO2dCQUNUSDtnQkFDQU07Z0JBQ0FPO2dCQUNBRyxjQUFjO2dCQUNkQyxVQUFVO29CQUNSQyxjQUFjO29CQUNkL0IsUUFBUUQsU0FBU0MsTUFBTTtvQkFDdkJnQyxZQUFZbEMsS0FBS1UsT0FBTyxDQUFDVCxTQUFTQyxNQUFNLElBQUksRUFBRTtnQkFDaEQ7Z0JBQ0FrQjtZQUNGO1FBRUYsRUFBRSxPQUFPSixPQUFPO1lBQ2RGLElBQUFBLGNBQU0sRUFBQyx3Q0FBd0NFO1lBQy9DLE9BQU87Z0JBQ0xjLFNBQVM7Z0JBQ1RaLFNBQVNGLGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHO2dCQUNsREgsUUFBUWhCLFFBQVFnQixNQUFNO2dCQUN0QmdCLGNBQWM7Z0JBQ2RDLFVBQVU7b0JBQ1JDLGNBQWM7b0JBQ2RqQixPQUFPQSxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRztnQkFDbEQ7Z0JBQ0FFLGNBQWNyQixRQUFRcUIsWUFBWTtZQUNwQztRQUNGO0lBQ0Y7SUFFQSxNQUFNZSxpQkFBaUJuQyxJQUFjLEVBQUVvQyxLQUFpQixFQUF3QjtRQUM5RSxJQUFJO1lBQ0YsTUFBTUMsWUFBWWYsS0FBS0MsR0FBRztZQUUxQiw4QkFBOEI7WUFDOUIsTUFBTWUsY0FBc0MsQ0FBQztZQUM3QyxNQUFNQyxvQkFBNEMsQ0FBQztZQUVuRCx5QkFBeUI7WUFDekJ2QyxLQUFLVSxPQUFPLENBQUM4QixPQUFPLENBQUMsQ0FBQ0MsR0FBR0M7Z0JBQ3ZCSixXQUFXLENBQUNJLE1BQU1oQixRQUFRLEdBQUcsR0FBRztnQkFDaENhLGlCQUFpQixDQUFDRyxNQUFNaEIsUUFBUSxHQUFHLEdBQUc7WUFDeEM7WUFFQSxjQUFjO1lBQ2QsSUFBSWlCLGFBQWE7WUFDakJQLE1BQU1JLE9BQU8sQ0FBQ0ksQ0FBQUE7Z0JBQ1osSUFBSUEsS0FBSzFDLE1BQU0sS0FBS0MsYUFBYXlDLEtBQUsxQyxNQUFNLElBQUksS0FBSzBDLEtBQUsxQyxNQUFNLEdBQUdGLEtBQUtVLE9BQU8sQ0FBQ0MsTUFBTSxFQUFFO29CQUN0RixNQUFNa0MsWUFBWUQsS0FBSzFDLE1BQU0sQ0FBQ3dCLFFBQVE7b0JBQ3RDLElBQUlZLFdBQVcsQ0FBQ08sVUFBVSxLQUFLMUMsV0FBVzt3QkFDeENtQyxXQUFXLENBQUNPLFVBQVU7d0JBQ3RCRjtvQkFDRjtnQkFDRjtZQUNGO1lBRUEsd0JBQXdCO1lBQ3hCLElBQUlBLGFBQWEsR0FBRztnQkFDbEJHLE9BQU9DLElBQUksQ0FBQ1QsYUFBYUUsT0FBTyxDQUFDUSxDQUFBQTtvQkFDL0IsTUFBTVosUUFBUUUsV0FBVyxDQUFDVSxZQUFZO29CQUN0QyxJQUFJWixVQUFVakMsV0FBVzt3QkFDdkJvQyxpQkFBaUIsQ0FBQ1MsWUFBWSxHQUFHLEFBQUNaLFFBQVFPLGFBQWM7b0JBQzFEO2dCQUNGO1lBQ0Y7WUFFQSxjQUFjO1lBQ2QsSUFBSU07WUFDSixJQUFJQyxjQUFjO1lBQ2xCLElBQUlDLG1CQUFtQjtZQUV2QixJQUFJUixhQUFhLEdBQUc7Z0JBQ2xCRyxPQUFPTSxPQUFPLENBQUNkLGFBQWFFLE9BQU8sQ0FBQyxDQUFDLENBQUNRLGFBQWFaLE1BQU07b0JBQ3ZELElBQUlBLFFBQVFjLGFBQWE7d0JBQ3ZCRCxTQUFTakQsS0FBS1UsT0FBTyxDQUFDMkMsU0FBU0wsYUFBYSxFQUFFTSxNQUFNTjt3QkFDcERFLGNBQWNkO3dCQUNkZSxtQkFBbUJaLGlCQUFpQixDQUFDUyxZQUFZLElBQUk7b0JBQ3ZEO2dCQUNGO1lBQ0Y7WUFFQSxNQUFNTyxVQUF1QjtnQkFDM0JOO2dCQUNBQztnQkFDQUM7Z0JBQ0FiO2dCQUNBQztnQkFDQWlCLGFBQWE7Z0JBQ2JDLHNCQUFzQjtZQUN4QjtZQUVBLE1BQU1DLGNBQTJCO2dCQUMvQjNDLFFBQVFmLEtBQUtzRCxFQUFFO2dCQUNmckIsY0FBYztnQkFDZFU7Z0JBQ0FnQixtQkFBbUJoQixhQUFhLElBQUksTUFBTTtnQkFDMUNZO2dCQUNBSyxjQUFjLElBQUl0QyxPQUFPdUMsV0FBVztnQkFDcEM3QixVQUFVO29CQUNSOEIsaUJBQWlCeEMsS0FBS0MsR0FBRyxLQUFLYztvQkFDOUIwQixXQUFXZCxXQUFXOUM7b0JBQ3RCNkQsT0FBT2QsY0FBYyxLQUFLSixPQUFPbUIsTUFBTSxDQUFDM0IsYUFBYTRCLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsTUFBTWpCLGFBQWF2QyxNQUFNLEdBQUc7Z0JBQy9GO1lBQ0Y7WUFFQUcsSUFBQUEsY0FBTSxFQUFDLG9DQUFvQztnQkFDekNDLFFBQVFmLEtBQUtzRCxFQUFFO2dCQUNmWDtnQkFDQU07Z0JBQ0FDO2dCQUNBQztnQkFDQVcsaUJBQWlCeEMsS0FBS0MsR0FBRyxLQUFLYztZQUNoQztZQUVBLE9BQU9xQjtRQUVULEVBQUUsT0FBTzFDLE9BQU87WUFDZEYsSUFBQUEsY0FBTSxFQUFDLDRDQUE0Q0U7WUFDbkQsTUFBTSxJQUFJQyxNQUFNLENBQUMsMkNBQTJDLEVBQUVELGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHLGdCQUFnQixDQUFDO1FBQzFIO0lBQ0Y7SUFFQWtELG1CQUE0QztRQUMxQyxPQUFPO1lBQ0xDLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsaUJBQWlCO1lBQ2pCQyxpQkFBaUI7WUFDakJDLDBCQUEwQjtZQUMxQkMsWUFBWTtZQUNaQyxVQUFVO2dCQUNSO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsYUFBYTtnQkFDWDtnQkFDQTtnQkFDQTthQUNEO1FBQ0g7SUFDRjtJQUVBLE1BQWNqRCxtQkFBbUI1QixRQU9oQyxFQUFpQjtRQUNoQixJQUFJO1lBQ0YsbURBQW1EO1lBQ25ELE1BQU0sRUFBRThFLFVBQVUsRUFBRSxHQUFHLE1BQU0sbUVBQUEsUUFBTztZQUNwQyxNQUFNQyxTQUFTLElBQUlEO1lBRW5CLHVEQUF1RDtZQUN2RCxNQUFNQyxPQUFPQyxRQUFRLENBQUNoRixTQUFTQSxRQUFRLEVBQUU7Z0JBQ3ZDYyxRQUFRZCxTQUFTYyxNQUFNO2dCQUN2Qk0sUUFBUXBCLFNBQVNvQixNQUFNO2dCQUN2QlIsUUFBUVosU0FBU1ksTUFBTTtnQkFDdkJlLGNBQWMzQixTQUFTMkIsWUFBWTtnQkFDbkNSLGNBQWNuQixTQUFTbUIsWUFBWTtZQUNyQztZQUVBTixJQUFBQSxjQUFNLEVBQUMsdUNBQXVDO2dCQUM1Q0MsUUFBUWQsU0FBU2MsTUFBTTtnQkFDdkJNLFFBQVFwQixTQUFTb0IsTUFBTTtnQkFDdkJSLFFBQVFaLFNBQVNZLE1BQU07WUFDekI7UUFDRixFQUFFLE9BQU9HLE9BQU87WUFDZEYsSUFBQUEsY0FBTSxFQUFDLG9DQUFvQ0U7WUFDM0MsTUFBTSxJQUFJQyxNQUFNLENBQUMsc0JBQXNCLEVBQUVELGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHLGdCQUFnQixDQUFDO1FBQ3JHO0lBQ0Y7QUFDRiJ9