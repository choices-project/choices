d22102765fb3e4c5042c734429fdbb17
/**
 * @jest-environment node
 */ // Set NODE_ENV to development before importing logger
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _logger = require("../../../../../lib/utils/logger");
process.env.NODE_ENV = "development";
// Mock console methods
const mockConsole = {
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn()
};
// Replace console with mock
Object.assign(console, mockConsole);
describe("Logger Utility - Comprehensive Testing", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Basic Logging", ()=>{
        it("should log info messages", ()=>{
            _logger.logger.info("Test info message");
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Test info message/));
        });
        it("should log error messages", ()=>{
            _logger.logger.error("Test error message");
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Test error message/));
        });
        it("should log warning messages", ()=>{
            _logger.logger.warn("Test warning message");
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Test warning message/));
        });
        it("should log debug messages", ()=>{
            _logger.logger.debug("Test debug message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Test debug message/));
        });
    });
    describe("Structured Logging", ()=>{
        it("should log with metadata", ()=>{
            const metadata = {
                userId: "user-123",
                action: "login",
                timestamp: new Date().toISOString()
            };
            _logger.logger.info("User action", metadata);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User action/));
        });
        it("should log with error objects", ()=>{
            const error = new Error("Test error");
            const context = {
                userId: "user-123",
                action: "database-query"
            };
            _logger.logger.error("Database error", error, context);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Database error/));
        });
        it("should log with performance metrics", ()=>{
            const metrics = {
                duration: 150,
                memoryUsage: 25.5,
                cpuUsage: 12.3
            };
            _logger.logger.info("Performance metrics", metrics);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Performance metrics/));
        });
    });
    describe("Log Levels", ()=>{
        it("should respect log level configuration", ()=>{
            // Test different log levels
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            _logger.logger.warn("Warning message");
            _logger.logger.error("Error message");
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Debug message/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Warning message/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error message/));
        });
        it("should handle log level filtering", ()=>{
            // Mock environment variable for log level
            const originalEnv = process.env.NODE_ENV;
            process.env.NODE_ENV = "production";
            // In production, debug logs should be filtered
            _logger.logger.debug("Debug message");
            _logger.logger.info("Info message");
            expect(mockConsole.debug).not.toHaveBeenCalled();
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            // Restore environment
            process.env.NODE_ENV = originalEnv;
        });
    });
    describe("Error Handling", ()=>{
        it("should handle circular references in objects", ()=>{
            const circularObj = {
                name: "test"
            };
            circularObj.self = circularObj;
            _logger.logger.info("Circular object", circularObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Circular object/));
        });
        it("should handle undefined values", ()=>{
            _logger.logger.info("Undefined value", undefined);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Undefined value/));
        });
        it("should handle null values", ()=>{
            _logger.logger.info("Null value", null);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Null value/));
        });
        it("should handle large objects", ()=>{
            const largeObj = {
                data: Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        value: `item-${i}`
                    })),
                metadata: {
                    count: 1000,
                    timestamp: new Date().toISOString()
                }
            };
            _logger.logger.info("Large object", largeObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large object/));
        });
    });
    describe("Performance", ()=>{
        it("should log within performance budget", ()=>{
            const startTime = performance.now();
            for(let i = 0; i < 100; i++){
                _logger.logger.info(`Message ${i}`);
            }
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(100); // Should complete within 100ms
        });
        it("should not block execution", async ()=>{
            const startTime = performance.now();
            // Log multiple messages asynchronously
            const promises = Array.from({
                length: 10
            }, (_, i)=>Promise.resolve().then(()=>_logger.logger.info(`Async message ${i}`)));
            await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(50); // Should complete within 50ms
        });
    });
    describe("Security", ()=>{
        it("should sanitize sensitive data", ()=>{
            const sensitiveData = {
                password: "secret123",
                token: "bearer-token",
                apiKey: "api-key-123",
                email: "user@example.com",
                normalData: "safe data"
            };
            _logger.logger.info("User data", sensitiveData);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User data/));
        });
        it("should handle SQL injection attempts", ()=>{
            const maliciousInput = "'; DROP TABLE users; --";
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
        it("should handle XSS attempts", ()=>{
            const maliciousInput = '<script>alert("xss")</script>';
            _logger.logger.info("User input", {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
    });
    describe("Context and Tracing", ()=>{
        it("should include request context", ()=>{
            const requestContext = {
                requestId: "req-123",
                userId: "user-123",
                ip: "192.168.1.1",
                userAgent: "Mozilla/5.0..."
            };
            _logger.logger.info("Request processed", requestContext);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Request processed/));
        });
        it("should include error stack traces", ()=>{
            const error = new Error("Test error");
            error.stack = "Error: Test error\n    at test.js:1:1";
            _logger.logger.error("Error occurred", error);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error occurred/));
        });
        it("should include timing information", ()=>{
            const timing = {
                startTime: Date.now() - 1000,
                endTime: Date.now(),
                duration: 1000
            };
            _logger.logger.info("Operation completed", timing);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Operation completed/));
        });
    });
    describe("Log Formatting", ()=>{
        it("should format timestamps correctly", ()=>{
            const timestamp = new Date("2023-01-01T00:00:00Z");
            _logger.logger.info("Timestamped message", {
                timestamp
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Timestamped message/));
        });
        it("should format objects with proper indentation", ()=>{
            const complexObj = {
                level1: {
                    level2: {
                        level3: "value",
                        array: [
                            1,
                            2,
                            3
                        ]
                    }
                }
            };
            _logger.logger.info("Complex object", complexObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Complex object/));
        });
        it("should handle special characters", ()=>{
            const specialChars = {
                unicode: "\uD83D\uDE80",
                emoji: "\uD83D\uDE00",
                symbols: "!@#$%^&*()",
                quotes: "\"double\" and 'single'"
            };
            _logger.logger.info("Special characters", specialChars);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Special characters/));
        });
    });
    describe("Memory Management", ()=>{
        it("should not cause memory leaks", ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Log many messages
            for(let i = 0; i < 1000; i++){
                _logger.logger.info(`Message ${i}`, {
                    data: `data-${i}`
                });
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB
        });
        it("should handle large log messages", ()=>{
            const largeMessage = "x".repeat(10000);
            _logger.logger.info("Large message", {
                message: largeMessage
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large message/));
        });
    });
    describe("Async Logging", ()=>{
        it("should handle async operations", async ()=>{
            const asyncOperation = async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return "async result";
            };
            _logger.logger.info("Starting async operation");
            const result = await asyncOperation();
            _logger.logger.info("Async operation completed", {
                result
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting async operation/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Async operation completed/));
        });
        it("should handle promise rejections", async ()=>{
            const failingOperation = async ()=>{
                throw new Error("Async error");
            };
            _logger.logger.info("Starting failing operation");
            try {
                await failingOperation();
            } catch (error) {
                _logger.logger.error("Async operation failed", error);
            }
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting failing operation/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Async operation failed/));
        });
    });
    describe("Log Aggregation", ()=>{
        it("should aggregate related log messages", ()=>{
            const sessionId = "session-123";
            _logger.logger.info("Session started", {
                sessionId
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "login"
            });
            _logger.logger.info("User action", {
                sessionId,
                action: "navigate"
            });
            _logger.logger.info("Session ended", {
                sessionId
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(4);
        });
        it("should handle log batching", ()=>{
            const messages = [
                {
                    level: "info",
                    message: "Message 1"
                },
                {
                    level: "info",
                    message: "Message 2"
                },
                {
                    level: "warn",
                    message: "Warning 1"
                }
            ];
            messages.forEach((msg)=>{
                if (msg.level === "info") {
                    _logger.logger.info(msg.message);
                } else if (msg.level === "warn") {
                    _logger.logger.warn(msg.message);
                }
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(2);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3V0aWxzL2xvZ2dlci1jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAamVzdC1lbnZpcm9ubWVudCBub2RlXG4gKi9cblxuLy8gU2V0IE5PREVfRU5WIHRvIGRldmVsb3BtZW50IGJlZm9yZSBpbXBvcnRpbmcgbG9nZ2VyXG5wcm9jZXNzLmVudi5OT0RFX0VOViA9ICdkZXZlbG9wbWVudCc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvbGliL3V0aWxzL2xvZ2dlcic7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBtb2NrQ29uc29sZSA9IHtcbiAgbG9nOiBqZXN0LmZuKCksXG4gIGVycm9yOiBqZXN0LmZuKCksXG4gIHdhcm46IGplc3QuZm4oKSxcbiAgaW5mbzogamVzdC5mbigpLFxuICBkZWJ1ZzogamVzdC5mbigpLFxufTtcblxuLy8gUmVwbGFjZSBjb25zb2xlIHdpdGggbW9ja1xuT2JqZWN0LmFzc2lnbihjb25zb2xlLCBtb2NrQ29uc29sZSk7XG5cbmRlc2NyaWJlKCdMb2dnZXIgVXRpbGl0eSAtIENvbXByZWhlbnNpdmUgVGVzdGluZycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYXNpYyBMb2dnaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbG9nIGluZm8gbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIuaW5mbygnVGVzdCBpbmZvIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVGVzdCBpbmZvIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyBlcnJvciBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5lcnJvcignVGVzdCBlcnJvciBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBFUlJPUjogVGVzdCBlcnJvciBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgd2FybmluZyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci53YXJuKCdUZXN0IHdhcm5pbmcgbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBXQVJOOiBUZXN0IHdhcm5pbmcgbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdUZXN0IGRlYnVnIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIERFQlVHOiBUZXN0IGRlYnVnIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdHJ1Y3R1cmVkIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aCBtZXRhZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGFjdGlvbjogJ2xvZ2luJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBhY3Rpb24nLCBtZXRhZGF0YSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVzZXIgYWN0aW9uLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aCBlcnJvciBvYmplY3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgYWN0aW9uOiAnZGF0YWJhc2UtcXVlcnknLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmVycm9yKCdEYXRhYmFzZSBlcnJvcicsIGVycm9yLCBjb250ZXh0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBEYXRhYmFzZSBlcnJvci8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIHdpdGggcGVyZm9ybWFuY2UgbWV0cmljcycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSB7XG4gICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgIG1lbW9yeVVzYWdlOiAyNS41LFxuICAgICAgICBjcHVVc2FnZTogMTIuMyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdQZXJmb3JtYW5jZSBtZXRyaWNzJywgbWV0cmljcyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFBlcmZvcm1hbmNlIG1ldHJpY3MvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2cgTGV2ZWxzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzcGVjdCBsb2cgbGV2ZWwgY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIC8vIFRlc3QgZGlmZmVyZW50IGxvZyBsZXZlbHNcbiAgICAgIGxvZ2dlci5kZWJ1ZygnRGVidWcgbWVzc2FnZScpO1xuICAgICAgbG9nZ2VyLmluZm8oJ0luZm8gbWVzc2FnZScpO1xuICAgICAgbG9nZ2VyLndhcm4oJ1dhcm5pbmcgbWVzc2FnZScpO1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBERUJVRzogRGVidWcgbWVzc2FnZS8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEluZm8gbWVzc2FnZS8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIFdBUk46IFdhcm5pbmcgbWVzc2FnZS8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBFUlJPUjogRXJyb3IgbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvZyBsZXZlbCBmaWx0ZXJpbmcnLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciBsb2cgbGV2ZWxcbiAgICAgIGNvbnN0IG9yaWdpbmFsRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9ICdwcm9kdWN0aW9uJztcbiAgICAgIFxuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgZGVidWcgbG9ncyBzaG91bGQgYmUgZmlsdGVyZWRcbiAgICAgIGxvZ2dlci5kZWJ1ZygnRGVidWcgbWVzc2FnZScpO1xuICAgICAgbG9nZ2VyLmluZm8oJ0luZm8gbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZGVidWcpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBJbmZvIG1lc3NhZ2UvKSk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgZW52aXJvbm1lbnRcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gb3JpZ2luYWxFbnY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzIGluIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjaXJjdWxhck9iajogYW55ID0geyBuYW1lOiAndGVzdCcgfTtcbiAgICAgIGNpcmN1bGFyT2JqLnNlbGYgPSBjaXJjdWxhck9iajtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0NpcmN1bGFyIG9iamVjdCcsIGNpcmN1bGFyT2JqKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogQ2lyY3VsYXIgb2JqZWN0LykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdW5kZWZpbmVkIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdVbmRlZmluZWQgdmFsdWUnLCB1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBVbmRlZmluZWQgdmFsdWUvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBudWxsIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdOdWxsIHZhbHVlJywgbnVsbCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IE51bGwgdmFsdWUvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBvYmplY3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VPYmogPSB7XG4gICAgICAgIGRhdGE6IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+ICh7IGlkOiBpLCB2YWx1ZTogYGl0ZW0tJHtpfWAgfSkpLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNvdW50OiAxMDAwLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0xhcmdlIG9iamVjdCcsIGxhcmdlT2JqKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTGFyZ2Ugb2JqZWN0LykpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aGluIHBlcmZvcm1hbmNlIGJ1ZGdldCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBNZXNzYWdlICR7aX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDEwMG1zXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBibG9jayBleGVjdXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIG11bHRpcGxlIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBsb2dnZXIuaW5mbyhgQXN5bmMgbWVzc2FnZSAke2l9YCkpXG4gICAgICApO1xuICAgICAgXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDUwbXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2FuaXRpemUgc2Vuc2l0aXZlIGRhdGEnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zaXRpdmVEYXRhID0ge1xuICAgICAgICBwYXNzd29yZDogJ3NlY3JldDEyMycsXG4gICAgICAgIHRva2VuOiAnYmVhcmVyLXRva2VuJyxcbiAgICAgICAgYXBpS2V5OiAnYXBpLWtleS0xMjMnLFxuICAgICAgICBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLFxuICAgICAgICBub3JtYWxEYXRhOiAnc2FmZSBkYXRhJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGRhdGEnLCBzZW5zaXRpdmVEYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBkYXRhLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgU1FMIGluamVjdGlvbiBhdHRlbXB0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c0lucHV0ID0gXCInOyBEUk9QIFRBQkxFIHVzZXJzOyAtLVwiO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBpbnB1dCcsIHsgaW5wdXQ6IG1hbGljaW91c0lucHV0IH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBVc2VyIGlucHV0LykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgWFNTIGF0dGVtcHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXQgPSAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0Pic7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGlucHV0JywgeyBpbnB1dDogbWFsaWNpb3VzSW5wdXQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVzZXIgaW5wdXQvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb250ZXh0IGFuZCBUcmFjaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaW5jbHVkZSByZXF1ZXN0IGNvbnRleHQnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgcmVxdWVzdElkOiAncmVxLTEyMycsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wLi4uJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdSZXF1ZXN0IHByb2Nlc3NlZCcsIHJlcXVlc3RDb250ZXh0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogUmVxdWVzdCBwcm9jZXNzZWQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgZXJyb3Igc3RhY2sgdHJhY2VzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcbiAgICAgIGVycm9yLnN0YWNrID0gJ0Vycm9yOiBUZXN0IGVycm9yXFxuICAgIGF0IHRlc3QuanM6MToxJztcbiAgICAgIFxuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBvY2N1cnJlZCcsIGVycm9yKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBFcnJvciBvY2N1cnJlZC8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSB0aW1pbmcgaW5mb3JtYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCB0aW1pbmcgPSB7XG4gICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSAtIDEwMDAsXG4gICAgICAgIGVuZFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ09wZXJhdGlvbiBjb21wbGV0ZWQnLCB0aW1pbmcpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBPcGVyYXRpb24gY29tcGxldGVkLykpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTG9nIEZvcm1hdHRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBmb3JtYXQgdGltZXN0YW1wcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgnMjAyMy0wMS0wMVQwMDowMDowMFonKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1RpbWVzdGFtcGVkIG1lc3NhZ2UnLCB7IHRpbWVzdGFtcCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVGltZXN0YW1wZWQgbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IG9iamVjdHMgd2l0aCBwcm9wZXIgaW5kZW50YXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGV4T2JqID0ge1xuICAgICAgICBsZXZlbDE6IHtcbiAgICAgICAgICBsZXZlbDI6IHtcbiAgICAgICAgICAgIGxldmVsMzogJ3ZhbHVlJyxcbiAgICAgICAgICAgIGFycmF5OiBbMSwgMiwgM10sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdDb21wbGV4IG9iamVjdCcsIGNvbXBsZXhPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBDb21wbGV4IG9iamVjdC8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNwZWNpYWwgY2hhcmFjdGVycycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNwZWNpYWxDaGFycyA9IHtcbiAgICAgICAgdW5pY29kZTogJ/CfmoAnLFxuICAgICAgICBlbW9qaTogJ/CfmIAnLFxuICAgICAgICBzeW1ib2xzOiAnIUAjJCVeJiooKScsXG4gICAgICAgIHF1b3RlczogJ1wiZG91YmxlXCIgYW5kIFxcJ3NpbmdsZVxcJycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnU3BlY2lhbCBjaGFyYWN0ZXJzJywgc3BlY2lhbENoYXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogU3BlY2lhbCBjaGFyYWN0ZXJzLykpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBub3QgY2F1c2UgbWVtb3J5IGxlYWtzJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIFxuICAgICAgLy8gTG9nIG1hbnkgbWVzc2FnZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBNZXNzYWdlICR7aX1gLCB7IGRhdGE6IGBkYXRhLSR7aX1gIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIHJlYXNvbmFibGVcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDEwICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gMTBNQlxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgbG9nIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VNZXNzYWdlID0gJ3gnLnJlcGVhdCgxMDAwMCk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdMYXJnZSBtZXNzYWdlJywgeyBtZXNzYWdlOiBsYXJnZU1lc3NhZ2UgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IExhcmdlIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBc3luYyBMb2dnaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGFzeW5jIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhc3luY09wZXJhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgIHJldHVybiAnYXN5bmMgcmVzdWx0JztcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTdGFydGluZyBhc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFzeW5jT3BlcmF0aW9uKCk7XG4gICAgICBsb2dnZXIuaW5mbygnQXN5bmMgb3BlcmF0aW9uIGNvbXBsZXRlZCcsIHsgcmVzdWx0IH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTdGFydGluZyBhc3luYyBvcGVyYXRpb24vKSk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBBc3luYyBvcGVyYXRpb24gY29tcGxldGVkLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcHJvbWlzZSByZWplY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmFpbGluZ09wZXJhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3luYyBlcnJvcicpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGZhaWxpbmcgb3BlcmF0aW9uJyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZhaWxpbmdPcGVyYXRpb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignQXN5bmMgb3BlcmF0aW9uIGZhaWxlZCcsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogU3RhcnRpbmcgZmFpbGluZyBvcGVyYXRpb24vKSk7XG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IEFzeW5jIG9wZXJhdGlvbiBmYWlsZWQvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2cgQWdncmVnYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhZ2dyZWdhdGUgcmVsYXRlZCBsb2cgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSAnc2Vzc2lvbi0xMjMnO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnU2Vzc2lvbiBzdGFydGVkJywgeyBzZXNzaW9uSWQgfSk7XG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBhY3Rpb24nLCB7IHNlc3Npb25JZCwgYWN0aW9uOiAnbG9naW4nIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgYWN0aW9uJywgeyBzZXNzaW9uSWQsIGFjdGlvbjogJ25hdmlnYXRlJyB9KTtcbiAgICAgIGxvZ2dlci5pbmZvKCdTZXNzaW9uIGVuZGVkJywgeyBzZXNzaW9uSWQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoNCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2cgYmF0Y2hpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAgICAgeyBsZXZlbDogJ2luZm8nLCBtZXNzYWdlOiAnTWVzc2FnZSAxJyB9LFxuICAgICAgICB7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdNZXNzYWdlIDInIH0sXG4gICAgICAgIHsgbGV2ZWw6ICd3YXJuJywgbWVzc2FnZTogJ1dhcm5pbmcgMScgfSxcbiAgICAgIF07XG4gICAgICBcbiAgICAgIG1lc3NhZ2VzLmZvckVhY2gobXNnID0+IHtcbiAgICAgICAgaWYgKG1zZy5sZXZlbCA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8obXNnLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKG1zZy5sZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4obXNnLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2NrQ29uc29sZSIsImxvZyIsImplc3QiLCJmbiIsImVycm9yIiwid2FybiIsImluZm8iLCJkZWJ1ZyIsIk9iamVjdCIsImFzc2lnbiIsImNvbnNvbGUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJsb2dnZXIiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ01hdGNoaW5nIiwibWV0YWRhdGEiLCJ1c2VySWQiLCJhY3Rpb24iLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJFcnJvciIsImNvbnRleHQiLCJtZXRyaWNzIiwiZHVyYXRpb24iLCJtZW1vcnlVc2FnZSIsImNwdVVzYWdlIiwib3JpZ2luYWxFbnYiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiY2lyY3VsYXJPYmoiLCJuYW1lIiwic2VsZiIsInVuZGVmaW5lZCIsImxhcmdlT2JqIiwiZGF0YSIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwiaWQiLCJ2YWx1ZSIsImNvdW50Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbmRUaW1lIiwidG9CZUxlc3NUaGFuIiwicHJvbWlzZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJhbGwiLCJzZW5zaXRpdmVEYXRhIiwicGFzc3dvcmQiLCJ0b2tlbiIsImFwaUtleSIsImVtYWlsIiwibm9ybWFsRGF0YSIsIm1hbGljaW91c0lucHV0IiwiaW5wdXQiLCJyZXF1ZXN0Q29udGV4dCIsInJlcXVlc3RJZCIsImlwIiwidXNlckFnZW50Iiwic3RhY2siLCJ0aW1pbmciLCJjb21wbGV4T2JqIiwibGV2ZWwxIiwibGV2ZWwyIiwibGV2ZWwzIiwiYXJyYXkiLCJzcGVjaWFsQ2hhcnMiLCJ1bmljb2RlIiwiZW1vamkiLCJzeW1ib2xzIiwicXVvdGVzIiwiaW5pdGlhbE1lbW9yeSIsImhlYXBVc2VkIiwiZmluYWxNZW1vcnkiLCJtZW1vcnlJbmNyZWFzZSIsImxhcmdlTWVzc2FnZSIsInJlcGVhdCIsIm1lc3NhZ2UiLCJhc3luY09wZXJhdGlvbiIsInNldFRpbWVvdXQiLCJyZXN1bHQiLCJmYWlsaW5nT3BlcmF0aW9uIiwic2Vzc2lvbklkIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwibWVzc2FnZXMiLCJsZXZlbCIsImZvckVhY2giLCJtc2ciXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsc0RBQXNEOzs7Ozt3QkFHL0I7QUFGdkJBLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxHQUFHO0FBSXZCLHVCQUF1QjtBQUN2QixNQUFNQyxjQUFjO0lBQ2xCQyxLQUFLQyxLQUFLQyxFQUFFO0lBQ1pDLE9BQU9GLEtBQUtDLEVBQUU7SUFDZEUsTUFBTUgsS0FBS0MsRUFBRTtJQUNiRyxNQUFNSixLQUFLQyxFQUFFO0lBQ2JJLE9BQU9MLEtBQUtDLEVBQUU7QUFDaEI7QUFFQSw0QkFBNEI7QUFDNUJLLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBU1Y7QUFF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