aba2ed8711492909b5f07a99e6b8e85f
/**
 * Store Type Safety Tests
 * 
 * Validates that all Zustand stores have proper type definitions,
 * index signatures, and error handling patterns.
 * 
 * Created: January 27, 2025
 * Status: âœ… ACTIVE
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _fs = /*#__PURE__*/ _interop_require_wildcard(require("fs"));
const _glob = /*#__PURE__*/ _interop_require_wildcard(require("glob"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
(0, _globals.describe)("Store Type Safety", ()=>{
    (0, _globals.it)("all stores should have proper index signatures", ()=>{
        const storeFiles = _glob.sync("web/lib/stores/*.ts", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicStores = [];
        storeFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for interfaces that need index signatures
            const interfaceMatches = content.match(/interface\s+(\w+)\s*\{[^}]*\}/g);
            if (interfaceMatches) {
                interfaceMatches.forEach((match)=>{
                    const interfaceName = match.match(/interface\s+(\w+)/)?.[1];
                    if (interfaceName && !match.includes("[key: string]: unknown")) {
                        // Check if this interface is used in store contexts
                        if (content.includes("use" + interfaceName) || content.includes(interfaceName + "Store")) {
                            problematicStores.push(`${file}: interface '${interfaceName}' needs index signature`);
                        }
                    }
                });
            }
        });
        if (problematicStores.length > 0) {
            console.log("Stores needing index signatures:", problematicStores);
        }
        (0, _globals.expect)(problematicStores).toHaveLength(0);
    });
    (0, _globals.it)("store actions should be properly typed", ()=>{
        const storeFiles = _glob.sync("web/lib/stores/*.ts", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicStores = [];
        storeFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for action functions that should be properly typed
            const actionMatches = content.match(/(\w+):\s*\([^)]*\)\s*=>/g);
            if (actionMatches) {
                actionMatches.forEach((match)=>{
                    const actionName = match.match(/(\w+):/)?.[1];
                    if (actionName && !match.includes(":")) {
                        problematicStores.push(`${file}: action '${actionName}' needs proper typing`);
                    }
                });
            }
        });
        if (problematicStores.length > 0) {
            console.log("Stores with untyped actions:", problematicStores);
        }
        (0, _globals.expect)(problematicStores).toHaveLength(0);
    });
    (0, _globals.it)("store subscriptions should be properly implemented", ()=>{
        const storeFiles = _glob.sync("web/lib/stores/*.ts", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicStores = [];
        storeFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for subscription methods
            if (content.includes("subscribe")) {
                // Should have proper subscription implementation
                if (!content.includes("useStore.subscribe")) {
                    problematicStores.push(`${file}: subscription methods should use useStore.subscribe`);
                }
            }
        });
        if (problematicStores.length > 0) {
            console.log("Stores with improper subscriptions:", problematicStores);
        }
        (0, _globals.expect)(problematicStores).toHaveLength(0);
    });
    (0, _globals.it)("store error handling should be comprehensive", ()=>{
        const storeFiles = _glob.sync("web/lib/stores/*.ts", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicStores = [];
        storeFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for async actions that should have error handling
            const asyncActions = content.match(/(\w+):\s*async\s*\([^)]*\)\s*=>/g);
            if (asyncActions) {
                asyncActions.forEach((match)=>{
                    const actionName = match.match(/(\w+):/)?.[1];
                    if (actionName && !content.includes(`try {`) && !content.includes(`catch`)) {
                        problematicStores.push(`${file}: async action '${actionName}' needs error handling`);
                    }
                });
            }
        });
        if (problematicStores.length > 0) {
            console.log("Stores with missing error handling:", problematicStores);
        }
        (0, _globals.expect)(problematicStores).toHaveLength(0);
    });
    (0, _globals.it)("store imports should use centralized pattern", ()=>{
        const componentFiles = _glob.sync("web/**/*.{ts,tsx}", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**",
                "**/lib/stores/**"
            ]
        });
        const problematicFiles = [];
        componentFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for direct Zustand imports
            if (content.includes("from 'zustand'") || content.includes('from "zustand"')) {
                problematicFiles.push(`${file}: should use centralized store imports`);
            }
            // Check for direct store imports
            if (content.includes("from '../stores/") || content.includes('from "../stores/')) {
                problematicFiles.push(`${file}: should use @/lib/stores imports`);
            }
        });
        if (problematicFiles.length > 0) {
            console.log("Files with improper store imports:", problematicFiles);
        }
        (0, _globals.expect)(problematicFiles).toHaveLength(0);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvc3RvcmVzL3N0b3JlLXR5cGUtc2FmZXR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdG9yZSBUeXBlIFNhZmV0eSBUZXN0c1xuICogXG4gKiBWYWxpZGF0ZXMgdGhhdCBhbGwgWnVzdGFuZCBzdG9yZXMgaGF2ZSBwcm9wZXIgdHlwZSBkZWZpbml0aW9ucyxcbiAqIGluZGV4IHNpZ25hdHVyZXMsIGFuZCBlcnJvciBoYW5kbGluZyBwYXR0ZXJucy5cbiAqIFxuICogQ3JlYXRlZDogSmFudWFyeSAyNywgMjAyNVxuICogU3RhdHVzOiDinIUgQUNUSVZFXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGdsb2IgZnJvbSAnZ2xvYic7XG5cbmRlc2NyaWJlKCdTdG9yZSBUeXBlIFNhZmV0eScsICgpID0+IHtcbiAgaXQoJ2FsbCBzdG9yZXMgc2hvdWxkIGhhdmUgcHJvcGVyIGluZGV4IHNpZ25hdHVyZXMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmVGaWxlcyA9IGdsb2Iuc3luYygnd2ViL2xpYi9zdG9yZXMvKi50cycsIHsgXG4gICAgICBpZ25vcmU6IFsnKiovKi50ZXN0LionLCAnKiovKi5zcGVjLionLCAnKiovbm9kZV9tb2R1bGVzLyoqJ10gXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcHJvYmxlbWF0aWNTdG9yZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgc3RvcmVGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaW50ZXJmYWNlcyB0aGF0IG5lZWQgaW5kZXggc2lnbmF0dXJlc1xuICAgICAgY29uc3QgaW50ZXJmYWNlTWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goL2ludGVyZmFjZVxccysoXFx3KylcXHMqXFx7W159XSpcXH0vZyk7XG4gICAgICBpZiAoaW50ZXJmYWNlTWF0Y2hlcykge1xuICAgICAgICBpbnRlcmZhY2VNYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVyZmFjZU5hbWUgPSBtYXRjaC5tYXRjaCgvaW50ZXJmYWNlXFxzKyhcXHcrKS8pPy5bMV07XG4gICAgICAgICAgaWYgKGludGVyZmFjZU5hbWUgJiYgIW1hdGNoLmluY2x1ZGVzKCdba2V5OiBzdHJpbmddOiB1bmtub3duJykpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaW50ZXJmYWNlIGlzIHVzZWQgaW4gc3RvcmUgY29udGV4dHNcbiAgICAgICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCd1c2UnICsgaW50ZXJmYWNlTmFtZSkgfHwgY29udGVudC5pbmNsdWRlcyhpbnRlcmZhY2VOYW1lICsgJ1N0b3JlJykpIHtcbiAgICAgICAgICAgICAgcHJvYmxlbWF0aWNTdG9yZXMucHVzaChgJHtmaWxlfTogaW50ZXJmYWNlICcke2ludGVyZmFjZU5hbWV9JyBuZWVkcyBpbmRleCBzaWduYXR1cmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChwcm9ibGVtYXRpY1N0b3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RvcmVzIG5lZWRpbmcgaW5kZXggc2lnbmF0dXJlczonLCBwcm9ibGVtYXRpY1N0b3Jlcyk7XG4gICAgfVxuICAgIFxuICAgIGV4cGVjdChwcm9ibGVtYXRpY1N0b3JlcykudG9IYXZlTGVuZ3RoKDApO1xuICB9KTtcblxuICBpdCgnc3RvcmUgYWN0aW9ucyBzaG91bGQgYmUgcHJvcGVybHkgdHlwZWQnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmVGaWxlcyA9IGdsb2Iuc3luYygnd2ViL2xpYi9zdG9yZXMvKi50cycsIHsgXG4gICAgICBpZ25vcmU6IFsnKiovKi50ZXN0LionLCAnKiovKi5zcGVjLionLCAnKiovbm9kZV9tb2R1bGVzLyoqJ10gXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcHJvYmxlbWF0aWNTdG9yZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgc3RvcmVGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgYWN0aW9uIGZ1bmN0aW9ucyB0aGF0IHNob3VsZCBiZSBwcm9wZXJseSB0eXBlZFxuICAgICAgY29uc3QgYWN0aW9uTWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goLyhcXHcrKTpcXHMqXFwoW14pXSpcXClcXHMqPT4vZyk7XG4gICAgICBpZiAoYWN0aW9uTWF0Y2hlcykge1xuICAgICAgICBhY3Rpb25NYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSBtYXRjaC5tYXRjaCgvKFxcdyspOi8pPy5bMV07XG4gICAgICAgICAgaWYgKGFjdGlvbk5hbWUgJiYgIW1hdGNoLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIHByb2JsZW1hdGljU3RvcmVzLnB1c2goYCR7ZmlsZX06IGFjdGlvbiAnJHthY3Rpb25OYW1lfScgbmVlZHMgcHJvcGVyIHR5cGluZ2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHByb2JsZW1hdGljU3RvcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdG9yZXMgd2l0aCB1bnR5cGVkIGFjdGlvbnM6JywgcHJvYmxlbWF0aWNTdG9yZXMpO1xuICAgIH1cbiAgICBcbiAgICBleHBlY3QocHJvYmxlbWF0aWNTdG9yZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgfSk7XG5cbiAgaXQoJ3N0b3JlIHN1YnNjcmlwdGlvbnMgc2hvdWxkIGJlIHByb3Blcmx5IGltcGxlbWVudGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlRmlsZXMgPSBnbG9iLnN5bmMoJ3dlYi9saWIvc3RvcmVzLyoudHMnLCB7IFxuICAgICAgaWdub3JlOiBbJyoqLyoudGVzdC4qJywgJyoqLyouc3BlYy4qJywgJyoqL25vZGVfbW9kdWxlcy8qKiddIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHByb2JsZW1hdGljU3RvcmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIHN0b3JlRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHN1YnNjcmlwdGlvbiBtZXRob2RzXG4gICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnc3Vic2NyaWJlJykpIHtcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgcHJvcGVyIHN1YnNjcmlwdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAoIWNvbnRlbnQuaW5jbHVkZXMoJ3VzZVN0b3JlLnN1YnNjcmliZScpKSB7XG4gICAgICAgICAgcHJvYmxlbWF0aWNTdG9yZXMucHVzaChgJHtmaWxlfTogc3Vic2NyaXB0aW9uIG1ldGhvZHMgc2hvdWxkIHVzZSB1c2VTdG9yZS5zdWJzY3JpYmVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChwcm9ibGVtYXRpY1N0b3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RvcmVzIHdpdGggaW1wcm9wZXIgc3Vic2NyaXB0aW9uczonLCBwcm9ibGVtYXRpY1N0b3Jlcyk7XG4gICAgfVxuICAgIFxuICAgIGV4cGVjdChwcm9ibGVtYXRpY1N0b3JlcykudG9IYXZlTGVuZ3RoKDApO1xuICB9KTtcblxuICBpdCgnc3RvcmUgZXJyb3IgaGFuZGxpbmcgc2hvdWxkIGJlIGNvbXByZWhlbnNpdmUnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmVGaWxlcyA9IGdsb2Iuc3luYygnd2ViL2xpYi9zdG9yZXMvKi50cycsIHsgXG4gICAgICBpZ25vcmU6IFsnKiovKi50ZXN0LionLCAnKiovKi5zcGVjLionLCAnKiovbm9kZV9tb2R1bGVzLyoqJ10gXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcHJvYmxlbWF0aWNTdG9yZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgc3RvcmVGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgYXN5bmMgYWN0aW9ucyB0aGF0IHNob3VsZCBoYXZlIGVycm9yIGhhbmRsaW5nXG4gICAgICBjb25zdCBhc3luY0FjdGlvbnMgPSBjb250ZW50Lm1hdGNoKC8oXFx3Kyk6XFxzKmFzeW5jXFxzKlxcKFteKV0qXFwpXFxzKj0+L2cpO1xuICAgICAgaWYgKGFzeW5jQWN0aW9ucykge1xuICAgICAgICBhc3luY0FjdGlvbnMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IG1hdGNoLm1hdGNoKC8oXFx3Kyk6Lyk/LlsxXTtcbiAgICAgICAgICBpZiAoYWN0aW9uTmFtZSAmJiAhY29udGVudC5pbmNsdWRlcyhgdHJ5IHtgKSAmJiAhY29udGVudC5pbmNsdWRlcyhgY2F0Y2hgKSkge1xuICAgICAgICAgICAgcHJvYmxlbWF0aWNTdG9yZXMucHVzaChgJHtmaWxlfTogYXN5bmMgYWN0aW9uICcke2FjdGlvbk5hbWV9JyBuZWVkcyBlcnJvciBoYW5kbGluZ2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHByb2JsZW1hdGljU3RvcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdG9yZXMgd2l0aCBtaXNzaW5nIGVycm9yIGhhbmRsaW5nOicsIHByb2JsZW1hdGljU3RvcmVzKTtcbiAgICB9XG4gICAgXG4gICAgZXhwZWN0KHByb2JsZW1hdGljU3RvcmVzKS50b0hhdmVMZW5ndGgoMCk7XG4gIH0pO1xuXG4gIGl0KCdzdG9yZSBpbXBvcnRzIHNob3VsZCB1c2UgY2VudHJhbGl6ZWQgcGF0dGVybicsICgpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRGaWxlcyA9IGdsb2Iuc3luYygnd2ViLyoqLyoue3RzLHRzeH0nLCB7IFxuICAgICAgaWdub3JlOiBbJyoqLyoudGVzdC4qJywgJyoqLyouc3BlYy4qJywgJyoqL25vZGVfbW9kdWxlcy8qKicsICcqKi9saWIvc3RvcmVzLyoqJ10gXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcHJvYmxlbWF0aWNGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBjb21wb25lbnRGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZGlyZWN0IFp1c3RhbmQgaW1wb3J0c1xuICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ2Zyb20gXFwnenVzdGFuZFxcJycpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2Zyb20gXCJ6dXN0YW5kXCInKSkge1xuICAgICAgICBwcm9ibGVtYXRpY0ZpbGVzLnB1c2goYCR7ZmlsZX06IHNob3VsZCB1c2UgY2VudHJhbGl6ZWQgc3RvcmUgaW1wb3J0c2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZGlyZWN0IHN0b3JlIGltcG9ydHNcbiAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdmcm9tIFxcJy4uL3N0b3Jlcy8nKSB8fCBjb250ZW50LmluY2x1ZGVzKCdmcm9tIFwiLi4vc3RvcmVzLycpKSB7XG4gICAgICAgIHByb2JsZW1hdGljRmlsZXMucHVzaChgJHtmaWxlfTogc2hvdWxkIHVzZSBAL2xpYi9zdG9yZXMgaW1wb3J0c2ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChwcm9ibGVtYXRpY0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGaWxlcyB3aXRoIGltcHJvcGVyIHN0b3JlIGltcG9ydHM6JywgcHJvYmxlbWF0aWNGaWxlcyk7XG4gICAgfVxuICAgIFxuICAgIGV4cGVjdChwcm9ibGVtYXRpY0ZpbGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsInN0b3JlRmlsZXMiLCJnbG9iIiwic3luYyIsImlnbm9yZSIsInByb2JsZW1hdGljU3RvcmVzIiwiZm9yRWFjaCIsImZpbGUiLCJjb250ZW50IiwiZnMiLCJyZWFkRmlsZVN5bmMiLCJpbnRlcmZhY2VNYXRjaGVzIiwibWF0Y2giLCJpbnRlcmZhY2VOYW1lIiwiaW5jbHVkZXMiLCJwdXNoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsImV4cGVjdCIsInRvSGF2ZUxlbmd0aCIsImFjdGlvbk1hdGNoZXMiLCJhY3Rpb25OYW1lIiwiYXN5bmNBY3Rpb25zIiwiY29tcG9uZW50RmlsZXMiLCJwcm9ibGVtYXRpY0ZpbGVzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQzs7Ozt5QkFFb0M7NERBQ2pCOzhEQUNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFdEJBLElBQUFBLGlCQUFRLEVBQUMscUJBQXFCO0lBQzVCQyxJQUFBQSxXQUFFLEVBQUMsa0RBQWtEO1FBQ25ELE1BQU1DLGFBQWFDLE1BQUtDLElBQUksQ0FBQyx1QkFBdUI7WUFDbERDLFFBQVE7Z0JBQUM7Z0JBQWU7Z0JBQWU7YUFBcUI7UUFDOUQ7UUFFQSxNQUFN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