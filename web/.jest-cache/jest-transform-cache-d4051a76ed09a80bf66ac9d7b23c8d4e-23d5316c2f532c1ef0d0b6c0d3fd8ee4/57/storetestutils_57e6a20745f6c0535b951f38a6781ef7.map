{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/tests/jest/helpers/store-test-utils.ts"],"sourcesContent":["/**\n * Store Testing Utilities\n * \n * Comprehensive utilities for testing Zustand stores with proper\n * mocking, setup, and validation patterns.\n * \n * Created: January 16, 2025\n * Status: âœ… ACTIVE\n */\n\nimport React from 'react';\nimport { act, renderHook } from '@testing-library/react';\nimport { create } from 'zustand';\nimport { devtools } from 'zustand/middleware';\nimport { immer } from 'zustand/middleware/immer';\n\n/**\n * Create a mock store for testing\n */\nexport const createMockStore = <T>(initialState: T) => {\n  return create<T>()(() => initialState);\n};\n\n/**\n * Create a mock store with middleware\n */\nexport const createMockStoreWithMiddleware = <T>(\n  initialState: T,\n  middleware: any[] = []\n) => {\n  return create<T>()(\n    ...middleware,\n    () => initialState\n  );\n};\n\n/**\n * Render a hook with store context\n */\nexport const renderWithStore = <T>(\n  hook: () => T,\n  store: any\n) => {\n  return renderHook(hook, {\n    wrapper: ({ children }: { children: React.ReactNode }) => \n      React.createElement('div', { 'data-testid': 'store-provider' }, children)\n  });\n};\n\n/**\n * Test store actions\n */\nexport const testStoreAction = async <T>(\n  store: any,\n  action: (state: T) => void,\n  expectedState: Partial<T>\n) => {\n  await act(async () => {\n    action(store.getState());\n  });\n  \n  const state = store.getState();\n  expect(state).toMatchObject(expectedState);\n};\n\n/**\n * Test store selectors\n */\nexport const testStoreSelector = <T, R>(\n  store: any,\n  selector: (state: T) => R,\n  expectedValue: R\n) => {\n  const result = selector(store.getState());\n  expect(result).toEqual(expectedValue);\n};\n\n/**\n * Test store subscriptions\n */\nexport const testStoreSubscription = <T>(\n  store: any,\n  selector: (state: T) => any,\n  callback: (value: any) => void\n) => {\n  const unsubscribe = store.subscribe(selector, callback);\n  \n  // Test subscription\n  const testValue = selector(store.getState());\n  callback(testValue);\n  \n  // Cleanup\n  unsubscribe();\n};\n\n/**\n * Test store persistence\n */\nexport const testStorePersistence = async <T>(\n  store: any,\n  key: string,\n  expectedValue: T\n) => {\n  // Set value\n  store.setState(expectedValue);\n  \n  // Simulate persistence\n  const persisted = JSON.parse(localStorage.getItem(key) || '{}');\n  expect(persisted).toMatchObject(expectedValue);\n};\n\n/**\n * Test store middleware\n */\nexport const testStoreMiddleware = <T>(\n  store: any,\n  middleware: any,\n  action: (state: T) => void,\n  expectedBehavior: () => void\n) => {\n  // Test middleware behavior\n  action(store.getState());\n  expectedBehavior();\n};\n\n/**\n * Test store performance\n */\nexport const testStorePerformance = <T>(\n  store: any,\n  action: (state: T) => void,\n  maxDuration: number = 10\n) => {\n  const startTime = performance.now();\n  action(store.getState());\n  const endTime = performance.now();\n  const duration = endTime - startTime;\n  \n  expect(duration).toBeLessThan(maxDuration);\n};\n\n/**\n * Test store error handling\n */\nexport const testStoreErrorHandling = <T>(\n  store: any,\n  errorAction: (state: T) => void,\n  expectedError: string\n) => {\n  expect(() => {\n    errorAction(store.getState());\n  }).toThrow(expectedError);\n};\n\n/**\n * Test store state transitions\n */\nexport const testStoreStateTransition = <T>(\n  store: any,\n  initialState: T,\n  actions: Array<(state: T) => void>,\n  expectedFinalState: T\n) => {\n  // Set initial state\n  store.setState(initialState);\n  \n  // Apply actions\n  actions.forEach(action => {\n    action(store.getState());\n  });\n  \n  // Check final state\n  const finalState = store.getState();\n  expect(finalState).toMatchObject(expectedFinalState);\n};\n\n/**\n * Test store subscriptions with multiple listeners\n */\nexport const testStoreMultipleSubscriptions = <T>(\n  store: any,\n  selector: (state: T) => any,\n  listeners: Array<(value: any) => void>\n) => {\n  const unsubscribes = listeners.map(listener => \n    store.subscribe(selector, listener)\n  );\n  \n  // Test all listeners\n  const testValue = selector(store.getState());\n  listeners.forEach(listener => listener(testValue));\n  \n  // Cleanup\n  unsubscribes.forEach(unsubscribe => unsubscribe());\n};\n\n/**\n * Test store with React components\n */\nexport const testStoreWithComponent = <T>(\n  store: any,\n  component: React.ComponentType<any>,\n  props: any = {}\n) => {\n  const wrapper = ({ children }: { children: React.ReactNode }) => \n    React.createElement('div', { 'data-testid': 'store-wrapper' }, children);\n  \n  return renderHook(() => component(props), { wrapper });\n};\n\n/**\n * Test store with async actions\n */\nexport const testStoreAsyncAction = async <T>(\n  store: any,\n  asyncAction: (state: T) => Promise<void>,\n  expectedState: Partial<T>\n) => {\n  await act(async () => {\n    await asyncAction(store.getState());\n  });\n  \n  const state = store.getState();\n  expect(state).toMatchObject(expectedState);\n};\n\n/**\n * Test store with side effects\n */\nexport const testStoreSideEffects = <T>(\n  store: any,\n  action: (state: T) => void,\n  sideEffect: () => void\n) => {\n  const mockSideEffect = jest.fn(sideEffect);\n  \n  action(store.getState());\n  expect(mockSideEffect).toHaveBeenCalled();\n};\n\n/**\n * Test store with external dependencies\n */\nexport const testStoreWithDependencies = <T>(\n  store: any,\n  dependencies: Record<string, any>,\n  action: (state: T, deps: Record<string, any>) => void\n) => {\n  action(store.getState(), dependencies);\n  // Test that dependencies were used correctly\n  Object.values(dependencies).forEach(dep => {\n    if (typeof dep === 'function') {\n      expect(dep).toHaveBeenCalled();\n    }\n  });\n};\n\n/**\n * Test store with validation\n */\nexport const testStoreValidation = <T>(\n  store: any,\n  validator: (state: T) => boolean,\n  invalidAction: (state: T) => void\n) => {\n  const initialState = store.getState();\n  expect(validator(initialState)).toBe(true);\n  \n  expect(() => {\n    invalidAction(store.getState());\n  }).toThrow();\n};\n\n/**\n * Test store with time-based actions\n */\nexport const testStoreTimeBased = <T>(\n  store: any,\n  timeAction: (state: T) => void,\n  expectedDuration: number\n) => {\n  const startTime = Date.now();\n  timeAction(store.getState());\n  const endTime = Date.now();\n  const duration = endTime - startTime;\n  \n  expect(duration).toBeGreaterThanOrEqual(expectedDuration);\n};\n\n/**\n * Test store with cleanup\n */\nexport const testStoreCleanup = <T>(\n  store: any,\n  action: (state: T) => void,\n  cleanup: () => void\n) => {\n  action(store.getState());\n  cleanup();\n  \n  // Verify cleanup was called\n  expect(cleanup).toHaveBeenCalled();\n};\n\n/**\n * Test store with concurrent actions\n */\nexport const testStoreConcurrent = <T>(\n  store: any,\n  actions: Array<(state: T) => void>,\n  expectedFinalState: T\n) => {\n  // Run actions concurrently\n  const promises = actions.map(action => \n    Promise.resolve(action(store.getState()))\n  );\n  \n  return Promise.all(promises).then(() => {\n    const finalState = store.getState();\n    expect(finalState).toMatchObject(expectedFinalState);\n  });\n};\n\n/**\n * Test store with error recovery\n */\nexport const testStoreErrorRecovery = <T>(\n  store: any,\n  errorAction: (state: T) => void,\n  recoveryAction: (state: T) => void,\n  expectedRecoveredState: T\n) => {\n  // Trigger error\n  expect(() => {\n    errorAction(store.getState());\n  }).toThrow();\n  \n  // Test recovery\n  recoveryAction(store.getState());\n  const recoveredState = store.getState();\n  expect(recoveredState).toMatchObject(expectedRecoveredState);\n};\n\n/**\n * Test store with state snapshots\n */\nexport const testStoreSnapshots = <T>(\n  store: any,\n  actions: Array<(state: T) => void>,\n  expectedSnapshots: Array<T>\n) => {\n  const snapshots: T[] = [];\n  \n  // Capture initial state\n  snapshots.push(store.getState());\n  \n  // Apply actions and capture snapshots\n  actions.forEach(action => {\n    action(store.getState());\n    snapshots.push(store.getState());\n  });\n  \n  // Compare snapshots\n  expect(snapshots).toEqual(expectedSnapshots);\n};\n\n/**\n * Mock store for testing\n */\nexport const mockStore = {\n  create: createMockStore,\n  createWithMiddleware: createMockStoreWithMiddleware,\n  render: renderWithStore,\n  testAction: testStoreAction,\n  testSelector: testStoreSelector,\n  testSubscription: testStoreSubscription,\n  testPersistence: testStorePersistence,\n  testMiddleware: testStoreMiddleware,\n  testPerformance: testStorePerformance,\n  testErrorHandling: testStoreErrorHandling,\n  testStateTransition: testStoreStateTransition,\n  testMultipleSubscriptions: testStoreMultipleSubscriptions,\n  testWithComponent: testStoreWithComponent,\n  testAsyncAction: testStoreAsyncAction,\n  testSideEffects: testStoreSideEffects,\n  testWithDependencies: testStoreWithDependencies,\n  testValidation: testStoreValidation,\n  testTimeBased: testStoreTimeBased,\n  testCleanup: testStoreCleanup,\n  testConcurrent: testStoreConcurrent,\n  testErrorRecovery: testStoreErrorRecovery,\n  testSnapshots: testStoreSnapshots\n};\n"],"names":["createMockStore","createMockStoreWithMiddleware","mockStore","renderWithStore","testStoreAction","testStoreAsyncAction","testStoreCleanup","testStoreConcurrent","testStoreErrorHandling","testStoreErrorRecovery","testStoreMiddleware","testStoreMultipleSubscriptions","testStorePerformance","testStorePersistence","testStoreSelector","testStoreSideEffects","testStoreSnapshots","testStoreStateTransition","testStoreSubscription","testStoreTimeBased","testStoreValidation","testStoreWithComponent","testStoreWithDependencies","initialState","create","middleware","hook","store","renderHook","wrapper","children","React","createElement","action","expectedState","act","getState","state","expect","toMatchObject","selector","expectedValue","result","toEqual","callback","unsubscribe","subscribe","testValue","key","setState","persisted","JSON","parse","localStorage","getItem","expectedBehavior","maxDuration","startTime","performance","now","endTime","duration","toBeLessThan","errorAction","expectedError","toThrow","actions","expectedFinalState","forEach","finalState","listeners","unsubscribes","map","listener","component","props","asyncAction","sideEffect","mockSideEffect","jest","fn","toHaveBeenCalled","dependencies","Object","values","dep","validator","invalidAction","toBe","timeAction","expectedDuration","Date","toBeGreaterThanOrEqual","cleanup","promises","Promise","resolve","all","then","recoveryAction","expectedRecoveredState","recoveredState","expectedSnapshots","snapshots","push","createWithMiddleware","render","testAction","testSelector","testSubscription","testPersistence","testMiddleware","testPerformance","testErrorHandling","testStateTransition","testMultipleSubscriptions","testWithComponent","testAsyncAction","testSideEffects","testWithDependencies","testValidation","testTimeBased","testCleanup","testConcurrent","testErrorRecovery","testSnapshots"],"mappings":"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"}