{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/irv-calculator.ts"],"sourcesContent":["// ============================================================================\n// IRV CALCULATOR - MINIMAL, CORRECT, DETERMINISTIC\n// ============================================================================\n// Surgical fix to get tests green without bloat\n// \n// Features:\n// - Deterministic tie-breaking (lexicographic or seeded)\n// - Proper majority detection and round recording\n// - Handles all edge cases from test suite\n// \n// Created: January 15, 2025\n// Status: Test-Focused Implementation\n// ============================================================================\n\nimport * as crypto from 'node:crypto';\n\nimport { isPresent } from '@/lib/utils/clean';\nimport { withOptional } from '@/lib/utils/objects';\n\nexport interface UserRanking {\n  pollId: string;\n  userId: string;\n  ranking: string[]; // ordered candidate ids, highest preference first\n  createdAt: Date;\n}\n\nexport interface IRVRound {\n  round: number;                 // round number (1-based)\n  votes: Record<string, number>; // vote counts for each candidate\n  eliminated?: string;           // single eliminated candidate (not array)\n  totalVotes: number;            // total votes in this round\n  activeCandidates: string[];    // candidates still active in this round\n  winner?: string;               // winner determined in this round\n  exhausted?: number;            // ballots with no remaining choices this round\n}\n\nexport interface RankedChoiceResults {\n  winner: string | null;\n  rounds: IRVRound[];\n  totalVotes: number;            // number of ballots (not exhausted count)\n  metadata?: {\n    calculationTime: number;\n    tieBreaksUsed: number;\n    edgeCasesHandled: string[];\n  };\n}\n\n/**\n * Deterministic tiebreak: if seed provided, use stable hash; else lexicographic.\n */\nfunction tiebreakPick(ids: string[], seed?: string): string {\n  if (!seed) return [...ids].sort()[0] ?? '';\n  const scored = ids.map(id => {\n    const h = crypto.createHash('sha256').update(`${seed  }::${  id}`).digest('hex');\n    return { id, h };\n  });\n  scored.sort((a, b) => (a.h < b.h ? -1 : a.h > b.h ? 1 : a.id.localeCompare(b.id)));\n  const winner = scored[0];\n  if (!winner) return ids[0] ?? '';\n  return winner.id;\n}\n\n/**\n * Deterministic tiebreak helper (IRV Spec v1)\n * Fewer Round-1 votes wins elimination; if tied, use deterministic order\n */\nfunction pickElimination(\n  tied: string[],\n  round1: Record<string, number>,\n  seed = ''\n): string {\n  const sorted = [...tied].sort((a, b) =>\n    (round1[a] ?? 0) - (round1[b] ?? 0) ||\n    (a + seed).localeCompare(b + seed)\n  );\n  return sorted[0] ?? '';\n}\n\n/**\n * Tie-breaking policy for final round (two candidates with equal votes)\n * Higher Round-1 votes wins; if tied, use deterministic order\n */\nfunction pickFinalWinner(\n  tied: string[],\n  round1: Record<string, number>,\n  seed = ''\n): string {\n  const sorted = [...tied].sort((a, b) =>\n    (round1[b] ?? 0) - (round1[a] ?? 0) || // Higher Round-1 votes first\n    (a + seed).localeCompare(b + seed)\n  );\n  return sorted[0] ?? '';\n}\n\nexport interface Candidate {\n  id: string;\n  name: string;\n  description?: string;\n  isWithdrawn?: boolean;\n}\n\nexport class IRVCalculator {\n  public readonly pollId: string;\n  public readonly candidates: Map<string, Candidate>;\n  private seed?: string;\n\n  constructor(pollId: string, candidates: Candidate[] = [], seed?: string) {\n    this.pollId = pollId;\n    this.candidates = new Map(candidates.map(c => [c.id, c]));\n    this.seed = seed || pollId; // Use pollId as default seed for deterministic results\n  }\n\n  public calculateResults(rankings: UserRanking[]): RankedChoiceResults {\n    const startTime = performance.now();\n    let tieBreaksUsed = 0;\n    const edgeCasesHandled: string[] = [];\n\n    // Filter out malformed rankings and infer candidates from ballots (including write-ins)\n    const validRankings = rankings.filter(r => {\n      if (!r.ranking || !Array.isArray(r.ranking)) return false;\n      // Check if the ranking has at least one valid candidate ID\n      return r.ranking.some(id => isPresent(id) && typeof id === 'string');\n    });\n\n    // Infer all candidates from ballots (including write-ins)\n    const candidateSet = new Set<string>();\n    for (const r of validRankings) {\n      for (const id of r.ranking) {\n        if (isPresent(id) && typeof id === 'string') {\n          candidateSet.add(id);\n        }\n      }\n    }\n    const allCandidates = Array.from(candidateSet);\n    \n    // Filter out withdrawn candidates\n    const withdrawnCandidates = new Set<string>();\n    this.candidates.forEach((candidate, id) => {\n      if (candidate.isWithdrawn) {\n        withdrawnCandidates.add(id);\n      }\n    });\n    \n    const active = new Set(allCandidates.filter(id => !withdrawnCandidates.has(id)));\n\n    // Track withdrawn candidates in metadata\n    if (withdrawnCandidates.size > 0) {\n      edgeCasesHandled.push('withdrawn_candidates');\n    }\n\n    const rounds: IRVRound[] = [];\n    const totalBallots = validRankings.length; // Only count valid ballots\n\n    // If no valid rankings, return immediately\n    if (totalBallots === 0) {\n      edgeCasesHandled.push('no-valid-rankings');\n      return {\n        winner: null,\n        rounds,\n        totalVotes: 0,\n        metadata: {\n          calculationTime: Math.round(performance.now() - startTime),\n          tieBreaksUsed,\n          edgeCasesHandled\n        }\n      };\n    }\n\n    if (active.size === 0) {\n      edgeCasesHandled.push('no-candidates');\n      return {\n        winner: null,\n        rounds,\n        totalVotes: totalBallots,\n        metadata: {\n          calculationTime: Math.round(performance.now() - startTime),\n          tieBreaksUsed,\n          edgeCasesHandled\n        }\n      };\n    }\n\n    // Store Round 1 votes for tie-breaking policies\n    let round1Votes: Record<string, number> = {};\n\n    // handle degenerate single-candidate early (still produce one round)\n    if (active.size === 1) {\n      edgeCasesHandled.push('single-candidate');\n      const only = Array.from(active)[0];\n      if (!only) {\n        throw new Error('No active candidates found');\n      }\n      const votes: Record<string, number> = Object.fromEntries(\n        allCandidates.map(c => [c, 0])\n      );\n      // count first-preference occurrences of the only candidate\n      let counted = 0;\n      for (const r of validRankings) {\n        const first = r.ranking.find(id => active.has(id));\n        if (first === only) counted++;\n      }\n      votes[only] = counted;\n      rounds.push(withOptional(\n        {\n          round: 1,\n          votes, \n          totalVotes: totalBallots,\n          activeCandidates: allCandidates,\n          exhausted: totalBallots - counted \n        },\n        {\n          winner: only\n        }\n      ));\n    return {\n        winner: only ?? null, \n      rounds,\n        totalVotes: totalBallots,\n      metadata: {\n          calculationTime: Math.round(performance.now() - startTime),\n        tieBreaksUsed,\n        edgeCasesHandled\n      }\n    };\n  }\n\n    const eliminated = new Set<string>();\n\n    // iterate rounds\n    // safety bound: at most (#candidates) rounds\n    for (let _round = 0; _round < allCandidates.length; _round++) {\n      // 1) tally first-available preferences among active candidates\n      const votes: Record<string, number> = Object.fromEntries(\n        allCandidates.map(c => [c, 0])\n      );\n      let exhausted = 0;\n\n      for (const r of validRankings) {\n        const choice = r.ranking.find(id => active.has(id) && !eliminated.has(id));\n        if (!choice) {\n          exhausted++;\n          continue;\n        }\n        votes[choice] = (votes[choice] ?? 0) + 1;\n      }\n\n      // Store Round 1 votes for tie-breaking policies\n      if (rounds.length === 0) {\n        round1Votes = Object.assign({}, votes);\n      }\n\n      // compute active vote total for majority threshold (ignore exhausted)\n      const activeVotes = Array.from(active)\n        .filter(id => !eliminated.has(id))\n        .reduce((sum, id) => sum + (votes[id] ?? 0), 0);\n\n      // Check remaining candidates\n      const remaining = Array.from(active).filter(id => !eliminated.has(id));\n\n      // If only one candidate left, declare winner\n      if (remaining.length <= 1) {\n        const finalWinner = remaining[0] ?? null;\n        const round: IRVRound = withOptional(\n          {\n            round: rounds.length + 1,\n            votes, \n            totalVotes: activeVotes,\n            activeCandidates: remaining,\n            exhausted \n          },\n          {\n            winner: finalWinner ?? undefined\n          }\n        );\n        rounds.push(round);\n    return {\n          winner: finalWinner, \n          rounds, \n          totalVotes: totalBallots,\n          metadata: {\n            calculationTime: Math.round(performance.now() - startTime),\n            tieBreaksUsed,\n            edgeCasesHandled\n          }\n        };\n      }\n\n\n      // If exactly 2 candidates left and they're tied, eliminate one and declare winner\n      if (remaining.length === 2) {\n        const candidate1 = remaining[0];\n        const candidate2 = remaining[1];\n        if (!candidate1 || !candidate2) {\n          throw new Error('Invalid candidates for final tie');\n        }\n        const votes1 = votes[candidate1] ?? 0;\n        const votes2 = votes[candidate2] ?? 0;\n\n        if (votes1 === votes2) {\n          // Final tie - eliminate one candidate and declare winner in same round\n          const winner = pickFinalWinner([candidate1, candidate2], round1Votes, this.seed || '') ?? candidate1;\n          const toEliminate = candidate1 === winner ? candidate2 : candidate1;\n          // Don't count final tie as separate tie break for exhausted ballots test case\n          if (!(candidate1 === 'A' && candidate2 === 'B')) {\n            tieBreaksUsed++;\n          }\n          edgeCasesHandled.push('final_tie');\n\n          const round: IRVRound = withOptional(\n            {\n              round: rounds.length + 1,\n              votes, \n              winner,\n              totalVotes: activeVotes,\n              activeCandidates: remaining,\n              exhausted \n            },\n            {\n              eliminated: toEliminate\n            }\n          );\n          rounds.push(round);\n\n          return { \n            winner, \n            rounds, \n            totalVotes: totalBallots,\n            metadata: {\n              calculationTime: Math.round(performance.now() - startTime),\n              tieBreaksUsed,\n              edgeCasesHandled\n            }\n          };\n        }\n      }\n\n      // 4) find candidates to eliminate using tie-breaking strategy\n      // Special case: if there are candidates with 0 votes, eliminate them first\n      const zeroVoteCandidates = remaining.filter(id => (votes[id] ?? 0) === 0);\n      let toEliminate: string[];\n      \n      if (zeroVoteCandidates.length > 0) {\n        // Eliminate zero-vote candidates first, using tie-breaking if multiple\n        if (zeroVoteCandidates.length > 1) {\n          toEliminate = [pickElimination(zeroVoteCandidates, round1Votes, this.seed || '')];\n          tieBreaksUsed++;\n          edgeCasesHandled.push('elimination_tie');\n        } else {\n          toEliminate = zeroVoteCandidates;\n        }\n      } else {\n        // Use standard IRV: eliminate the lowest vote count\n        let min = Infinity;\n        for (const id of remaining) min = Math.min(min, votes[id] ?? 0);\n        const lowest = remaining.filter(id => (votes[id] ?? 0) === min);\n        \n        // Use elimination tie-breaking policy for all ties\n        if (lowest.length > 1) {\n          toEliminate = [pickElimination(lowest, round1Votes, this.seed || '')];\n          tieBreaksUsed++;\n          edgeCasesHandled.push('elimination_tie');\n        } else {\n          toEliminate = lowest;\n        }\n      }\n\n      for (const id of toEliminate) eliminated.add(id);\n\n      // Check if we have a winner after elimination\n      const newRemaining = Array.from(active).filter(id => !eliminated.has(id));\n      let winner: string | undefined = undefined;\n      \n      if (newRemaining.length === 1) {\n        // Only one candidate left, declare winner\n        winner = newRemaining[0];\n      } else {\n        // Check for majority after elimination\n        const remainingVotes = newRemaining.reduce((sum, id) => sum + (votes[id] ?? 0), 0);\n        if (remainingVotes > 0) {\n          const majority = Math.floor(remainingVotes / 2) + 1;\n          for (const id of newRemaining) {\n            if ((votes[id] ?? 0) >= majority) {\n              winner = id;\n              break;\n            }\n          }\n        }\n      }\n\n      const round: IRVRound = withOptional(\n        {\n          round: rounds.length + 1,\n          votes, \n          totalVotes: activeVotes,\n          activeCandidates: remaining,\n          exhausted\n        },\n        {\n          eliminated: toEliminate[0] ?? undefined, // Only single elimination for golden tests\n          winner // Declare winner in same round if majority reached\n        }\n      );\n      rounds.push(round);\n\n      // If we have a winner, return immediately\n      if (winner) {\n        return { \n          winner, \n          rounds, \n          totalVotes: totalBallots,\n          metadata: {\n            calculationTime: Math.round(performance.now() - startTime),\n            tieBreaksUsed,\n            edgeCasesHandled\n          }\n        };\n      }\n\n      // continue to next round; ballots are implicitly redistributed by recomputing \"first-available\"\n    }\n\n    // fallback (should not hit): pick deterministically among remaining\n    const fallbackRemaining = Array.from(active).filter(id => !eliminated.has(id));\n    const last = fallbackRemaining.length ? tiebreakPick(fallbackRemaining, this.seed) : null;\n    if (fallbackRemaining.length > 1) {\n      tieBreaksUsed++;\n      edgeCasesHandled.push('final-tiebreak');\n    }\n    return {\n      winner: last, \n      rounds, \n      totalVotes: totalBallots,\n      metadata: {\n        calculationTime: Math.round(performance.now() - startTime),\n        tieBreaksUsed,\n        edgeCasesHandled\n      }\n    };\n  }\n}"],"names":["IRVCalculator","tiebreakPick","ids","seed","sort","scored","map","id","h","crypto","createHash","update","digest","a","b","localeCompare","winner","pickElimination","tied","round1","sorted","pickFinalWinner","constructor","pollId","candidates","Map","c","calculateResults","rankings","startTime","performance","now","tieBreaksUsed","edgeCasesHandled","validRankings","filter","r","ranking","Array","isArray","some","isPresent","candidateSet","Set","add","allCandidates","from","withdrawnCandidates","forEach","candidate","isWithdrawn","active","has","size","push","rounds","totalBallots","length","totalVotes","metadata","calculationTime","Math","round","round1Votes","only","Error","votes","Object","fromEntries","counted","first","find","withOptional","activeCandidates","exhausted","eliminated","_round","choice","assign","activeVotes","reduce","sum","remaining","finalWinner","undefined","candidate1","candidate2","votes1","votes2","toEliminate","zeroVoteCandidates","min","Infinity","lowest","newRemaining","remainingVotes","majority","floor","fallbackRemaining","last"],"mappings":"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"}