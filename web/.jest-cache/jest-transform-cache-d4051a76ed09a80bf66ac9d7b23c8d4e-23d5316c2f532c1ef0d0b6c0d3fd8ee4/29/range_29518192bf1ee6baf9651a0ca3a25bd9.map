{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/strategies/range.ts"],"sourcesContent":["/**\n * Range Voting Strategy\n * \n * Implements range voting where voters rate each option on a scale.\n * Results show average ratings for each option, with the highest rated option winning.\n * \n * Created: September 15, 2025\n * Updated: September 15, 2025\n */\n\nimport { devLog } from '@/lib/utils/logger';\n\nimport type { \n  VotingStrategy, \n  VoteRequest, \n  VoteResponse, \n  VoteValidation, \n  PollData, \n  VoteData, \n  ResultsData,\n  VotingMethod,\n  PollResults\n} from '../types';\n\nexport class RangeStrategy implements VotingStrategy {\n  \n  getVotingMethod(): VotingMethod {\n    return 'range';\n  }\n\n  async validateVote(request: VoteRequest, poll: PollData): Promise<VoteValidation> {\n    await Promise.resolve(); // Satisfy require-await rule\n    try {\n      const voteData = request.voteData;\n\n      // Validate ratings object exists\n      if (!voteData.ratings || typeof voteData.ratings !== 'object') {\n        return {\n          valid: false,\n          isValid: false,\n          error: 'Range voting requires ratings',\n          errors: ['Range voting requires ratings'],\n          requiresAuthentication: false,\n          requiresTokens: false\n        };\n      }\n\n      // Validate ratings are numbers within range\n      const ratings = voteData.ratings;\n      const minRating = typeof poll.settings?.minRating === 'number' ? poll.settings.minRating : 0;\n      const maxRating = typeof poll.settings?.maxRating === 'number' ? poll.settings.maxRating : 10;\n      \n      for (const [optionId, rating] of Object.entries(ratings)) {\n        if (typeof rating !== 'number') {\n          return {\n            valid: false,\n            isValid: false,\n            error: 'Ratings must be numbers',\n            errors: ['Ratings must be numbers'],\n            requiresAuthentication: false,\n            requiresTokens: false\n          };\n        }\n        \n        if (rating < minRating || rating > maxRating) {\n          return {\n            valid: false,\n            isValid: false,\n            error: `Ratings must be between ${minRating} and ${maxRating}`,\n            errors: [`Ratings must be between ${minRating} and ${maxRating}`],\n            requiresAuthentication: false,\n            requiresTokens: false\n          };\n        }\n        \n        // Check if option exists\n        const optionExists = poll.options.some(option => option.id === optionId);\n        if (!optionExists) {\n          return {\n            valid: false,\n            isValid: false,\n            error: 'Invalid option selected',\n            errors: ['Invalid option selected'],\n            requiresAuthentication: false,\n            requiresTokens: false\n          };\n        }\n      }\n\n      devLog('Range vote validated successfully', {\n        pollId: request.pollId,\n        ratings: voteData.ratings,\n        userId: request.userId\n      });\n\n      return {\n        valid: true,\n        isValid: true,\n        requiresAuthentication: false,\n        requiresTokens: false\n      };\n\n    } catch (error) {\n      devLog('Range vote validation error:', { error: error instanceof Error ? error.message : String(error) });\n      return {\n        valid: false,\n        isValid: false,\n        error: 'Range vote validation failed',\n        errors: ['Range vote validation failed'],\n        requiresAuthentication: false,\n        requiresTokens: false\n      };\n    }\n  }\n\n  async processVote(request: VoteRequest, poll: PollData): Promise<VoteResponse> {\n    await Promise.resolve(); // Satisfy require-await rule\n    try {\n      const voteData = request.voteData;\n      \n      // Create vote data for storage\n      const voteRecord: VoteData = {\n        id: `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        pollId: request.pollId,\n        userId: request.userId,\n        ratings: voteData.ratings,\n        privacyLevel: 'standard',\n        auditReceipt: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date(),\n        ipAddress: request.ipAddress,\n        userAgent: request.userAgent\n      };\n\n      devLog('Range vote processed successfully', {\n        pollId: request.pollId,\n        userId: request.userId,\n        ratings: voteData.ratings,\n        voteId: voteRecord.id\n      });\n\n      return {\n        success: true,\n        voteId: voteRecord.id,\n        message: 'Vote recorded successfully',\n        pollId: request.pollId\n      };\n\n    } catch (error) {\n      devLog('Range vote processing error:', { error: error instanceof Error ? error.message : String(error) });\n      return {\n        success: false,\n        error: 'Failed to process range vote',\n        message: 'Failed to process range vote',\n        pollId: request.pollId\n      };\n    }\n  }\n\n  async calculateResults(poll: PollData, votes: VoteData[]): Promise<ResultsData> {\n    await Promise.resolve(); // Satisfy require-await rule\n    try {\n      const startTime = Date.now();\n      \n      // Initialize tracking objects\n      const totalRatings: Record<string, number> = {};\n      const ratingCounts: Record<string, number> = {};\n      const averageRatings: Record<string, number> = {};\n      const optionVotes: Record<string, number> = {};\n      const optionPercentages: Record<string, number> = {};\n\n      // Initialize all options with zero scores\n      poll.options.forEach(option => {\n        totalRatings[option.id] = 0;\n        ratingCounts[option.id] = 0;\n        averageRatings[option.id] = 0;\n        optionVotes[option.id] = 0;\n        optionPercentages[option.id] = 0;\n      });\n\n      // Process each vote\n      votes.forEach(vote => {\n        if (vote.voteData?.ratings) {\n          Object.entries(vote.voteData.ratings).forEach(([optionId, rating]) => {\n            if (typeof rating === 'number') {\n              totalRatings[optionId] = (totalRatings[optionId] || 0) + rating;\n              ratingCounts[optionId] = (ratingCounts[optionId] || 0) + 1;\n              optionVotes[optionId] = (optionVotes[optionId] || 0) + 1;\n            }\n          });\n        }\n      });\n\n      // Calculate average ratings\n      Object.keys(totalRatings).forEach(optionId => {\n        const count = ratingCounts[optionId] || 0;\n        const total = totalRatings[optionId] || 0;\n        if (count > 0) {\n          averageRatings[optionId] = total / count;\n        }\n      });\n\n      const totalVotes = votes.length;\n\n      // Calculate percentages\n      if (totalVotes > 0) {\n        Object.keys(optionVotes).forEach(optionId => {\n          const votes = optionVotes[optionId] || 0;\n          optionPercentages[optionId] = (votes / totalVotes) * 100;\n        });\n      }\n\n      // Find winner (highest average rating)\n      let winner: string | undefined;\n      let winnerVotes = 0;\n      let winnerPercentage = 0;\n\n      if (totalVotes > 0) {\n        Object.entries(averageRatings).forEach(([optionId, rating]) => {\n          if (rating && rating > winnerVotes) {\n            winner = optionId;\n            winnerVotes = rating;\n            winnerPercentage = optionPercentages[optionId] || 0;\n          }\n        });\n      }\n\n      const results: PollResults = {\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        optionVotes,\n        optionPercentages,\n        abstentions: 0,\n        abstentionPercentage: 0\n      };\n\n      devLog('Range results calculated', {\n        pollId: poll.id,\n        totalVotes,\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        calculationTime: Date.now() - startTime\n      });\n\n      return {\n        pollId: poll.id,\n        votingMethod: poll.votingMethod,\n        totalVotes,\n        participationRate: totalVotes / 100, // Mock participation rate\n        results,\n        calculatedAt: new Date().toISOString(),\n        metadata: {\n          calculationTime: Date.now() - startTime,\n          method: 'range'\n        }\n      };\n\n    } catch (error) {\n      devLog('Range results calculation error:', { error: error instanceof Error ? error.message : String(error) });\n      \n      // Return empty results on error\n      return {\n        pollId: poll.id,\n        votingMethod: poll.votingMethod,\n        totalVotes: 0,\n        participationRate: 0,\n        results: {\n          winner: undefined,\n          winnerVotes: 0,\n          winnerPercentage: 0,\n          optionVotes: {},\n          optionPercentages: {},\n          abstentions: 0,\n          abstentionPercentage: 0\n        },\n        calculatedAt: new Date().toISOString(),\n        metadata: {\n          calculationTime: 0,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        }\n      };\n    }\n  }\n\n  getConfiguration(): Record<string, unknown> {\n    return {\n      method: 'range',\n      description: 'Voters rate each option on a scale',\n      allowsMultipleSelections: true,\n      requiresRanking: false,\n      maxSelections: 'all options',\n      ratingScale: 'configurable'\n    };\n  }\n}"],"names":["RangeStrategy","getVotingMethod","validateVote","request","poll","Promise","resolve","voteData","ratings","valid","isValid","error","errors","requiresAuthentication","requiresTokens","minRating","settings","maxRating","optionId","rating","Object","entries","optionExists","options","some","option","id","devLog","pollId","userId","Error","message","String","processVote","voteRecord","Date","now","Math","random","toString","substr","privacyLevel","auditReceipt","timestamp","ipAddress","userAgent","voteId","success","calculateResults","votes","startTime","totalRatings","ratingCounts","averageRatings","optionVotes","optionPercentages","forEach","vote","keys","count","total","totalVotes","length","winner","winnerVotes","winnerPercentage","results","abstentions","abstentionPercentage","calculationTime","votingMethod","participationRate","calculatedAt","toISOString","metadata","method","undefined","getConfiguration","description","allowsMultipleSelections","requiresRanking","maxSelections","ratingScale"],"mappings":"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"}