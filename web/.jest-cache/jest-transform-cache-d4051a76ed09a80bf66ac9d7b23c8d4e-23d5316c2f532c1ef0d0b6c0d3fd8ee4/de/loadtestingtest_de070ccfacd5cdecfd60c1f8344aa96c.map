{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/tests/jest/unit/performance/load-testing.test.ts"],"sourcesContent":["/**\n * Load Testing - PHASE 3 COMPREHENSIVE TESTING\n * \n * Tests performance under load:\n * - High user load testing\n * - Database performance\n * - API response times\n * - System scalability validation\n * - Stress testing\n * - Peak load scenarios\n * - Resource exhaustion testing\n * - Recovery testing\n */\n\nimport { describe, it, expect, beforeEach, jest } from '@jest/globals';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { BrowserRouter } from 'react-router-dom';\n\n// Mock performance monitoring with proper high-resolution timing\nlet mockTime = 0;\nconst mockPerformance = {\n  now: jest.fn(() => {\n    mockTime += Math.random() * 10; // Simulate realistic timing increments\n    return mockTime;\n  }),\n  mark: jest.fn(),\n  measure: jest.fn(),\n  getEntriesByType: jest.fn(() => []),\n  getEntriesByName: jest.fn(() => [])\n};\n\nObject.defineProperty(window, 'performance', {\n  value: mockPerformance,\n  writable: true,\n});\n\n// Mock fetch with performance tracking\nconst mockFetch = jest.fn();\nglobal.fetch = mockFetch;\n\n// Mock Zustand stores for load testing\nconst mockFeedsStore = {\n  feeds: [],\n  isLoading: false,\n  error: null,\n  loadFeeds: jest.fn(),\n  refreshFeeds: jest.fn(),\n  loadMoreFeeds: jest.fn(),\n  setFilters: jest.fn()\n};\n\njest.mock('@/lib/stores', () => ({\n  useFeeds: () => mockFeedsStore.feeds,\n  useFeedsStore: (selector) => {\n    const state = mockFeedsStore;\n    return selector ? selector(state) : state;\n  },\n  useFeedsLoading: () => mockFeedsStore.isLoading,\n  useFeedsError: () => mockFeedsStore.error\n}));\n\ndescribe('Load Testing', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockFeedsStore.feeds = [];\n    mockFeedsStore.isLoading = false;\n    mockFeedsStore.error = null;\n    mockTime = 0; // Reset mock time for each test\n  });\n\n  describe('High User Load Testing', () => {\n    it('should handle 1000 concurrent users', async () => {\n      const concurrentUsers = 1000;\n      const startTime = performance.now();\n      \n      // Simulate concurrent user requests\n      const userRequests = Array.from({ length: concurrentUsers }, (_, i) => ({\n        userId: `user-${i}`,\n        requestTime: performance.now(),\n        endpoint: '/api/feeds',\n        method: 'GET'\n      }));\n\n      // Mock API responses for concurrent users\n      mockFetch.mockImplementation((url) => {\n        return Promise.resolve({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve({ success: true, data: [] }),\n          headers: new Map()\n        });\n      });\n\n      // Process all requests\n      const responses = await Promise.all(\n        userRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            responseTime: performance.now() - request.requestTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageResponseTime = responses.reduce((sum, r) => sum + r.responseTime, 0) / responses.length;\n\n      // Performance assertions\n      expect(responses.length).toBe(concurrentUsers);\n      expect(totalTime).toBeLessThan(5000); // Should complete within 5 seconds\n      expect(averageResponseTime).toBeLessThan(100); // Average response time under 100ms\n      \n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.responseTime).toBeLessThan(500); // Individual response under 500ms\n      });\n    });\n\n    it('should handle 5000 concurrent feed requests', async () => {\n      const feedRequests = 5000;\n      const startTime = performance.now();\n      \n      // Generate mock feed data\n      const mockFeeds = Array.from({ length: 100 }, (_, i) => ({\n        id: `feed-${i}`,\n        title: `Feed Item ${i}`,\n        content: `Content for feed item ${i}`,\n        author: { id: `author-${i}`, name: `Author ${i}` },\n        publishedAt: new Date().toISOString(),\n        engagement: { likes: Math.floor(Math.random() * 100), comments: Math.floor(Math.random() * 50) }\n      }));\n\n      mockFetch.mockImplementation((url) => {\n        return Promise.resolve({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve(mockFeeds),\n          headers: new Map()\n        });\n      });\n\n      // Simulate concurrent feed requests\n      const requests = Array.from({ length: feedRequests }, (_, i) => ({\n        id: i,\n        startTime: performance.now(),\n        endpoint: '/api/feeds'\n      }));\n\n      const responses = await Promise.all(\n        requests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          const data = await response.json();\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            dataLength: data.length,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageResponseTime = responses.reduce((sum, r) => sum + r.responseTime, 0) / responses.length;\n\n      // Performance assertions\n      expect(responses.length).toBe(feedRequests);\n      expect(totalTime).toBeLessThan(10000); // Should complete within 10 seconds\n      expect(averageResponseTime).toBeLessThan(200); // Average response time under 200ms\n      \n      // All requests should succeed and return data\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n        expect(response.dataLength).toBe(100);\n        expect(response.responseTime).toBeLessThan(1000); // Individual response under 1 second\n      });\n    });\n\n    it('should handle mixed concurrent operations', async () => {\n      const operations = [\n        { type: 'feed_load', count: 1000, endpoint: '/api/feeds' },\n        { type: 'user_auth', count: 500, endpoint: '/api/auth/login' },\n        { type: 'vote_cast', count: 2000, endpoint: '/api/votes' },\n        { type: 'poll_create', count: 100, endpoint: '/api/polls' }\n      ];\n\n      const startTime = performance.now();\n      \n      // Mock different endpoints\n      mockFetch.mockImplementation((url) => {\n        if (url.includes('/api/feeds')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ feeds: [] }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/auth/login')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ token: 'auth-token' }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/votes')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ success: true }),\n            headers: new Map()\n          });\n        }\n        if (url.includes('/api/polls')) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve({ pollId: 'poll-123' }),\n            headers: new Map()\n          });\n        }\n        return Promise.resolve({ ok: true, status: 200, json: () => Promise.resolve({}) });\n      });\n\n      // Execute all operations concurrently\n      const allRequests = operations.flatMap(op => \n        Array.from({ length: op.count }, (_, i) => ({\n          type: op.type,\n          id: i,\n          endpoint: op.endpoint,\n          startTime: performance.now()\n        }))\n      );\n\n      const responses = await Promise.all(\n        allRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Performance assertions\n      expect(responses.length).toBe(3600); // Total operations\n      expect(totalTime).toBeLessThan(15000); // Should complete within 15 seconds\n      \n      // Check performance by operation type\n      const operationStats = operations.map(op => {\n        const opResponses = responses.filter(r => r.type === op.type);\n        const avgResponseTime = opResponses.reduce((sum, r) => sum + r.responseTime, 0) / opResponses.length;\n        return { type: op.type, count: opResponses.length, avgResponseTime };\n      });\n\n      operationStats.forEach(stat => {\n        expect(stat.count).toBeGreaterThan(0);\n        expect(stat.avgResponseTime).toBeLessThan(500); // Each operation type under 500ms average\n      });\n    });\n  });\n\n  describe('Database Performance Testing', () => {\n    it('should handle large dataset queries efficiently', async () => {\n      const largeDataset = Array.from({ length: 10000 }, (_, i) => ({\n        id: `item-${i}`,\n        title: `Item ${i}`,\n        content: `Content for item ${i}`,\n        category: `category-${i % 10}`,\n        createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString()\n      }));\n\n      const startTime = performance.now();\n      \n      // Simulate database query\n      const queryDatabase = async (query: string, limit: number = 100) => {\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 10)); // Simulate DB delay\n        return largeDataset.slice(0, limit);\n      };\n\n      // Test different query scenarios\n      const queries = [\n        { name: 'recent_items', query: 'SELECT * FROM items ORDER BY createdAt DESC LIMIT 100' },\n        { name: 'category_items', query: 'SELECT * FROM items WHERE category = \"category-1\" LIMIT 100' },\n        { name: 'search_items', query: 'SELECT * FROM items WHERE title LIKE \"%Item%\" LIMIT 100' }\n      ];\n\n      const results = await Promise.all(\n        queries.map(async (q) => {\n          const start = performance.now();\n          const data = await queryDatabase(q.query);\n          const end = performance.now();\n          return {\n            name: q.name,\n            dataLength: data.length,\n            queryTime: end - start\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Performance assertions\n      expect(totalTime).toBeLessThan(1000); // All queries under 1 second\n      results.forEach(result => {\n        expect(result.dataLength).toBe(100);\n        expect(result.queryTime).toBeLessThan(200); // Individual query under 200ms\n      });\n    });\n\n    it('should handle concurrent database writes', async () => {\n      const writeOperations = 1000;\n      const startTime = performance.now();\n      \n      // Simulate database write operations\n      const writeToDatabase = async (data: any) => {\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 5)); // Simulate DB write delay\n        return { id: `new-${Date.now()}`, ...data };\n      };\n\n      const writeRequests = Array.from({ length: writeOperations }, (_, i) => ({\n        id: i,\n        data: { title: `New Item ${i}`, content: `Content ${i}` },\n        startTime: performance.now()\n      }));\n\n      const results = await Promise.all(\n        writeRequests.map(async (request) => {\n          const result = await writeToDatabase(request.data);\n          return {\n            ...request,\n            endTime: performance.now(),\n            writeTime: performance.now() - request.startTime,\n            result\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      const averageWriteTime = results.reduce((sum, r) => sum + r.writeTime, 0) / results.length;\n\n      // Performance assertions\n      expect(results.length).toBe(writeOperations);\n      expect(totalTime).toBeLessThan(5000); // All writes under 5 seconds\n      expect(averageWriteTime).toBeLessThan(50); // Average write time under 50ms\n      \n      // All writes should succeed\n      results.forEach(result => {\n        expect(result.result.id).toBeDefined();\n        expect(result.writeTime).toBeLessThan(100); // Individual write under 100ms\n      });\n    });\n  });\n\n  describe('API Response Time Testing', () => {\n    it('should maintain fast API response times under load', async () => {\n      const apiEndpoints = [\n        '/api/feeds',\n        '/api/auth/status',\n        '/api/votes',\n        '/api/polls',\n        '/api/users/profile'\n      ];\n\n      const requestsPerEndpoint = 100;\n      const startTime = performance.now();\n      \n      // Mock API responses with realistic delays\n      mockFetch.mockImplementation((url) => {\n        const delay = Math.random() * 50 + 10; // 10-60ms delay\n        return new Promise(resolve => {\n          setTimeout(() => {\n            resolve({\n              ok: true,\n              status: 200,\n              json: () => Promise.resolve({ success: true, data: [] }),\n              headers: new Map()\n            });\n          }, delay);\n        });\n      });\n\n      // Test all endpoints concurrently\n      const allRequests = apiEndpoints.flatMap(endpoint =>\n        Array.from({ length: requestsPerEndpoint }, (_, i) => ({\n          endpoint,\n          id: i,\n          startTime: performance.now()\n        }))\n      );\n\n      const responses = await Promise.all(\n        allRequests.map(async (request) => {\n          const response = await fetch(request.endpoint);\n          return {\n            ...request,\n            endTime: performance.now(),\n            responseTime: performance.now() - request.startTime,\n            status: response.status\n          };\n        })\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Calculate performance metrics\n      const endpointStats = apiEndpoints.map(endpoint => {\n        const endpointResponses = responses.filter(r => r.endpoint === endpoint);\n        const avgResponseTime = endpointResponses.reduce((sum, r) => sum + r.responseTime, 0) / endpointResponses.length;\n        const maxResponseTime = Math.max(...endpointResponses.map(r => r.responseTime));\n        const minResponseTime = Math.min(...endpointResponses.map(r => r.responseTime));\n        \n        return {\n          endpoint,\n          count: endpointResponses.length,\n          avgResponseTime,\n          maxResponseTime,\n          minResponseTime\n        };\n      });\n\n      // Performance assertions\n      expect(totalTime).toBeLessThan(10000); // All requests under 10 seconds\n      \n      endpointStats.forEach(stat => {\n        expect(stat.count).toBe(requestsPerEndpoint);\n        expect(stat.avgResponseTime).toBeLessThan(100); // Average under 100ms\n        expect(stat.maxResponseTime).toBeLessThan(200); // Max under 200ms\n        expect(stat.minResponseTime).toBeGreaterThan(0); // Min greater than 0\n      });\n    });\n  });\n\n  describe('Stress Testing', () => {\n    it('should handle resource exhaustion gracefully', async () => {\n      const maxConcurrentRequests = 10000;\n      const startTime = performance.now();\n      \n      // Simulate resource exhaustion scenario\n      let activeRequests = 0;\n      let maxActiveRequests = 0;\n      \n      const simulateRequest = async (requestId: number) => {\n        activeRequests++;\n        maxActiveRequests = Math.max(maxActiveRequests, activeRequests);\n        \n        try {\n          // Simulate processing time\n          await new Promise(resolve => setTimeout(resolve, Math.random() * 100));\n          \n          // Simulate occasional failures under stress\n          if (Math.random() < 0.1) { // 10% failure rate under stress\n            throw new Error('Resource exhausted');\n          }\n          \n          return { requestId, success: true };\n        } catch (error) {\n          return { requestId, success: false, error: error.message };\n        } finally {\n          activeRequests--;\n        }\n      };\n\n      // Execute stress test\n      const requests = Array.from({ length: maxConcurrentRequests }, (_, i) => i);\n      const results = await Promise.all(\n        requests.map(requestId => simulateRequest(requestId))\n      );\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      const successCount = results.filter(r => r.success).length;\n      const failureCount = results.filter(r => !r.success).length;\n      const successRate = successCount / results.length;\n\n      // Stress test assertions\n      expect(results.length).toBe(maxConcurrentRequests);\n      expect(maxActiveRequests).toBeGreaterThan(0);\n      expect(successRate).toBeGreaterThan(0.8); // At least 80% success rate\n      expect(totalTime).toBeLessThan(30000); // Complete within 30 seconds\n      \n      // System should handle stress gracefully\n      expect(failureCount).toBeLessThan(maxConcurrentRequests * 0.3); // Less than 30% failures\n    });\n\n    it('should recover from peak load scenarios', async () => {\n      const peakLoadDuration = 5000; // 5 seconds\n      const recoveryDuration = 2000; // 2 seconds\n      const startTime = performance.now();\n      \n      // Simulate peak load scenario\n      const simulatePeakLoad = async () => {\n        const requests = Array.from({ length: 1000 }, (_, i) => ({\n          id: i,\n          startTime: performance.now()\n        }));\n        \n        const results = await Promise.all(\n          requests.map(async (request) => {\n            try {\n              // Simulate processing\n              await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n              return { ...request, success: true, endTime: performance.now() };\n            } catch (error) {\n              return { ...request, success: false, error: error.message, endTime: performance.now() };\n            }\n          })\n        );\n        \n        return results;\n      };\n      \n      // Execute peak load\n      const peakResults = await simulatePeakLoad();\n      const peakEndTime = performance.now();\n      const peakDuration = peakEndTime - startTime;\n      \n      // Wait for recovery\n      await new Promise(resolve => setTimeout(resolve, recoveryDuration));\n      \n      // Test recovery\n      const recoveryStartTime = performance.now();\n      const recoveryResults = await simulatePeakLoad();\n      const recoveryEndTime = performance.now();\n      const actualRecoveryDuration = recoveryEndTime - recoveryStartTime;\n      \n      // Recovery assertions\n      expect(peakResults.length).toBe(1000);\n      expect(recoveryResults.length).toBe(1000);\n      \n      // System should recover and perform well after peak load\n      const peakSuccessRate = peakResults.filter(r => r.success).length / peakResults.length;\n      const recoverySuccessRate = recoveryResults.filter(r => r.success).length / recoveryResults.length;\n      \n      expect(peakSuccessRate).toBeGreaterThan(0.7); // At least 70% success during peak\n      expect(recoverySuccessRate).toBeGreaterThan(0.9); // At least 90% success after recovery\n      expect(actualRecoveryDuration).toBeLessThan(peakDuration * 1.5); // Recovery should be reasonably fast\n    });\n  });\n\n  describe('Memory and Resource Testing', () => {\n    it('should handle memory-intensive operations', async () => {\n      const largeDataSize = 1000000; // 1 million items\n      const startTime = performance.now();\n      \n      // Generate large dataset\n      const largeDataset = Array.from({ length: largeDataSize }, (_, i) => ({\n        id: i,\n        data: `Large data item ${i}`.repeat(100), // Each item ~1KB\n        timestamp: Date.now()\n      }));\n      \n      // Process large dataset\n      const processLargeDataset = (data: any[]) => {\n        return data\n          .filter(item => item.id % 2 === 0) // Filter even IDs\n          .map(item => ({ ...item, processed: true })) // Transform\n          .slice(0, 1000); // Limit results\n      };\n      \n      const processedData = processLargeDataset(largeDataset);\n      const endTime = performance.now();\n      const processingTime = endTime - startTime;\n      \n      // Memory and performance assertions\n      expect(processedData.length).toBe(1000);\n      expect(processingTime).toBeLessThan(5000); // Should process within 5 seconds\n      expect(processedData.every(item => item.processed)).toBe(true);\n    });\n\n    it('should handle concurrent memory operations', async () => {\n      const concurrentOperations = 100;\n      const dataSizePerOperation = 10000;\n      \n      const startTime = performance.now();\n      \n      // Simulate concurrent memory operations\n      const memoryOperations = Array.from({ length: concurrentOperations }, (_, i) => {\n        const data = Array.from({ length: dataSizePerOperation }, (_, j) => ({\n          id: `${i}-${j}`,\n          value: Math.random() * 1000,\n          timestamp: Date.now()\n        }));\n        \n        // Process data\n        const processed = data\n          .filter(item => item.value > 500)\n          .map(item => ({ ...item, processed: true }))\n          .sort((a, b) => b.value - a.value)\n          .slice(0, 100);\n        \n        return processed;\n      });\n      \n      const results = await Promise.all(memoryOperations);\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Performance assertions\n      expect(results.length).toBe(concurrentOperations);\n      expect(totalTime).toBeLessThan(10000); // All operations under 10 seconds\n      \n      results.forEach(result => {\n        expect(result.length).toBeLessThanOrEqual(100);\n        expect(result.every(item => item.processed)).toBe(true);\n      });\n    });\n  });\n});\n\n\n\n"],"names":["mockTime","mockPerformance","now","jest","fn","Math","random","mark","measure","getEntriesByType","getEntriesByName","Object","defineProperty","window","value","writable","mockFetch","global","fetch","mockFeedsStore","feeds","isLoading","error","loadFeeds","refreshFeeds","loadMoreFeeds","setFilters","mock","useFeeds","useFeedsStore","selector","state","useFeedsLoading","useFeedsError","describe","beforeEach","clearAllMocks","it","concurrentUsers","startTime","performance","userRequests","Array","from","length","_","i","userId","requestTime","endpoint","method","mockImplementation","url","Promise","resolve","ok","status","json","success","data","headers","Map","responses","all","map","request","response","responseTime","endTime","totalTime","averageResponseTime","reduce","sum","r","expect","toBe","toBeLessThan","forEach","feedRequests","mockFeeds","id","title","content","author","name","publishedAt","Date","toISOString","engagement","likes","floor","comments","requests","dataLength","operations","type","count","includes","token","pollId","allRequests","flatMap","op","operationStats","opResponses","filter","avgResponseTime","stat","toBeGreaterThan","largeDataset","category","createdAt","queryDatabase","query","limit","setTimeout","slice","queries","results","q","start","end","queryTime","result","writeOperations","writeToDatabase","writeRequests","writeTime","averageWriteTime","toBeDefined","apiEndpoints","requestsPerEndpoint","delay","endpointStats","endpointResponses","maxResponseTime","max","minResponseTime","min","maxConcurrentRequests","activeRequests","maxActiveRequests","simulateRequest","requestId","Error","message","successCount","failureCount","successRate","peakLoadDuration","recoveryDuration","simulatePeakLoad","peakResults","peakEndTime","peakDuration","recoveryStartTime","recoveryResults","recoveryEndTime","actualRecoveryDuration","peakSuccessRate","recoverySuccessRate","largeDataSize","repeat","timestamp","processLargeDataset","item","processed","processedData","processingTime","every","concurrentOperations","dataSizePerOperation","memoryOperations","j","sort","a","b","toBeLessThanOrEqual"],"mappings":"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"}