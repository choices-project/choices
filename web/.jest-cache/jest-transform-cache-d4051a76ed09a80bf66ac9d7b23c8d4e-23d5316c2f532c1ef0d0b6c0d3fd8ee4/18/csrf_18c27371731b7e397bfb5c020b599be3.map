{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/app/api/auth/_shared/csrf.ts"],"sourcesContent":["import { randomBytes } from \"crypto\";\n\nimport { cookies } from \"next/headers\";\n\nimport { CSRF_COOKIE } from \"./cookies\";\n\n/**\n * CSRF Protection Module\n * \n * Implements double-submit token pattern:\n * 1. Server sets CSRF token in cookie\n * 2. Client sends same token in X-CSRF-Token header\n * 3. Server verifies tokens match\n * \n * This protects against Cross-Site Request Forgery attacks\n * by ensuring requests originate from the same origin.\n */\n\n/**\n * Generates a cryptographically secure random token\n * \n * @param length - Number of bytes to generate (default: 32)\n * @returns Hex-encoded random string\n */\nfunction generateCsrfToken(length: number = 32): string {\n  return randomBytes(length).toString(\"hex\");\n}\n\n/**\n * Gets existing CSRF token from cookie or creates a new one\n * \n * @returns CSRF token string\n */\nexport function getOrSetCsrfCookie(): string {\n  const cookieStore = cookies();\n  const existingToken = cookieStore.get(CSRF_COOKIE)?.value;\n  \n  if (existingToken) {\n    return existingToken;\n  }\n  \n  // Generate new token if none exists\n  const newToken = generateCsrfToken();\n  \n  // Set cookie with appropriate configuration\n  const isProduction = process.env.NODE_ENV === \"production\";\n  cookieStore.set(CSRF_COOKIE, newToken, {\n    httpOnly: false, // Client needs to read this\n    secure: isProduction,\n    sameSite: \"lax\",\n    path: \"/\",\n    maxAge: 60 * 60 * 24 * 7, // 7 days\n  });\n  \n  return newToken;\n}\n\n/**\n * Verifies CSRF token from request header against cookie\n * \n * @param headerToken - Token from X-CSRF-Token header\n * @returns true if tokens match, false otherwise\n */\nexport function verifyCsrfToken(headerToken?: string): boolean {\n  if (!headerToken) {\n    return false;\n  }\n  \n  const cookieStore = cookies();\n  const cookieToken = cookieStore.get(CSRF_COOKIE)?.value;\n  \n  if (!cookieToken) {\n    return false;\n  }\n  \n  // Use constant-time comparison to prevent timing attacks\n  return headerToken === cookieToken;\n}\n\n/**\n * Checks if CSRF protection is required for the given HTTP method\n * \n * @param method - HTTP method from request\n * @returns true if CSRF protection is required\n */\nexport function requiresCsrfProtection(method: string): boolean {\n  const safeMethods = [\"GET\", \"HEAD\", \"OPTIONS\"];\n  return !safeMethods.includes(method.toUpperCase());\n}\n\n/**\n * Validates CSRF protection for a request\n * \n * @param request - Request object containing method and headers\n * @returns true if CSRF validation passes or is not required\n */\nexport function validateCsrfProtection(request: Request): boolean {\n  const method = request.method;\n  \n  // Skip CSRF check for safe methods\n  if (!requiresCsrfProtection(method)) {\n    return true;\n  }\n  \n  // Skip CSRF check for E2E tests and development\n  const isE2E = request.headers.get('x-e2e-bypass') === '1' || \n                process.env.NODE_ENV === 'test' || \n                process.env.E2E === '1';\n  \n  if (isE2E) {\n    return true;\n  }\n  \n  // Get CSRF token from header\n  const headerToken = request.headers.get(\"x-csrf-token\");\n  \n  // Verify token\n  return verifyCsrfToken(headerToken || undefined);\n}\n\n/**\n * Creates a CSRF validation error response\n * \n * @returns NextResponse with 403 Forbidden status\n */\nexport function createCsrfErrorResponse(): Response {\n  return new Response(\n    JSON.stringify({ \n      error: \"CSRF token validation failed\",\n      message: \"Request blocked for security reasons\"\n    }),\n    {\n      status: 403,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n}\n"],"names":["createCsrfErrorResponse","getOrSetCsrfCookie","requiresCsrfProtection","validateCsrfProtection","verifyCsrfToken","generateCsrfToken","length","randomBytes","toString","cookieStore","cookies","existingToken","get","CSRF_COOKIE","value","newToken","isProduction","process","env","NODE_ENV","set","httpOnly","secure","sameSite","path","maxAge","headerToken","cookieToken","method","safeMethods","includes","toUpperCase","request","isE2E","headers","E2E","undefined","Response","JSON","stringify","error","message","status"],"mappings":";;;;;;;;;;;IA6HgBA,uBAAuB;eAAvBA;;IA5FAC,kBAAkB;eAAlBA;;IAoDAC,sBAAsB;eAAtBA;;IAWAC,sBAAsB;eAAtBA;;IAjCAC,eAAe;eAAfA;;;wBA/DY;yBAEJ;yBAEI;AAE5B;;;;;;;;;;CAUC,GAED;;;;;CAKC,GACD,SAASC,kBAAkBC,SAAiB,EAAE;IAC5C,OAAOC,IAAAA,mBAAW,EAACD,QAAQE,QAAQ,CAAC;AACtC;AAOO,SAASP;IACd,MAAMQ,cAAcC,IAAAA,gBAAO;IAC3B,MAAMC,gBAAgBF,YAAYG,GAAG,CAACC,oBAAW,GAAGC;IAEpD,IAAIH,eAAe;QACjB,OAAOA;IACT;IAEA,oCAAoC;IACpC,MAAMI,WAAWV;IAEjB,4CAA4C;IAC5C,MAAMW,eAAeC,QAAQC,GAAG,CAACC,QAAQ,KAAK;IAC9CV,YAAYW,GAAG,CAACP,oBAAW,EAAEE,UAAU;QACrCM,UAAU;QACVC,QAAQN;QACRO,UAAU;QACVC,MAAM;QACNC,QAAQ,KAAK,KAAK,KAAK;IACzB;IAEA,OAAOV;AACT;AAQO,SAASX,gBAAgBsB,WAAoB;IAClD,IAAI,CAACA,aAAa;QAChB,OAAO;IACT;IAEA,MAAMjB,cAAcC,IAAAA,gBAAO;IAC3B,MAAMiB,cAAclB,YAAYG,GAAG,CAACC,oBAAW,GAAGC;IAElD,IAAI,CAACa,aAAa;QAChB,OAAO;IACT;IAEA,yDAAyD;IACzD,OAAOD,gBAAgBC;AACzB;AAQO,SAASzB,uBAAuB0B,MAAc;IACnD,MAAMC,cAAc;QAAC;QAAO;QAAQ;KAAU;IAC9C,OAAO,CAACA,YAAYC,QAAQ,CAACF,OAAOG,WAAW;AACjD;AAQO,SAAS5B,uBAAuB6B,OAAgB;IACrD,MAAMJ,SAASI,QAAQJ,MAAM;IAE7B,mCAAmC;IACnC,IAAI,CAAC1B,uBAAuB0B,SAAS;QACnC,OAAO;IACT;IAEA,gDAAgD;IAChD,MAAMK,QAAQD,QAAQE,OAAO,CAACtB,GAAG,CAAC,oBAAoB,OACxCK,QAAQC,GAAG,CAACC,QAAQ,KAAK,UACzBF,QAAQC,GAAG,CAACiB,GAAG,KAAK;IAElC,IAAIF,OAAO;QACT,OAAO;IACT;IAEA,6BAA6B;IAC7B,MAAMP,cAAcM,QAAQE,OAAO,CAACtB,GAAG,CAAC;IAExC,eAAe;IACf,OAAOR,gBAAgBsB,eAAeU;AACxC;AAOO,SAASpC;IACd,OAAO,IAAIqC,SACTC,KAAKC,SAAS,CAAC;QACbC,OAAO;QACPC,SAAS;IACX,IACA;QACEC,QAAQ;QACRR,SAAS;YACP,gBAAgB;QAClB;IACF;AAEJ"}