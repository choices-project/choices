f58b474b86c517df951cc1a3aeb149af
/**
 * Login API Route Tests
 * 
 * Tests the POST /api/auth/login endpoint including:
 * - Authentication flow
 * - Input validation
 * - Error handling
 * - Security measures
 * - Rate limiting
 */ "use strict";
jest.mock("@/utils/supabase/server", ()=>({
        getSupabaseServerClient: jest.fn(()=>Promise.resolve(mockSupabaseClient))
    }));
// Mock rate limiting
jest.mock("@/lib/core/security/rate-limit", ()=>({
        rateLimiters: {
            auth: {
                check: jest.fn()
            }
        }
    }));
// Mock CSRF protection
jest.mock("@/app/api/auth/_shared", ()=>({
        validateCsrfProtection: jest.fn(()=>true),
        createCsrfErrorResponse: jest.fn(()=>new Response("CSRF Error", {
                status: 403
            }))
    }));
// Mock logger
jest.mock("@/lib/utils/logger", ()=>({
        logger: {
            warn: jest.fn(),
            info: jest.fn(),
            error: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _route = require("../../../../../app/api/auth/login/route");
// Mock Supabase client
const mockSupabaseClient = {
    auth: {
        signInWithPassword: jest.fn()
    },
    from: jest.fn(()=>({
            select: jest.fn(()=>({
                    eq: jest.fn(()=>({
                            single: jest.fn()
                        }))
                }))
        }))
};
(0, _globals.describe)("Login API Route", ()=>{
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        jest.resetAllMocks();
    });
    (0, _globals.describe)("Successful Authentication", ()=>{
        (0, _globals.it)("should authenticate user with valid credentials", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com",
                user_metadata: {
                    username: "testuser"
                }
            };
            const mockProfile = {
                user_id: "user-123",
                onboarding_completed: true,
                is_active: true
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: mockProfile,
                                    error: null
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.success).toBe(true);
            (0, _globals.expect)(responseData.user.id).toBe("user-123");
            (0, _globals.expect)(responseData.user.email).toBe("test@example.com");
        });
        (0, _globals.it)("should handle user without completed onboarding", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com"
            };
            const mockProfile = {
                user_id: "user-123",
                onboarding_completed: false,
                is_active: true
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: mockProfile,
                                    error: null
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.requiresOnboarding).toBe(true);
        });
    });
    (0, _globals.describe)("Input Validation", ()=>{
        (0, _globals.it)("should reject request with missing email", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(responseData.message).toBe("Email and password are required");
        });
        (0, _globals.it)("should reject request with missing password", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(responseData.message).toBe("Email and password are required");
        });
        (0, _globals.it)("should reject request with empty email", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(responseData.message).toBe("Email and password are required");
        });
        (0, _globals.it)("should reject request with empty password", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: ""
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(responseData.message).toBe("Email and password are required");
        });
    });
    (0, _globals.describe)("Authentication Errors", ()=>{
        (0, _globals.it)("should handle invalid credentials", async ()=>{
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: null
                },
                error: {
                    message: "Invalid login credentials"
                }
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "wrongpassword"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(responseData.message).toBe("Invalid email or password");
        });
        (0, _globals.it)("should handle user not found", async ()=>{
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: null
                },
                error: {
                    message: "User not found"
                }
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "nonexistent@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(responseData.message).toBe("Invalid email or password");
        });
        (0, _globals.it)("should handle inactive user", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com"
            };
            const mockProfile = {
                user_id: "user-123",
                onboarding_completed: true,
                is_active: false
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: mockProfile,
                                    error: null
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(403);
            (0, _globals.expect)(responseData.message).toBe("Account is inactive");
        });
    });
    (0, _globals.describe)("Rate Limiting", ()=>{
        (0, _globals.it)("should handle rate limit exceeded", async ()=>{
            const { rateLimiters } = require("@/lib/core/security/rate-limit");
            rateLimiters.auth.check.mockResolvedValue({
                allowed: false,
                remaining: 0,
                resetTime: Date.now() + 900000
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(429);
            (0, _globals.expect)(responseData.message).toBe("Too many login attempts. Please try again later.");
        });
    });
    (0, _globals.describe)("CSRF Protection", ()=>{
        (0, _globals.it)("should handle CSRF protection failure", async ()=>{
            const { validateCsrfProtection } = require("@/app/api/auth/_shared");
            validateCsrfProtection.mockReturnValue(false);
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            (0, _globals.expect)(response.status).toBe(403);
        });
    });
    (0, _globals.describe)("Server Errors", ()=>{
        (0, _globals.it)("should handle Supabase client unavailable", async ()=>{
            const { getSupabaseServerClient } = require("@/utils/supabase/server");
            getSupabaseServerClient.mockResolvedValue(null);
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(responseData.message).toBe("Authentication service unavailable");
        });
        (0, _globals.it)("should handle profile lookup error", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com"
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: null,
                                    error: {
                                        message: "Profile not found"
                                    }
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.requiresOnboarding).toBe(true);
        });
    });
    (0, _globals.describe)("Security Measures", ()=>{
        (0, _globals.it)("should normalize email to lowercase", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com"
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        user_id: "user-123",
                                        onboarding_completed: true,
                                        is_active: true
                                    },
                                    error: null
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "TEST@EXAMPLE.COM",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(mockSupabaseClient.auth.signInWithPassword).toHaveBeenCalledWith({
                email: "test@example.com",
                password: "password123"
            });
        });
        (0, _globals.it)("should trim email whitespace", async ()=>{
            const mockUser = {
                id: "user-123",
                email: "test@example.com"
            };
            mockSupabaseClient.auth.signInWithPassword.mockResolvedValue({
                data: {
                    user: mockUser
                },
                error: null
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn(()=>({
                        eq: jest.fn(()=>({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        user_id: "user-123",
                                        onboarding_completed: true,
                                        is_active: true
                                    },
                                    error: null
                                })
                            }))
                    }))
            });
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "  test@example.com  ",
                    password: "password123"
                })
            });
            const response = await (0, _route.POST)(request);
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(mockSupabaseClient.auth.signInWithPassword).toHaveBeenCalledWith({
                email: "test@example.com",
                password: "password123"
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYXBpL2F1dGgvbG9naW4tcm91dGUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZ2luIEFQSSBSb3V0ZSBUZXN0c1xuICogXG4gKiBUZXN0cyB0aGUgUE9TVCAvYXBpL2F1dGgvbG9naW4gZW5kcG9pbnQgaW5jbHVkaW5nOlxuICogLSBBdXRoZW50aWNhdGlvbiBmbG93XG4gKiAtIElucHV0IHZhbGlkYXRpb25cbiAqIC0gRXJyb3IgaGFuZGxpbmdcbiAqIC0gU2VjdXJpdHkgbWVhc3VyZXNcbiAqIC0gUmF0ZSBsaW1pdGluZ1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgUE9TVCB9IGZyb20gJ0AvYXBwL2FwaS9hdXRoL2xvZ2luL3JvdXRlJztcblxuLy8gTW9jayBTdXBhYmFzZSBjbGllbnRcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgYXV0aDoge1xuICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLFxuICB9LFxuICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKSxcbiAgICAgIH0pKSxcbiAgICB9KSksXG4gIH0pKSxcbn07XG5cbmplc3QubW9jaygnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInLCAoKSA9PiAoe1xuICBnZXRTdXBhYmFzZVNlcnZlckNsaWVudDogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1cGFiYXNlQ2xpZW50KSksXG59KSk7XG5cbi8vIE1vY2sgcmF0ZSBsaW1pdGluZ1xuamVzdC5tb2NrKCdAL2xpYi9jb3JlL3NlY3VyaXR5L3JhdGUtbGltaXQnLCAoKSA9PiAoe1xuICByYXRlTGltaXRlcnM6IHtcbiAgICBhdXRoOiB7XG4gICAgICBjaGVjazogamVzdC5mbigpLFxuICAgIH0sXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgQ1NSRiBwcm90ZWN0aW9uXG5qZXN0Lm1vY2soJ0AvYXBwL2FwaS9hdXRoL19zaGFyZWQnLCAoKSA9PiAoe1xuICB2YWxpZGF0ZUNzcmZQcm90ZWN0aW9uOiBqZXN0LmZuKCgpID0+IHRydWUpLFxuICBjcmVhdGVDc3JmRXJyb3JSZXNwb25zZTogamVzdC5mbigoKSA9PiBuZXcgUmVzcG9uc2UoJ0NTUkYgRXJyb3InLCB7IHN0YXR1czogNDAzIH0pKSxcbn0pKTtcblxuLy8gTW9jayBsb2dnZXJcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgbG9nZ2VyOiB7XG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICB9LFxufSkpO1xuXG5kZXNjcmliZSgnTG9naW4gQVBJIFJvdXRlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc2V0QWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N1Y2Nlc3NmdWwgQXV0aGVudGljYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhdXRoZW50aWNhdGUgdXNlciB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB1c2VyX21ldGFkYXRhOiB7XG4gICAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUHJvZmlsZSA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXItMTIzJyxcbiAgICAgICAgb25ib2FyZGluZ19jb21wbGV0ZWQ6IHRydWUsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbW9ja1Byb2ZpbGUsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9KSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEudXNlci5pZCkudG9CZSgndXNlci0xMjMnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEudXNlci5lbWFpbCkudG9CZSgndGVzdEBleGFtcGxlLmNvbScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXNlciB3aXRob3V0IGNvbXBsZXRlZCBvbmJvYXJkaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1Byb2ZpbGUgPSB7XG4gICAgICAgIHVzZXJfaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIG9uYm9hcmRpbmdfY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmF1dGguc2lnbkluV2l0aFBhc3N3b3JkLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyB1c2VyOiBtb2NrVXNlciB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBtb2NrUHJvZmlsZSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0pKSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5yZXF1aXJlc09uYm9hcmRpbmcpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnB1dCBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IHJlcXVlc3Qgd2l0aCBtaXNzaW5nIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhLm1lc3NhZ2UpLnRvQmUoJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHJlcXVlc3Qgd2l0aCBtaXNzaW5nIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEubWVzc2FnZSkudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgcmVxdWVzdCB3aXRoIGVtcHR5IGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJycsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5tZXNzYWdlKS50b0JlKCdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCByZXF1ZXN0IHdpdGggZW1wdHkgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEubWVzc2FnZSkudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXV0aGVudGljYXRpb24gRXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwgfSxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnVXNlciBub3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhLm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGluYWN0aXZlIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUHJvZmlsZSA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXItMTIzJyxcbiAgICAgICAgb25ib2FyZGluZ19jb21wbGV0ZWQ6IHRydWUsXG4gICAgICAgIGlzX2FjdGl2ZTogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHVzZXI6IG1vY2tVc2VyIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tQcm9maWxlLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSkpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMyk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhLm1lc3NhZ2UpLnRvQmUoJ0FjY291bnQgaXMgaW5hY3RpdmUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmF0ZSBsaW1pdCBleGNlZWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmF0ZUxpbWl0ZXJzIH0gPSByZXF1aXJlKCdAL2xpYi9jb3JlL3NlY3VyaXR5L3JhdGUtbGltaXQnKTtcbiAgICAgIHJhdGVMaW1pdGVycy5hdXRoLmNoZWNrLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgYWxsb3dlZDogZmFsc2UsXG4gICAgICAgIHJlbWFpbmluZzogMCxcbiAgICAgICAgcmVzZXRUaW1lOiBEYXRlLm5vdygpICsgOTAwMDAwLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQyOSk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhLm1lc3NhZ2UpLnRvQmUoJ1RvbyBtYW55IGxvZ2luIGF0dGVtcHRzLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ1NSRiBQcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIENTUkYgcHJvdGVjdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB2YWxpZGF0ZUNzcmZQcm90ZWN0aW9uIH0gPSByZXF1aXJlKCdAL2FwcC9hcGkvYXV0aC9fc2hhcmVkJyk7XG4gICAgICB2YWxpZGF0ZUNzcmZQcm90ZWN0aW9uLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZXJ2ZXIgRXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIFN1cGFiYXNlIGNsaWVudCB1bmF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSA9IHJlcXVpcmUoJ0AvdXRpbHMvc3VwYWJhc2Uvc2VydmVyJyk7XG4gICAgICBnZXRTdXBhYmFzZVNlcnZlckNsaWVudC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gc2VydmljZSB1bmF2YWlsYWJsZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcHJvZmlsZSBsb29rdXAgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICB9O1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHVzZXI6IG1vY2tVc2VyIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdQcm9maWxlIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSkpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhLnJlcXVpcmVzT25ib2FyZGluZykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5IE1lYXN1cmVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm9ybWFsaXplIGVtYWlsIHRvIGxvd2VyY2FzZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLnNpZ25JbldpdGhQYXNzd29yZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogeyB1c2VyX2lkOiAndXNlci0xMjMnLCBvbmJvYXJkaW5nX2NvbXBsZXRlZDogdHJ1ZSwgaXNfYWN0aXZlOiB0cnVlIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9KSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ1RFU1RARVhBTVBMRS5DT00nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJpbSBlbWFpbCB3aGl0ZXNwYWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgfTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmF1dGguc2lnbkluV2l0aFBhc3N3b3JkLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyB1c2VyOiBtb2NrVXNlciB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiB7IHVzZXJfaWQ6ICd1c2VyLTEyMycsIG9uYm9hcmRpbmdfY29tcGxldGVkOiB0cnVlLCBpc19hY3RpdmU6IHRydWUgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0pKSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAnICB0ZXN0QGV4YW1wbGUuY29tICAnLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldFN1cGFiYXNlU2VydmVyQ2xpZW50IiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vY2tTdXBhYmFzZUNsaWVudCIsInJhdGVMaW1pdGVycyIsImF1dGgiLCJjaGVjayIsInZhbGlkYXRlQ3NyZlByb3RlY3Rpb24iLCJjcmVhdGVDc3JmRXJyb3JSZXNwb25zZSIsIlJlc3BvbnNlIiwic3RhdHVzIiwibG9nZ2VyIiwid2FybiIsImluZm8iLCJlcnJvciIsInNpZ25JbldpdGhQYXNzd29yZCIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJyZXNldEFsbE1vY2tzIiwiaXQiLCJtb2NrVXNlciIsImlkIiwiZW1haWwiLCJ1c2VyX21ldGFkYXRhIiwidXNlcm5hbWUiLCJtb2NrUHJvZmlsZSIsInVzZXJfaWQiLCJvbmJvYXJkaW5nX2NvbXBsZXRlZCIsImlzX2FjdGl2ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsInVzZXIiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXNzd29yZCIsInJlc3BvbnNlIiwiUE9TVCIsInJlc3BvbnNlRGF0YSIsImpzb24iLCJleHBlY3QiLCJ0b0JlIiwic3VjY2VzcyIsInJlcXVpcmVzT25ib2FyZGluZyIsIm1lc3NhZ2UiLCJyZXF1aXJlIiwiYWxsb3dlZCIsInJlbWFpbmluZyIsInJlc2V0VGltZSIsIkRhdGUiLCJub3ciLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDO0FBb0JEQSxLQUFLQyxJQUFJLENBQUMsMkJBQTJCLElBQU8sQ0FBQTtRQUMxQ0MseUJBQXlCRixLQUFLRyxFQUFFLENBQUMsSUFBTUMsUUFBUUMsT0FBTyxDQUFDQztJQUN6RCxDQUFBO0FBRUEscUJBQXFCO0FBQ3JCTixLQUFLQyxJQUFJLENBQUMsa0NBQWtDLElBQU8sQ0FBQTtRQUNqRE0sY0FBYztZQUNaQyxNQUFNO2dCQUNKQyxPQUFPVCxLQUFLRyxFQUFFO1lBQ2hCO1FBQ0Y7SUFDRixDQUFBO0FBRUEsdUJBQXVCO0FBQ3ZCSCxLQUFLQyxJQUFJLENBQUMsMEJBQTBCLElBQU8sQ0FBQTtRQUN6Q1Msd0JBQXdCVixLQUFLRyxFQUFFLENBQUMsSUFBTTtRQUN0Q1EseUJBQXlCWCxLQUFLRyxFQUFFLENBQUMsSUFBTSxJQUFJUyxTQUFTLGNBQWM7Z0JBQUVDLFFBQVE7WUFBSTtJQUNsRixDQUFBO0FBRUEsY0FBYztBQUNkYixLQUFLQyxJQUFJLENBQUMsc0JBQXNCLElBQU8sQ0FBQTtRQUNyQ2EsUUFBUTtZQUNOQyxNQUFNZixLQUFLRyxFQUFFO1lBQ2JhLE1BQU1oQixLQUFLRyxFQUFFO1lBQ2JjLE9BQU9qQixLQUFLRyxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTs7Ozt5QkE1QzREO3dCQUNoQzt1QkFDUDtBQUVyQix1QkFBdUI7QUFDdkIsTUFBTUcscUJBQXFCO0lBQ3pCRSxNQUFNO1FBQ0pVLG9CQUFvQmxCLEtBQUtHLEVBQUU7SUFDN0I7SUFDQWdCLE1BQU1uQixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO1lBQ25CaUIsUUFBUXBCLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7b0JBQ3JCa0IsSUFBSXJCLEtBQUtHLEVBQUUs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