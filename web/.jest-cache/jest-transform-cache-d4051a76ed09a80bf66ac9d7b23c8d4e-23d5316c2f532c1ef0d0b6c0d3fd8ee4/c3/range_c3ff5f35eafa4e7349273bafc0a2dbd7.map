{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/strategies/range.ts"],"sourcesContent":["/**\n * Range Voting Strategy\n * \n * Implements range voting where voters rate each option on a scale.\n * Results show the average rating for each option, with the highest average winning.\n * \n * Created: September 15, 2025\n * Updated: September 15, 2025\n */\n\nimport { devLog } from '@/lib/utils/logger';\nimport { withOptional } from '@/lib/utils/objects';\n\nimport type { \n  VotingStrategy, \n  VoteRequest, \n  VoteResponse, \n  VoteValidation, \n  PollData, \n  VoteData, \n  ResultsData,\n  VotingMethod,\n  PollResults\n} from '../types';\n\nexport class RangeStrategy implements VotingStrategy {\n  \n  getVotingMethod(): VotingMethod {\n    return 'range';\n  }\n\n  async validateVote(request: VoteRequest, poll: PollData): Promise<VoteValidation> {\n    try {\n      const { voteData } = request;\n      \n      // Check if ratings object is provided\n      if (!voteData.ratings || typeof voteData.ratings !== 'object') {\n        return {\n          isValid: false,\n          error: 'Ratings object is required for range voting',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      const ratings = voteData.ratings;\n      const rangeMin = poll.votingConfig.rangeMin || 0;\n      const rangeMax = poll.votingConfig.rangeMax || 10;\n      \n      // Validate all ratings are within range\n      for (const [optionIndex, rating] of Object.entries(ratings)) {\n        if (typeof rating !== 'number' || isNaN(rating)) {\n          return {\n            isValid: false,\n            error: 'All ratings must be valid numbers',\n            requiresAuthentication: true,\n            requiresTokens: false\n          };\n        }\n\n        if (rating < rangeMin || rating > rangeMax) {\n          return {\n            isValid: false,\n            error: `Rating must be between ${rangeMin} and ${rangeMax}`,\n            requiresAuthentication: true,\n            requiresTokens: false\n          };\n        }\n\n        // Validate option index is valid\n        const optionIdx = parseInt(optionIndex);\n        if (optionIdx < 0 || optionIdx >= poll.options.length) {\n          return {\n            isValid: false,\n            error: `Invalid option index: ${optionIndex}`,\n            requiresAuthentication: true,\n            requiresTokens: false\n          };\n        }\n      }\n\n      // Check if all options are rated\n      if (Object.keys(ratings).length !== poll.options.length) {\n        return {\n          isValid: false,\n          error: 'All options must be rated',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      // Check if at least one option has a non-zero rating\n      const hasNonZeroRating = Object.values(ratings).some(rating => (rating) > rangeMin);\n      if (!hasNonZeroRating) {\n        return {\n          isValid: false,\n          error: 'At least one option must have a rating above the minimum',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      devLog('Range vote validated successfully', {\n        pollId: request.pollId,\n        ratings,\n        rangeMin,\n        rangeMax,\n        userId: request.userId\n      });\n\n      return {\n        isValid: true,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n\n    } catch (error) {\n      devLog('Range vote validation error:', error);\n      return {\n        isValid: false,\n        error: error instanceof Error ? error.message : 'Validation failed',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n  }\n\n  async processVote(request: VoteRequest, poll: PollData): Promise<VoteResponse> {\n    try {\n      const { voteData, userId, pollId, privacyLevel } = request;\n      \n      // Generate vote ID\n      const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create audit receipt\n      const auditReceipt = `receipt_${voteId}_${Date.now()}`;\n\n      // Calculate total score for audit\n      const ratings = voteData.ratings || {};\n      const totalScore = Object.values(ratings).reduce((sum: number, rating) => sum + (rating), 0);\n      const averageScore = Object.keys(ratings).length > 0 ? (totalScore) / Object.keys(ratings).length : 0;\n\n      // Store the vote in the database\n      await this.saveVoteToDatabase({\n        pollId,\n        voteId,\n        userId,\n        voteData,\n        auditReceipt,\n        privacyLevel\n      });\n\n      devLog('Range vote processed successfully', {\n        pollId,\n        voteId,\n        ratings,\n        totalScore,\n        averageScore,\n        userId,\n        auditReceipt\n      });\n\n      return withOptional(\n        {\n          success: true,\n          message: 'Vote submitted successfully',\n          pollId,\n          voteId,\n          auditReceipt,\n          responseTime: 0, // Will be set by the engine\n          metadata: {\n            votingMethod: 'range',\n            ratings,\n            totalScore,\n            averageScore,\n            rangeMin: poll.votingConfig.rangeMin || 0,\n            rangeMax: poll.votingConfig.rangeMax || 10\n          }\n        },\n        {\n          privacyLevel\n        }\n      );\n\n    } catch (error) {\n      devLog('Range vote processing error:', error);\n      return withOptional(\n        {\n          success: false,\n          message: error instanceof Error ? error.message : 'Vote processing failed',\n          pollId: request.pollId,\n          responseTime: 0,\n          metadata: {\n            votingMethod: 'range',\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        },\n        {\n          voteId: undefined,\n          auditReceipt: undefined,\n          privacyLevel: request.privacyLevel\n        }\n      );\n    }\n  }\n\n  async calculateResults(poll: PollData, votes: VoteData[]): Promise<ResultsData> {\n    try {\n      const startTime = Date.now();\n      \n      // Calculate range scores and averages for each option\n      const rangeScores: Record<string, number> = {};\n      const rangeAverages: Record<string, number> = {};\n      const optionVotes: Record<string, number> = {};\n      const optionPercentages: Record<string, number> = {};\n      const ratingCounts: Record<string, number> = {};\n      \n      // Initialize scores\n      poll.options.forEach((_, index) => {\n        rangeScores[index.toString()] = 0;\n        rangeAverages[index.toString()] = 0;\n        optionVotes[index.toString()] = 0;\n        optionPercentages[index.toString()] = 0;\n        ratingCounts[index.toString()] = 0;\n      });\n\n      // Calculate scores from votes\n      let totalVotes = 0;\n      votes.forEach(vote => {\n        if (vote.ratings && typeof vote.ratings === 'object') {\n          totalVotes++;\n          Object.entries(vote.ratings).forEach(([optionIndex, rating]) => {\n            const ratingNum = rating;\n            const optionIdx = optionIndex.toString();\n            // Ensure the option exists in our tracking objects\n            if (rangeScores[optionIdx] !== undefined && \n                ratingCounts[optionIdx] !== undefined && \n                optionVotes[optionIdx] !== undefined) {\n              rangeScores[optionIdx] += ratingNum;\n              ratingCounts[optionIdx]++;\n              optionVotes[optionIdx]++;\n            }\n          });\n        }\n      });\n\n      // Calculate averages\n      Object.keys(rangeScores).forEach(optionIndex => {\n        const count = ratingCounts[optionIndex];\n        const score = rangeScores[optionIndex];\n        if (count !== undefined && score !== undefined && count > 0) {\n          rangeAverages[optionIndex] = score / count;\n        }\n      });\n\n      // Calculate percentages (based on vote count)\n      if (totalVotes > 0) {\n        Object.keys(optionVotes).forEach(optionIndex => {\n          const votes = optionVotes[optionIndex];\n          if (votes !== undefined) {\n            optionPercentages[optionIndex] = (votes / totalVotes) * 100;\n          }\n        });\n      }\n\n      // Find winner (highest average rating)\n      let winner: string | undefined;\n      let winnerVotes = 0;\n      let winnerPercentage = 0;\n\n      if (totalVotes > 0) {\n        Object.entries(rangeAverages).forEach(([optionIndex, average]) => {\n          if (average > winnerVotes) {\n            winner = optionIndex;\n            winnerVotes = average;\n            winnerPercentage = optionPercentages[optionIndex] ?? 0;\n          }\n        });\n      }\n\n      const results: PollResults = withOptional(\n        {\n          winnerVotes,\n          winnerPercentage,\n          rangeScores,\n          rangeAverages,\n          optionVotes,\n          optionPercentages,\n          abstentions: 0,\n          abstentionPercentage: 0\n        },\n        {\n          winner\n        }\n      );\n\n      const resultsData: ResultsData = {\n        pollId: poll.id,\n        votingMethod: 'range',\n        totalVotes,\n        participationRate: totalVotes > 0 ? 100 : 0, // This would be calculated based on eligible voters\n        results,\n        calculatedAt: new Date().toISOString(),\n        metadata: {\n          calculationTime: Date.now() - startTime,\n          hasWinner: winner !== undefined,\n          isTie: winnerVotes > 0 && Object.values(rangeAverages).filter(a => a === winnerVotes).length > 1,\n          averageRating: totalVotes > 0 ? Object.values(rangeScores).reduce((sum, score) => sum + score, 0) / (Object.values(ratingCounts).reduce((sum, count) => sum + count, 0) || 1) : 0,\n          rangeMin: poll.votingConfig.rangeMin || 0,\n          rangeMax: poll.votingConfig.rangeMax || 10\n        }\n      };\n\n      devLog('Range results calculated', {\n        pollId: poll.id,\n        totalVotes,\n        winner,\n        winnerVotes,\n        winnerPercentage,\n        calculationTime: Date.now() - startTime\n      });\n\n      return resultsData;\n\n    } catch (error) {\n      devLog('Range results calculation error:', error);\n      throw new Error(`Failed to calculate range results: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  getConfiguration(): Record<string, unknown> {\n    return {\n      name: 'Range Voting',\n      description: 'Voters rate each option on a scale. The option with the highest average rating wins.',\n      minOptions: 2,\n      maxOptions: 20,\n      allowAbstention: false,\n      requiresRanking: false,\n      allowsMultipleSelections: true,\n      resultType: 'highest_average',\n      features: [\n        'Captures intensity of preference',\n        'Allows nuanced expression',\n        'Good for satisfaction surveys',\n        'Provides detailed feedback'\n      ],\n      limitations: [\n        'Requires rating all options',\n        'Can be time-consuming',\n        'May not reflect true preferences',\n        'Susceptible to strategic voting'\n      ],\n      defaultRangeMin: 0,\n      defaultRangeMax: 10,\n      allowDecimals: true\n    };\n  }\n\n  private async saveVoteToDatabase(voteData: {\n    pollId: string;\n    voteId: string;\n    userId?: string;\n    voteData: any;\n    auditReceipt: string;\n    privacyLevel?: string;\n  }): Promise<void> {\n    try {\n      // Import the VoteEngine to use its saveVote method\n      const { VoteEngine } = await import('../engine');\n      const engine = new VoteEngine();\n      \n      // Use the engine's saveVote method to persist the vote\n      await engine.saveVote({\n        pollId: voteData.pollId,\n        voteId: voteData.voteId,\n        userId: voteData.userId,\n        voteData: voteData.voteData,\n        auditReceipt: voteData.auditReceipt,\n        privacyLevel: voteData.privacyLevel\n      });\n      \n      devLog('Vote saved to database successfully', {\n        pollId: voteData.pollId,\n        voteId: voteData.voteId,\n        userId: voteData.userId\n      });\n    } catch (error) {\n      devLog('Failed to save vote to database:', error);\n      throw new Error(`Database save failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n}"],"names":["RangeStrategy","getVotingMethod","validateVote","request","poll","voteData","ratings","isValid","error","requiresAuthentication","requiresTokens","rangeMin","votingConfig","rangeMax","optionIndex","rating","Object","entries","isNaN","optionIdx","parseInt","options","length","keys","hasNonZeroRating","values","some","devLog","pollId","userId","Error","message","processVote","privacyLevel","voteId","Date","now","Math","random","toString","substr","auditReceipt","totalScore","reduce","sum","averageScore","saveVoteToDatabase","withOptional","success","responseTime","metadata","votingMethod","undefined","calculateResults","votes","startTime","rangeScores","rangeAverages","optionVotes","optionPercentages","ratingCounts","forEach","_","index","totalVotes","vote","ratingNum","count","score","winner","winnerVotes","winnerPercentage","average","results","abstentions","abstentionPercentage","resultsData","id","participationRate","calculatedAt","toISOString","calculationTime","hasWinner","isTie","filter","a","averageRating","getConfiguration","name","description","minOptions","maxOptions","allowAbstention","requiresRanking","allowsMultipleSelections","resultType","features","limitations","defaultRangeMin","defaultRangeMax","allowDecimals","VoteEngine","engine","saveVote"],"mappings":"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"}