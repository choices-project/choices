22ce740106aee08a8554f26aef28d218
/**
 * Phase 4: exactOptionalPropertyTypes Cleanup Utilities
 * 
 * Core utilities to eliminate undefined assignments and ensure type safety
 * without loosening TypeScript configuration
 */ /**
 * Recursively strips undefined values from objects and arrays
 * Essential for DB writes and object construction with exactOptionalPropertyTypes
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createCleanObject: function() {
        return createCleanObject;
    },
    filterPresent: function() {
        return filterPresent;
    },
    isPresent: function() {
        return isPresent;
    },
    safeGet: function() {
        return safeGet;
    },
    stripUndefinedDeep: function() {
        return stripUndefinedDeep;
    }
});
function stripUndefinedDeep(input) {
    if (Array.isArray(input)) {
        return input.map(stripUndefinedDeep);
    }
    if (input && typeof input === "object") {
        const out = {};
        for (const [k, v] of Object.entries(input)){
            if (v === undefined) continue;
            out[k] = stripUndefinedDeep(v);
        }
        return out;
    }
    return input;
}
const isPresent = (x)=>x != null;
function filterPresent(arr) {
    return arr.filter(isPresent);
}
function safeGet(obj, key, fallback) {
    return obj?.[key] ?? fallback;
}
function createCleanObject(obj) {
    const result = {};
    for (const [key, value] of Object.entries(obj)){
        if (value !== undefined) {
            result[key] = value;
        }
    }
    return result;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvdXRpbHMvY2xlYW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQaGFzZSA0OiBleGFjdE9wdGlvbmFsUHJvcGVydHlUeXBlcyBDbGVhbnVwIFV0aWxpdGllc1xuICogXG4gKiBDb3JlIHV0aWxpdGllcyB0byBlbGltaW5hdGUgdW5kZWZpbmVkIGFzc2lnbm1lbnRzIGFuZCBlbnN1cmUgdHlwZSBzYWZldHlcbiAqIHdpdGhvdXQgbG9vc2VuaW5nIFR5cGVTY3JpcHQgY29uZmlndXJhdGlvblxuICovXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgc3RyaXBzIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEVzc2VudGlhbCBmb3IgREIgd3JpdGVzIGFuZCBvYmplY3QgY29uc3RydWN0aW9uIHdpdGggZXhhY3RPcHRpb25hbFByb3BlcnR5VHlwZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVW5kZWZpbmVkRGVlcDxUPihpbnB1dDogVCk6IFQge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKHN0cmlwVW5kZWZpbmVkRGVlcCkgYXMgYW55XG4gIH1cbiAgXG4gIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qgb3V0OiBhbnkgPSB7fVxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGlucHV0KSkge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgIG91dFtrXSA9IHN0cmlwVW5kZWZpbmVkRGVlcCh2KVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBwcmVzZW50IChub3QgbnVsbCBvciB1bmRlZmluZWQpXG4gKiBNb3JlIGV4cGxpY2l0IHRoYW4ganVzdCB0cnV0aHkgY2hlY2tzXG4gKi9cbmV4cG9ydCBjb25zdCBpc1ByZXNlbnQgPSA8VD4oeDogVCk6IHggaXMgTm9uTnVsbGFibGU8VD4gPT4geCAhPSBudWxsXG5cbi8qKlxuICogRmlsdGVyIGFycmF5IHRvIHJlbW92ZSBudWxsL3VuZGVmaW5lZCB2YWx1ZXMgd2l0aCBwcm9wZXIgdHlwaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQcmVzZW50PFQ+KGFycjogQXJyYXk8VCB8IG51bGwgfCB1bmRlZmluZWQ+KTogVFtdIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoaXNQcmVzZW50KVxufVxuXG4vKipcbiAqIFNhZmUgb2JqZWN0IHByb3BlcnR5IGFjY2VzcyB3aXRoIGZhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgb2JqOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgXG4gIGtleTogSywgXG4gIGZhbGxiYWNrOiBUW0tdXG4pOiBUW0tdIHtcbiAgcmV0dXJuIG9iaj8uW2tleV0gPz8gZmFsbGJhY2tcbn1cblxuLyoqXG4gKiBDcmVhdGUgb2JqZWN0IHdpdGggb25seSBkZWZpbmVkIHByb3BlcnRpZXMgKG5vIHVuZGVmaW5lZCBrZXlzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xlYW5PYmplY3Q8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KG9iajogVCk6IFBhcnRpYWw8VD4ge1xuICBjb25zdCByZXN1bHQ6IFBhcnRpYWw8VD4gPSB7fVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFtrZXkgYXMga2V5b2YgVF0gPSB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xlYW5PYmplY3QiLCJmaWx0ZXJQcmVzZW50IiwiaXNQcmVzZW50Iiwic2FmZUdldCIsInN0cmlwVW5kZWZpbmVkRGVlcCIsImlucHV0IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwib3V0IiwiayIsInYiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwieCIsImFyciIsImZpbHRlciIsIm9iaiIsImtleSIsImZhbGxiYWNrIiwicmVzdWx0IiwidmFsdWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQ7OztDQUdDOzs7Ozs7Ozs7OztJQTZDZUEsaUJBQWlCO2VBQWpCQTs7SUFsQkFDLGFBQWE7ZUFBYkE7O0lBTEhDLFNBQVM7ZUFBVEE7O0lBWUdDLE9BQU87ZUFBUEE7O0lBakNBQyxrQkFBa0I7ZUFBbEJBOzs7QUFBVCxTQUFTQSxtQkFBc0JDLEtBQVE7SUFDNUMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3hCLE9BQU9BLE1BQU1HLEdBQUcsQ0FBQ0o7SUFDbkI7SUFFQSxJQUFJQyxTQUFTLE9BQU9BLFVBQVUsVUFBVTtRQUN0QyxNQUFNSSxNQUFXLENBQUM7UUFDbEIsS0FBSyxNQUFNLENBQUNDLEdBQUdDLEVBQUUsSUFBSUMsT0FBT0MsT0FBTyxDQUFDUixPQUFRO1lBQzFDLElBQUlNLE1BQU1HLFdBQVc7WUFDckJMLEdBQUcsQ0FBQ0MsRUFBRSxHQUFHTixtQkFBbUJPO1FBQzlCO1FBQ0EsT0FBT0Y7SUFDVDtJQUVBLE9BQU9KO0FBQ1Q7QUFNTyxNQUFNSCxZQUFZLENBQUlhLElBQThCQSxLQUFLO0FBS3pELFNBQVNkLGNBQWlCZSxHQUFnQztJQUMvRCxPQUFPQSxJQUFJQyxNQUFNLENBQUNmO0FBQ3BCO0FBS08sU0FBU0MsUUFDZGUsR0FBeUIsRUFDekJDLEdBQU0sRUFDTkMsUUFBYztJQUVkLE9BQU9GLEtBQUssQ0FBQ0MsSUFBSSxJQUFJQztBQUN2QjtBQUtPLFNBQVNwQixrQkFBaURrQixHQUFNO0lBQ3JFLE1BQU1HLFNBQXFCLENBQUM7SUFDNUIsS0FBSyxNQUFNLENBQUNGLEtBQUtHLE1BQU0sSUFBSVYsT0FBT0MsT0FBTyxDQUFDSyxLQUFNO1FBQzlDLElBQUlJLFVBQVVSLFdBQVc7WUFDdkJPLE1BQU0sQ0FBQ0YsSUFBZSxHQUFHRztRQUMzQjtJQUNGO0lBQ0EsT0FBT0Q7QUFDVCJ9