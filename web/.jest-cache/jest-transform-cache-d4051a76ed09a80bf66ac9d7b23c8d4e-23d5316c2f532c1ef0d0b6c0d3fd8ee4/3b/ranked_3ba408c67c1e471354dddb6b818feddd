c615c29d82a8ffcb252e3d6f213a01a8
/**
 * Ranked Choice Voting Strategy
 * 
 * Implements ranked choice voting (Instant Runoff Voting) where voters rank options
 * in order of preference. Results are calculated using multiple rounds of elimination.
 * 
 * Created: September 15, 2025
 * Updated: September 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RankedStrategy", {
    enumerable: true,
    get: function() {
        return RankedStrategy;
    }
});
const _logger = require("../../utils/logger");
const _objects = require("../../utils/objects");
class RankedStrategy {
    getVotingMethod() {
        return "ranked";
    }
    async validateVote(request, poll) {
        try {
            const { voteData } = request;
            // Check if rankings array is provided
            if (!voteData.rankings || !Array.isArray(voteData.rankings)) {
                return {
                    valid: false,
                    errors: [
                        "Rankings array is required for ranked choice voting"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Validate rankings array is not empty
            if (voteData.rankings.length === 0) {
                return {
                    valid: false,
                    errors: [
                        "At least one option must be ranked"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Validate all rankings are valid integers
            for (const ranking of voteData.rankings){
                if (typeof ranking !== "number" || !Number.isInteger(ranking)) {
                    return {
                        valid: false,
                        errors: [
                            "All rankings must be valid integers"
                        ],
                        requiresAuthentication: true,
                        requiresTokens: false
                    };
                }
                if (ranking < 0 || ranking >= poll.options.length) {
                    return {
                        valid: false,
                        errors: [
                            "Invalid option selected"
                        ],
                        requiresAuthentication: true,
                        requiresTokens: false
                    };
                }
            }
            // Check for duplicate rankings
            const uniqueRankings = new Set(voteData.rankings);
            if (uniqueRankings.size !== voteData.rankings.length) {
                return {
                    valid: false,
                    errors: [
                        "Duplicate rankings are not allowed"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            // Validate ranking completeness (all options must be ranked)
            if (voteData.rankings.length !== poll.options.length) {
                return {
                    valid: false,
                    errors: [
                        "All options must be ranked"
                    ],
                    requiresAuthentication: true,
                    requiresTokens: false
                };
            }
            (0, _logger.devLog)("Ranked vote validated successfully", {
                pollId: request.pollId,
                rankings: voteData.rankings,
                userId: request.userId
            });
            return {
                valid: true,
                requiresAuthentication: true,
                requiresTokens: false
            };
        } catch (error) {
            (0, _logger.devLog)("Ranked vote validation error:", error);
            return {
                valid: false,
                errors: [
                    error instanceof Error ? error.message : "Validation failed"
                ],
                requiresAuthentication: true,
                requiresTokens: false
            };
        }
    }
    async processVote(request, poll) {
        try {
            const { voteData, userId, pollId, privacyLevel } = request;
            // Generate vote ID
            const voteId = `vote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            // Create audit receipt
            const auditReceipt = `receipt_${voteId}_${Date.now()}`;
            // In a real implementation, this would:
            // 1. Store the vote in the database
            // 2. Update poll vote counts
            // 3. Trigger any necessary notifications
            // 4. Log the vote for audit purposes
            (0, _logger.devLog)("Ranked vote processed successfully", {
                pollId,
                voteId,
                rankings: voteData.rankings,
                userId,
                auditReceipt
            });
            return {
                success: true,
                message: "Vote submitted successfully",
                pollId,
                voteId,
                auditReceipt,
                responseTime: 0,
                privacyLevel,
                metadata: {
                    votingMethod: "ranked",
                    rankings: voteData.rankings,
                    rankedOptions: voteData.rankings?.map((rank, index)=>({
                            rank: index + 1,
                            option: poll.options[rank]?.text
                        })) || []
                }
            };
        } catch (error) {
            (0, _logger.devLog)("Ranked vote processing error:", error);
            return {
                success: false,
                message: error instanceof Error ? error.message : "Vote processing failed",
                pollId: request.pollId,
                responseTime: 0,
                privacyLevel: request.privacyLevel,
                metadata: {
                    votingMethod: "ranked",
                    error: error instanceof Error ? error.message : "Unknown error"
                }
            };
        }
    }
    async calculateResults(poll, votes) {
        try {
            const startTime = Date.now();
            // Run instant runoff voting
            const runoffRounds = this.runInstantRunoff(poll, votes);
            // Calculate Borda scores
            const bordaScores = this.calculateBordaScores(poll, votes);
            // Find winner from final round
            const finalRound = runoffRounds[runoffRounds.length - 1];
            let winner;
            let winnerVotes = 0;
            let winnerPercentage = 0;
            if (finalRound && Object.keys(finalRound.votes).length > 0) {
                const entries = Object.entries(finalRound.votes);
                const maxEntry = entries.reduce((max, current)=>current[1] > max[1] ? current : max);
                winner = maxEntry[0];
                winnerVotes = maxEntry[1];
                winnerPercentage = finalRound.percentages[winner] || 0;
            }
            // Calculate option votes and percentages
            const optionVotes = {};
            const optionPercentages = {};
            poll.options.forEach((_, index)=>{
                optionVotes[index.toString()] = 0;
                optionPercentages[index.toString()] = 0;
            });
            // Count first-choice votes
            votes.forEach((vote)=>{
                if (vote.rankings && vote.rankings.length > 0) {
                    const firstRanking = vote.rankings[0];
                    if (firstRanking !== undefined) {
                        const firstChoice = firstRanking.toString();
                        if (optionVotes[firstChoice] !== undefined) {
                            optionVotes[firstChoice]++;
                        }
                    }
                }
            });
            const totalVotes = votes.length;
            if (totalVotes > 0) {
                Object.keys(optionVotes).forEach((optionIndex)=>{
                    const votes = optionVotes[optionIndex];
                    if (votes !== undefined) {
                        optionPercentages[optionIndex] = votes / totalVotes * 100;
                    }
                });
            }
            const results = (0, _objects.withOptional)({
                winnerVotes,
                winnerPercentage,
                bordaScores,
                instantRunoffRounds: runoffRounds,
                optionVotes,
                optionPercentages,
                abstentions: 0,
                abstentionPercentage: 0
            }, {
                winner
            });
            const resultsData = {
                pollId: poll.id,
                votingMethod: "ranked",
                totalVotes,
                participationRate: totalVotes > 0 ? 100 : 0,
                results,
                calculatedAt: new Date().toISOString(),
                metadata: {
                    calculationTime: Date.now() - startTime,
                    hasWinner: winner !== undefined,
                    totalRounds: runoffRounds.length,
                    isTie: winnerVotes > 0 && Object.values(finalRound?.votes || {}).filter((v)=>v === winnerVotes).length > 1
                }
            };
            (0, _logger.devLog)("Ranked results calculated", {
                pollId: poll.id,
                totalVotes,
                winner,
                winnerVotes,
                winnerPercentage,
                totalRounds: runoffRounds.length,
                calculationTime: Date.now() - startTime
            });
            return resultsData;
        } catch (error) {
            (0, _logger.devLog)("Ranked results calculation error:", error);
            throw new Error(`Failed to calculate ranked results: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    runInstantRunoff(poll, votes) {
        const rounds = [];
        const remainingOptions = new Set(poll.options.map((_, index)=>index.toString()));
        const currentVotes = [
            ...votes
        ];
        let round = 1;
        while(remainingOptions.size > 1){
            // Count first-choice votes for remaining options
            const roundVotes = {};
            remainingOptions.forEach((option)=>{
                roundVotes[option] = 0;
            });
            currentVotes.forEach((vote)=>{
                if (vote.rankings && vote.rankings.length > 0) {
                    // Find the highest-ranked remaining option
                    for (const ranking of vote.rankings){
                        if (ranking !== undefined) {
                            const optionIndex = ranking.toString();
                            if (remainingOptions.has(optionIndex)) {
                                roundVotes[optionIndex] = (roundVotes[optionIndex] ?? 0) + 1;
                                break;
                            }
                        }
                    }
                }
            });
            // Calculate percentages
            const totalVotes = Object.values(roundVotes).reduce((sum, count)=>sum + count, 0);
            const roundPercentages = {};
            Object.keys(roundVotes).forEach((option)=>{
                const votes = roundVotes[option];
                if (votes !== undefined) {
                    roundPercentages[option] = totalVotes > 0 ? votes / totalVotes * 100 : 0;
                }
            });
            // Check for majority winner
            const majorityThreshold = totalVotes / 2;
            const winner = Object.entries(roundVotes).find(([_, votes])=>votes > majorityThreshold);
            if (winner) {
                // We have a majority winner
                rounds.push({
                    round,
                    votes: roundVotes,
                    percentages: roundPercentages
                });
                break;
            }
            // Find option with fewest votes to eliminate
            const minVotes = Math.min(...Object.values(roundVotes));
            const eliminatedOptions = Object.entries(roundVotes).filter(([_, votes])=>votes === minVotes).map(([option, _])=>option);
            // If there's a tie for elimination, eliminate the first one
            const eliminated = eliminatedOptions[0];
            if (!eliminated) {
                throw new Error("No options to eliminate");
            }
            remainingOptions.delete(eliminated);
            rounds.push((0, _objects.withOptional)({
                round,
                votes: roundVotes,
                percentages: roundPercentages
            }, {
                eliminated
            }));
            round++;
        }
        return rounds;
    }
    calculateBordaScores(poll, votes) {
        const bordaScores = {};
        // Initialize scores
        poll.options.forEach((_, index)=>{
            bordaScores[index.toString()] = 0;
        });
        // Calculate Borda scores
        votes.forEach((vote)=>{
            if (vote.rankings && vote.rankings.length > 0) {
                vote.rankings.forEach((optionIndex, rank)=>{
                    const score = poll.options.length - rank - 1; // Higher rank = higher score
                    const optionKey = optionIndex.toString();
                    if (bordaScores[optionKey] !== undefined) {
                        bordaScores[optionKey] += score;
                    }
                });
            }
        });
        return bordaScores;
    }
    getConfiguration() {
        return {
            name: "Ranked Choice Voting",
            description: "Voters rank options in order of preference. Results use instant runoff voting.",
            minOptions: 3,
            maxOptions: 20,
            allowAbstention: false,
            requiresRanking: true,
            allowsMultipleSelections: false,
            resultType: "instant_runoff",
            features: [
                "Eliminates vote splitting",
                "Reflects true preferences",
                "Majority winner guaranteed",
                "No wasted votes"
            ],
            limitations: [
                "More complex to understand",
                "Requires complete ranking",
                "Can be time-consuming to count",
                "May not satisfy Condorcet criterion"
            ]
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvdm90ZS9zdHJhdGVnaWVzL3JhbmtlZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJhbmtlZCBDaG9pY2UgVm90aW5nIFN0cmF0ZWd5XG4gKiBcbiAqIEltcGxlbWVudHMgcmFua2VkIGNob2ljZSB2b3RpbmcgKEluc3RhbnQgUnVub2ZmIFZvdGluZykgd2hlcmUgdm90ZXJzIHJhbmsgb3B0aW9uc1xuICogaW4gb3JkZXIgb2YgcHJlZmVyZW5jZS4gUmVzdWx0cyBhcmUgY2FsY3VsYXRlZCB1c2luZyBtdWx0aXBsZSByb3VuZHMgb2YgZWxpbWluYXRpb24uXG4gKiBcbiAqIENyZWF0ZWQ6IFNlcHRlbWJlciAxNSwgMjAyNVxuICogVXBkYXRlZDogU2VwdGVtYmVyIDE1LCAyMDI1XG4gKi9cblxuaW1wb3J0IHsgZGV2TG9nIH0gZnJvbSAnQC9saWIvdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IHdpdGhPcHRpb25hbCB9IGZyb20gJ0AvbGliL3V0aWxzL29iamVjdHMnO1xuXG5pbXBvcnQgdHlwZSB7IFxuICBWb3RpbmdTdHJhdGVneSwgXG4gIFZvdGVSZXF1ZXN0LCBcbiAgVm90ZVJlc3BvbnNlLCBcbiAgVm90ZVZhbGlkYXRpb24sIFxuICBQb2xsRGF0YSwgXG4gIFZvdGVEYXRhLCBcbiAgUmVzdWx0c0RhdGEsXG4gIFZvdGluZ01ldGhvZCxcbiAgUG9sbFJlc3VsdHMsXG4gIEluc3RhbnRSdW5vZmZSb3VuZFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBSYW5rZWRTdHJhdGVneSBpbXBsZW1lbnRzIFZvdGluZ1N0cmF0ZWd5IHtcbiAgXG4gIGdldFZvdGluZ01ldGhvZCgpOiBWb3RpbmdNZXRob2Qge1xuICAgIHJldHVybiAncmFua2VkJztcbiAgfVxuXG4gIGFzeW5jIHZhbGlkYXRlVm90ZShyZXF1ZXN0OiBWb3RlUmVxdWVzdCwgcG9sbDogUG9sbERhdGEpOiBQcm9taXNlPFZvdGVWYWxpZGF0aW9uPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdm90ZURhdGEgfSA9IHJlcXVlc3Q7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHJhbmtpbmdzIGFycmF5IGlzIHByb3ZpZGVkXG4gICAgICBpZiAoIXZvdGVEYXRhLnJhbmtpbmdzIHx8ICFBcnJheS5pc0FycmF5KHZvdGVEYXRhLnJhbmtpbmdzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFsnUmFua2luZ3MgYXJyYXkgaXMgcmVxdWlyZWQgZm9yIHJhbmtlZCBjaG9pY2Ugdm90aW5nJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgcmFua2luZ3MgYXJyYXkgaXMgbm90IGVtcHR5XG4gICAgICBpZiAodm90ZURhdGEucmFua2luZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogWydBdCBsZWFzdCBvbmUgb3B0aW9uIG11c3QgYmUgcmFua2VkJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgYWxsIHJhbmtpbmdzIGFyZSB2YWxpZCBpbnRlZ2Vyc1xuICAgICAgZm9yIChjb25zdCByYW5raW5nIG9mIHZvdGVEYXRhLnJhbmtpbmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFua2luZyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmFua2luZykpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiBbJ0FsbCByYW5raW5ncyBtdXN0IGJlIHZhbGlkIGludGVnZXJzJ10sXG4gICAgICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYW5raW5nIDwgMCB8fCByYW5raW5nID49IHBvbGwub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiBbJ0ludmFsaWQgb3B0aW9uIHNlbGVjdGVkJ10sXG4gICAgICAgICAgICByZXF1aXJlc0F1dGhlbnRpY2F0aW9uOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIHJhbmtpbmdzXG4gICAgICBjb25zdCB1bmlxdWVSYW5raW5ncyA9IG5ldyBTZXQodm90ZURhdGEucmFua2luZ3MpO1xuICAgICAgaWYgKHVuaXF1ZVJhbmtpbmdzLnNpemUgIT09IHZvdGVEYXRhLnJhbmtpbmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFsnRHVwbGljYXRlIHJhbmtpbmdzIGFyZSBub3QgYWxsb3dlZCddLFxuICAgICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIHJhbmtpbmcgY29tcGxldGVuZXNzIChhbGwgb3B0aW9ucyBtdXN0IGJlIHJhbmtlZClcbiAgICAgIGlmICh2b3RlRGF0YS5yYW5raW5ncy5sZW5ndGggIT09IHBvbGwub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiBbJ0FsbCBvcHRpb25zIG11c3QgYmUgcmFua2VkJ10sXG4gICAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXF1aXJlc1Rva2VuczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZGV2TG9nKCdSYW5rZWQgdm90ZSB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5Jywge1xuICAgICAgICBwb2xsSWQ6IHJlcXVlc3QucG9sbElkLFxuICAgICAgICByYW5raW5nczogdm90ZURhdGEucmFua2luZ3MsXG4gICAgICAgIHVzZXJJZDogcmVxdWVzdC51c2VySWRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZXNUb2tlbnM6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnUmFua2VkIHZvdGUgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yczogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1ZhbGlkYXRpb24gZmFpbGVkJ10sXG4gICAgICAgIHJlcXVpcmVzQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgIHJlcXVpcmVzVG9rZW5zOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBwcm9jZXNzVm90ZShyZXF1ZXN0OiBWb3RlUmVxdWVzdCwgcG9sbDogUG9sbERhdGEpOiBQcm9taXNlPFZvdGVSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZvdGVEYXRhLCB1c2VySWQsIHBvbGxJZCwgcHJpdmFjeUxldmVsIH0gPSByZXF1ZXN0O1xuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSB2b3RlIElEXG4gICAgICBjb25zdCB2b3RlSWQgPSBgdm90ZV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhdWRpdCByZWNlaXB0XG4gICAgICBjb25zdCBhdWRpdFJlY2VpcHQgPSBgcmVjZWlwdF8ke3ZvdGVJZH1fJHtEYXRlLm5vdygpfWA7XG5cbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZDpcbiAgICAgIC8vIDEuIFN0b3JlIHRoZSB2b3RlIGluIHRoZSBkYXRhYmFzZVxuICAgICAgLy8gMi4gVXBkYXRlIHBvbGwgdm90ZSBjb3VudHNcbiAgICAgIC8vIDMuIFRyaWdnZXIgYW55IG5lY2Vzc2FyeSBub3RpZmljYXRpb25zXG4gICAgICAvLyA0LiBMb2cgdGhlIHZvdGUgZm9yIGF1ZGl0IHB1cnBvc2VzXG5cbiAgICAgIGRldkxvZygnUmFua2VkIHZvdGUgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScsIHtcbiAgICAgICAgcG9sbElkLFxuICAgICAgICB2b3RlSWQsXG4gICAgICAgIHJhbmtpbmdzOiB2b3RlRGF0YS5yYW5raW5ncyxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBhdWRpdFJlY2VpcHRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiAnVm90ZSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgcG9sbElkLFxuICAgICAgICB2b3RlSWQsXG4gICAgICAgIGF1ZGl0UmVjZWlwdCxcbiAgICAgICAgcmVzcG9uc2VUaW1lOiAwLCAvLyBXaWxsIGJlIHNldCBieSB0aGUgZW5naW5lXG4gICAgICAgIHByaXZhY3lMZXZlbCxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB2b3RpbmdNZXRob2Q6ICdyYW5rZWQnLFxuICAgICAgICAgIHJhbmtpbmdzOiB2b3RlRGF0YS5yYW5raW5ncyxcbiAgICAgICAgICByYW5rZWRPcHRpb25zOiB2b3RlRGF0YS5yYW5raW5ncz8ubWFwKChyYW5rLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIHJhbms6IGluZGV4ICsgMSxcbiAgICAgICAgICAgIG9wdGlvbjogcG9sbC5vcHRpb25zW3JhbmtdPy50ZXh0XG4gICAgICAgICAgfSkpIHx8IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2TG9nKCdSYW5rZWQgdm90ZSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdWb3RlIHByb2Nlc3NpbmcgZmFpbGVkJyxcbiAgICAgICAgcG9sbElkOiByZXF1ZXN0LnBvbGxJZCxcbiAgICAgICAgcmVzcG9uc2VUaW1lOiAwLFxuICAgICAgICBwcml2YWN5TGV2ZWw6IHJlcXVlc3QucHJpdmFjeUxldmVsLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHZvdGluZ01ldGhvZDogJ3JhbmtlZCcsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY2FsY3VsYXRlUmVzdWx0cyhwb2xsOiBQb2xsRGF0YSwgdm90ZXM6IFZvdGVEYXRhW10pOiBQcm9taXNlPFJlc3VsdHNEYXRhPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJ1biBpbnN0YW50IHJ1bm9mZiB2b3RpbmdcbiAgICAgIGNvbnN0IHJ1bm9mZlJvdW5kcyA9IHRoaXMucnVuSW5zdGFudFJ1bm9mZihwb2xsLCB2b3Rlcyk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBCb3JkYSBzY29yZXNcbiAgICAgIGNvbnN0IGJvcmRhU2NvcmVzID0gdGhpcy5jYWxjdWxhdGVCb3JkYVNjb3Jlcyhwb2xsLCB2b3Rlcyk7XG4gICAgICBcbiAgICAgIC8vIEZpbmQgd2lubmVyIGZyb20gZmluYWwgcm91bmRcbiAgICAgIGNvbnN0IGZpbmFsUm91bmQgPSBydW5vZmZSb3VuZHNbcnVub2ZmUm91bmRzLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IHdpbm5lcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IHdpbm5lclZvdGVzID0gMDtcbiAgICAgIGxldCB3aW5uZXJQZXJjZW50YWdlID0gMDtcblxuICAgICAgaWYgKGZpbmFsUm91bmQgJiYgT2JqZWN0LmtleXMoZmluYWxSb3VuZC52b3RlcykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZmluYWxSb3VuZC52b3Rlcyk7XG4gICAgICAgIGNvbnN0IG1heEVudHJ5ID0gZW50cmllcy5yZWR1Y2UoKG1heCwgY3VycmVudCkgPT4gXG4gICAgICAgICAgY3VycmVudFsxXSA+IG1heFsxXSA/IGN1cnJlbnQgOiBtYXhcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHdpbm5lciA9IG1heEVudHJ5WzBdO1xuICAgICAgICB3aW5uZXJWb3RlcyA9IG1heEVudHJ5WzFdO1xuICAgICAgICB3aW5uZXJQZXJjZW50YWdlID0gZmluYWxSb3VuZC5wZXJjZW50YWdlc1t3aW5uZXJdIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvcHRpb24gdm90ZXMgYW5kIHBlcmNlbnRhZ2VzXG4gICAgICBjb25zdCBvcHRpb25Wb3RlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgY29uc3Qgb3B0aW9uUGVyY2VudGFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIFxuICAgICAgcG9sbC5vcHRpb25zLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIG9wdGlvblZvdGVzW2luZGV4LnRvU3RyaW5nKCldID0gMDtcbiAgICAgICAgb3B0aW9uUGVyY2VudGFnZXNbaW5kZXgudG9TdHJpbmcoKV0gPSAwO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENvdW50IGZpcnN0LWNob2ljZSB2b3Rlc1xuICAgICAgdm90ZXMuZm9yRWFjaCh2b3RlID0+IHtcbiAgICAgICAgaWYgKHZvdGUucmFua2luZ3MgJiYgdm90ZS5yYW5raW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RSYW5raW5nID0gdm90ZS5yYW5raW5nc1swXTtcbiAgICAgICAgICBpZiAoZmlyc3RSYW5raW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hvaWNlID0gZmlyc3RSYW5raW5nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uVm90ZXNbZmlyc3RDaG9pY2VdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3B0aW9uVm90ZXNbZmlyc3RDaG9pY2VdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdG90YWxWb3RlcyA9IHZvdGVzLmxlbmd0aDtcbiAgICAgIGlmICh0b3RhbFZvdGVzID4gMCkge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25Wb3RlcykuZm9yRWFjaChvcHRpb25JbmRleCA9PiB7XG4gICAgICAgICAgY29uc3Qgdm90ZXMgPSBvcHRpb25Wb3Rlc1tvcHRpb25JbmRleF07XG4gICAgICAgICAgaWYgKHZvdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvblBlcmNlbnRhZ2VzW29wdGlvbkluZGV4XSA9ICh2b3RlcyAvIHRvdGFsVm90ZXMpICogMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdHM6IFBvbGxSZXN1bHRzID0gd2l0aE9wdGlvbmFsKFxuICAgICAgICB7XG4gICAgICAgICAgd2lubmVyVm90ZXMsXG4gICAgICAgICAgd2lubmVyUGVyY2VudGFnZSxcbiAgICAgICAgICBib3JkYVNjb3JlcyxcbiAgICAgICAgICBpbnN0YW50UnVub2ZmUm91bmRzOiBydW5vZmZSb3VuZHMsXG4gICAgICAgICAgb3B0aW9uVm90ZXMsXG4gICAgICAgICAgb3B0aW9uUGVyY2VudGFnZXMsXG4gICAgICAgICAgYWJzdGVudGlvbnM6IDAsXG4gICAgICAgICAgYWJzdGVudGlvblBlcmNlbnRhZ2U6IDBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHdpbm5lclxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHRzRGF0YTogUmVzdWx0c0RhdGEgPSB7XG4gICAgICAgIHBvbGxJZDogcG9sbC5pZCxcbiAgICAgICAgdm90aW5nTWV0aG9kOiAncmFua2VkJyxcbiAgICAgICAgdG90YWxWb3RlcyxcbiAgICAgICAgcGFydGljaXBhdGlvblJhdGU6IHRvdGFsVm90ZXMgPiAwID8gMTAwIDogMCwgLy8gVGhpcyB3b3VsZCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIGVsaWdpYmxlIHZvdGVyc1xuICAgICAgICByZXN1bHRzLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjYWxjdWxhdGlvblRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgaGFzV2lubmVyOiB3aW5uZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICB0b3RhbFJvdW5kczogcnVub2ZmUm91bmRzLmxlbmd0aCxcbiAgICAgICAgICBpc1RpZTogd2lubmVyVm90ZXMgPiAwICYmIE9iamVjdC52YWx1ZXMoZmluYWxSb3VuZD8udm90ZXMgfHwge30pLmZpbHRlcih2ID0+IHYgPT09IHdpbm5lclZvdGVzKS5sZW5ndGggPiAxXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRldkxvZygnUmFua2VkIHJlc3VsdHMgY2FsY3VsYXRlZCcsIHtcbiAgICAgICAgcG9sbElkOiBwb2xsLmlkLFxuICAgICAgICB0b3RhbFZvdGVzLFxuICAgICAgICB3aW5uZXIsXG4gICAgICAgIHdpbm5lclZvdGVzLFxuICAgICAgICB3aW5uZXJQZXJjZW50YWdlLFxuICAgICAgICB0b3RhbFJvdW5kczogcnVub2ZmUm91bmRzLmxlbmd0aCxcbiAgICAgICAgY2FsY3VsYXRpb25UaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdHNEYXRhO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkxvZygnUmFua2VkIHJlc3VsdHMgY2FsY3VsYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2FsY3VsYXRlIHJhbmtlZCByZXN1bHRzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcnVuSW5zdGFudFJ1bm9mZihwb2xsOiBQb2xsRGF0YSwgdm90ZXM6IFZvdGVEYXRhW10pOiBJbnN0YW50UnVub2ZmUm91bmRbXSB7XG4gICAgY29uc3Qgcm91bmRzOiBJbnN0YW50UnVub2ZmUm91bmRbXSA9IFtdO1xuICAgIGNvbnN0IHJlbWFpbmluZ09wdGlvbnMgPSBuZXcgU2V0KHBvbGwub3B0aW9ucy5tYXAoKF8sIGluZGV4KSA9PiBpbmRleC50b1N0cmluZygpKSk7XG4gICAgY29uc3QgY3VycmVudFZvdGVzID0gWy4uLnZvdGVzXTtcblxuICAgIGxldCByb3VuZCA9IDE7XG4gICAgd2hpbGUgKHJlbWFpbmluZ09wdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIC8vIENvdW50IGZpcnN0LWNob2ljZSB2b3RlcyBmb3IgcmVtYWluaW5nIG9wdGlvbnNcbiAgICAgIGNvbnN0IHJvdW5kVm90ZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIHJlbWFpbmluZ09wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICByb3VuZFZvdGVzW29wdGlvbl0gPSAwO1xuICAgICAgfSk7XG5cbiAgICAgIGN1cnJlbnRWb3Rlcy5mb3JFYWNoKHZvdGUgPT4ge1xuICAgICAgICBpZiAodm90ZS5yYW5raW5ncyAmJiB2b3RlLnJhbmtpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBoaWdoZXN0LXJhbmtlZCByZW1haW5pbmcgb3B0aW9uXG4gICAgICAgICAgZm9yIChjb25zdCByYW5raW5nIG9mIHZvdGUucmFua2luZ3MpIHtcbiAgICAgICAgICAgIGlmIChyYW5raW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uSW5kZXggPSByYW5raW5nLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGlmIChyZW1haW5pbmdPcHRpb25zLmhhcyhvcHRpb25JbmRleCkpIHtcbiAgICAgICAgICAgICAgICByb3VuZFZvdGVzW29wdGlvbkluZGV4XSA9IChyb3VuZFZvdGVzW29wdGlvbkluZGV4XSA/PyAwKSArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZXNcbiAgICAgIGNvbnN0IHRvdGFsVm90ZXMgPSBPYmplY3QudmFsdWVzKHJvdW5kVm90ZXMpLnJlZHVjZSgoc3VtLCBjb3VudCkgPT4gc3VtICsgY291bnQsIDApO1xuICAgICAgY29uc3Qgcm91bmRQZXJjZW50YWdlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMocm91bmRWb3RlcykuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICBjb25zdCB2b3RlcyA9IHJvdW5kVm90ZXNbb3B0aW9uXTtcbiAgICAgICAgaWYgKHZvdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByb3VuZFBlcmNlbnRhZ2VzW29wdGlvbl0gPSB0b3RhbFZvdGVzID4gMCA/ICh2b3RlcyAvIHRvdGFsVm90ZXMpICogMTAwIDogMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBtYWpvcml0eSB3aW5uZXJcbiAgICAgIGNvbnN0IG1ham9yaXR5VGhyZXNob2xkID0gdG90YWxWb3RlcyAvIDI7XG4gICAgICBjb25zdCB3aW5uZXIgPSBPYmplY3QuZW50cmllcyhyb3VuZFZvdGVzKS5maW5kKChbXywgdm90ZXNdKSA9PiB2b3RlcyA+IG1ham9yaXR5VGhyZXNob2xkKTtcbiAgICAgIFxuICAgICAgaWYgKHdpbm5lcikge1xuICAgICAgICAvLyBXZSBoYXZlIGEgbWFqb3JpdHkgd2lubmVyXG4gICAgICAgIHJvdW5kcy5wdXNoKHtcbiAgICAgICAgICByb3VuZCxcbiAgICAgICAgICB2b3Rlczogcm91bmRWb3RlcyxcbiAgICAgICAgICBwZXJjZW50YWdlczogcm91bmRQZXJjZW50YWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgb3B0aW9uIHdpdGggZmV3ZXN0IHZvdGVzIHRvIGVsaW1pbmF0ZVxuICAgICAgY29uc3QgbWluVm90ZXMgPSBNYXRoLm1pbiguLi5PYmplY3QudmFsdWVzKHJvdW5kVm90ZXMpKTtcbiAgICAgIGNvbnN0IGVsaW1pbmF0ZWRPcHRpb25zID0gT2JqZWN0LmVudHJpZXMocm91bmRWb3RlcylcbiAgICAgICAgLmZpbHRlcigoW18sIHZvdGVzXSkgPT4gdm90ZXMgPT09IG1pblZvdGVzKVxuICAgICAgICAubWFwKChbb3B0aW9uLCBfXSkgPT4gb3B0aW9uKTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBhIHRpZSBmb3IgZWxpbWluYXRpb24sIGVsaW1pbmF0ZSB0aGUgZmlyc3Qgb25lXG4gICAgICBjb25zdCBlbGltaW5hdGVkID0gZWxpbWluYXRlZE9wdGlvbnNbMF07XG4gICAgICBpZiAoIWVsaW1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb25zIHRvIGVsaW1pbmF0ZScpO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nT3B0aW9ucy5kZWxldGUoZWxpbWluYXRlZCk7XG5cbiAgICAgIHJvdW5kcy5wdXNoKHdpdGhPcHRpb25hbChcbiAgICAgICAge1xuICAgICAgICAgIHJvdW5kLFxuICAgICAgICAgIHZvdGVzOiByb3VuZFZvdGVzLFxuICAgICAgICAgIHBlcmNlbnRhZ2VzOiByb3VuZFBlcmNlbnRhZ2VzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlbGltaW5hdGVkXG4gICAgICAgIH1cbiAgICAgICkpO1xuXG4gICAgICByb3VuZCsrO1xuICAgIH1cblxuICAgIHJldHVybiByb3VuZHM7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUJvcmRhU2NvcmVzKHBvbGw6IFBvbGxEYXRhLCB2b3RlczogVm90ZURhdGFbXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIGNvbnN0IGJvcmRhU2NvcmVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBzY29yZXNcbiAgICBwb2xsLm9wdGlvbnMuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICAgIGJvcmRhU2NvcmVzW2luZGV4LnRvU3RyaW5nKCldID0gMDtcbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBCb3JkYSBzY29yZXNcbiAgICB2b3Rlcy5mb3JFYWNoKHZvdGUgPT4ge1xuICAgICAgaWYgKHZvdGUucmFua2luZ3MgJiYgdm90ZS5yYW5raW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZvdGUucmFua2luZ3MuZm9yRWFjaCgob3B0aW9uSW5kZXgsIHJhbmspID0+IHtcbiAgICAgICAgICBjb25zdCBzY29yZSA9IHBvbGwub3B0aW9ucy5sZW5ndGggLSByYW5rIC0gMTsgLy8gSGlnaGVyIHJhbmsgPSBoaWdoZXIgc2NvcmVcbiAgICAgICAgICBjb25zdCBvcHRpb25LZXkgPSBvcHRpb25JbmRleC50b1N0cmluZygpO1xuICAgICAgICAgIGlmIChib3JkYVNjb3Jlc1tvcHRpb25LZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJvcmRhU2NvcmVzW29wdGlvbktleV0gKz0gc2NvcmU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBib3JkYVNjb3JlcztcbiAgfVxuXG4gIGdldENvbmZpZ3VyYXRpb24oKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnUmFua2VkIENob2ljZSBWb3RpbmcnLFxuICAgICAgZGVzY3JpcHRpb246ICdWb3RlcnMgcmFuayBvcHRpb25zIGluIG9yZGVyIG9mIHByZWZlcmVuY2UuIFJlc3VsdHMgdXNlIGluc3RhbnQgcnVub2ZmIHZvdGluZy4nLFxuICAgICAgbWluT3B0aW9uczogMyxcbiAgICAgIG1heE9wdGlvbnM6IDIwLFxuICAgICAgYWxsb3dBYnN0ZW50aW9uOiBmYWxzZSxcbiAgICAgIHJlcXVpcmVzUmFua2luZzogdHJ1ZSxcbiAgICAgIGFsbG93c011bHRpcGxlU2VsZWN0aW9uczogZmFsc2UsXG4gICAgICByZXN1bHRUeXBlOiAnaW5zdGFudF9ydW5vZmYnLFxuICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgJ0VsaW1pbmF0ZXMgdm90ZSBzcGxpdHRpbmcnLFxuICAgICAgICAnUmVmbGVjdHMgdHJ1ZSBwcmVmZXJlbmNlcycsXG4gICAgICAgICdNYWpvcml0eSB3aW5uZXIgZ3VhcmFudGVlZCcsXG4gICAgICAgICdObyB3YXN0ZWQgdm90ZXMnXG4gICAgICBdLFxuICAgICAgbGltaXRhdGlvbnM6IFtcbiAgICAgICAgJ01vcmUgY29tcGxleCB0byB1bmRlcnN0YW5kJyxcbiAgICAgICAgJ1JlcXVpcmVzIGNvbXBsZXRlIHJhbmtpbmcnLFxuICAgICAgICAnQ2FuIGJlIHRpbWUtY29uc3VtaW5nIHRvIGNvdW50JyxcbiAgICAgICAgJ01heSBub3Qgc2F0aXNmeSBDb25kb3JjZXQgY3JpdGVyaW9uJ1xuICAgICAgXVxuICAgIH07XG4gIH1cbn0iXSwibmFtZXMiOlsiUmFua2VkU3RyYXRlZ3kiLCJnZXRWb3RpbmdNZXRob2QiLCJ2YWxpZGF0ZVZvdGUiLCJyZXF1ZXN0IiwicG9sbCIsInZvdGVEYXRhIiwicmFua2luZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZCIsImVycm9ycyIsInJlcXVpcmVzQXV0aGVudGljYXRpb24iLCJyZXF1aXJlc1Rva2VucyIsImxlbmd0aCIsInJhbmtpbmciLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcHRpb25zIiwidW5pcXVlUmFua2luZ3MiLCJTZXQiLCJzaXplIiwiZGV2TG9nIiwicG9sbElkIiwidXNlcklkIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJwcm9jZXNzVm90ZSIsInByaXZhY3lMZXZlbCIsInZvdGVJZCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJhdWRpdFJlY2VpcHQiLCJzdWNjZXNzIiwicmVzcG9uc2VUaW1lIiwibWV0YWRhdGEiLCJ2b3RpbmdNZXRob2QiLCJyYW5rZWRPcHRpb25zIiwibWFwIiwicmFuayIsImluZGV4Iiwib3B0aW9uIiwidGV4dCIsImNhbGN1bGF0ZVJlc3VsdHMiLCJ2b3RlcyIsInN0YXJ0VGltZSIsInJ1bm9mZlJvdW5kcyIsInJ1bkluc3RhbnRSdW5vZmYiLCJib3JkYVNjb3JlcyIsImNhbGN1bGF0ZUJvcmRhU2NvcmVzIiwiZmluYWxSb3VuZCIsIndpbm5lciIsIndpbm5lclZvdGVzIiwid2lubmVyUGVyY2VudGFnZSIsIk9iamVjdCIsImtleXMiLCJlbnRyaWVzIiwibWF4RW50cnkiLCJyZWR1Y2UiLCJtYXgiLCJjdXJyZW50IiwicGVyY2VudGFnZXMiLCJvcHRpb25Wb3RlcyIsIm9wdGlvblBlcmNlbnRhZ2VzIiwiZm9yRWFjaCIsIl8iLCJ2b3RlIiwiZmlyc3RSYW5raW5nIiwidW5kZWZpbmVkIiwiZmlyc3RDaG9pY2UiLCJ0b3RhbFZvdGVzIiwib3B0aW9uSW5kZXgiLCJyZXN1bHRzIiwid2l0aE9wdGlvbmFsIiwiaW5zdGFudFJ1bm9mZlJvdW5kcyIsImFic3RlbnRpb25zIiwiYWJzdGVudGlvblBlcmNlbnRhZ2UiLCJyZXN1bHRzRGF0YSIsImlkIiwicGFydGljaXBhdGlvblJhdGUiLCJjYWxjdWxhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImNhbGN1bGF0aW9uVGltZSIsImhhc1dpbm5lciIsInRvdGFsUm91bmRzIiwiaXNUaWUiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJ2Iiwicm91bmRzIiwicmVtYWluaW5nT3B0aW9ucyIsImN1cnJlbnRWb3RlcyIsInJvdW5kIiwicm91bmRWb3RlcyIsImhhcyIsInN1bSIsImNvdW50Iiwicm91bmRQZXJjZW50YWdlcyIsIm1ham9yaXR5VGhyZXNob2xkIiwiZmluZCIsInB1c2giLCJtaW5Wb3RlcyIsIm1pbiIsImVsaW1pbmF0ZWRPcHRpb25zIiwiZWxpbWluYXRlZCIsImRlbGV0ZSIsInNjb3JlIiwib3B0aW9uS2V5IiwiZ2V0Q29uZmlndXJhdGlvbiIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsIm1pbk9wdGlvbnMiLCJtYXhPcHRpb25zIiwiYWxsb3dBYnN0ZW50aW9uIiwicmVxdWlyZXNSYW5raW5nIiwiYWxsb3dzTXVsdGlwbGVTZWxlY3Rpb25zIiwicmVzdWx0VHlwZSIsImZlYXR1cmVzIiwibGltaXRhdGlvbnMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7OytCQWtCWUE7OztlQUFBQTs7O3dCQWhCVTt5QkFDTTtBQWV0QixNQUFNQTtJQUVYQyxrQkFBZ0M7UUFDOUIsT0FBTztJQUNUO0lBRUEsTUFBTUMsYUFBYUMsT0FBb0IsRUFBRUMsSUFBYyxFQUEyQjtRQUNoRixJQUFJO1lBQ0YsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7WUFFckIsc0NBQXNDO1lBQ3RDLElBQUksQ0FBQ0UsU0FBU0MsUUFBUSxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsU0FBU0MsUUFBUSxHQUFHO2dCQUMzRCxPQUFPO29CQUNMRyxPQUFPO29CQUNQQyxRQUFRO3dCQUFDO3FCQUFzRDtvQkFDL0RDLHdCQUF3QjtvQkFDeEJDLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLHVDQUF1QztZQUN2QyxJQUFJUCxTQUFTQyxRQUFRLENBQUNPLE1BQU0sS0FBSyxHQUFHO2dCQUNsQyxPQUFPO29CQUNMSixPQUFPO29CQUNQQyxRQUFRO3dCQUFDO3FCQUFxQztvQkFDOUNDLHdCQUF3QjtvQkFDeEJDLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLDJDQUEyQztZQUMzQyxLQUFLLE1BQU1FLFdBQVdULFNBQVNDLFFBQVEsQ0FBRTtnQkFDdkMsSUFBSSxPQUFPUSxZQUFZLFlBQVksQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDRixVQUFVO29CQUM3RCxPQUFPO3dCQUNMTCxPQUFPO3dCQUNQQyxRQUFROzRCQUFDO3lCQUFzQzt3QkFDL0NDLHdCQUF3Qjt3QkFDeEJDLGdCQUFnQjtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsSUFBSUUsVUFBVSxLQUFLQSxXQUFXVixLQUFLYSxPQUFPLENBQUNKLE1BQU0sRUFBRTtvQkFDakQsT0FBTzt3QkFDTEosT0FBTzt3QkFDUEMsUUFBUTs0QkFBQzt5QkFBMEI7d0JBQ25DQyx3QkFBd0I7d0JBQ3hCQyxnQkFBZ0I7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFFQSwrQkFBK0I7WUFDL0IsTUFBTU0saUJBQWlCLElBQUlDLElBQUlkLFNBQVNDLFFBQVE7WUFDaEQsSUFBSVksZUFBZUUsSUFBSSxLQUFLZixTQUFTQyxRQUFRLENBQUNPLE1BQU0sRUFBRTtnQkFDcEQsT0FBTztvQkFDTEosT0FBTztvQkFDUEMsUUFBUTt3QkFBQztxQkFBcUM7b0JBQzlDQyx3QkFBd0I7b0JBQ3hCQyxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSw2REFBNkQ7WUFDN0QsSUFBSVAsU0FBU0MsUUFBUSxDQUFDTyxNQUFNLEtBQUtULEtBQUthLE9BQU8sQ0FBQ0osTUFBTSxFQUFFO2dCQUNwRCxPQUFPO29CQUNMSixPQUFPO29CQUNQQyxRQUFRO3dCQUFDO3FCQUE2QjtvQkFDdENDLHdCQUF3QjtvQkFDeEJDLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBUyxJQUFBQSxjQUFNLEVBQUMsc0NBQXNDO2dCQUMzQ0MsUUFBUW5CLFFBQVFtQixNQUFNO2dCQUN0QmhCLFVBQVVELFNBQVNDLFFBQVE7Z0JBQzNCaUIsUUFBUXBCLFFBQVFvQixNQUFNO1lBQ3hCO1lBRUEsT0FBTztnQkFDTGQsT0FBTztnQkFDUEUsd0JBQXdCO2dCQUN4QkMsZ0JBQWdCO1lBQ2xCO1FBRUYsRUFBRSxPQUFPWSxPQUFPO1lBQ2RILElBQUFBLGNBQU0sRUFBQyxpQ0FBaUNHO1lBQ3hDLE9BQU87Z0JBQ0xmLE9BQU87Z0JBQ1BDLFFBQVE7b0JBQUNjLGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHO2lCQUFvQjtnQkFDdEVmLHdCQUF3QjtnQkFDeEJDLGdCQUFnQjtZQUNsQjtRQUNGO0lBQ0Y7SUFFQSxNQUFNZSxZQUFZeEIsT0FBb0IsRUFBRUMsSUFBYyxFQUF5QjtRQUM3RSxJQUFJO1lBQ0YsTUFBTSxFQUFFQyxRQUFRLEVBQUVrQixNQUFNLEVBQUVELE1BQU0sRUFBRU0sWUFBWSxFQUFFLEdBQUd6QjtZQUVuRCxtQkFBbUI7WUFDbkIsTUFBTTBCLFNBQVMsQ0FBQyxLQUFLLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVDLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUU5RSx1QkFBdUI7WUFDdkIsTUFBTUMsZUFBZSxDQUFDLFFBQVEsRUFBRVAsT0FBTyxDQUFDLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDO1lBRXRELHdDQUF3QztZQUN4QyxvQ0FBb0M7WUFDcEMsNkJBQTZCO1lBQzdCLHlDQUF5QztZQUN6QyxxQ0FBcUM7WUFFckNWLElBQUFBLGNBQU0sRUFBQyxzQ0FBc0M7Z0JBQzNDQztnQkFDQU87Z0JBQ0F2QixVQUFVRCxTQUFTQyxRQUFRO2dCQUMzQmlCO2dCQUNBYTtZQUNGO1lBRUEsT0FBTztnQkFDTEMsU0FBUztnQkFDVFgsU0FBUztnQkFDVEo7Z0JBQ0FPO2dCQUNBTztnQkFDQUUsY0FBYztnQkFDZFY7Z0JBQ0FXLFVBQVU7b0JBQ1JDLGNBQWM7b0JBQ2RsQyxVQUFVRCxTQUFTQyxRQUFRO29CQUMzQm1DLGVBQWVwQyxTQUFTQyxRQUFRLEVBQUVvQyxJQUFJLENBQUNDLE1BQU1DLFFBQVcsQ0FBQTs0QkFDdERELE1BQU1DLFFBQVE7NEJBQ2RDLFFBQVF6QyxLQUFLYSxPQUFPLENBQUMwQixLQUFLLEVBQUVHO3dCQUM5QixDQUFBLE1BQU8sRUFBRTtnQkFDWDtZQUNGO1FBRUYsRUFBRSxPQUFPdEIsT0FBTztZQUNkSCxJQUFBQSxjQUFNLEVBQUMsaUNBQWlDRztZQUN4QyxPQUFPO2dCQUNMYSxTQUFTO2dCQUNUWCxTQUFTRixpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRztnQkFDbERKLFFBQVFuQixRQUFRbUIsTUFBTTtnQkFDdEJnQixjQUFjO2dCQUNkVixjQUFjekIsUUFBUXlCLFlBQVk7Z0JBQ2xDVyxVQUFVO29CQUNSQyxjQUFjO29CQUNkaEIsT0FBT0EsaUJBQWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUc7Z0JBQ2xEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsTUFBTXFCLGlCQUFpQjNDLElBQWMsRUFBRTRDLEtBQWlCLEVBQXdCO1FBQzlFLElBQUk7WUFDRixNQUFNQyxZQUFZbkIsS0FBS0MsR0FBRztZQUUxQiw0QkFBNEI7WUFDNUIsTUFBTW1CLGVBQWUsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQy9DLE1BQU00QztZQUVqRCx5QkFBeUI7WUFDekIsTUFBTUksY0FBYyxJQUFJLENBQUNDLG9CQUFvQixDQUFDakQsTUFBTTRDO1lBRXBELCtCQUErQjtZQUMvQixNQUFNTSxhQUFhSixZQUFZLENBQUNBLGFBQWFyQyxNQUFNLEdBQUcsRUFBRTtZQUN4RCxJQUFJMEM7WUFDSixJQUFJQyxjQUFjO1lBQ2xCLElBQUlDLG1CQUFtQjtZQUV2QixJQUFJSCxjQUFjSSxPQUFPQyxJQUFJLENBQUNMLFdBQVdOLEtBQUssRUFBRW5DLE1BQU0sR0FBRyxHQUFHO2dCQUMxRCxNQUFNK0MsVUFBVUYsT0FBT0UsT0FBTyxDQUFDTixXQUFXTixLQUFLO2dCQUMvQyxNQUFNYSxXQUFXRCxRQUFRRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsVUFDcENBLE9BQU8sQ0FBQyxFQUFFLEdBQUdELEdBQUcsQ0FBQyxFQUFFLEdBQUdDLFVBQVVEO2dCQUdsQ1IsU0FBU00sUUFBUSxDQUFDLEVBQUU7Z0JBQ3BCTCxjQUFjSyxRQUFRLENBQUMsRUFBRTtnQkFDekJKLG1CQUFtQkgsV0FBV1csV0FBVyxDQUFDVixPQUFPLElBQUk7WUFDdkQ7WUFFQSx5Q0FBeUM7WUFDekMsTUFBTVcsY0FBc0MsQ0FBQztZQUM3QyxNQUFNQyxvQkFBNEMsQ0FBQztZQUVuRC9ELEtBQUthLE9BQU8sQ0FBQ21ELE9BQU8sQ0FBQyxDQUFDQyxHQUFHekI7Z0JBQ3ZCc0IsV0FBVyxDQUFDdEIsTUFBTVYsUUFBUSxHQUFHLEdBQUc7Z0JBQ2hDaUMsaUJBQWlCLENBQUN2QixNQUFNVixRQUFRLEdBQUcsR0FBRztZQUN4QztZQUVBLDJCQUEyQjtZQUMzQmMsTUFBTW9CLE9BQU8sQ0FBQ0UsQ0FBQUE7Z0JBQ1osSUFBSUEsS0FBS2hFLFFBQVEsSUFBSWdFLEtBQUtoRSxRQUFRLENBQUNPLE1BQU0sR0FBRyxHQUFHO29CQUM3QyxNQUFNMEQsZUFBZUQsS0FBS2hFLFFBQVEsQ0FBQyxFQUFFO29CQUNyQyxJQUFJaUUsaUJBQWlCQyxXQUFXO3dCQUM5QixNQUFNQyxjQUFjRixhQUFhckMsUUFBUTt3QkFDekMsSUFBSWdDLFdBQVcsQ0FBQ08sWUFBWSxLQUFLRCxXQUFXOzRCQUMxQ04sV0FBVyxDQUFDTyxZQUFZO3dCQUMxQjtvQkFDRjtnQkFDRjtZQUNGO1lBRUEsTUFBTUMsYUFBYTFCLE1BQU1uQyxNQUFNO1lBQy9CLElBQUk2RCxhQUFhLEdBQUc7Z0JBQ2xCaEIsT0FBT0MsSUFBSSxDQUFDTyxhQUFhRSxPQUFPLENBQUNPLENBQUFBO29CQUMvQixNQUFNM0IsUUFBUWtCLFdBQVcsQ0FBQ1MsWUFBWTtvQkFDdEMsSUFBSTNCLFVBQVV3QixXQUFXO3dCQUN2QkwsaUJBQWlCLENBQUNRLFlBQVksR0FBRyxBQUFDM0IsUUFBUTBCLGFBQWM7b0JBQzFEO2dCQUNGO1lBQ0Y7WUFFQSxNQUFNRSxVQUF1QkMsSUFBQUEscUJBQVksRUFDdkM7Z0JBQ0VyQjtnQkFDQUM7Z0JBQ0FMO2dCQUNBMEIscUJBQXFCNUI7Z0JBQ3JCZ0I7Z0JBQ0FDO2dCQUNBWSxhQUFhO2dCQUNiQyxzQkFBc0I7WUFDeEIsR0FDQTtnQkFDRXpCO1lBQ0Y7WUFHRixNQUFNMEIsY0FBMkI7Z0JBQy9CM0QsUUFBUWxCLEtBQUs4RSxFQUFFO2dCQUNmMUMsY0FBYztnQkFDZGtDO2dCQUNBUyxtQkFBbUJULGFBQWEsSUFBSSxNQUFNO2dCQUMxQ0U7Z0JBQ0FRLGNBQWMsSUFBSXRELE9BQU91RCxXQUFXO2dCQUNwQzlDLFVBQVU7b0JBQ1IrQyxpQkFBaUJ4RCxLQUFLQyxHQUFHLEtBQUtrQjtvQkFDOUJzQyxXQUFXaEMsV0FBV2lCO29CQUN0QmdCLGFBQWF0QyxhQUFhckMsTUFBTTtvQkFDaEM0RSxPQUFPakMsY0FBYyxLQUFLRSxPQUFPZ0MsTUFBTSxDQUFDcEMsWUFBWU4sU0FBUyxDQUFDLEdBQUcyQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU1wQyxhQUFhM0MsTUFBTSxHQUFHO2dCQUMzRztZQUNGO1lBRUFRLElBQUFBLGNBQU0sRUFBQyw2QkFBNkI7Z0JBQ2xDQyxRQUFRbEIsS0FBSzhFLEVBQUU7Z0JBQ2ZSO2dCQUNBbkI7Z0JBQ0FDO2dCQUNBQztnQkFDQStCLGFBQWF0QyxhQUFhckMsTUFBTTtnQkFDaEN5RSxpQkFBaUJ4RCxLQUFLQyxHQUFHLEtBQUtrQjtZQUNoQztZQUVBLE9BQU9nQztRQUVULEVBQUUsT0FBT3pELE9BQU87WUFDZEgsSUFBQUEsY0FBTSxFQUFDLHFDQUFxQ0c7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsb0NBQW9DLEVBQUVELGlCQUFpQkMsUUFBUUQsTUFBTUUsT0FBTyxHQUFHLGdCQUFnQixDQUFDO1FBQ25IO0lBQ0Y7SUFFUXlCLGlCQUFpQi9DLElBQWMsRUFBRTRDLEtBQWlCLEVBQXdCO1FBQ2hGLE1BQU02QyxTQUErQixFQUFFO1FBQ3ZDLE1BQU1DLG1CQUFtQixJQUFJM0UsSUFBSWYsS0FBS2EsT0FBTyxDQUFDeUIsR0FBRyxDQUFDLENBQUMyQixHQUFHekIsUUFBVUEsTUFBTVYsUUFBUTtRQUM5RSxNQUFNNkQsZUFBZTtlQUFJL0M7U0FBTTtRQUUvQixJQUFJZ0QsUUFBUTtRQUNaLE1BQU9GLGlCQUFpQjFFLElBQUksR0FBRyxFQUFHO1lBQ2hDLGlEQUFpRDtZQUNqRCxNQUFNNkUsYUFBcUMsQ0FBQztZQUM1Q0gsaUJBQWlCMUIsT0FBTyxDQUFDdkIsQ0FBQUE7Z0JBQ3ZCb0QsVUFBVSxDQUFDcEQsT0FBTyxHQUFHO1lBQ3ZCO1lBRUFrRCxhQUFhM0IsT0FBTyxDQUFDRSxDQUFBQTtnQkFDbkIsSUFBSUEsS0FBS2hFLFFBQVEsSUFBSWdFLEtBQUtoRSxRQUFRLENBQUNPLE1BQU0sR0FBRyxHQUFHO29CQUM3QywyQ0FBMkM7b0JBQzNDLEtBQUssTUFBTUMsV0FBV3dELEtBQUtoRSxRQUFRLENBQUU7d0JBQ25DLElBQUlRLFlBQVkwRCxXQUFXOzRCQUN6QixNQUFNRyxjQUFjN0QsUUFBUW9CLFFBQVE7NEJBQ3BDLElBQUk0RCxpQkFBaUJJLEdBQUcsQ0FBQ3ZCLGNBQWM7Z0NBQ3JDc0IsVUFBVSxDQUFDdEIsWUFBWSxHQUFHLEFBQUNzQixDQUFBQSxVQUFVLENBQUN0QixZQUFZLElBQUksQ0FBQSxJQUFLO2dDQUMzRDs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1lBRUEsd0JBQXdCO1lBQ3hCLE1BQU1ELGFBQWFoQixPQUFPZ0MsTUFBTSxDQUFDTyxZQUFZbkMsTUFBTSxDQUFDLENBQUNxQyxLQUFLQyxRQUFVRCxNQUFNQyxPQUFPO1lBQ2pGLE1BQU1DLG1CQUEyQyxDQUFDO1lBQ2xEM0MsT0FBT0MsSUFBSSxDQUFDc0MsWUFBWTdCLE9BQU8sQ0FBQ3ZCLENBQUFBO2dCQUM5QixNQUFNRyxRQUFRaUQsVUFBVSxDQUFDcEQsT0FBTztnQkFDaEMsSUFBSUcsVUFBVXdCLFdBQVc7b0JBQ3ZCNkIsZ0JBQWdCLENBQUN4RCxPQUFPLEdBQUc2QixhQUFhLElBQUksQUFBQzFCLFFBQVEwQixhQUFjLE1BQU07Z0JBQzNFO1lBQ0Y7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTTRCLG9CQUFvQjVCLGFBQWE7WUFDdkMsTUFBTW5CLFNBQVNHLE9BQU9FLE9BQU8sQ0FBQ3FDLFlBQVlNLElBQUksQ0FBQyxDQUFDLENBQUNsQyxHQUFHckIsTUFBTSxHQUFLQSxRQUFRc0Q7WUFFdkUsSUFBSS9DLFFBQVE7Z0JBQ1YsNEJBQTRCO2dCQUM1QnNDLE9BQU9XLElBQUksQ0FBQztvQkFDVlI7b0JBQ0FoRCxPQUFPaUQ7b0JBQ1BoQyxhQUFhb0M7Z0JBQ2Y7Z0JBQ0E7WUFDRjtZQUVBLDZDQUE2QztZQUM3QyxNQUFNSSxXQUFXekUsS0FBSzBFLEdBQUcsSUFBSWhELE9BQU9nQyxNQUFNLENBQUNPO1lBQzNDLE1BQU1VLG9CQUFvQmpELE9BQU9FLE9BQU8sQ0FBQ3FDLFlBQ3RDTixNQUFNLENBQUMsQ0FBQyxDQUFDdEIsR0FBR3JCLE1BQU0sR0FBS0EsVUFBVXlELFVBQ2pDL0QsR0FBRyxDQUFDLENBQUMsQ0FBQ0csUUFBUXdCLEVBQUUsR0FBS3hCO1lBRXhCLDREQUE0RDtZQUM1RCxNQUFNK0QsYUFBYUQsaUJBQWlCLENBQUMsRUFBRTtZQUN2QyxJQUFJLENBQUNDLFlBQVk7Z0JBQ2YsTUFBTSxJQUFJbkYsTUFBTTtZQUNsQjtZQUNBcUUsaUJBQWlCZSxNQUFNLENBQUNEO1lBRXhCZixPQUFPVyxJQUFJLENBQUMzQixJQUFBQSxxQkFBWSxFQUN0QjtnQkFDRW1CO2dCQUNBaEQsT0FBT2lEO2dCQUNQaEMsYUFBYW9DO1lBQ2YsR0FDQTtnQkFDRU87WUFDRjtZQUdGWjtRQUNGO1FBRUEsT0FBT0g7SUFDVDtJQUVReEMscUJBQXFCakQsSUFBYyxFQUFFNEMsS0FBaUIsRUFBMEI7UUFDdEYsTUFBTUksY0FBc0MsQ0FBQztRQUU3QyxvQkFBb0I7UUFDcEJoRCxLQUFLYSxPQUFPLENBQUNtRCxPQUFPLENBQUMsQ0FBQ0MsR0FBR3pCO1lBQ3ZCUSxXQUFXLENBQUNSLE1BQU1WLFFBQVEsR0FBRyxHQUFHO1FBQ2xDO1FBRUEseUJBQXlCO1FBQ3pCYyxNQUFNb0IsT0FBTyxDQUFDRSxDQUFBQTtZQUNaLElBQUlBLEtBQUtoRSxRQUFRLElBQUlnRSxLQUFLaEUsUUFBUSxDQUFDTyxNQUFNLEdBQUcsR0FBRztnQkFDN0N5RCxLQUFLaEUsUUFBUSxDQUFDOEQsT0FBTyxDQUFDLENBQUNPLGFBQWFoQztvQkFDbEMsTUFBTW1FLFFBQVExRyxLQUFLYSxPQUFPLENBQUNKLE1BQU0sR0FBRzhCLE9BQU8sR0FBRyw2QkFBNkI7b0JBQzNFLE1BQU1vRSxZQUFZcEMsWUFBWXpDLFFBQVE7b0JBQ3RDLElBQUlrQixXQUFXLENBQUMyRCxVQUFVLEtBQUt2QyxXQUFXO3dCQUN4Q3BCLFdBQVcsQ0FBQzJELFVBQVUsSUFBSUQ7b0JBQzVCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU8xRDtJQUNUO0lBRUE0RCxtQkFBNEM7UUFDMUMsT0FBTztZQUNMQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLGlCQUFpQjtZQUNqQkMsaUJBQWlCO1lBQ2pCQywwQkFBMEI7WUFDMUJDLFlBQVk7WUFDWkMsVUFBVTtnQkFDUjtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBQ0RDLGFBQWE7Z0JBQ1g7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtRQUNIO0lBQ0Y7QUFDRiJ9