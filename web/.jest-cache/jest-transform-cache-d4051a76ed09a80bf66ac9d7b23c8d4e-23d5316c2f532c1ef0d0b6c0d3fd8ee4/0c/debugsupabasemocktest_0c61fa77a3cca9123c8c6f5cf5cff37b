8439c0775556a39e36f84af9d5556683
/**
 * Debug Supabase Mock Test
 * 
 * This test is to debug why the Supabase mock is not working
 */ "use strict";
// Mock before any imports
jest.mock("@/utils/supabase/server", ()=>({
        getSupabaseServerClient: jest.fn(()=>Promise.resolve(mockSupabaseClient))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock the Supabase server client
const mockSupabaseClient = {
    from: jest.fn().mockReturnValue({
        select: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
                limit: jest.fn().mockResolvedValue({
                    data: [
                        {
                            id: "test-poll",
                            title: "Test Poll"
                        }
                    ],
                    error: null
                })
            })
        })
    })
};
(0, _globals.describe)("Debug Supabase Mock", ()=>{
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.it)("should mock getSupabaseServerClient correctly", async ()=>{
        const { getSupabaseServerClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../../../utils/supabase/server")));
        const client = await getSupabaseServerClient();
        console.log("Mock client:", client);
        console.log("Mock client type:", typeof client);
        console.log("Mock client from:", typeof client.from);
        (0, _globals.expect)(client).toBeDefined();
        (0, _globals.expect)(client.from).toBeDefined();
        (0, _globals.expect)(typeof client.from).toBe("function");
    });
    (0, _globals.it)("should be able to call mock methods", async ()=>{
        const { getSupabaseServerClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../../../utils/supabase/server")));
        const client = await getSupabaseServerClient();
        console.log("Client from function:", client.from);
        console.log("Client from call result:", client.from("polls"));
        // This should work if the mock is applied correctly
        const fromResult = client.from("polls");
        console.log("From result:", fromResult);
        if (fromResult) {
            const selectResult = fromResult.select();
            console.log("Select result:", selectResult);
            const result = await selectResult.eq("status", "active").limit(10);
            console.log("Mock result:", result);
            (0, _globals.expect)(result).toBeDefined();
            (0, _globals.expect)(result.data).toBeDefined();
        } else {
            throw new Error("client.from() returned undefined");
        }
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYXBpL2RlYnVnLXN1cGFiYXNlLW1vY2sudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlYnVnIFN1cGFiYXNlIE1vY2sgVGVzdFxuICogXG4gKiBUaGlzIHRlc3QgaXMgdG8gZGVidWcgd2h5IHRoZSBTdXBhYmFzZSBtb2NrIGlzIG5vdCB3b3JraW5nXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcblxuLy8gTW9jayB0aGUgU3VwYWJhc2Ugc2VydmVyIGNsaWVudFxuY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBsaW1pdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBkYXRhOiBbeyBpZDogJ3Rlc3QtcG9sbCcsIHRpdGxlOiAnVGVzdCBQb2xsJyB9XSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICB9KSxcbiAgfSksXG59O1xuXG4vLyBNb2NrIGJlZm9yZSBhbnkgaW1wb3J0c1xuamVzdC5tb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlU2VydmVyQ2xpZW50OiBqZXN0LmZuKCgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VwYWJhc2VDbGllbnQpKSxcbn0pKTtcblxuZGVzY3JpYmUoJ0RlYnVnIFN1cGFiYXNlIE1vY2snLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG1vY2sgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInKTtcbiAgICBcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZVNlcnZlckNsaWVudCgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdNb2NrIGNsaWVudDonLCBjbGllbnQpO1xuICAgIGNvbnNvbGUubG9nKCdNb2NrIGNsaWVudCB0eXBlOicsIHR5cGVvZiBjbGllbnQpO1xuICAgIGNvbnNvbGUubG9nKCdNb2NrIGNsaWVudCBmcm9tOicsIHR5cGVvZiBjbGllbnQuZnJvbSk7XG4gICAgXG4gICAgZXhwZWN0KGNsaWVudCkudG9CZURlZmluZWQoKTtcbiAgICBleHBlY3QoY2xpZW50LmZyb20pLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHR5cGVvZiBjbGllbnQuZnJvbSkudG9CZSgnZnVuY3Rpb24nKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBiZSBhYmxlIHRvIGNhbGwgbW9jayBtZXRob2RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInKTtcbiAgICBcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZVNlcnZlckNsaWVudCgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDbGllbnQgZnJvbSBmdW5jdGlvbjonLCBjbGllbnQuZnJvbSk7XG4gICAgY29uc29sZS5sb2coJ0NsaWVudCBmcm9tIGNhbGwgcmVzdWx0OicsIGNsaWVudC5mcm9tKCdwb2xscycpKTtcbiAgICBcbiAgICAvLyBUaGlzIHNob3VsZCB3b3JrIGlmIHRoZSBtb2NrIGlzIGFwcGxpZWQgY29ycmVjdGx5XG4gICAgY29uc3QgZnJvbVJlc3VsdCA9IGNsaWVudC5mcm9tKCdwb2xscycpO1xuICAgIGNvbnNvbGUubG9nKCdGcm9tIHJlc3VsdDonLCBmcm9tUmVzdWx0KTtcbiAgICBcbiAgICBpZiAoZnJvbVJlc3VsdCkge1xuICAgICAgY29uc3Qgc2VsZWN0UmVzdWx0ID0gZnJvbVJlc3VsdC5zZWxlY3QoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTZWxlY3QgcmVzdWx0OicsIHNlbGVjdFJlc3VsdCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbGVjdFJlc3VsdC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpLmxpbWl0KDEwKTtcbiAgICAgIGNvbnNvbGUubG9nKCdNb2NrIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudC5mcm9tKCkgcmV0dXJuZWQgdW5kZWZpbmVkJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJmbiIsIlByb21pc2UiLCJyZXNvbHZlIiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiZnJvbSIsIm1vY2tSZXR1cm5WYWx1ZSIsInNlbGVjdCIsImVxIiwibGltaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJpZCIsInRpdGxlIiwiZXJyb3IiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJjbGllbnQiLCJjb25zb2xlIiwibG9nIiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0JlIiwiZnJvbVJlc3VsdCIsInNlbGVjdFJlc3VsdCIsInJlc3VsdCIsIkVy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