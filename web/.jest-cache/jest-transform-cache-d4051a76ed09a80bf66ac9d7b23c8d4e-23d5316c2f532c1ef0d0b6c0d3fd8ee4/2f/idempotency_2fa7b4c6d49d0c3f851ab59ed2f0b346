a7cedbcb3bdaa7ac21e120e3f3958157
/**
 * Idempotency Management System
 * Prevents double-submission attacks and ensures data consistency
 * 
 * Features:
 * - UUID-based idempotency keys
 * - Redis-based storage for distributed systems
 * - Automatic cleanup of expired keys
 * - Proper error handling and logging
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    checkIdempotencyKey: function() {
        return checkIdempotencyKey;
    },
    cleanupExpiredIdempotencyKeys: function() {
        return cleanupExpiredIdempotencyKeys;
    },
    createIdempotencyKey: function() {
        return createIdempotencyKey;
    },
    generateIdempotencyKey: function() {
        return generateIdempotencyKey;
    },
    getIdempotencyStats: function() {
        return getIdempotencyStats;
    },
    storeIdempotencyKey: function() {
        return storeIdempotencyKey;
    },
    validateIdempotencyKey: function() {
        return validateIdempotencyKey;
    },
    withIdempotency: function() {
        return withIdempotency;
    }
});
const _logger = require("../../utils/logger");
const _objects = require("../../utils/objects");
const _server = require("../../../utils/supabase/server");
const DEFAULT_OPTIONS = {
    ttl: 60 * 60 * 24,
    namespace: "default"
};
// Initialize Supabase client for idempotency storage
let supabase = null;
const getSupabase = async ()=>{
    if (!supabase) {
        supabase = await (0, _server.getSupabaseServerClient)();
    }
    return supabase;
};
function generateIdempotencyKey() {
    return `idem_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}
function createIdempotencyKey(key, namespace = DEFAULT_OPTIONS.namespace) {
    return `${namespace}:${key}`;
}
async function checkIdempotencyKey(key, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                exists: false,
                error: "Failed to initialize Supabase client"
            };
        }
        const { data, error } = await supabaseClient.from("idempotency_keys").select("*").eq("key", fullKey).gt("expires_at", new Date().toISOString()).single();
        if (error && error.code !== "PGRST116") {
            _logger.logger.error("Idempotency key check failed", error, {
                key: fullKey
            });
            return {
                exists: false,
                error: "Database error"
            };
        }
        return {
            exists: !!data,
            data: data?.result_data
        };
    } catch (error) {
        _logger.logger.error("Idempotency key check exception", error instanceof Error ? error : new Error("Unknown error"), {
            key: fullKey
        });
        return {
            exists: false,
            error: "System error"
        };
    }
}
async function storeIdempotencyKey(key, resultData, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    const expiresAt = new Date(Date.now() + opts.ttl * 1000).toISOString();
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                success: false,
                error: "Failed to initialize Supabase client"
            };
        }
        const { error } = await supabaseClient.from("idempotency_keys").insert({
            key: fullKey,
            result_data: resultData,
            expires_at: expiresAt,
            created_at: new Date().toISOString()
        });
        if (error) {
            _logger.logger.error("Failed to store idempotency key", error, {
                key: fullKey
            });
            return {
                success: false,
                error: "Storage failed"
            };
        }
        _logger.logger.info("Idempotency key stored", {
            key: fullKey,
            expiresAt
        });
        return {
            success: true
        };
    } catch (error) {
        _logger.logger.error("Idempotency key storage exception", error instanceof Error ? error : new Error("Unknown error"), {
            key: fullKey
        });
        return {
            success: false,
            error: "System error"
        };
    }
}
async function withIdempotency(key, operation, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    // Check if key already exists
    const checkResult = await checkIdempotencyKey(key, opts);
    if (checkResult.error) {
        return {
            success: false,
            error: checkResult.error,
            isDuplicate: false
        };
    }
    if (checkResult.exists) {
        _logger.logger.info("Idempotency key found, returning cached result", {
            key
        });
        return (0, _objects.withOptional)({
            success: true,
            isDuplicate: true
        }, {
            data: checkResult.data
        });
    }
    // Execute operation
    try {
        const result = await operation();
        // Store result for future requests
        const storeResult = await storeIdempotencyKey(key, result, opts);
        if (!storeResult.success) {
            _logger.logger.warn("Failed to store idempotency result, but operation succeeded", {
                key,
                error: storeResult.error
            });
        }
        return {
            success: true,
            data: result,
            isDuplicate: false
        };
    } catch (error) {
        _logger.logger.error("Operation failed during idempotency execution", error instanceof Error ? error : new Error("Unknown error"), {
            key
        });
        return {
            success: false,
            error: error instanceof Error ? error.message : "Operation failed",
            isDuplicate: false
        };
    }
}
async function cleanupExpiredIdempotencyKeys() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                deleted: 0,
                error: "Failed to initialize Supabase client"
            };
        }
        const { count, error } = await client.from("idempotency_keys").delete().lt("expires_at", new Date().toISOString()).select("*");
        if (error) {
            _logger.logger.error("Failed to cleanup expired idempotency keys", error);
            return {
                deleted: 0,
                error: "Cleanup failed"
            };
        }
        _logger.logger.info("Cleaned up expired idempotency keys", {
            deleted: count || 0
        });
        return {
            deleted: count || 0
        };
    } catch (error) {
        _logger.logger.error("Idempotency cleanup exception", error instanceof Error ? error : new Error("Unknown error"));
        return {
            deleted: 0,
            error: "System error"
        };
    }
}
function validateIdempotencyKey(key) {
    // Basic validation - should be a valid UUID or our custom format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const customRegex = /^idem_\d+_[a-z0-9]+$/i;
    return uuidRegex.test(key) || customRegex.test(key);
}
async function getIdempotencyStats() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Failed to initialize Supabase client"
            };
        }
        const now = new Date().toISOString();
        const { count: total, error: totalError } = await client.from("idempotency_keys").select("*", {
            count: "exact",
            head: true
        });
        if (totalError) {
            _logger.logger.error("Failed to get total idempotency keys", totalError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Query failed"
            };
        }
        const { count: expired, error: expiredError } = await client.from("idempotency_keys").select("*", {
            count: "exact",
            head: true
        }).lt("expires_at", now);
        if (expiredError) {
            _logger.logger.error("Failed to get expired idempotency keys", expiredError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Query failed"
            };
        }
        const active = (total || 0) - (expired || 0);
        return {
            total: total || 0,
            expired: expired || 0,
            active: Math.max(0, active)
        };
    } catch (error) {
        _logger.logger.error("Idempotency stats exception", error instanceof Error ? error : new Error("Unknown error"));
        return {
            total: 0,
            expired: 0,
            active: 0,
            error: "System error"
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvY29yZS9hdXRoL2lkZW1wb3RlbmN5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSWRlbXBvdGVuY3kgTWFuYWdlbWVudCBTeXN0ZW1cbiAqIFByZXZlbnRzIGRvdWJsZS1zdWJtaXNzaW9uIGF0dGFja3MgYW5kIGVuc3VyZXMgZGF0YSBjb25zaXN0ZW5jeVxuICogXG4gKiBGZWF0dXJlczpcbiAqIC0gVVVJRC1iYXNlZCBpZGVtcG90ZW5jeSBrZXlzXG4gKiAtIFJlZGlzLWJhc2VkIHN0b3JhZ2UgZm9yIGRpc3RyaWJ1dGVkIHN5c3RlbXNcbiAqIC0gQXV0b21hdGljIGNsZWFudXAgb2YgZXhwaXJlZCBrZXlzXG4gKiAtIFByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZ1xuICovXG5cbmltcG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvbGliL3V0aWxzL2xvZ2dlcidcbmltcG9ydCB7IHdpdGhPcHRpb25hbCB9IGZyb20gJ0AvbGliL3V0aWxzL29iamVjdHMnXG5pbXBvcnQgeyBnZXRTdXBhYmFzZVNlcnZlckNsaWVudCB9IGZyb20gJ0AvdXRpbHMvc3VwYWJhc2Uvc2VydmVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElkZW1wb3RlbmN5UmVzdWx0PFQ+IHtcbiAgc3VjY2VzczogYm9vbGVhblxuICBkYXRhPzogVFxuICBlcnJvcj86IHN0cmluZ1xuICBpc0R1cGxpY2F0ZTogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElkZW1wb3RlbmN5T3B0aW9ucyB7XG4gIHR0bD86IG51bWJlciAvLyBUaW1lIHRvIGxpdmUgaW4gc2Vjb25kc1xuICBuYW1lc3BhY2U/OiBzdHJpbmcgLy8gTmFtZXNwYWNlIGZvciBrZXkgaXNvbGF0aW9uXG59XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogUmVxdWlyZWQ8SWRlbXBvdGVuY3lPcHRpb25zPiA9IHtcbiAgdHRsOiA2MCAqIDYwICogMjQsIC8vIDI0IGhvdXJzXG4gIG5hbWVzcGFjZTogJ2RlZmF1bHQnXG59XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IGZvciBpZGVtcG90ZW5jeSBzdG9yYWdlXG5sZXQgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50IHwgbnVsbCA9IG51bGxcblxuY29uc3QgZ2V0U3VwYWJhc2UgPSBhc3luYyAoKSA9PiB7XG4gIGlmICghc3VwYWJhc2UpIHtcbiAgICBzdXBhYmFzZSA9IGF3YWl0IGdldFN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgfVxuICByZXR1cm4gc3VwYWJhc2Vcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVtcG90ZW5jeSBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSWRlbXBvdGVuY3lLZXkoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBpZGVtXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpfWBcbn1cblxuLyoqXG4gKiBDcmVhdGUgaWRlbXBvdGVuY3kga2V5IHdpdGggbmFtZXNwYWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJZGVtcG90ZW5jeUtleShrZXk6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmcgPSBERUZBVUxUX09QVElPTlMubmFtZXNwYWNlKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke25hbWVzcGFjZX06JHtrZXl9YFxufVxuXG4vKipcbiAqIENoZWNrIGlmIGlkZW1wb3RlbmN5IGtleSBleGlzdHMgYW5kIGlzIHZhbGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0lkZW1wb3RlbmN5S2V5PFQgPSB1bmtub3duPihcbiAga2V5OiBzdHJpbmcsIFxuICBvcHRpb25zOiBJZGVtcG90ZW5jeU9wdGlvbnMgPSB7fVxuKTogUHJvbWlzZTx7IGV4aXN0czogYm9vbGVhbjsgZGF0YT86IFQ7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucylcbiAgY29uc3QgZnVsbEtleSA9IGNyZWF0ZUlkZW1wb3RlbmN5S2V5KGtleSwgb3B0cy5uYW1lc3BhY2UpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZUNsaWVudCA9IGF3YWl0IGdldFN1cGFiYXNlKClcbiAgICBpZiAoIXN1cGFiYXNlQ2xpZW50KSB7XG4gICAgICByZXR1cm4geyBleGlzdHM6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIGNsaWVudCcgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZUNsaWVudFxuICAgICAgLmZyb20oJ2lkZW1wb3RlbmN5X2tleXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2tleScsIGZ1bGxLZXkpXG4gICAgICAuZ3QoJ2V4cGlyZXNfYXQnLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7IC8vIFBHUlNUMTE2ID0gbm8gcm93cyByZXR1cm5lZFxuICAgICAgbG9nZ2VyLmVycm9yKCdJZGVtcG90ZW5jeSBrZXkgY2hlY2sgZmFpbGVkJywgZXJyb3IsIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgICByZXR1cm4geyBleGlzdHM6IGZhbHNlLCBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4aXN0czogISFkYXRhLFxuICAgICAgZGF0YTogZGF0YT8ucmVzdWx0X2RhdGFcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdJZGVtcG90ZW5jeSBrZXkgY2hlY2sgZXhjZXB0aW9uJywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyksIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgcmV0dXJuIHsgZXhpc3RzOiBmYWxzZSwgZXJyb3I6ICdTeXN0ZW0gZXJyb3InIH1cbiAgfVxufVxuXG4vKipcbiAqIFN0b3JlIGlkZW1wb3RlbmN5IGtleSB3aXRoIHJlc3VsdCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9yZUlkZW1wb3RlbmN5S2V5PFQgPSB1bmtub3duPihcbiAga2V5OiBzdHJpbmcsXG4gIHJlc3VsdERhdGE6IFQsXG4gIG9wdGlvbnM6IElkZW1wb3RlbmN5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuICBjb25zdCBmdWxsS2V5ID0gY3JlYXRlSWRlbXBvdGVuY3lLZXkoa2V5LCBvcHRzLm5hbWVzcGFjZSlcbiAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdHMudHRsICogMTAwMCkudG9JU09TdHJpbmcoKVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2VDbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFzdXBhYmFzZUNsaWVudCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQ2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAga2V5OiBmdWxsS2V5LFxuICAgICAgICByZXN1bHRfZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHN0b3JlIGlkZW1wb3RlbmN5IGtleScsIGVycm9yLCB7IGtleTogZnVsbEtleSB9KVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnU3RvcmFnZSBmYWlsZWQnIH1cbiAgICB9XG5cbiAgICBsb2dnZXIuaW5mbygnSWRlbXBvdGVuY3kga2V5IHN0b3JlZCcsIHsga2V5OiBmdWxsS2V5LCBleHBpcmVzQXQgfSlcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IGtleSBzdG9yYWdlIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpLCB7IGtleTogZnVsbEtleSB9KVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1N5c3RlbSBlcnJvcicgfVxuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZSBmdW5jdGlvbiB3aXRoIGlkZW1wb3RlbmN5IHByb3RlY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhJZGVtcG90ZW5jeTxUPihcbiAga2V5OiBzdHJpbmcsXG4gIG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPixcbiAgb3B0aW9uczogSWRlbXBvdGVuY3lPcHRpb25zID0ge31cbik6IFByb21pc2U8SWRlbXBvdGVuY3lSZXN1bHQ8VD4+IHtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucylcblxuICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcbiAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCBjaGVja0lkZW1wb3RlbmN5S2V5PFQ+KGtleSwgb3B0cylcbiAgXG4gIGlmIChjaGVja1Jlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBjaGVja1Jlc3VsdC5lcnJvcixcbiAgICAgIGlzRHVwbGljYXRlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja1Jlc3VsdC5leGlzdHMpIHtcbiAgICBsb2dnZXIuaW5mbygnSWRlbXBvdGVuY3kga2V5IGZvdW5kLCByZXR1cm5pbmcgY2FjaGVkIHJlc3VsdCcsIHsga2V5IH0pXG4gICAgcmV0dXJuIHdpdGhPcHRpb25hbCh7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgaXNEdXBsaWNhdGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBkYXRhOiBjaGVja1Jlc3VsdC5kYXRhXG4gICAgfSlcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgb3BlcmF0aW9uXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKClcbiAgICBcbiAgICAvLyBTdG9yZSByZXN1bHQgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgIGNvbnN0IHN0b3JlUmVzdWx0ID0gYXdhaXQgc3RvcmVJZGVtcG90ZW5jeUtleShrZXksIHJlc3VsdCwgb3B0cylcbiAgICBcbiAgICBpZiAoIXN0b3JlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gc3RvcmUgaWRlbXBvdGVuY3kgcmVzdWx0LCBidXQgb3BlcmF0aW9uIHN1Y2NlZWRlZCcsIHsgXG4gICAgICAgIGtleSwgXG4gICAgICAgIGVycm9yOiBzdG9yZVJlc3VsdC5lcnJvciBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiByZXN1bHQsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdPcGVyYXRpb24gZmFpbGVkIGR1cmluZyBpZGVtcG90ZW5jeSBleGVjdXRpb24nLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKSwgeyBrZXkgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnT3BlcmF0aW9uIGZhaWxlZCcsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhbiB1cCBleHBpcmVkIGlkZW1wb3RlbmN5IGtleXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkSWRlbXBvdGVuY3lLZXlzKCk6IFByb21pc2U8eyBkZWxldGVkOiBudW1iZXI7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgIC5mcm9tKCdpZGVtcG90ZW5jeV9rZXlzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgLnNlbGVjdCgnKicpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNsZWFudXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgZXJyb3IpXG4gICAgICByZXR1cm4geyBkZWxldGVkOiAwLCBlcnJvcjogJ0NsZWFudXAgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8oJ0NsZWFuZWQgdXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgeyBkZWxldGVkOiBjb3VudCB8fCAwIH0pXG4gICAgcmV0dXJuIHsgZGVsZXRlZDogY291bnQgfHwgMCB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdJZGVtcG90ZW5jeSBjbGVhbnVwIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBpZGVtcG90ZW5jeSBrZXkgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlkZW1wb3RlbmN5S2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBzaG91bGQgYmUgYSB2YWxpZCBVVUlEIG9yIG91ciBjdXN0b20gZm9ybWF0XG4gIGNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2lcbiAgY29uc3QgY3VzdG9tUmVnZXggPSAvXmlkZW1fXFxkK19bYS16MC05XSskL2lcbiAgXG4gIHJldHVybiB1dWlkUmVnZXgudGVzdChrZXkpIHx8IGN1c3RvbVJlZ2V4LnRlc3Qoa2V5KVxufVxuXG4vKipcbiAqIEdldCBpZGVtcG90ZW5jeSBrZXkgc3RhdGlzdGljc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWRlbXBvdGVuY3lTdGF0cygpOiBQcm9taXNlPHtcbiAgdG90YWw6IG51bWJlclxuICBleHBpcmVkOiBudW1iZXJcbiAgYWN0aXZlOiBudW1iZXJcbiAgZXJyb3I/OiBzdHJpbmdcbn0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQ6IHRvdGFsLCBlcnJvcjogdG90YWxFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXG4gICAgaWYgKHRvdGFsRXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCB0b3RhbCBpZGVtcG90ZW5jeSBrZXlzJywgdG90YWxFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb3VudDogZXhwaXJlZCwgZXJyb3I6IGV4cGlyZWRFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgLmx0KCdleHBpcmVzX2F0Jywgbm93KVxuXG4gICAgaWYgKGV4cGlyZWRFcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGV4cGlyZWQgaWRlbXBvdGVuY3kga2V5cycsIGV4cGlyZWRFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlID0gKHRvdGFsIHx8IDApIC0gKGV4cGlyZWQgfHwgMClcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbDogdG90YWwgfHwgMCxcbiAgICAgIGV4cGlyZWQ6IGV4cGlyZWQgfHwgMCxcbiAgICAgIGFjdGl2ZTogTWF0aC5tYXgoMCwgYWN0aXZlKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IHN0YXRzIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjaGVja0lkZW1wb3RlbmN5S2V5IiwiY2xlYW51cEV4cGlyZWRJZGVtcG90ZW5jeUtleXMiLCJjcmVhdGVJZGVtcG90ZW5jeUtleSIsImdlbmVyYXRlSWRlbXBvdGVuY3lLZXkiLCJnZXRJZGVtcG90ZW5jeVN0YXRzIiwic3RvcmVJZGVtcG90ZW5jeUtleSIsInZhbGlkYXRlSWRlbXBvdGVuY3lLZXkiLCJ3aXRoSWRlbXBvdGVuY3kiLCJERUZBVUxUX09QVElPTlMiLCJ0dGwiLCJuYW1lc3BhY2UiLCJzdXBhYmFzZSIsImdldFN1cGFiYXNlIiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwia2V5Iiwib3B0aW9ucyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJmdWxsS2V5Iiwic3VwYWJhc2VDbGllbnQiLCJleGlzdHMiLCJlcnJvciIsImRhdGEiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJndCIsInRvSVNPU3RyaW5nIiwic2luZ2xlIiwiY29kZSIsImxvZ2dlciIsInJlc3VsdF9kYXRhIiwiRXJyb3IiLCJyZXN1bHREYXRhIiwiZXhwaXJlc0F0Iiwic3VjY2VzcyIsImluc2VydCIsImV4cGlyZXNfYXQiLCJjcmVhdGVkX2F0IiwiaW5mbyIsIm9wZXJhdGlvbiIsImNoZWNrUmVzdWx0IiwiaXNEdXBsaWNhdGUiLCJ3aXRoT3B0aW9uYWwiLCJyZXN1bHQiLCJzdG9yZVJlc3VsdCIsIndhcm4iLCJtZXNzYWdlIiwiY2xpZW50IiwiZGVsZXRlZCIsImNvdW50IiwiZGVsZXRlIiwibHQiLCJ1dWlkUmVnZXgiLCJjdXN0b21SZWdleCIsInRlc3QiLCJ0b3RhbCIsImV4cGlyZWQiLCJhY3RpdmUiLCJ0b3RhbEVycm9yIiwiaGVhZCIsImV4cGlyZWRFcnJvciIsIm1heCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDOzs7Ozs7Ozs7OztJQW9EcUJBLG1CQUFtQjtlQUFuQkE7O0lBMElBQyw2QkFBNkI7ZUFBN0JBOztJQWpKTkMsb0JBQW9CO2VBQXBCQTs7SUFQQUMsc0JBQXNCO2VBQXRCQTs7SUFnTU1DLG1CQUFtQjtlQUFuQkE7O0lBNUlBQyxtQkFBbUI7ZUFBbkJBOztJQWlJTkMsc0JBQXNCO2VBQXRCQTs7SUF6Rk1DLGVBQWU7ZUFBZkE7Ozt3QkE5SEM7eUJBQ007d0JBQ1c7QUFjeEMsTUFBTUMsa0JBQWdEO0lBQ3BEQyxLQUFLLEtBQUssS0FBSztJQUNmQyxXQUFXO0FBQ2I7QUFFQSxxREFBcUQ7QUFDckQsSUFBSUMsV0FBa0M7QUFFdEMsTUFBTUMsY0FBYztJQUNsQixJQUFJLENBQUNELFVBQVU7UUFDYkEsV0FBVyxNQUFNRSxJQUFBQSwrQkFBdUI7SUFDMUM7SUFDQSxPQUFPRjtBQUNUO0FBS08sU0FBU1I7SUFDZCxPQUFPLENBQUMsS0FBSyxFQUFFVyxLQUFLQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENB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