163aa5032482cf6c9615b8718c5913f3
/**
 * Idempotency Management System
 * Prevents double-submission attacks and ensures data consistency
 * 
 * Features:
 * - UUID-based idempotency keys
 * - Redis-based storage for distributed systems
 * - Automatic cleanup of expired keys
 * - Proper error handling and logging
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    checkIdempotencyKey: function() {
        return checkIdempotencyKey;
    },
    cleanupExpiredIdempotencyKeys: function() {
        return cleanupExpiredIdempotencyKeys;
    },
    createIdempotencyKey: function() {
        return createIdempotencyKey;
    },
    generateIdempotencyKey: function() {
        return generateIdempotencyKey;
    },
    getIdempotencyStats: function() {
        return getIdempotencyStats;
    },
    storeIdempotencyKey: function() {
        return storeIdempotencyKey;
    },
    validateIdempotencyKey: function() {
        return validateIdempotencyKey;
    },
    withIdempotency: function() {
        return withIdempotency;
    }
});
const _logger = require("../../utils/logger");
const _server = require("../../../utils/supabase/server");
const DEFAULT_OPTIONS = {
    ttl: 60 * 60 * 24,
    namespace: "default"
};
// Initialize Supabase client for idempotency storage
let supabase = null;
const getSupabase = async ()=>{
    if (!supabase) {
        supabase = await (0, _server.getSupabaseServerClient)();
    }
    return supabase;
};
function generateIdempotencyKey() {
    return `idem_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}
function createIdempotencyKey(key, namespace = DEFAULT_OPTIONS.namespace) {
    return `${namespace}:${key}`;
}
async function checkIdempotencyKey(key, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                exists: false,
                error: "Failed to initialize Supabase client"
            };
        }
        const { data, error } = await supabaseClient.from("idempotency_keys").select("*").eq("key", fullKey).gt("expires_at", new Date().toISOString()).single();
        if (error && error.code !== "PGRST116") {
            _logger.logger.error("Idempotency key check failed", error, {
                key: fullKey
            });
            return {
                exists: false,
                error: "Database error"
            };
        }
        return {
            exists: !!data,
            data: data?.result_data
        };
    } catch (error) {
        _logger.logger.error("Idempotency key check exception", error instanceof Error ? error : new Error("Unknown error"), {
            key: fullKey
        });
        return {
            exists: false,
            error: "System error"
        };
    }
}
async function storeIdempotencyKey(key, resultData, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    const expiresAt = new Date(Date.now() + opts.ttl * 1000).toISOString();
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                success: false,
                error: "Failed to initialize Supabase client"
            };
        }
        const { error } = await supabaseClient.from("idempotency_keys").insert({
            key: fullKey,
            result_data: resultData,
            expires_at: expiresAt,
            created_at: new Date().toISOString()
        });
        if (error) {
            _logger.logger.error("Failed to store idempotency key", error, {
                key: fullKey
            });
            return {
                success: false,
                error: "Storage failed"
            };
        }
        _logger.logger.info("Idempotency key stored", {
            key: fullKey,
            expiresAt
        });
        return {
            success: true
        };
    } catch (error) {
        _logger.logger.error("Idempotency key storage exception", error instanceof Error ? error : new Error("Unknown error"), {
            key: fullKey
        });
        return {
            success: false,
            error: "System error"
        };
    }
}
async function withIdempotency(key, operation, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    // Check if key already exists
    const checkResult = await checkIdempotencyKey(key, opts);
    if (checkResult.error) {
        return {
            success: false,
            error: checkResult.error,
            isDuplicate: false
        };
    }
    if (checkResult.exists) {
        _logger.logger.info("Idempotency key found, returning cached result", {
            key
        });
        return {
            success: true,
            isDuplicate: true,
            data: checkResult.data
        };
    }
    // Execute operation
    try {
        const result = await operation();
        // Store result for future requests
        const storeResult = await storeIdempotencyKey(key, result, opts);
        if (!storeResult.success) {
            _logger.logger.warn("Failed to store idempotency result, but operation succeeded", {
                key,
                error: storeResult.error
            });
        }
        return {
            success: true,
            data: result,
            isDuplicate: false
        };
    } catch (error) {
        _logger.logger.error("Operation failed during idempotency execution", error instanceof Error ? error : new Error("Unknown error"), {
            key
        });
        return {
            success: false,
            error: error instanceof Error ? error.message : "Operation failed",
            isDuplicate: false
        };
    }
}
async function cleanupExpiredIdempotencyKeys() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                deleted: 0,
                error: "Failed to initialize Supabase client"
            };
        }
        const { count, error } = await client.from("idempotency_keys").delete().lt("expires_at", new Date().toISOString()).select("*");
        if (error) {
            _logger.logger.error("Failed to cleanup expired idempotency keys", error);
            return {
                deleted: 0,
                error: "Cleanup failed"
            };
        }
        _logger.logger.info("Cleaned up expired idempotency keys", {
            deleted: count || 0
        });
        return {
            deleted: count || 0
        };
    } catch (error) {
        _logger.logger.error("Idempotency cleanup exception", error instanceof Error ? error : new Error("Unknown error"));
        return {
            deleted: 0,
            error: "System error"
        };
    }
}
function validateIdempotencyKey(key) {
    // Basic validation - should be a valid UUID or our custom format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const customRegex = /^idem_\d+_[a-z0-9]+$/i;
    return uuidRegex.test(key) || customRegex.test(key);
}
async function getIdempotencyStats() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Failed to initialize Supabase client"
            };
        }
        const now = new Date().toISOString();
        const { count: total, error: totalError } = await client.from("idempotency_keys").select("*", {
            count: "exact",
            head: true
        });
        if (totalError) {
            _logger.logger.error("Failed to get total idempotency keys", totalError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Query failed"
            };
        }
        const { count: expired, error: expiredError } = await client.from("idempotency_keys").select("*", {
            count: "exact",
            head: true
        }).lt("expires_at", now);
        if (expiredError) {
            _logger.logger.error("Failed to get expired idempotency keys", expiredError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: "Query failed"
            };
        }
        const active = (total || 0) - (expired || 0);
        return {
            total: total || 0,
            expired: expired || 0,
            active: Math.max(0, active)
        };
    } catch (error) {
        _logger.logger.error("Idempotency stats exception", error instanceof Error ? error : new Error("Unknown error"));
        return {
            total: 0,
            expired: 0,
            active: 0,
            error: "System error"
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvY29yZS9hdXRoL2lkZW1wb3RlbmN5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSWRlbXBvdGVuY3kgTWFuYWdlbWVudCBTeXN0ZW1cbiAqIFByZXZlbnRzIGRvdWJsZS1zdWJtaXNzaW9uIGF0dGFja3MgYW5kIGVuc3VyZXMgZGF0YSBjb25zaXN0ZW5jeVxuICogXG4gKiBGZWF0dXJlczpcbiAqIC0gVVVJRC1iYXNlZCBpZGVtcG90ZW5jeSBrZXlzXG4gKiAtIFJlZGlzLWJhc2VkIHN0b3JhZ2UgZm9yIGRpc3RyaWJ1dGVkIHN5c3RlbXNcbiAqIC0gQXV0b21hdGljIGNsZWFudXAgb2YgZXhwaXJlZCBrZXlzXG4gKiAtIFByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZ1xuICovXG5cbmltcG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvbGliL3V0aWxzL2xvZ2dlcidcbmltcG9ydCB7IGdldFN1cGFiYXNlU2VydmVyQ2xpZW50IH0gZnJvbSAnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbXBvdGVuY3lSZXN1bHQ8VD4ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGRhdGE/OiBUXG4gIGVycm9yPzogc3RyaW5nXG4gIGlzRHVwbGljYXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbXBvdGVuY3lPcHRpb25zIHtcbiAgdHRsPzogbnVtYmVyIC8vIFRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzXG4gIG5hbWVzcGFjZT86IHN0cmluZyAvLyBOYW1lc3BhY2UgZm9yIGtleSBpc29sYXRpb25cbn1cblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBSZXF1aXJlZDxJZGVtcG90ZW5jeU9wdGlvbnM+ID0ge1xuICB0dGw6IDYwICogNjAgKiAyNCwgLy8gMjQgaG91cnNcbiAgbmFtZXNwYWNlOiAnZGVmYXVsdCdcbn1cblxuLy8gSW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQgZm9yIGlkZW1wb3RlbmN5IHN0b3JhZ2VcbmxldCBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQgfCBudWxsID0gbnVsbFxuXG5jb25zdCBnZXRTdXBhYmFzZSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFzdXBhYmFzZSkge1xuICAgIHN1cGFiYXNlID0gYXdhaXQgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuICB9XG4gIHJldHVybiBzdXBhYmFzZVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW1wb3RlbmN5IGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZGVtcG90ZW5jeUtleSgpOiBzdHJpbmcge1xuICByZXR1cm4gYGlkZW1fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSl9YFxufVxuXG4vKipcbiAqIENyZWF0ZSBpZGVtcG90ZW5jeSBrZXkgd2l0aCBuYW1lc3BhY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlkZW1wb3RlbmN5S2V5KGtleTogc3RyaW5nLCBuYW1lc3BhY2U6IHN0cmluZyA9IERFRkFVTFRfT1BUSU9OUy5uYW1lc3BhY2UpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7bmFtZXNwYWNlfToke2tleX1gXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgaWRlbXBvdGVuY3kga2V5IGV4aXN0cyBhbmQgaXMgdmFsaWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrSWRlbXBvdGVuY3lLZXk8VCA9IHVua25vd24+KFxuICBrZXk6IHN0cmluZywgXG4gIG9wdGlvbnM6IElkZW1wb3RlbmN5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHsgZXhpc3RzOiBib29sZWFuOyBkYXRhPzogVDsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuICBjb25zdCBmdWxsS2V5ID0gY3JlYXRlSWRlbXBvdGVuY3lLZXkoa2V5LCBvcHRzLm5hbWVzcGFjZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlQ2xpZW50ID0gYXdhaXQgZ2V0U3VwYWJhc2UoKVxuICAgIGlmICghc3VwYWJhc2VDbGllbnQpIHtcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQ2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgna2V5JywgZnVsbEtleSlcbiAgICAgIC5ndCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHsgLy8gUEdSU1QxMTYgPSBubyByb3dzIHJldHVybmVkXG4gICAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IGtleSBjaGVjayBmYWlsZWQnLCBlcnJvciwgeyBrZXk6IGZ1bGxLZXkgfSlcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UsIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpc3RzOiAhIWRhdGEsXG4gICAgICBkYXRhOiBkYXRhPy5yZXN1bHRfZGF0YVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IGtleSBjaGVjayBleGNlcHRpb24nLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKSwgeyBrZXk6IGZ1bGxLZXkgfSlcbiAgICByZXR1cm4geyBleGlzdHM6IGZhbHNlLCBlcnJvcjogJ1N5c3RlbSBlcnJvcicgfVxuICB9XG59XG5cbi8qKlxuICogU3RvcmUgaWRlbXBvdGVuY3kga2V5IHdpdGggcmVzdWx0IGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0b3JlSWRlbXBvdGVuY3lLZXk8VCA9IHVua25vd24+KFxuICBrZXk6IHN0cmluZyxcbiAgcmVzdWx0RGF0YTogVCxcbiAgb3B0aW9uczogSWRlbXBvdGVuY3lPcHRpb25zID0ge31cbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpXG4gIGNvbnN0IGZ1bGxLZXkgPSBjcmVhdGVJZGVtcG90ZW5jeUtleShrZXksIG9wdHMubmFtZXNwYWNlKVxuICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0cy50dGwgKiAxMDAwKS50b0lTT1N0cmluZygpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZUNsaWVudCA9IGF3YWl0IGdldFN1cGFiYXNlKClcbiAgICBpZiAoIXN1cGFiYXNlQ2xpZW50KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQnIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VDbGllbnRcbiAgICAgIC5mcm9tKCdpZGVtcG90ZW5jeV9rZXlzJylcbiAgICAgIC5pbnNlcnQoe1xuICAgICAgICBrZXk6IGZ1bGxLZXksXG4gICAgICAgIHJlc3VsdF9kYXRhOiByZXN1bHREYXRhLFxuICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgaWRlbXBvdGVuY3kga2V5JywgZXJyb3IsIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTdG9yYWdlIGZhaWxlZCcgfVxuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvKCdJZGVtcG90ZW5jeSBrZXkgc3RvcmVkJywgeyBrZXk6IGZ1bGxLZXksIGV4cGlyZXNBdCB9KVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcignSWRlbXBvdGVuY3kga2V5IHN0b3JhZ2UgZXhjZXB0aW9uJywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyksIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGZ1bmN0aW9uIHdpdGggaWRlbXBvdGVuY3kgcHJvdGVjdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aElkZW1wb3RlbmN5PFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBvcHRpb25zOiBJZGVtcG90ZW5jeU9wdGlvbnMgPSB7fVxuKTogUHJvbWlzZTxJZGVtcG90ZW5jeVJlc3VsdDxUPj4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuXG4gIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuICBjb25zdCBjaGVja1Jlc3VsdCA9IGF3YWl0IGNoZWNrSWRlbXBvdGVuY3lLZXk8VD4oa2V5LCBvcHRzKVxuICBcbiAgaWYgKGNoZWNrUmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGNoZWNrUmVzdWx0LmVycm9yLFxuICAgICAgaXNEdXBsaWNhdGU6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrUmVzdWx0LmV4aXN0cykge1xuICAgIGxvZ2dlci5pbmZvKCdJZGVtcG90ZW5jeSBrZXkgZm91bmQsIHJldHVybmluZyBjYWNoZWQgcmVzdWx0JywgeyBrZXkgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGlzRHVwbGljYXRlOiB0cnVlLFxuICAgICAgZGF0YTogY2hlY2tSZXN1bHQuZGF0YVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4ZWN1dGUgb3BlcmF0aW9uXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKClcbiAgICBcbiAgICAvLyBTdG9yZSByZXN1bHQgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgIGNvbnN0IHN0b3JlUmVzdWx0ID0gYXdhaXQgc3RvcmVJZGVtcG90ZW5jeUtleShrZXksIHJlc3VsdCwgb3B0cylcbiAgICBcbiAgICBpZiAoIXN0b3JlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gc3RvcmUgaWRlbXBvdGVuY3kgcmVzdWx0LCBidXQgb3BlcmF0aW9uIHN1Y2NlZWRlZCcsIHsgXG4gICAgICAgIGtleSwgXG4gICAgICAgIGVycm9yOiBzdG9yZVJlc3VsdC5lcnJvciBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiByZXN1bHQsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdPcGVyYXRpb24gZmFpbGVkIGR1cmluZyBpZGVtcG90ZW5jeSBleGVjdXRpb24nLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKSwgeyBrZXkgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnT3BlcmF0aW9uIGZhaWxlZCcsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhbiB1cCBleHBpcmVkIGlkZW1wb3RlbmN5IGtleXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkSWRlbXBvdGVuY3lLZXlzKCk6IFByb21pc2U8eyBkZWxldGVkOiBudW1iZXI7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgIC5mcm9tKCdpZGVtcG90ZW5jeV9rZXlzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgLnNlbGVjdCgnKicpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNsZWFudXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgZXJyb3IpXG4gICAgICByZXR1cm4geyBkZWxldGVkOiAwLCBlcnJvcjogJ0NsZWFudXAgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8oJ0NsZWFuZWQgdXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgeyBkZWxldGVkOiBjb3VudCB8fCAwIH0pXG4gICAgcmV0dXJuIHsgZGVsZXRlZDogY291bnQgfHwgMCB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdJZGVtcG90ZW5jeSBjbGVhbnVwIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBpZGVtcG90ZW5jeSBrZXkgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlkZW1wb3RlbmN5S2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBzaG91bGQgYmUgYSB2YWxpZCBVVUlEIG9yIG91ciBjdXN0b20gZm9ybWF0XG4gIGNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2lcbiAgY29uc3QgY3VzdG9tUmVnZXggPSAvXmlkZW1fXFxkK19bYS16MC05XSskL2lcbiAgXG4gIHJldHVybiB1dWlkUmVnZXgudGVzdChrZXkpIHx8IGN1c3RvbVJlZ2V4LnRlc3Qoa2V5KVxufVxuXG4vKipcbiAqIEdldCBpZGVtcG90ZW5jeSBrZXkgc3RhdGlzdGljc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWRlbXBvdGVuY3lTdGF0cygpOiBQcm9taXNlPHtcbiAgdG90YWw6IG51bWJlclxuICBleHBpcmVkOiBudW1iZXJcbiAgYWN0aXZlOiBudW1iZXJcbiAgZXJyb3I/OiBzdHJpbmdcbn0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQ6IHRvdGFsLCBlcnJvcjogdG90YWxFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXG4gICAgaWYgKHRvdGFsRXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCB0b3RhbCBpZGVtcG90ZW5jeSBrZXlzJywgdG90YWxFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb3VudDogZXhwaXJlZCwgZXJyb3I6IGV4cGlyZWRFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgLmx0KCdleHBpcmVzX2F0Jywgbm93KVxuXG4gICAgaWYgKGV4cGlyZWRFcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGV4cGlyZWQgaWRlbXBvdGVuY3kga2V5cycsIGV4cGlyZWRFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlID0gKHRvdGFsIHx8IDApIC0gKGV4cGlyZWQgfHwgMClcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbDogdG90YWwgfHwgMCxcbiAgICAgIGV4cGlyZWQ6IGV4cGlyZWQgfHwgMCxcbiAgICAgIGFjdGl2ZTogTWF0aC5tYXgoMCwgYWN0aXZlKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IHN0YXRzIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjaGVja0lkZW1wb3RlbmN5S2V5IiwiY2xlYW51cEV4cGlyZWRJZGVtcG90ZW5jeUtleXMiLCJjcmVhdGVJZGVtcG90ZW5jeUtleSIsImdlbmVyYXRlSWRlbXBvdGVuY3lLZXkiLCJnZXRJZGVtcG90ZW5jeVN0YXRzIiwic3RvcmVJZGVtcG90ZW5jeUtleSIsInZhbGlkYXRlSWRlbXBvdGVuY3lLZXkiLCJ3aXRoSWRlbXBvdGVuY3kiLCJERUZBVUxUX09QVElPTlMiLCJ0dGwiLCJuYW1lc3BhY2UiLCJzdXBhYmFzZSIsImdldFN1cGFiYXNlIiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwia2V5Iiwib3B0aW9ucyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJmdWxsS2V5Iiwic3VwYWJhc2VDbGllbnQiLCJleGlzdHMiLCJlcnJvciIsImRhdGEiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJndCIsInRvSVNPU3RyaW5nIiwic2luZ2xlIiwiY29kZSIsImxvZ2dlciIsInJlc3VsdF9kYXRhIiwiRXJyb3IiLCJyZXN1bHREYXRhIiwiZXhwaXJlc0F0Iiwic3VjY2VzcyIsImluc2VydCIsImV4cGlyZXNfYXQiLCJjcmVhdGVkX2F0IiwiaW5mbyIsIm9wZXJhdGlvbiIsImNoZWNrUmVzdWx0IiwiaXNEdXBsaWNhdGUiLCJyZXN1bHQiLCJzdG9yZVJlc3VsdCIsIndhcm4iLCJtZXNzYWdlIiwiY2xpZW50IiwiZGVsZXRlZCIsImNvdW50IiwiZGVsZXRlIiwibHQiLCJ1dWlkUmVnZXgiLCJjdXN0b21SZWdleCIsInRlc3QiLCJ0b3RhbCIsImV4cGlyZWQiLCJhY3RpdmUiLCJ0b3RhbEVycm9yIiwiaGVhZCIsImV4cGlyZWRFcnJvciIsIm1heCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDOzs7Ozs7Ozs7OztJQW1EcUJBLG1CQUFtQjtlQUFuQkE7O0lBeUlBQyw2QkFBNkI7ZUFBN0JBOztJQWhKTkMsb0JBQW9CO2VBQXBCQTs7SUFQQUMsc0JBQXNCO2VBQXRCQTs7SUErTE1DLG1CQUFtQjtlQUFuQkE7O0lBM0lBQyxtQkFBbUI7ZUFBbkJBOztJQWdJTkMsc0JBQXNCO2VBQXRCQTs7SUF4Rk1DLGVBQWU7ZUFBZkE7Ozt3QkE3SEM7d0JBQ2lCO0FBY3hDLE1BQU1DLGtCQUFnRDtJQUNwREMsS0FBSyxLQUFLLEtBQUs7SUFDZkMsV0FBVztBQUNiO0FBRUEscURBQXFEO0FBQ3JELElBQUlDLFdBQWtDO0FBRXRDLE1BQU1DLGNBQWM7SUFDbEIsSUFBSSxDQUFDRCxVQUFVO1FBQ2JBLFdBQVcsTUFBTUUsSUFBQUEsK0JBQXVCO0lBQzFDO0lBQ0EsT0FBT0Y7QUFDVDtBQUtPLFNBQVNSO0lBQ2QsT0FBTyxDQUFDLEtBQUssRUFBRVcsS0FBS0MsR0FBRyxHQUFHLENBQUMsRUFBRUMsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQzVFO0FBS08sU0FBU2pCLHFCQUFxQmtCLEdBQVcsRUFBRVYsWUFBb0JGLGdCQUFnQkUsU0FBUztJQUM3RixPQUFPLENBQUMsRUFB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