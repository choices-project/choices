c0d258620466ec34779c99551feac23c
/**
 * Polls CRUD API Tests - INTEGRATION VERSION
 * 
 * This is an integration test that uses real database connections.
 * No mocks - tests actual API endpoints with real Supabase database.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _route = require("../../../../../app/api/polls/route");
// This is an integration test - use real database connections
// No mocks needed - let the API connect to real Supabase database
// Set real Supabase credentials for integration testing
process.env.NEXT_PUBLIC_SUPABASE_URL = "https://muqwrehywjrbaeerjgfb.supabase.co";
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = "sb_publishable_tJOpGO2IPjujJDQou44P_g_BgbTFBfc";
(0, _globals.describe)("Polls CRUD API - INTEGRATION", ()=>{
    (0, _globals.beforeEach)(()=>{
    // No mocks to clear - using real database
    });
    (0, _globals.afterEach)(()=>{
    // No mocks to restore - using real database
    });
    (0, _globals.describe)("GET /api/polls - List Polls", ()=>{
        (0, _globals.it)("should return list of polls", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/polls");
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            // Debug: Let's see what we actually get
            console.log("Response status:", response.status);
            console.log("Response data:", responseData);
            // For now, just check that we get a response
            // We'll evolve this to check the exact structure later
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData).toHaveProperty("success");
            (0, _globals.expect)(responseData).toHaveProperty("polls");
        });
        (0, _globals.it)("should handle errors gracefully", async ()=>{
            // Test with invalid request to trigger error handling
            const request = new _server.NextRequest("http://localhost:3000/api/polls?invalid=param");
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            // Should still return 200 but with error handling
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData).toHaveProperty("success");
        });
    });
    (0, _globals.describe)("POST /api/polls - Create Poll", ()=>{
        (0, _globals.it)("should create a new poll with valid data", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/polls", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    title: "New Test Poll",
                    options: [
                        {
                            text: "New Option 1"
                        },
                        {
                            text: "New Option 2"
                        }
                    ]
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            console.log("POST Response status:", response.status);
            console.log("POST Response data:", responseData);
            // For now, just check that we get a response
            (0, _globals.expect)(response.status).toBe(201);
            (0, _globals.expect)(responseData).toHaveProperty("success");
            (0, _globals.expect)(responseData).toHaveProperty("poll");
        });
        (0, _globals.it)("should reject poll creation without authentication", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/polls", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    title: "Unauthorized Poll",
                    options: [
                        {
                            text: "Option 1"
                        },
                        {
                            text: "Option 2"
                        }
                    ]
                })
            });
            const response = await (0, _route.POST)(request);
            const responseData = await response.json();
            console.log("Unauthorized Response status:", response.status);
            console.log("Unauthorized Response data:", responseData);
            // Should reject without authentication
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(responseData).toHaveProperty("error");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYXBpL2NvcmUvcG9sbHMtY3J1ZC1pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUG9sbHMgQ1JVRCBBUEkgVGVzdHMgLSBJTlRFR1JBVElPTiBWRVJTSU9OXG4gKiBcbiAqIFRoaXMgaXMgYW4gaW50ZWdyYXRpb24gdGVzdCB0aGF0IHVzZXMgcmVhbCBkYXRhYmFzZSBjb25uZWN0aW9ucy5cbiAqIE5vIG1vY2tzIC0gdGVzdHMgYWN0dWFsIEFQSSBlbmRwb2ludHMgd2l0aCByZWFsIFN1cGFiYXNlIGRhdGFiYXNlLlxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgR0VULCBQT1NUIH0gZnJvbSAnQC9hcHAvYXBpL3BvbGxzL3JvdXRlJztcblxuLy8gVGhpcyBpcyBhbiBpbnRlZ3JhdGlvbiB0ZXN0IC0gdXNlIHJlYWwgZGF0YWJhc2UgY29ubmVjdGlvbnNcbi8vIE5vIG1vY2tzIG5lZWRlZCAtIGxldCB0aGUgQVBJIGNvbm5lY3QgdG8gcmVhbCBTdXBhYmFzZSBkYXRhYmFzZVxuXG4vLyBTZXQgcmVhbCBTdXBhYmFzZSBjcmVkZW50aWFscyBmb3IgaW50ZWdyYXRpb24gdGVzdGluZ1xucHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vbXVxd3JlaHl3anJiYWVlcmpnZmIuc3VwYWJhc2UuY28nO1xucHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPSAnc2JfcHVibGlzaGFibGVfdEpPcEdPMklQanVqSkRRb3U0NFBfZ19CZ2JURkJmYyc7XG5cbmRlc2NyaWJlKCdQb2xscyBDUlVEIEFQSSAtIElOVEVHUkFUSU9OJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBObyBtb2NrcyB0byBjbGVhciAtIHVzaW5nIHJlYWwgZGF0YWJhc2VcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBObyBtb2NrcyB0byByZXN0b3JlIC0gdXNpbmcgcmVhbCBkYXRhYmFzZVxuICB9KTtcblxuICBkZXNjcmliZSgnR0VUIC9hcGkvcG9sbHMgLSBMaXN0IFBvbGxzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGxpc3Qgb2YgcG9sbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BvbGxzJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBEZWJ1ZzogTGV0J3Mgc2VlIHdoYXQgd2UgYWN0dWFsbHkgZ2V0XG4gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgZGF0YTonLCByZXNwb25zZURhdGEpO1xuXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGNoZWNrIHRoYXQgd2UgZ2V0IGEgcmVzcG9uc2VcbiAgICAgIC8vIFdlJ2xsIGV2b2x2ZSB0aGlzIHRvIGNoZWNrIHRoZSBleGFjdCBzdHJ1Y3R1cmUgbGF0ZXJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEpLnRvSGF2ZVByb3BlcnR5KCdzdWNjZXNzJyk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhKS50b0hhdmVQcm9wZXJ0eSgncG9sbHMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIGludmFsaWQgcmVxdWVzdCB0byB0cmlnZ2VyIGVycm9yIGhhbmRsaW5nXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BvbGxzP2ludmFsaWQ9cGFyYW0nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBTaG91bGQgc3RpbGwgcmV0dXJuIDIwMCBidXQgd2l0aCBlcnJvciBoYW5kbGluZ1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YSkudG9IYXZlUHJvcGVydHkoJ3N1Y2Nlc3MnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9wb2xscyAtIENyZWF0ZSBQb2xsJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHBvbGwgd2l0aCB2YWxpZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGl0bGU6ICdOZXcgVGVzdCBQb2xsJyxcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHRleHQ6ICdOZXcgT3B0aW9uIDEnIH0sXG4gICAgICAgICAgICB7IHRleHQ6ICdOZXcgT3B0aW9uIDInIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgY29uc29sZS5sb2coJ1BPU1QgUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjb25zb2xlLmxvZygnUE9TVCBSZXNwb25zZSBkYXRhOicsIHJlc3BvbnNlRGF0YSk7XG5cbiAgICAgIC8vIEZvciBub3csIGp1c3QgY2hlY2sgdGhhdCB3ZSBnZXQgYSByZXNwb25zZVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YSkudG9IYXZlUHJvcGVydHkoJ3N1Y2Nlc3MnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZURhdGEpLnRvSGF2ZVByb3BlcnR5KCdwb2xsJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBwb2xsIGNyZWF0aW9uIHdpdGhvdXQgYXV0aGVudGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BvbGxzJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0aXRsZTogJ1VuYXV0aG9yaXplZCBQb2xsJyxcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHRleHQ6ICdPcHRpb24gMScgfSxcbiAgICAgICAgICAgIHsgdGV4dDogJ09wdGlvbiAyJyB9XG4gICAgICAgICAgXVxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdVbmF1dGhvcml6ZWQgUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjb25zb2xlLmxvZygnVW5hdXRob3JpemVkIFJlc3BvbnNlIGRhdGE6JywgcmVzcG9uc2VEYXRhKTtcblxuICAgICAgLy8gU2hvdWxkIHJlamVjdCB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QocmVzcG9uc2VEYXRhKS50b0hhdmVQcm9wZXJ0eSgnZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJpdCIsInJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsInJlc3BvbnNlIiwiR0VUIiwicmVzcG9uc2VEYXRhIiwianNvbiIsImNvbnNvbGUiLCJsb2ciLCJzdGF0dXMiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlUHJvcGVydHkiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0aXRsZSIsIm9wdGlvbnMiLCJ0ZXh0IiwiUE9TVCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRTJEO3dCQUNoQzt1QkFDRjtBQUUxQiw4REFBOEQ7QUFDOUQsa0VBQWtFO0FBRWxF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