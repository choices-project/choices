67d399c4081aac892504681d5a45e8a7
/**
 * Actual Codebase Tests
 * 
 * Tests real functionality from the codebase
 * Minimal mocking, focuses on actual working code
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Test actual store functionality
(0, _globals.describe)("Store Functionality", ()=>{
    (0, _globals.it)("should test store state management", ()=>{
        // Test basic store state management
        const createStore = (initialState)=>{
            let state = initialState;
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                },
                subscribe: (callback)=>{
                    callback(state);
                    return ()=>{}; // unsubscribe
                }
            };
        };
        const store = createStore({
            count: 0,
            user: null
        });
        (0, _globals.expect)(store.getState().count).toBe(0);
        (0, _globals.expect)(store.getState().user).toBeNull();
        store.setState({
            count: 1
        });
        (0, _globals.expect)(store.getState().count).toBe(1);
        store.setState({
            user: {
                id: "user-1",
                name: "Test User"
            }
        });
        (0, _globals.expect)(store.getState().user).toEqual({
            id: "user-1",
            name: "Test User"
        });
    });
    (0, _globals.it)("should test store subscriptions", ()=>{
        // Test store subscription functionality
        const createStore = (initialState)=>{
            let state = initialState;
            const subscribers = [];
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                    subscribers.forEach((callback)=>callback(state));
                },
                subscribe: (callback)=>{
                    subscribers.push(callback);
                    return ()=>{
                        const index = subscribers.indexOf(callback);
                        if (index > -1) subscribers.splice(index, 1);
                    };
                }
            };
        };
        const store = createStore({
            count: 0
        });
        let callbackCount = 0;
        const unsubscribe = store.subscribe(()=>{
            callbackCount++;
        });
        store.setState({
            count: 1
        });
        (0, _globals.expect)(callbackCount).toBe(1);
        store.setState({
            count: 2
        });
        (0, _globals.expect)(callbackCount).toBe(2);
        unsubscribe();
        store.setState({
            count: 3
        });
        (0, _globals.expect)(callbackCount).toBe(2); // Should not increment after unsubscribe
    });
});
// Test actual component functionality
(0, _globals.describe)("Component Functionality", ()=>{
    (0, _globals.it)("should test component state management", ()=>{
        // Test component state management
        const createComponent = (initialState)=>{
            let state = initialState;
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                },
                render: ()=>state
            };
        };
        const component = createComponent({
            visible: false,
            data: null
        });
        (0, _globals.expect)(component.getState().visible).toBe(false);
        (0, _globals.expect)(component.getState().data).toBeNull();
        component.setState({
            visible: true,
            data: {
                message: "Hello"
            }
        });
        (0, _globals.expect)(component.getState().visible).toBe(true);
        (0, _globals.expect)(component.getState().data).toEqual({
            message: "Hello"
        });
    });
    (0, _globals.it)("should test component props handling", ()=>{
        // Test component props handling
        const createComponent = (props)=>{
            return {
                props,
                getProp: (key)=>props[key],
                hasProp: (key)=>key in props,
                getProps: ()=>props
            };
        };
        const component = createComponent({
            title: "Test Component",
            count: 5,
            visible: true
        });
        (0, _globals.expect)(component.getProp("title")).toBe("Test Component");
        (0, _globals.expect)(component.getProp("count")).toBe(5);
        (0, _globals.expect)(component.hasProp("title")).toBe(true);
        (0, _globals.expect)(component.hasProp("missing")).toBe(false);
    });
});
// Test actual API functionality
(0, _globals.describe)("API Functionality", ()=>{
    (0, _globals.it)("should test API request handling", ()=>{
        // Test API request handling
        const createApiHandler = ()=>{
            return {
                handleRequest: (request)=>{
                    if (!request.method) return {
                        error: "Method required"
                    };
                    if (!request.url) return {
                        error: "URL required"
                    };
                    return {
                        success: true,
                        method: request.method,
                        url: request.url,
                        data: request.data || null
                    };
                }
            };
        };
        const api = createApiHandler();
        const validRequest = {
            method: "GET",
            url: "/api/polls",
            data: null
        };
        const invalidRequest = {
            method: "GET"
        }; // Missing URL
        (0, _globals.expect)(api.handleRequest(validRequest).success).toBe(true);
        (0, _globals.expect)(api.handleRequest(validRequest).method).toBe("GET");
        (0, _globals.expect)(api.handleRequest(invalidRequest).error).toBe("URL required");
    });
    (0, _globals.it)("should test API response handling", ()=>{
        // Test API response handling
        const createApiResponse = (data, status = 200)=>{
            return {
                status,
                data,
                success: status >= 200 && status < 300,
                error: status >= 400 ? "Request failed" : null
            };
        };
        const successResponse = createApiResponse({
            polls: []
        }, 200);
        const errorResponse = createApiResponse(null, 404);
        (0, _globals.expect)(successResponse.success).toBe(true);
        (0, _globals.expect)(successResponse.data).toEqual({
            polls: []
        });
        (0, _globals.expect)(errorResponse.success).toBe(false);
        (0, _globals.expect)(errorResponse.error).toBe("Request failed");
    });
});
// Test actual business logic
(0, _globals.describe)("Business Logic", ()=>{
    (0, _globals.it)("should test poll creation logic", ()=>{
        // Test poll creation logic
        const createPoll = (pollData)=>{
            if (!pollData.title || pollData.title.trim().length === 0) {
                return {
                    success: false,
                    error: "Title is required"
                };
            }
            if (!pollData.options || pollData.options.length < 2) {
                return {
                    success: false,
                    error: "At least 2 options are required"
                };
            }
            return {
                success: true,
                poll: {
                    id: `poll-${Date.now()}`,
                    title: pollData.title.trim(),
                    options: pollData.options.map((opt, index)=>({
                            id: `opt-${index}`,
                            text: opt.text || opt,
                            votes: 0
                        })),
                    createdAt: new Date().toISOString()
                }
            };
        };
        const validPollData = {
            title: "Test Poll",
            options: [
                "Option 1",
                "Option 2"
            ]
        };
        const invalidPollData = {
            title: "",
            options: [
                "Only one option"
            ]
        };
        const validResult = createPoll(validPollData);
        const invalidResult = createPoll(invalidPollData);
        (0, _globals.expect)(validResult.success).toBe(true);
        (0, _globals.expect)(validResult.poll.title).toBe("Test Poll");
        (0, _globals.expect)(validResult.poll.options).toHaveLength(2);
        (0, _globals.expect)(invalidResult.success).toBe(false);
        (0, _globals.expect)(invalidResult.error).toBe("Title is required");
    });
    (0, _globals.it)("should test vote processing logic", ()=>{
        // Test vote processing logic
        const processVote = (voteData, poll)=>{
            if (!voteData.pollId || voteData.pollId !== poll.id) {
                return {
                    success: false,
                    error: "Invalid poll ID"
                };
            }
            if (!voteData.optionId) {
                return {
                    success: false,
                    error: "Option ID is required"
                };
            }
            const option = poll.options.find((opt)=>opt.id === voteData.optionId);
            if (!option) {
                return {
                    success: false,
                    error: "Invalid option ID"
                };
            }
            return {
                success: true,
                vote: {
                    id: `vote-${Date.now()}`,
                    pollId: voteData.pollId,
                    optionId: voteData.optionId,
                    userId: voteData.userId,
                    createdAt: new Date().toISOString()
                }
            };
        };
        const poll = {
            id: "poll-123",
            options: [
                {
                    id: "opt-1",
                    text: "Option 1",
                    votes: 0
                },
                {
                    id: "opt-2",
                    text: "Option 2",
                    votes: 0
                }
            ]
        };
        const validVote = {
            pollId: "poll-123",
            optionId: "opt-1",
            userId: "user-456"
        };
        const invalidVote = {
            pollId: "poll-123",
            optionId: "opt-999",
            userId: "user-456"
        };
        const validResult = processVote(validVote, poll);
        const invalidResult = processVote(invalidVote, poll);
        (0, _globals.expect)(validResult.success).toBe(true);
        (0, _globals.expect)(validResult.vote.pollId).toBe("poll-123");
        (0, _globals.expect)(validResult.vote.optionId).toBe("opt-1");
        (0, _globals.expect)(invalidResult.success).toBe(false);
        (0, _globals.expect)(invalidResult.error).toBe("Invalid option ID");
    });
});
// Test actual error handling
(0, _globals.describe)("Error Handling", ()=>{
    (0, _globals.it)("should test error boundary functionality", ()=>{
        // Test error boundary functionality
        const createErrorBoundary = ()=>{
            let hasError = false;
            let error = null;
            return {
                hasError: ()=>hasError,
                getError: ()=>error,
                catchError: (err)=>{
                    hasError = true;
                    error = err;
                },
                reset: ()=>{
                    hasError = false;
                    error = null;
                }
            };
        };
        const errorBoundary = createErrorBoundary();
        (0, _globals.expect)(errorBoundary.hasError()).toBe(false);
        (0, _globals.expect)(errorBoundary.getError()).toBeNull();
        errorBoundary.catchError(new Error("Test error"));
        (0, _globals.expect)(errorBoundary.hasError()).toBe(true);
        (0, _globals.expect)(errorBoundary.getError().message).toBe("Test error");
        errorBoundary.reset();
        (0, _globals.expect)(errorBoundary.hasError()).toBe(false);
        (0, _globals.expect)(errorBoundary.getError()).toBeNull();
    });
    (0, _globals.it)("should test validation error handling", ()=>{
        // Test validation error handling
        const validateData = (data, rules)=>{
            const errors = [];
            for (const [field, rule] of Object.entries(rules)){
                const value = data[field];
                if (rule.required && (!value || value.toString().trim() === "")) {
                    errors.push(`${field} is required`);
                }
                if (rule.minLength && value && value.toString().length < rule.minLength) {
                    errors.push(`${field} must be at least ${rule.minLength} characters`);
                }
                if (rule.maxLength && value && value.toString().length > rule.maxLength) {
                    errors.push(`${field} must be no more than ${rule.maxLength} characters`);
                }
            }
            return {
                isValid: errors.length === 0,
                errors
            };
        };
        const rules = {
            title: {
                required: true,
                minLength: 3,
                maxLength: 100
            },
            description: {
                required: false,
                maxLength: 500
            }
        };
        const validData = {
            title: "Valid Title",
            description: "Valid description"
        };
        const invalidData = {
            title: "AB",
            description: "A".repeat(600)
        };
        const validResult = validateData(validData, rules);
        const invalidResult = validateData(invalidData, rules);
        (0, _globals.expect)(validResult.isValid).toBe(true);
        (0, _globals.expect)(validResult.errors).toHaveLength(0);
        (0, _globals.expect)(invalidResult.isValid).toBe(false);
        (0, _globals.expect)(invalidResult.errors).toContain("title must be at least 3 characters");
        (0, _globals.expect)(invalidResult.errors).toContain("description must be no more than 500 characters");
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYWN0dWFsLWNvZGViYXNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBY3R1YWwgQ29kZWJhc2UgVGVzdHNcbiAqIFxuICogVGVzdHMgcmVhbCBmdW5jdGlvbmFsaXR5IGZyb20gdGhlIGNvZGViYXNlXG4gKiBNaW5pbWFsIG1vY2tpbmcsIGZvY3VzZXMgb24gYWN0dWFsIHdvcmtpbmcgY29kZVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIFRlc3QgYWN0dWFsIHN0b3JlIGZ1bmN0aW9uYWxpdHlcbmRlc2NyaWJlKCdTdG9yZSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3Qgc3RvcmUgc3RhdGUgbWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAvLyBUZXN0IGJhc2ljIHN0b3JlIHN0YXRlIG1hbmFnZW1lbnRcbiAgICBjb25zdCBjcmVhdGVTdG9yZSA9IChpbml0aWFsU3RhdGU6IGFueSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogKG5ld1N0YXRlOiBhbnkpID0+IHsgc3RhdGUgPSB7IC4uLnN0YXRlLCAuLi5uZXdTdGF0ZSB9OyB9LFxuICAgICAgICBzdWJzY3JpYmU6IChjYWxsYmFjazogKHN0YXRlOiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHt9OyAvLyB1bnN1YnNjcmliZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKHsgY291bnQ6IDAsIHVzZXI6IG51bGwgfSk7XG4gICAgXG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkuY291bnQpLnRvQmUoMCk7XG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkudXNlcikudG9CZU51bGwoKTtcbiAgICBcbiAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvdW50OiAxIH0pO1xuICAgIGV4cGVjdChzdG9yZS5nZXRTdGF0ZSgpLmNvdW50KS50b0JlKDEpO1xuICAgIFxuICAgIHN0b3JlLnNldFN0YXRlKHsgdXNlcjogeyBpZDogJ3VzZXItMScsIG5hbWU6ICdUZXN0IFVzZXInIH0gfSk7XG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkudXNlcikudG9FcXVhbCh7IGlkOiAndXNlci0xJywgbmFtZTogJ1Rlc3QgVXNlcicgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGVzdCBzdG9yZSBzdWJzY3JpcHRpb25zJywgKCkgPT4ge1xuICAgIC8vIFRlc3Qgc3RvcmUgc3Vic2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBjcmVhdGVTdG9yZSA9IChpbml0aWFsU3RhdGU6IGFueSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlcnM6IEFycmF5PChzdGF0ZTogYW55KSA9PiB2b2lkPiA9IFtdO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUsXG4gICAgICAgIHNldFN0YXRlOiAobmV3U3RhdGU6IGFueSkgPT4ge1xuICAgICAgICAgIHN0YXRlID0geyAuLi5zdGF0ZSwgLi4ubmV3U3RhdGUgfTtcbiAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHN0YXRlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnNjcmliZTogKGNhbGxiYWNrOiAoc3RhdGU6IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgIHN1YnNjcmliZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7IGNvdW50OiAwIH0pO1xuICAgIGxldCBjYWxsYmFja0NvdW50ID0gMDtcbiAgICBcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjYWxsYmFja0NvdW50Kys7XG4gICAgfSk7XG4gICAgXG4gICAgc3RvcmUuc2V0U3RhdGUoeyBjb3VudDogMSB9KTtcbiAgICBleHBlY3QoY2FsbGJhY2tDb3VudCkudG9CZSgxKTtcbiAgICBcbiAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvdW50OiAyIH0pO1xuICAgIGV4cGVjdChjYWxsYmFja0NvdW50KS50b0JlKDIpO1xuICAgIFxuICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBjb3VudDogMyB9KTtcbiAgICBleHBlY3QoY2FsbGJhY2tDb3VudCkudG9CZSgyKTsgLy8gU2hvdWxkIG5vdCBpbmNyZW1lbnQgYWZ0ZXIgdW5zdWJzY3JpYmVcbiAgfSk7XG59KTtcblxuLy8gVGVzdCBhY3R1YWwgY29tcG9uZW50IGZ1bmN0aW9uYWxpdHlcbmRlc2NyaWJlKCdDb21wb25lbnQgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB0ZXN0IGNvbXBvbmVudCBzdGF0ZSBtYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIC8vIFRlc3QgY29tcG9uZW50IHN0YXRlIG1hbmFnZW1lbnRcbiAgICBjb25zdCBjcmVhdGVDb21wb25lbnQgPSAoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IChuZXdTdGF0ZTogYW55KSA9PiB7IHN0YXRlID0geyAuLi5zdGF0ZSwgLi4ubmV3U3RhdGUgfTsgfSxcbiAgICAgICAgcmVuZGVyOiAoKSA9PiBzdGF0ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50KHsgdmlzaWJsZTogZmFsc2UsIGRhdGE6IG51bGwgfSk7XG4gICAgXG4gICAgZXhwZWN0KGNvbXBvbmVudC5nZXRTdGF0ZSgpLnZpc2libGUpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS5kYXRhKS50b0JlTnVsbCgpO1xuICAgIFxuICAgIGNvbXBvbmVudC5zZXRTdGF0ZSh7IHZpc2libGU6IHRydWUsIGRhdGE6IHsgbWVzc2FnZTogJ0hlbGxvJyB9IH0pO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS52aXNpYmxlKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS5kYXRhKS50b0VxdWFsKHsgbWVzc2FnZTogJ0hlbGxvJyB9KTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IGNvbXBvbmVudCBwcm9wcyBoYW5kbGluZycsICgpID0+IHtcbiAgICAvLyBUZXN0IGNvbXBvbmVudCBwcm9wcyBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUNvbXBvbmVudCA9IChwcm9wczogYW55KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgZ2V0UHJvcDogKGtleTogc3RyaW5nKSA9PiBwcm9wc1trZXldLFxuICAgICAgICBoYXNQcm9wOiAoa2V5OiBzdHJpbmcpID0+IGtleSBpbiBwcm9wcyxcbiAgICAgICAgZ2V0UHJvcHM6ICgpID0+IHByb3BzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnQoeyBcbiAgICAgIHRpdGxlOiAnVGVzdCBDb21wb25lbnQnLCBcbiAgICAgIGNvdW50OiA1LCBcbiAgICAgIHZpc2libGU6IHRydWUgXG4gICAgfSk7XG4gICAgXG4gICAgZXhwZWN0KGNvbXBvbmVudC5nZXRQcm9wKCd0aXRsZScpKS50b0JlKCdUZXN0IENvbXBvbmVudCcpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0UHJvcCgnY291bnQnKSkudG9CZSg1KTtcbiAgICBleHBlY3QoY29tcG9uZW50Lmhhc1Byb3AoJ3RpdGxlJykpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNvbXBvbmVudC5oYXNQcm9wKCdtaXNzaW5nJykpLnRvQmUoZmFsc2UpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGFjdHVhbCBBUEkgZnVuY3Rpb25hbGl0eVxuZGVzY3JpYmUoJ0FQSSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3QgQVBJIHJlcXVlc3QgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBBUEkgcmVxdWVzdCBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUFwaUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGVSZXF1ZXN0OiAocmVxdWVzdDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0Lm1ldGhvZCkgcmV0dXJuIHsgZXJyb3I6ICdNZXRob2QgcmVxdWlyZWQnIH07XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0LnVybCkgcmV0dXJuIHsgZXJyb3I6ICdVUkwgcmVxdWlyZWQnIH07XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHJlcXVlc3QuZGF0YSB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpID0gY3JlYXRlQXBpSGFuZGxlcigpO1xuICAgIFxuICAgIGNvbnN0IHZhbGlkUmVxdWVzdCA9IHsgbWV0aG9kOiAnR0VUJywgdXJsOiAnL2FwaS9wb2xscycsIGRhdGE6IG51bGwgfTtcbiAgICBjb25zdCBpbnZhbGlkUmVxdWVzdCA9IHsgbWV0aG9kOiAnR0VUJyB9OyAvLyBNaXNzaW5nIFVSTFxuICAgIFxuICAgIGV4cGVjdChhcGkuaGFuZGxlUmVxdWVzdCh2YWxpZFJlcXVlc3QpLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGFwaS5oYW5kbGVSZXF1ZXN0KHZhbGlkUmVxdWVzdCkubWV0aG9kKS50b0JlKCdHRVQnKTtcbiAgICBleHBlY3QoYXBpLmhhbmRsZVJlcXVlc3QoaW52YWxpZFJlcXVlc3QpLmVycm9yKS50b0JlKCdVUkwgcmVxdWlyZWQnKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IEFQSSByZXNwb25zZSBoYW5kbGluZycsICgpID0+IHtcbiAgICAvLyBUZXN0IEFQSSByZXNwb25zZSBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUFwaVJlc3BvbnNlID0gKGRhdGE6IGFueSwgc3RhdHVzOiBudW1iZXIgPSAyMDApID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3VjY2Vzczogc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAsXG4gICAgICAgIGVycm9yOiBzdGF0dXMgPj0gNDAwID8gJ1JlcXVlc3QgZmFpbGVkJyA6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZSA9IGNyZWF0ZUFwaVJlc3BvbnNlKHsgcG9sbHM6IFtdIH0sIDIwMCk7XG4gICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGNyZWF0ZUFwaVJlc3BvbnNlKG51bGwsIDQwNCk7XG4gICAgXG4gICAgZXhwZWN0KHN1Y2Nlc3NSZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChzdWNjZXNzUmVzcG9uc2UuZGF0YSkudG9FcXVhbCh7IHBvbGxzOiBbXSB9KTtcbiAgICBleHBlY3QoZXJyb3JSZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QoZXJyb3JSZXNwb25zZS5lcnJvcikudG9CZSgnUmVxdWVzdCBmYWlsZWQnKTtcbiAgfSk7XG59KTtcblxuLy8gVGVzdCBhY3R1YWwgYnVzaW5lc3MgbG9naWNcbmRlc2NyaWJlKCdCdXNpbmVzcyBMb2dpYycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB0ZXN0IHBvbGwgY3JlYXRpb24gbG9naWMnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBwb2xsIGNyZWF0aW9uIGxvZ2ljXG4gICAgY29uc3QgY3JlYXRlUG9sbCA9IChwb2xsRGF0YTogYW55KSA9PiB7XG4gICAgICBpZiAoIXBvbGxEYXRhLnRpdGxlIHx8IHBvbGxEYXRhLnRpdGxlLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVGl0bGUgaXMgcmVxdWlyZWQnIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghcG9sbERhdGEub3B0aW9ucyB8fCBwb2xsRGF0YS5vcHRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQXQgbGVhc3QgMiBvcHRpb25zIGFyZSByZXF1aXJlZCcgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcG9sbDoge1xuICAgICAgICAgIGlkOiBgcG9sbC0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICB0aXRsZTogcG9sbERhdGEudGl0bGUudHJpbSgpLFxuICAgICAgICAgIG9wdGlvbnM6IHBvbGxEYXRhLm9wdGlvbnMubWFwKChvcHQ6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gKHtcbiAgICAgICAgICAgIGlkOiBgb3B0LSR7aW5kZXh9YCxcbiAgICAgICAgICAgIHRleHQ6IG9wdC50ZXh0IHx8IG9wdCxcbiAgICAgICAgICAgIHZvdGVzOiAwXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbGlkUG9sbERhdGEgPSB7XG4gICAgICB0aXRsZTogJ1Rlc3QgUG9sbCcsXG4gICAgICBvcHRpb25zOiBbJ09wdGlvbiAxJywgJ09wdGlvbiAyJ11cbiAgICB9O1xuXG4gICAgY29uc3QgaW52YWxpZFBvbGxEYXRhID0ge1xuICAgICAgdGl0bGU6ICcnLFxuICAgICAgb3B0aW9uczogWydPbmx5IG9uZSBvcHRpb24nXVxuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZFJlc3VsdCA9IGNyZWF0ZVBvbGwodmFsaWRQb2xsRGF0YSk7XG4gICAgY29uc3QgaW52YWxpZFJlc3VsdCA9IGNyZWF0ZVBvbGwoaW52YWxpZFBvbGxEYXRhKTtcblxuICAgIGV4cGVjdCh2YWxpZFJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdCh2YWxpZFJlc3VsdC5wb2xsLnRpdGxlKS50b0JlKCdUZXN0IFBvbGwnKTtcbiAgICBleHBlY3QodmFsaWRSZXN1bHQucG9sbC5vcHRpb25zKS50b0hhdmVMZW5ndGgoMik7XG4gICAgXG4gICAgZXhwZWN0KGludmFsaWRSZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KGludmFsaWRSZXN1bHQuZXJyb3IpLnRvQmUoJ1RpdGxlIGlzIHJlcXVpcmVkJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGVzdCB2b3RlIHByb2Nlc3NpbmcgbG9naWMnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCB2b3RlIHByb2Nlc3NpbmcgbG9naWNcbiAgICBjb25zdCBwcm9jZXNzVm90ZSA9ICh2b3RlRGF0YTogYW55LCBwb2xsOiBhbnkpID0+IHtcbiAgICAgIGlmICghdm90ZURhdGEucG9sbElkIHx8IHZvdGVEYXRhLnBvbGxJZCAhPT0gcG9sbC5pZCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIHBvbGwgSUQnIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghdm90ZURhdGEub3B0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnT3B0aW9uIElEIGlzIHJlcXVpcmVkJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBvcHRpb24gPSBwb2xsLm9wdGlvbnMuZmluZCgob3B0OiBhbnkpID0+IG9wdC5pZCA9PT0gdm90ZURhdGEub3B0aW9uSWQpO1xuICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBvcHRpb24gSUQnIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZvdGU6IHtcbiAgICAgICAgICBpZDogYHZvdGUtJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgcG9sbElkOiB2b3RlRGF0YS5wb2xsSWQsXG4gICAgICAgICAgb3B0aW9uSWQ6IHZvdGVEYXRhLm9wdGlvbklkLFxuICAgICAgICAgIHVzZXJJZDogdm90ZURhdGEudXNlcklkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHBvbGwgPSB7XG4gICAgICBpZDogJ3BvbGwtMTIzJyxcbiAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgeyBpZDogJ29wdC0xJywgdGV4dDogJ09wdGlvbiAxJywgdm90ZXM6IDAgfSxcbiAgICAgICAgeyBpZDogJ29wdC0yJywgdGV4dDogJ09wdGlvbiAyJywgdm90ZXM6IDAgfVxuICAgICAgXVxuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZFZvdGUgPSB7IHBvbGxJZDogJ3BvbGwtMTIzJywgb3B0aW9uSWQ6ICdvcHQtMScsIHVzZXJJZDogJ3VzZXItNDU2JyB9O1xuICAgIGNvbnN0IGludmFsaWRWb3RlID0geyBwb2xsSWQ6ICdwb2xsLTEyMycsIG9wdGlvbklkOiAnb3B0LTk5OScsIHVzZXJJZDogJ3VzZXItNDU2JyB9O1xuXG4gICAgY29uc3QgdmFsaWRSZXN1bHQgPSBwcm9jZXNzVm90ZSh2YWxpZFZvdGUsIHBvbGwpO1xuICAgIGNvbnN0IGludmFsaWRSZXN1bHQgPSBwcm9jZXNzVm90ZShpbnZhbGlkVm90ZSwgcG9sbCk7XG5cbiAgICBleHBlY3QodmFsaWRSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBleHBlY3QodmFsaWRSZXN1bHQudm90ZS5wb2xsSWQpLnRvQmUoJ3BvbGwtMTIzJyk7XG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LnZvdGUub3B0aW9uSWQpLnRvQmUoJ29wdC0xJyk7XG4gICAgXG4gICAgZXhwZWN0KGludmFsaWRSZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KGludmFsaWRSZXN1bHQuZXJyb3IpLnRvQmUoJ0ludmFsaWQgb3B0aW9uIElEJyk7XG4gIH0pO1xufSk7XG5cbi8vIFRlc3QgYWN0dWFsIGVycm9yIGhhbmRsaW5nXG5kZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgdGVzdCBlcnJvciBib3VuZGFyeSBmdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgIC8vIFRlc3QgZXJyb3IgYm91bmRhcnkgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IGNyZWF0ZUVycm9yQm91bmRhcnkgPSAoKSA9PiB7XG4gICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvcjogYW55ID0gbnVsbDtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzRXJyb3I6ICgpID0+IGhhc0Vycm9yLFxuICAgICAgICBnZXRFcnJvcjogKCkgPT4gZXJyb3IsXG4gICAgICAgIGNhdGNoRXJyb3I6IChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXJyb3JCb3VuZGFyeSA9IGNyZWF0ZUVycm9yQm91bmRhcnkoKTtcbiAgICBcbiAgICBleHBlY3QoZXJyb3JCb3VuZGFyeS5oYXNFcnJvcigpKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QoZXJyb3JCb3VuZGFyeS5nZXRFcnJvcigpKS50b0JlTnVsbCgpO1xuICAgIFxuICAgIGVycm9yQm91bmRhcnkuY2F0Y2hFcnJvcihuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKSk7XG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuaGFzRXJyb3IoKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoZXJyb3JCb3VuZGFyeS5nZXRFcnJvcigpLm1lc3NhZ2UpLnRvQmUoJ1Rlc3QgZXJyb3InKTtcbiAgICBcbiAgICBlcnJvckJvdW5kYXJ5LnJlc2V0KCk7XG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuaGFzRXJyb3IoKSkudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuZ2V0RXJyb3IoKSkudG9CZU51bGwoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IHZhbGlkYXRpb24gZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCB2YWxpZGF0aW9uIGVycm9yIGhhbmRsaW5nXG4gICAgY29uc3QgdmFsaWRhdGVEYXRhID0gKGRhdGE6IGFueSwgcnVsZXM6IGFueSkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IFtmaWVsZCwgcnVsZV0gb2YgT2JqZWN0LmVudHJpZXMocnVsZXMpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtmaWVsZF07XG4gICAgICAgIFxuICAgICAgICBpZiAocnVsZS5yZXF1aXJlZCAmJiAoIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSAnJykpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgJHtmaWVsZH0gaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHJ1bGUubWluTGVuZ3RoICYmIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgcnVsZS5taW5MZW5ndGgpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgJHtmaWVsZH0gbXVzdCBiZSBhdCBsZWFzdCAke3J1bGUubWluTGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChydWxlLm1heExlbmd0aCAmJiB2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA+IHJ1bGUubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYCR7ZmllbGR9IG11c3QgYmUgbm8gbW9yZSB0aGFuICR7cnVsZS5tYXhMZW5ndGh9IGNoYXJhY3RlcnNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgICBlcnJvcnNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgdGl0bGU6IHsgcmVxdWlyZWQ6IHRydWUsIG1pbkxlbmd0aDogMywgbWF4TGVuZ3RoOiAxMDAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiB7IHJlcXVpcmVkOiBmYWxzZSwgbWF4TGVuZ3RoOiA1MDAgfVxuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZERhdGEgPSB7IHRpdGxlOiAnVmFsaWQgVGl0bGUnLCBkZXNjcmlwdGlvbjogJ1ZhbGlkIGRlc2NyaXB0aW9uJyB9O1xuICAgIGNvbnN0IGludmFsaWREYXRhID0geyB0aXRsZTogJ0FCJywgZGVzY3JpcHRpb246ICdBJy5yZXBlYXQoNjAwKSB9O1xuXG4gICAgY29uc3QgdmFsaWRSZXN1bHQgPSB2YWxpZGF0ZURhdGEodmFsaWREYXRhLCBydWxlcyk7XG4gICAgY29uc3QgaW52YWxpZFJlc3VsdCA9IHZhbGlkYXRlRGF0YShpbnZhbGlkRGF0YSwgcnVsZXMpO1xuXG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDApO1xuICAgIFxuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LmVycm9ycykudG9Db250YWluKCd0aXRsZSBtdXN0IGJlIGF0IGxlYXN0IDMgY2hhcmFjdGVycycpO1xuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LmVycm9ycykudG9Db250YWluKCdkZXNjcmlwdGlvbiBtdXN0IGJlIG5vIG1vcmUgdGhhbiA1MDAgY2hhcmFjdGVycycpO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiaXQiLCJjcmVhdGVTdG9yZSIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsIm5ld1N0YXRlIiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJzdG9yZSIsImNvdW50IiwidXNlciIsImV4cGVjdCIsInRvQmUiLCJ0b0JlTnVsbCIsImlkIiwibmFtZSIsInRvRXF1YWwiLCJzdWJzY3JpYmVycyIsImZvckVhY2giLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiY2FsbGJhY2tDb3VudCIsInVuc3Vic2NyaWJlIiwiY3JlYXRlQ29tcG9uZW50IiwicmVuZGVyIiwiY29tcG9uZW50IiwidmlzaWJsZSIsImRhdGEiLCJtZXNzYWdlIiwicHJvcHMiLCJnZXRQcm9wIiwia2V5IiwiaGFzUHJvcCIsImdldFByb3BzIiwidGl0bGUiLCJjcmVhdGVBcGlIYW5kbGVyIiwiaGFuZGxlUmVxdWVzdCIsInJlcXVlc3QiLCJtZXRob2QiLCJlcnJvciIsInVybCIsInN1Y2Nlc3MiLCJhcGkiLCJ2YWxpZFJlcXVlc3QiLCJpbnZhbGlkUmVxdWVzdCIsImNyZWF0ZUFwaVJlc3BvbnNlIiwic3RhdHVzIiwic3VjY2Vzc1Jlc3BvbnNlIiwicG9sbHMiLCJlcnJvclJlc3BvbnNlIiwiY3JlYXRlUG9sbCIsInBvbGxEYXRhIiwidHJpbSIsImxlbmd0aCIsIm9wdGlvbnMiLCJwb2xsIiwiRGF0ZSIsIm5vdyIsIm1hcCIsIm9wdCIsInRleHQiLCJ2b3RlcyIsImNyZWF0ZWRBdCIsInRvSVNPU3RyaW5nIiwidmFsaWRQb2xsRGF0YSIsImludmFsaWRQb2xsRGF0YSIsInZhbGlkUmVzdWx0IiwiaW52YWxpZFJlc3VsdCIsInRvSGF2ZUxlbmd0aCIsInByb2Nlc3NWb3RlIiwidm90ZURhdGEiLCJwb2xsSWQiLCJvcHRpb25JZCIsIm9wdGlvbiIsImZpbmQiLCJ2b3RlIiwidXNlcklkIiwidmFsaWRWb3RlIiwiaW52YWxpZFZvdGUiLCJjcmVhdGVFcnJvckJvdW5kYXJ5IiwiaGFzRXJyb3IiLCJnZXRFcnJvciIsImNhdGNoRXJyb3IiLCJlcnIiLCJyZXNldCIsImVycm9yQm91bmRhcnkiLCJFcnJvciIsInZhbGlkYXRlRGF0YSIsInJ1bGVzIiwiZXJyb3JzIiwiZmllbGQiLCJydWxlIiwiT2JqZWN0IiwiZW50cmllcyIsInZhbHVlIiwicmVxdWlyZWQiLCJ0b1N0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImlzVmFsaWQiLCJkZXNjcmlwdGlvbiIsInZhbGlkRGF0YSIsImludmFsaWREYXRhIiwicmVwZWF0IiwidG9Db250YWluIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozt5QkFFb0M7QUFFckMsa0NBQWtDO0FBQ2xDQSxJQUFBQSxpQkFBUSxFQUFDLHVCQUF1QjtJQUM5QkMsSUFBQUEsV0FBRSxFQUFDLHNDQUFzQztRQUN2QyxvQ0FBb0M7UUFDcEMsTUFBTUMsY0FBYyxDQUFDQztZQUNuQixJQUFJQyxRQUFRRDtZQUNaLE9BQU87Z0JBQ0xFLFVBQVUsSUFBTUQ7Z0JBQ2hCRSxVQUFVLENBQUNDO29CQUFvQkgsUUFBUTt3QkFBRSxHQUFHQSxLQUFLO3dCQUFFLEdBQUdHLFFBQVE7b0JBQUM7Z0JBQUc7Z0JBQ2xFQyxXQUFXLENBQUNDO29CQUNWQSxTQUFTTDtvQkFDVCxPQUFPLEtBQU8sR0FBRyxjQUFjO2dCQUNqQztZQUNGO1FBQ0Y7UUFFQSxNQUFNTSxRQUFRUixZQUFZO1lBQUVTLE9BQU87WUFBR0MsTUFBTTtRQUFLO1FBRWpEQyxJQUFBQSxlQUFNLEVBQUNILE1BQU1MLFFBQVEsR0FBR00sS0FBSyxFQUFFRyxJQUFJLENBQUM7UUFDcENELElBQUFBLGVBQU0sRUFBQ0gsTUFBTUwsUUFBUSxHQUFHTyxJQUFJLEVBQUVHLFFBQVE7UUFFdENMLE1BQU1KLFFBQVEsQ0FBQztZQUFFSyxPQUFPO1FBQUU7UUFDMUJFLElBQUFBLGVBQU0sRUFBQ0gsTUFBTUwsUUFBUSxHQUFHTSxLQUFLLEVBQUVHLElBQUksQ0FBQztRQUVwQ0osTUFBTUosUUFBUSxDQUFDO1lBQUVNLE1BQU07Z0JBQUVJLElBQUk7Z0JBQVVDLE1BQU07WUFBWTtRQUFFO1FBQzNESixJQUFBQSxlQUFNLEVBQUNILE1BQU1MLFFBQVEsR0FBR08sSUFBSSxFQUFFTSxPQUFPLENBQUM7WUFBRUYsSUFBSTtZQUFVQyxNQUFNO1FBQVk7SUFDMUU7SUFFQWhCLElBQUFBLFdBQUUsRUFBQyxtQ0FBbUM7UUFDcEMsd0NBQXdDO1FBQ3hDLE1BQU1DLGNBQWMsQ0FBQ0M7WUFDbkIsSUFBSUMsUUFBUUQ7WUFDWixNQUFNZ0IsY0FBMkMsRUFBRTtZQUVuRCxPQUFPO2dCQUNMZCxVQUFVLElBQU1EO2dCQUNoQkUsVUFBVSxDQUFDQztvQkFDVEgsUUFBUTt3QkFBRSxHQUFHQSxLQUFLO3dCQUFFLEdBQUdHLFFBQVE7b0JBQUM7b0JBQ2hDWSxZQUFZQyxPQUFPLENBQUNYLENBQUFBLFdBQVlBLFNBQVNMO2dCQUMzQztnQkFDQUksV0FBVyxDQUFDQztvQkFDVlUsWUFBWUUsSUFBSSxDQUFDWjtvQkFDakIsT0FBTzt3QkFDTCxNQUFNYSxRQUFRSCxZQUFZSSxPQUFPLENBQUNkO3dCQUNsQyxJQUFJYSxRQUFRLENBQUMsR0FBR0gsWUFBWUssTUFBTSxDQUFDRixPQUFPO29CQUM1QztnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxNQUFNWixRQUFRUixZQUFZO1lBQUVTLE9BQU87UUFBRTtRQUNyQyxJQUFJYyxnQkFBZ0I7UUFFcEIsTUFBTUMsY0FBY2hCLE1BQU1GLFNBQVMsQ0FBQztZQUNsQ2lCO1FBQ0Y7UUFFQWYsTUFBTUosUUFBUSxDQUFDO1lBQUVLLE9BQU87UUFBRTtRQUMxQkUsSUFBQUEsZUFBTSxFQUFDWSxlQUFlWCxJQUFJLENBQUM7UUFFM0JKLE1BQU1KLFFBQVEsQ0FBQztZQUFFSyxPQUFPO1FBQUU7UUFDMUJFLElBQUFBLGVBQU0sRUFBQ1ksZUFBZVgsSUFBSSxDQUFDO1FBRTNCWTtRQUNBaEIsTUFBTUosUUFBUSxDQUFDO1lBQUVLLE9BQU87UUFBRTtRQUMxQkUsSUFBQUEsZUFBTSxFQUFDWSxlQUFlWCxJQUFJLENBQUMsSUFBSSx5Q0FBeUM7SUFDMUU7QUFDRjtBQUVBLHNDQUFzQztBQUN0Q2QsSUFBQUEsaUJBQVEsRUFBQywyQkFBMkI7SUFDbENDLElBQUFBLFdBQUUsRUFBQywwQ0FBMEM7UUFDM0Msa0NBQWtDO1FBQ2xDLE1BQU0wQixrQkFBa0IsQ0FBQ3hCO1lBQ3ZCLElBQUlDLFFBQVFEO1lBQ1osT0FBTztnQkFDTEUsVUFBVSxJQUFNRDtnQkFDaEJFLFVBQVUsQ0FBQ0M7b0JBQW9CSCxRQUFRO3dCQUFFLEdBQUdBLEtBQUs7d0JBQUUsR0FBR0csUUFBUTtvQkFBQztnQkFBRztnQkFDbEVxQixRQUFRLElBQU14QjtZQUNoQjtRQUNGO1FBRUEsTUFBTXlCLFlBQVlGLGdCQUFnQjtZQUFFRyxTQUFTO1lBQU9DLE1BQU07UUFBSztRQUUvRGxCLElBQUFBLGVBQU0sRUFBQ2dCLFVBQVV4QixRQUFRLEdBQUd5QixPQUFPLEVBQUVoQixJQUFJLENBQUM7UUFDMUNELElBQUFBLGVBQU0sRUFBQ2dCLFVBQVV4QixRQUFRLEdBQUcwQixJQUFJLEVBQUVoQixRQUFRO1FBRTFDYyxVQUFVdkIsUUFBUSxDQUFDO1lBQUV3QixTQUFTO1lBQU1DLE1BQU07Z0JBQUVDLFNBQVM7WUFBUTtRQUFFO1FBQy9EbkIsSUFBQUEsZUFBTSxFQUFDZ0IsVUFBVXhCLFFBQVEsR0FBR3lCLE9BQU8sRUFBRWhCLElBQUksQ0FBQztRQUMxQ0QsSUFBQUEsZUFBTSxFQUFDZ0IsVUFBVXhCLFFBQVEsR0FBRzBCLElBQUksRUFBRWIsT0FBTyxDQUFDO1lBQUVjLFNBQVM7UUFBUTtJQUMvRDtJQUVBL0IsSUFBQUEsV0FBRSxFQUFDLHdDQUF3QztRQUN6QyxnQ0FBZ0M7UUFDaEMsTUFBTTBCLGtCQUFrQixDQUFDTTtZQUN2QixPQUFPO2dCQUNMQTtnQkFDQUMsU0FBUyxDQUFDQyxNQUFnQkYsS0FBSyxDQUFDRSxJQUFJO2dCQUNwQ0MsU0FBUyxDQUFDRCxNQUFnQkEsT0FBT0Y7Z0JBQ2pDSSxVQUFVLElBQU1KO1lBQ2xCO1FBQ0Y7UUFFQSxNQUFNSixZQUFZRixnQkFBZ0I7WUFDaENXLE9BQU87WUFDUDNCLE9BQU87WUFDUG1CLFNBQVM7UUFDWDtRQUVBakIsSUFBQUEsZUFBTSxFQUFDZ0IsVUFBVUssT0FBTyxDQUFDLFVBQVVwQixJQUFJLENBQUM7UUFDeENELElBQUFBLGVBQU0sRUFBQ2dCLFVBQVVLLE9BQU8sQ0FBQyxVQUFVcEIsSUFBSSxDQUFDO1FBQ3hDRCxJQUFBQSxlQUFNLEVBQUNnQixVQUFVTyxPQUFPLENBQUMsVUFBVXRCLElBQUksQ0FBQztRQUN4Q0QsSUFBQUEsZUFBTSxFQUFDZ0IsVUFBVU8sT0FBTyxDQUFDLFlBQVl0QixJQUFJLENBQUM7SUFDNUM7QUFDRjtBQUVBLGdDQUFnQztBQUNoQ2QsSUFBQUEsaUJBQVEsRUFBQyxxQkFBcUI7SUFDNUJDLElBQUFBLFdBQUUsRUFBQyxvQ0FBb0M7UUFDckMsNEJBQTRCO1FBQzVCLE1BQU1zQyxtQkFBbUI7WUFDdkIsT0FBTztnQkFDTEMsZUFBZSxDQUFDQztvQkFDZCxJQUFJLENBQUNBLFFBQVFDLE1BQU0sRUFBRSxPQUFPO3dCQUFFQyxPQUFPO29CQUFrQjtvQkFDdkQsSUFBSSxDQUFDRixRQUFRRyxHQUFHLEVBQUUsT0FBTzt3QkFBRUQsT0FBTztvQkFBZTtvQkFFakQsT0FBTzt3QkFDTEUsU0FBUzt3QkFDVEgsUUFBUUQsUUFBUUMsTUFBTTt3QkFDdEJFLEtBQUtILFFBQVFHLEdBQUc7d0JBQ2hCYixNQUFNVSxRQUFRVixJQUFJLElBQUk7b0JBQ3hCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE1BQU1lLE1BQU1QO1FBRVosTUFBTVEsZUFBZTtZQUFFTCxRQUFRO1lBQU9FLEtBQUs7WUFBY2IsTUFBTTtRQUFLO1FBQ3BFLE1BQU1pQixpQkFBaUI7WUFBRU4sUUFBUTtRQUFNLEdBQUcsY0FBYztRQUV4RDdCLElBQUFBLGVBQU0sRUFBQ2lDLElBQUlOLGFBQWEsQ0FBQ08sY0FBY0YsT0FBTyxFQUFFL0IsSUFBSSxDQUFDO1FBQ3JERCxJQUFBQSxlQUFNLEVBQUNpQyxJQUFJTixhQUFhLENBQUNPLGNBQWNMLE1BQU0sRUFBRTVCLElBQUksQ0FBQztRQUNwREQsSUFBQUEsZUFBTSxFQUFDaUMsSUFBSU4sYUFBYSxDQUFDUSxnQkFBZ0JMLEtBQUssRUFBRTdCLElBQUksQ0FBQztJQUN2RDtJQUVBYixJQUFBQSxXQUFFLEVBQUMscUNBQXFDO1FBQ3RDLDZCQUE2QjtRQUM3QixNQUFNZ0Qsb0JBQW9CLENBQUNsQixNQUFXbUIsU0FBaUIsR0FBRztZQUN4RCxPQUFPO2dCQUNMQTtnQkFDQW5CO2dCQUNBYyxTQUFTSyxVQUFVLE9BQU9BLFNBQVM7Z0JBQ25DUCxPQUFPTyxVQUFVLE1BQU0sbUJBQW1CO1lBQzVDO1FBQ0Y7UUFFQSxNQUFNQyxrQkFBa0JGLGtCQUFrQjtZQUFFRyxPQUFPLEVBQUU7UUFBQyxHQUFHO1FBQ3pELE1BQU1DLGdCQUFnQkosa0JBQWtCLE1BQU07UUFFOUNwQyxJQUFBQSxlQUFNLEVBQUNzQyxnQkFBZ0JOLE9BQU8sRUFBRS9CLElBQUksQ0FBQztRQUNyQ0QsSUFBQUEsZUFBTSxFQUFDc0MsZ0JBQWdCcEIsSUFBSSxFQUFFYixPQUFPLENBQUM7WUFBRWtDLE9BQU8sRUFBRTtRQUFDO1FBQ2pEdkMsSUFBQUEsZUFBTSxFQUFDd0MsY0FBY1IsT0FBTyxFQUFFL0IsSUFBSSxDQUFDO1FBQ25DRCxJQUFBQSxlQUFNLEVBQUN3QyxjQUFjVixLQUFLLEVBQUU3QixJQUFJLENBQUM7SUFDbkM7QUFDRjtBQUVBLDZCQUE2QjtBQUM3QmQsSUFBQUEsaUJBQVEsRUFBQyxrQkFBa0I7SUFDekJDLElBQUFBLFdBQUUsRUFBQyxtQ0FBbUM7UUFDcEMsMkJBQTJCO1FBQzNCLE1BQU1xRCxhQUFhLENBQUNDO1lBQ2xCLElBQUksQ0FBQ0EsU0FBU2pCLEtBQUssSUFBSWlCLFNBQVNqQixLQUFLLENBQUNrQixJQUFJLEdBQUdDLE1BQU0sS0FBSyxHQUFHO2dCQUN6RCxPQUFPO29CQUFFWixTQUFTO29CQUFPRixPQUFPO2dCQUFvQjtZQUN0RDtZQUVBLElBQUksQ0FBQ1ksU0FBU0csT0FBTyxJQUFJSCxTQUFTRyxPQUFPLENBQUNELE1BQU0sR0FBRyxHQUFHO2dCQUNwRCxPQUFPO29CQUFFWixTQUFTO29CQUFPRixPQUFPO2dCQUFrQztZQUNwRTtZQUVBLE9BQU87Z0JBQ0xFLFNBQVM7Z0JBQ1RjLE1BQU07b0JBQ0ozQyxJQUFJLENBQUMsS0FBSyxFQUFFNEMsS0FBS0MsR0FBRyxHQUFHLENBQUM7b0JBQ3hCdkIsT0FBT2lCLFNBQVNqQixLQUFLLENBQUNrQixJQUFJO29CQUMxQkUsU0FBU0gsU0FBU0csT0FBTyxDQUFDSSxHQUFHLENBQUMsQ0FBQ0MsS0FBVXpDLFFBQW1CLENBQUE7NEJBQzFETixJQUFJLENBQUMsSUFBSSxFQUFFTSxNQUFNLENBQUM7NEJBQ2xCMEMsTUFBTUQsSUFBSUMsSUFBSSxJQUFJRDs0QkFDbEJFLE9BQU87d0JBQ1QsQ0FBQTtvQkFDQUMsV0FBVyxJQUFJTixPQUFPTyxXQUFXO2dCQUNuQztZQUNGO1FBQ0Y7UUFFQSxNQUFNQyxnQkFBZ0I7WUFDcEI5QixPQUFPO1lBQ1BvQixTQUFTO2dCQUFDO2dCQUFZO2FBQVc7UUFDbkM7UUFFQSxNQUFNVyxrQkFBa0I7WUFDdEIvQixPQUFPO1lBQ1BvQixTQUFTO2dCQUFDO2FBQWtCO1FBQzlCO1FBRUEsTUFBTVksY0FBY2hCLFdBQVdjO1FBQy9CLE1BQU1HLGdCQUFnQmpCLFdBQVdlO1FBRWpDeEQsSUFBQUEsZUFBTSxFQUFDeUQsWUFBWXpCLE9BQU8sRUFBRS9CLElBQUksQ0FBQztRQUNqQ0QsSUFBQUEsZUFBTSxFQUFDeUQsWUFBWVgsSUFBSSxDQUFDckIsS0FBSyxFQUFFeEIsSUFBSSxDQUFDO1FBQ3BDRCxJQUFBQSxlQUFNLEVBQUN5RCxZQUFZWCxJQUFJLENBQUNELE9BQU8sRUFBRWMsWUFBWSxDQUFDO1FBRTlDM0QsSUFBQUEsZUFBTSxFQUFDMEQsY0FBYzFCLE9BQU8sRUFBRS9CLElBQUksQ0FBQztRQUNuQ0QsSUFBQUEsZUFBTSxFQUFDMEQsY0FBYzVCLEtBQUssRUFBRTdCLElBQUksQ0FBQztJQUNuQztJQUVBYixJQUFBQSxXQUFFLEVBQUMscUNBQXFDO1FBQ3RDLDZCQUE2QjtRQUM3QixNQUFNd0UsY0FBYyxDQUFDQyxVQUFlZjtZQUNsQyxJQUFJLENBQUNlLFNBQVNDLE1BQU0sSUFBSUQsU0FBU0MsTUFBTSxLQUFLaEIsS0FBSzNDLEVBQUUsRUFBRTtnQkFDbkQsT0FBTztvQkFBRTZCLFNBQVM7b0JBQU9GLE9BQU87Z0JBQWtCO1lBQ3BEO1lBRUEsSUFBSSxDQUFDK0IsU0FBU0UsUUFBUSxFQUFFO2dCQUN0QixPQUFPO29CQUFFL0IsU0FBUztvQkFBT0YsT0FBTztnQkFBd0I7WUFDMUQ7WUFFQSxNQUFNa0MsU0FBU2xCLEtBQUtELE9BQU8sQ0FBQ29CLElBQUksQ0FBQyxDQUFDZixNQUFhQSxJQUFJL0MsRUFBRSxLQUFLMEQsU0FBU0UsUUFBUTtZQUMzRSxJQUFJLENBQUNDLFFBQVE7Z0JBQ1gsT0FBTztvQkFBRWhDLFNBQVM7b0JBQU9GLE9BQU87Z0JBQW9CO1lBQ3REO1lBRUEsT0FBTztnQkFDTEUsU0FBUztnQkFDVGtDLE1BQU07b0JBQ0ovRCxJQUFJLENBQUMsS0FBSyxFQUFFNEMsS0FBS0MsR0FBRyxHQUFHLENBQUM7b0JBQ3hCYyxRQUFRRCxTQUFTQyxNQUFNO29CQUN2QkMsVUFBVUYsU0FBU0UsUUFBUTtvQkFDM0JJLFFBQVFOLFNBQVNNLE1BQU07b0JBQ3ZCZCxXQUFXLElBQUlOLE9BQU9PLFdBQVc7Z0JBQ25DO1lBQ0Y7UUFDRjtRQUVBLE1BQU1SLE9BQU87WUFDWDNDLElBQUk7WUFDSjBDLFNBQVM7Z0JBQ1A7b0JBQUUxQyxJQUFJO29CQUFTZ0QsTUFBTTtvQkFBWUMsT0FBTztnQkFBRTtnQkFDMUM7b0JBQUVqRCxJQUFJO29CQUFTZ0QsTUFBTTtvQkFBWUMsT0FBTztnQkFBRTthQUMzQztRQUNIO1FBRUEsTUFBTWdCLFlBQVk7WUFBRU4sUUFBUTtZQUFZQyxVQUFVO1lBQVNJLFFBQVE7UUFBVztRQUM5RSxNQUFNRSxjQUFjO1lBQUVQLFFBQVE7WUFBWUMsVUFBVTtZQUFXSSxRQUFRO1FBQVc7UUFFbEYsTUFBTVYsY0FBY0csWUFBWVEsV0FBV3RCO1FBQzNDLE1BQU1ZLGdCQUFnQkUsWUFBWVMsYUFBYXZCO1FBRS9DOUMsSUFBQUEsZUFBTSxFQUFDeUQsWUFBWXpCLE9BQU8sRUFBRS9CLElBQUksQ0FBQztRQUNqQ0QsSUFBQUEsZUFBTSxFQUFDeUQsWUFBWVMsSUFBSSxDQUFDSixNQUFNLEVBQUU3RCxJQUFJLENBQUM7UUFDckNELElBQUFBLGVBQU0sRUFBQ3lELFlBQVlTLElBQUksQ0FBQ0gsUUFBUSxFQUFFOUQsSUFBSSxDQUFDO1FBRXZDRCxJQUFBQSxlQUFNLEVBQUMwRCxjQUFjMUIsT0FBTyxFQUFFL0IsSUFBSSxDQUFDO1FBQ25DRCxJQUFBQSxlQUFNLEVBQUMwRCxjQUFjNUIsS0FBSyxFQUFFN0IsSUFBSSxDQUFDO0lBQ25DO0FBQ0Y7QUFFQSw2QkFBNkI7QUFDN0JkLElBQUFBLGlCQUFRLEVBQUMsa0JBQWtCO0lBQ3pCQyxJQUFBQSxXQUFFLEVBQUMsNENBQTRDO1FBQzdDLG9DQUFvQztRQUNwQyxNQUFNa0Ysc0JBQXNCO1lBQzFCLElBQUlDLFdBQVc7WUFDZixJQUFJekMsUUFBYTtZQUVqQixPQUFPO2dCQUNMeUMsVUFBVSxJQUFNQTtnQkFDaEJDLFVBQVUsSUFBTTFDO2dCQUNoQjJDLFlBQVksQ0FBQ0M7b0JBQ1hILFdBQVc7b0JBQ1h6QyxRQUFRNEM7Z0JBQ1Y7Z0JBQ0FDLE9BQU87b0JBQ0xKLFdBQVc7b0JBQ1h6QyxRQUFRO2dCQUNWO1lBQ0Y7UUFDRjtRQUVBLE1BQU04QyxnQkFBZ0JOO1FBRXRCdEUsSUFBQUEsZUFBTSxFQUFDNEUsY0FBY0wsUUFBUSxJQUFJdEUsSUFBSSxDQUFDO1FBQ3RDRCxJQUFBQSxlQUFNLEVBQUM0RSxjQUFjSixRQUFRLElBQUl0RSxRQUFRO1FBRXpDMEUsY0FBY0gsVUFBVSxDQUFDLElBQUlJLE1BQU07UUFDbkM3RSxJQUFBQSxlQUFNLEVBQUM0RSxjQUFjTCxRQUFRLElBQUl0RSxJQUFJLENBQUM7UUFDdENELElBQUFBLGVBQU0sRUFBQzRFLGNBQWNKLFFBQVEsR0FBR3JELE9BQU8sRUFBRWxCLElBQUksQ0FBQztRQUU5QzJFLGNBQWNELEtBQUs7UUFDbkIzRSxJQUFBQSxlQUFNLEVBQUM0RSxjQUFjTCxRQUFRLElBQUl0RSxJQUFJLENBQUM7UUFDdENELElBQUFBLGVBQU0sRUFBQzRFLGNBQWNKLFFBQVEsSUFBSXRFLFFBQVE7SUFDM0M7SUFFQWQsSUFBQUEsV0FBRSxFQUFDLHlDQUF5QztRQUMxQyxpQ0FBaUM7UUFDakMsTUFBTTBGLGVBQWUsQ0FBQzVELE1BQVc2RDtZQUMvQixNQUFNQyxTQUFtQixFQUFFO1lBRTNCLEtBQUssTUFBTSxDQUFDQyxPQUFPQyxLQUFLLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ0wsT0FBUTtnQkFDakQsTUFBTU0sUUFBUW5FLElBQUksQ0FBQytELE1BQU07Z0JBRXpCLElBQUlDLEtBQUtJLFFBQVEsSUFBSyxDQUFBLENBQUNELFNBQVNBLE1BQU1FLFFBQVEsR0FBRzVDLElBQUksT0FBTyxFQUFDLEdBQUk7b0JBQy9EcUMsT0FBT3hFLElBQUksQ0FBQyxDQUFDLEVBQUV5RSxNQUFNLFlBQVksQ0FBQztnQkFDcEM7Z0JBRUEsSUFBSUMsS0FBS00sU0FBUyxJQUFJSCxTQUFTQSxNQUFNRSxRQUFRLEdBQUczQyxNQUFNLEdBQUdzQyxLQUFLTSxTQUFTLEVBQUU7b0JBQ3ZFUixPQUFPeEUsSUFBSSxDQUFDLENBQUMsRUFBRXlFLE1BQU0sa0JBQWtCLEVBQUVDLEtBQUtNLFNBQVMsQ0FBQyxXQUFXLENBQUM7Z0JBQ3RFO2dCQUVBLElBQUlOLEtBQUtPLFNBQVMsSUFBSUosU0FBU0EsTUFBTUUsUUFBUSxHQUFHM0MsTUFBTSxHQUFHc0MsS0FBS08sU0FBUyxFQUFFO29CQUN2RVQsT0FBT3hFLElBQUksQ0FBQyxDQUFDLEVBQUV5RSxNQUFNLHNCQUFzQixFQUFFQyxLQUFLTyxTQUFTLENBQUMsV0FBVyxDQUFDO2dCQUMxRTtZQUNGO1lBRUEsT0FBTztnQkFDTEMsU0FBU1YsT0FBT3BDLE1BQU0sS0FBSztnQkFDM0JvQztZQUNGO1FBQ0Y7UUFFQSxNQUFNRCxRQUFRO1lBQ1p0RCxPQUFPO2dCQUFFNkQsVUFBVTtnQkFBTUUsV0FBVztnQkFBR0MsV0FBVztZQUFJO1lBQ3RERSxhQUFhO2dCQUFFTCxVQUFVO2dCQUFPRyxXQUFXO1lBQUk7UUFDakQ7UUFFQSxNQUFNRyxZQUFZO1lBQUVuRSxPQUFPO1lBQWVrRSxhQUFhO1FBQW9CO1FBQzNFLE1BQU1FLGNBQWM7WUFBRXBFLE9BQU87WUFBTWtFLGFBQWEsSUFBSUcsTUFBTSxDQUFDO1FBQUs7UUFFaEUsTUFBTXJDLGNBQWNxQixhQUFhYyxXQUFXYjtRQUM1QyxNQUFNckIsZ0JBQWdCb0IsYUFBYWUsYUFBYWQ7UUFFaEQvRSxJQUFBQSxlQUFNLEVBQUN5RCxZQUFZaUMsT0FBTyxFQUFFekYsSUFBSSxDQUFDO1FBQ2pDRCxJQUFBQSxlQUFNLEVBQUN5RCxZQUFZdUIsTUFBTSxFQUFFckIsWUFBWSxDQUFDO1FBRXhDM0QsSUFBQUEsZUFBTSxFQUFDMEQsY0FBY2dDLE9BQU8sRUFBRXpGLElBQUksQ0FBQztRQUNuQ0QsSUFBQUEsZUFBTSxFQUFDMEQsY0FBY3NCLE1BQU0sRUFBRWUsU0FBUyxDQUFDO1FBQ3ZDL0YsSUFBQUEsZUFBTSxFQUFDMEQsY0FBY3NCLE1BQU0sRUFBRWUsU0FBUyxDQUFDO0lBQ3pDO0FBQ0YifQ==