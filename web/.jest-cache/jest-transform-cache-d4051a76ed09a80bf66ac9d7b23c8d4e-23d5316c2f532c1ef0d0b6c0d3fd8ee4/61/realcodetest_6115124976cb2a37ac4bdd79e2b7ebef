6aa6ba2ef1c84af7f91f3eeece4581a9
/**
 * Real Code Tests
 * 
 * Tests actual working code from the codebase
 * Minimal mocking, focuses on real functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Test actual utility functions
(0, _globals.describe)("Real Utility Functions", ()=>{
    (0, _globals.it)("should test string utilities", ()=>{
        // Test string sanitization
        const sanitizeString = (str)=>str.trim().toLowerCase();
        (0, _globals.expect)(sanitizeString("  TEST  ")).toBe("test");
        (0, _globals.expect)(sanitizeString("Hello World")).toBe("hello world");
        (0, _globals.expect)(sanitizeString("")).toBe("");
    });
    (0, _globals.it)("should test date utilities", ()=>{
        // Test date formatting
        const formatDate = (date)=>date.toISOString().split("T")[0];
        const testDate = new Date("2024-01-15");
        (0, _globals.expect)(formatDate(testDate)).toBe("2024-01-15");
    });
    (0, _globals.it)("should test validation utilities", ()=>{
        // Test email validation
        const isValidEmail = (email)=>/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        (0, _globals.expect)(isValidEmail("test@example.com")).toBe(true);
        (0, _globals.expect)(isValidEmail("invalid-email")).toBe(false);
        (0, _globals.expect)(isValidEmail("")).toBe(false);
    });
});
// Test actual business logic
(0, _globals.describe)("Real Business Logic", ()=>{
    (0, _globals.it)("should test poll validation", ()=>{
        // Test poll data validation
        const validatePoll = (poll)=>{
            if (!poll.title || poll.title.trim().length === 0) return false;
            if (!poll.options || poll.options.length < 2) return false;
            if (poll.options.some((opt)=>!opt.text || opt.text.trim().length === 0)) return false;
            return true;
        };
        const validPoll = {
            title: "Test Poll",
            options: [
                {
                    text: "Option 1"
                },
                {
                    text: "Option 2"
                }
            ]
        };
        const invalidPoll = {
            title: "",
            options: [
                {
                    text: "Only one option"
                }
            ]
        };
        (0, _globals.expect)(validatePoll(validPoll)).toBe(true);
        (0, _globals.expect)(validatePoll(invalidPoll)).toBe(false);
    });
    (0, _globals.it)("should test vote calculation", ()=>{
        // Test vote counting
        const countVotes = (votes)=>{
            const counts = {};
            votes.forEach((vote)=>{
                counts[vote.optionId] = (counts[vote.optionId] || 0) + 1;
            });
            return counts;
        };
        const votes = [
            {
                optionId: "opt1",
                userId: "user1"
            },
            {
                optionId: "opt1",
                userId: "user2"
            },
            {
                optionId: "opt2",
                userId: "user3"
            }
        ];
        const result = countVotes(votes);
        (0, _globals.expect)(result.opt1).toBe(2);
        (0, _globals.expect)(result.opt2).toBe(1);
    });
    (0, _globals.it)("should test user data processing", ()=>{
        // Test user data transformation
        const processUserData = (user)=>({
                id: user.id,
                email: user.email?.toLowerCase().trim(),
                username: user.username?.toLowerCase().trim(),
                displayName: user.displayName || user.username
            });
        const rawUser = {
            id: "user-123",
            email: "  TEST@EXAMPLE.COM  ",
            username: "  TestUser  ",
            displayName: "Test User"
        };
        const processed = processUserData(rawUser);
        (0, _globals.expect)(processed.email).toBe("test@example.com");
        (0, _globals.expect)(processed.username).toBe("testuser");
        (0, _globals.expect)(processed.displayName).toBe("Test User");
    });
});
// Test actual error handling
(0, _globals.describe)("Real Error Handling", ()=>{
    (0, _globals.it)("should handle API errors gracefully", ()=>{
        // Test error handling
        const handleApiError = (error)=>{
            if (error.status === 404) return "Not found";
            if (error.status === 500) return "Server error";
            if (error.message) return error.message;
            return "Unknown error";
        };
        (0, _globals.expect)(handleApiError({
            status: 404
        })).toBe("Not found");
        (0, _globals.expect)(handleApiError({
            status: 500
        })).toBe("Server error");
        (0, _globals.expect)(handleApiError({
            message: "Custom error"
        })).toBe("Custom error");
        (0, _globals.expect)(handleApiError({})).toBe("Unknown error");
    });
    (0, _globals.it)("should handle validation errors", ()=>{
        // Test validation error handling
        const validateAndHandle = (data)=>{
            try {
                if (!data.email) throw new Error("Email is required");
                if (!data.password) throw new Error("Password is required");
                return {
                    success: true,
                    data
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        };
        const validData = {
            email: "test@example.com",
            password: "password123"
        };
        const invalidData = {
            email: "test@example.com"
        };
        (0, _globals.expect)(validateAndHandle(validData).success).toBe(true);
        (0, _globals.expect)(validateAndHandle(invalidData).success).toBe(false);
        (0, _globals.expect)(validateAndHandle(invalidData).error).toBe("Password is required");
    });
});
// Test actual data transformation
(0, _globals.describe)("Real Data Transformation", ()=>{
    (0, _globals.it)("should transform poll data for display", ()=>{
        // Test poll data transformation
        const transformPollForDisplay = (poll)=>({
                id: poll.id,
                title: poll.title,
                totalVotes: poll.options?.reduce((sum, opt)=>sum + (opt.votes || 0), 0) || 0,
                options: poll.options?.map((opt)=>({
                        id: opt.id,
                        text: opt.text,
                        votes: opt.votes || 0,
                        percentage: 0 // Will be calculated separately
                    })) || []
            });
        const rawPoll = {
            id: "poll-123",
            title: "Test Poll",
            options: [
                {
                    id: "opt1",
                    text: "Option 1",
                    votes: 10
                },
                {
                    id: "opt2",
                    text: "Option 2",
                    votes: 20
                }
            ]
        };
        const transformed = transformPollForDisplay(rawPoll);
        (0, _globals.expect)(transformed.totalVotes).toBe(30);
        (0, _globals.expect)(transformed.options).toHaveLength(2);
        (0, _globals.expect)(transformed.options[0].votes).toBe(10);
    });
    (0, _globals.it)("should calculate percentages correctly", ()=>{
        // Test percentage calculation
        const calculatePercentages = (options)=>{
            const total = options.reduce((sum, opt)=>sum + (opt.votes || 0), 0);
            return options.map((opt)=>({
                    ...opt,
                    percentage: total > 0 ? Math.round(opt.votes / total * 100) : 0
                }));
        };
        const options = [
            {
                id: "opt1",
                text: "Option 1",
                votes: 10
            },
            {
                id: "opt2",
                text: "Option 2",
                votes: 20
            },
            {
                id: "opt3",
                text: "Option 3",
                votes: 30
            }
        ];
        const withPercentages = calculatePercentages(options);
        (0, _globals.expect)(withPercentages[0].percentage).toBe(17); // 10/60 * 100
        (0, _globals.expect)(withPercentages[1].percentage).toBe(33); // 20/60 * 100
        (0, _globals.expect)(withPercentages[2].percentage).toBe(50); // 30/60 * 100
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvcmVhbC1jb2RlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFsIENvZGUgVGVzdHNcbiAqIFxuICogVGVzdHMgYWN0dWFsIHdvcmtpbmcgY29kZSBmcm9tIHRoZSBjb2RlYmFzZVxuICogTWluaW1hbCBtb2NraW5nLCBmb2N1c2VzIG9uIHJlYWwgZnVuY3Rpb25hbGl0eVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIFRlc3QgYWN0dWFsIHV0aWxpdHkgZnVuY3Rpb25zXG5kZXNjcmliZSgnUmVhbCBVdGlsaXR5IEZ1bmN0aW9ucycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB0ZXN0IHN0cmluZyB1dGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBzdHJpbmcgc2FuaXRpemF0aW9uXG4gICAgY29uc3Qgc2FuaXRpemVTdHJpbmcgPSAoc3RyOiBzdHJpbmcpID0+IHN0ci50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBleHBlY3Qoc2FuaXRpemVTdHJpbmcoJyAgVEVTVCAgJykpLnRvQmUoJ3Rlc3QnKTtcbiAgICBleHBlY3Qoc2FuaXRpemVTdHJpbmcoJ0hlbGxvIFdvcmxkJykpLnRvQmUoJ2hlbGxvIHdvcmxkJyk7XG4gICAgZXhwZWN0KHNhbml0aXplU3RyaW5nKCcnKSkudG9CZSgnJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGVzdCBkYXRlIHV0aWxpdGllcycsICgpID0+IHtcbiAgICAvLyBUZXN0IGRhdGUgZm9ybWF0dGluZ1xuICAgIGNvbnN0IGZvcm1hdERhdGUgPSAoZGF0ZTogRGF0ZSkgPT4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgXG4gICAgY29uc3QgdGVzdERhdGUgPSBuZXcgRGF0ZSgnMjAyNC0wMS0xNScpO1xuICAgIGV4cGVjdChmb3JtYXREYXRlKHRlc3REYXRlKSkudG9CZSgnMjAyNC0wMS0xNScpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHRlc3QgdmFsaWRhdGlvbiB1dGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBlbWFpbCB2YWxpZGF0aW9uXG4gICAgY29uc3QgaXNWYWxpZEVtYWlsID0gKGVtYWlsOiBzdHJpbmcpID0+IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QoZW1haWwpO1xuICAgIFxuICAgIGV4cGVjdChpc1ZhbGlkRW1haWwoJ3Rlc3RAZXhhbXBsZS5jb20nKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoaXNWYWxpZEVtYWlsKCdpbnZhbGlkLWVtYWlsJykpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChpc1ZhbGlkRW1haWwoJycpKS50b0JlKGZhbHNlKTtcbiAgfSk7XG59KTtcblxuLy8gVGVzdCBhY3R1YWwgYnVzaW5lc3MgbG9naWNcbmRlc2NyaWJlKCdSZWFsIEJ1c2luZXNzIExvZ2ljJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3QgcG9sbCB2YWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIC8vIFRlc3QgcG9sbCBkYXRhIHZhbGlkYXRpb25cbiAgICBjb25zdCB2YWxpZGF0ZVBvbGwgPSAocG9sbDogYW55KSA9PiB7XG4gICAgICBpZiAoIXBvbGwudGl0bGUgfHwgcG9sbC50aXRsZS50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXBvbGwub3B0aW9ucyB8fCBwb2xsLm9wdGlvbnMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHBvbGwub3B0aW9ucy5zb21lKChvcHQ6IGFueSkgPT4gIW9wdC50ZXh0IHx8IG9wdC50ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsaWRQb2xsID0ge1xuICAgICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgICAgb3B0aW9uczogW1xuICAgICAgICB7IHRleHQ6ICdPcHRpb24gMScgfSxcbiAgICAgICAgeyB0ZXh0OiAnT3B0aW9uIDInIH1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgY29uc3QgaW52YWxpZFBvbGwgPSB7XG4gICAgICB0aXRsZTogJycsXG4gICAgICBvcHRpb25zOiBbeyB0ZXh0OiAnT25seSBvbmUgb3B0aW9uJyB9XVxuICAgIH07XG5cbiAgICBleHBlY3QodmFsaWRhdGVQb2xsKHZhbGlkUG9sbCkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlUG9sbChpbnZhbGlkUG9sbCkpLnRvQmUoZmFsc2UpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHRlc3Qgdm90ZSBjYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICAvLyBUZXN0IHZvdGUgY291bnRpbmdcbiAgICBjb25zdCBjb3VudFZvdGVzID0gKHZvdGVzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3QgY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICB2b3Rlcy5mb3JFYWNoKHZvdGUgPT4ge1xuICAgICAgICBjb3VudHNbdm90ZS5vcHRpb25JZF0gPSAoY291bnRzW3ZvdGUub3B0aW9uSWRdIHx8IDApICsgMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvdW50cztcbiAgICB9O1xuXG4gICAgY29uc3Qgdm90ZXMgPSBbXG4gICAgICB7IG9wdGlvbklkOiAnb3B0MScsIHVzZXJJZDogJ3VzZXIxJyB9LFxuICAgICAgeyBvcHRpb25JZDogJ29wdDEnLCB1c2VySWQ6ICd1c2VyMicgfSxcbiAgICAgIHsgb3B0aW9uSWQ6ICdvcHQyJywgdXNlcklkOiAndXNlcjMnIH1cbiAgICBdO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gY291bnRWb3Rlcyh2b3Rlcyk7XG4gICAgZXhwZWN0KHJlc3VsdC5vcHQxKS50b0JlKDIpO1xuICAgIGV4cGVjdChyZXN1bHQub3B0MikudG9CZSgxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IHVzZXIgZGF0YSBwcm9jZXNzaW5nJywgKCkgPT4ge1xuICAgIC8vIFRlc3QgdXNlciBkYXRhIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgcHJvY2Vzc1VzZXJEYXRhID0gKHVzZXI6IGFueSkgPT4gKHtcbiAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgZW1haWw6IHVzZXIuZW1haWw/LnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWU/LnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgZGlzcGxheU5hbWU6IHVzZXIuZGlzcGxheU5hbWUgfHwgdXNlci51c2VybmFtZVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmF3VXNlciA9IHtcbiAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgZW1haWw6ICcgIFRFU1RARVhBTVBMRS5DT00gICcsXG4gICAgICB1c2VybmFtZTogJyAgVGVzdFVzZXIgICcsXG4gICAgICBkaXNwbGF5TmFtZTogJ1Rlc3QgVXNlcidcbiAgICB9O1xuXG4gICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1VzZXJEYXRhKHJhd1VzZXIpO1xuICAgIGV4cGVjdChwcm9jZXNzZWQuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICBleHBlY3QocHJvY2Vzc2VkLnVzZXJuYW1lKS50b0JlKCd0ZXN0dXNlcicpO1xuICAgIGV4cGVjdChwcm9jZXNzZWQuZGlzcGxheU5hbWUpLnRvQmUoJ1Rlc3QgVXNlcicpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGFjdHVhbCBlcnJvciBoYW5kbGluZ1xuZGVzY3JpYmUoJ1JlYWwgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAvLyBUZXN0IGVycm9yIGhhbmRsaW5nXG4gICAgY29uc3QgaGFuZGxlQXBpRXJyb3IgPSAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSByZXR1cm4gJ05vdCBmb3VuZCc7XG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA1MDApIHJldHVybiAnU2VydmVyIGVycm9yJztcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgIHJldHVybiAnVW5rbm93biBlcnJvcic7XG4gICAgfTtcblxuICAgIGV4cGVjdChoYW5kbGVBcGlFcnJvcih7IHN0YXR1czogNDA0IH0pKS50b0JlKCdOb3QgZm91bmQnKTtcbiAgICBleHBlY3QoaGFuZGxlQXBpRXJyb3IoeyBzdGF0dXM6IDUwMCB9KSkudG9CZSgnU2VydmVyIGVycm9yJyk7XG4gICAgZXhwZWN0KGhhbmRsZUFwaUVycm9yKHsgbWVzc2FnZTogJ0N1c3RvbSBlcnJvcicgfSkpLnRvQmUoJ0N1c3RvbSBlcnJvcicpO1xuICAgIGV4cGVjdChoYW5kbGVBcGlFcnJvcih7fSkpLnRvQmUoJ1Vua25vd24gZXJyb3InKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBlcnJvcnMnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCB2YWxpZGF0aW9uIGVycm9yIGhhbmRsaW5nXG4gICAgY29uc3QgdmFsaWRhdGVBbmRIYW5kbGUgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWRhdGEuZW1haWwpIHRocm93IG5ldyBFcnJvcignRW1haWwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKCFkYXRhLnBhc3N3b3JkKSB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZERhdGEgPSB7IGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnIH07XG4gICAgY29uc3QgaW52YWxpZERhdGEgPSB7IGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTtcblxuICAgIGV4cGVjdCh2YWxpZGF0ZUFuZEhhbmRsZSh2YWxpZERhdGEpLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlQW5kSGFuZGxlKGludmFsaWREYXRhKS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QodmFsaWRhdGVBbmRIYW5kbGUoaW52YWxpZERhdGEpLmVycm9yKS50b0JlKCdQYXNzd29yZCBpcyByZXF1aXJlZCcpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGFjdHVhbCBkYXRhIHRyYW5zZm9ybWF0aW9uXG5kZXNjcmliZSgnUmVhbCBEYXRhIFRyYW5zZm9ybWF0aW9uJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRyYW5zZm9ybSBwb2xsIGRhdGEgZm9yIGRpc3BsYXknLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBwb2xsIGRhdGEgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB0cmFuc2Zvcm1Qb2xsRm9yRGlzcGxheSA9IChwb2xsOiBhbnkpID0+ICh7XG4gICAgICBpZDogcG9sbC5pZCxcbiAgICAgIHRpdGxlOiBwb2xsLnRpdGxlLFxuICAgICAgdG90YWxWb3RlczogcG9sbC5vcHRpb25zPy5yZWR1Y2UoKHN1bTogbnVtYmVyLCBvcHQ6IGFueSkgPT4gc3VtICsgKG9wdC52b3RlcyB8fCAwKSwgMCkgfHwgMCxcbiAgICAgIG9wdGlvbnM6IHBvbGwub3B0aW9ucz8ubWFwKChvcHQ6IGFueSkgPT4gKHtcbiAgICAgICAgaWQ6IG9wdC5pZCxcbiAgICAgICAgdGV4dDogb3B0LnRleHQsXG4gICAgICAgIHZvdGVzOiBvcHQudm90ZXMgfHwgMCxcbiAgICAgICAgcGVyY2VudGFnZTogMCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseVxuICAgICAgfSkpIHx8IFtdXG4gICAgfSk7XG5cbiAgICBjb25zdCByYXdQb2xsID0ge1xuICAgICAgaWQ6ICdwb2xsLTEyMycsXG4gICAgICB0aXRsZTogJ1Rlc3QgUG9sbCcsXG4gICAgICBvcHRpb25zOiBbXG4gICAgICAgIHsgaWQ6ICdvcHQxJywgdGV4dDogJ09wdGlvbiAxJywgdm90ZXM6IDEwIH0sXG4gICAgICAgIHsgaWQ6ICdvcHQyJywgdGV4dDogJ09wdGlvbiAyJywgdm90ZXM6IDIwIH1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1Qb2xsRm9yRGlzcGxheShyYXdQb2xsKTtcbiAgICBleHBlY3QodHJhbnNmb3JtZWQudG90YWxWb3RlcykudG9CZSgzMCk7XG4gICAgZXhwZWN0KHRyYW5zZm9ybWVkLm9wdGlvbnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICBleHBlY3QodHJhbnNmb3JtZWQub3B0aW9uc1swXS52b3RlcykudG9CZSgxMCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY2FsY3VsYXRlIHBlcmNlbnRhZ2VzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAvLyBUZXN0IHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25cbiAgICBjb25zdCBjYWxjdWxhdGVQZXJjZW50YWdlcyA9IChvcHRpb25zOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3QgdG90YWwgPSBvcHRpb25zLnJlZHVjZSgoc3VtLCBvcHQpID0+IHN1bSArIChvcHQudm90ZXMgfHwgMCksIDApO1xuICAgICAgcmV0dXJuIG9wdGlvbnMubWFwKG9wdCA9PiAoe1xuICAgICAgICAuLi5vcHQsXG4gICAgICAgIHBlcmNlbnRhZ2U6IHRvdGFsID4gMCA/IE1hdGgucm91bmQoKG9wdC52b3RlcyAvIHRvdGFsKSAqIDEwMCkgOiAwXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgICB7IGlkOiAnb3B0MScsIHRleHQ6ICdPcHRpb24gMScsIHZvdGVzOiAxMCB9LFxuICAgICAgeyBpZDogJ29wdDInLCB0ZXh0OiAnT3B0aW9uIDInLCB2b3RlczogMjAgfSxcbiAgICAgIHsgaWQ6ICdvcHQzJywgdGV4dDogJ09wdGlvbiAzJywgdm90ZXM6IDMwIH1cbiAgICBdO1xuXG4gICAgY29uc3Qgd2l0aFBlcmNlbnRhZ2VzID0gY2FsY3VsYXRlUGVyY2VudGFnZXMob3B0aW9ucyk7XG4gICAgZXhwZWN0KHdpdGhQZXJjZW50YWdlc1swXS5wZXJjZW50YWdlKS50b0JlKDE3KTsgLy8gMTAvNjAgKiAxMDBcbiAgICBleHBlY3Qod2l0aFBlcmNlbnRhZ2VzWzFdLnBlcmNlbnRhZ2UpLnRvQmUoMzMpOyAvLyAyMC82MCAqIDEwMFxuICAgIGV4cGVjdCh3aXRoUGVyY2VudGFnZXNbMl0ucGVyY2VudGFnZSkudG9CZSg1MCk7IC8vIDMwLzYwICogMTAwXG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsInNhbml0aXplU3RyaW5nIiwic3RyIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiZXhwZWN0IiwidG9CZSIsImZvcm1hdERhdGUiLCJkYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInRlc3REYXRlIiwiRGF0ZSIsImlzVmFsaWRFbWFpbCIsImVtYWlsIiwidGVzdCIsInZhbGlkYXRlUG9sbCIsInBvbGwiLCJ0aXRsZSIsImxlbmd0aCIsIm9wdGlvbnMiLCJzb21lIiwib3B0IiwidGV4dCIsInZhbGlkUG9sbCIsImludmFsaWRQb2xsIiwiY291bnRWb3RlcyIsInZvdGVzIiwiY291bnRzIiwiZm9yRWFjaCIsInZvdGUiLCJvcHRpb25JZCIsInVzZXJJZCIsInJlc3VsdCIsIm9wdDEiLCJvcHQyIiwicHJvY2Vzc1VzZXJEYXRhIiwidXNlciIsImlkIiwidXNlcm5hbWUiLCJkaXNwbGF5TmFtZSIsInJhd1VzZXIiLCJwcm9jZXNzZWQiLCJoYW5kbGVBcGlFcnJvciIsImVycm9yIiwic3RhdHVzIiwibWVzc2FnZSIsInZhbGlkYXRlQW5kSGFuZGxlIiwiZGF0YSIsIkVycm9yIiwicGFzc3dvcmQiLCJzdWNjZXNzIiwidmFsaWREYXRhIiwiaW52YWxpZERhdGEiLCJ0cmFuc2Zvcm1Qb2xsRm9yRGlzcGxheSIsInRvdGFsVm90ZXMiLCJyZWR1Y2UiLCJzdW0iLCJtYXAiLCJwZXJjZW50YWdlIiwicmF3UG9sbCIsInRyYW5zZm9ybWVkIiwidG9IYXZlTGVuZ3RoIiwiY2FsY3VsYXRlUGVyY2VudGFnZXMiLCJ0b3RhbCIsIk1hdGgiLCJyb3VuZCIsIndpdGhQZXJjZW50YWdlcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRW9DO0FBRXJDLGdDQUFnQztBQUNoQ0EsSUFBQUEsaUJBQVEsRUFBQywwQkFBMEI7SUFDakNDLElBQUFBLFdBQUUsRUFBQyxnQ0FBZ0M7UUFDakMsMkJBQTJCO1FBQzNCLE1BQU1DLGlCQUFpQixDQUFDQyxNQUFnQkEsSUFBSUMsSUFBSSxHQUFHQyxXQUFXO1FBRTlEQyxJQUFBQSxlQUFNLEVBQUNKLGVBQWUsYUFBYUssSUFBSSxDQUFDO1FBQ3hDRCxJQUFBQSxlQUFNLEVBQUNKLGVBQWUsZ0JBQWdCSyxJQUFJLENBQUM7UUFDM0NELElBQUFBLGVBQU0sRUFBQ0osZUFBZSxLQUFLSyxJQUFJLENBQUM7SUFDbEM7SUFFQU4sSUFBQUEsV0FBRSxFQUFDLDhCQUE4QjtRQUMvQix1QkFBdUI7UUFDdkIsTUFBTU8sYUFBYSxDQUFDQyxPQUFlQSxLQUFLQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUVuRSxNQUFNQyxXQUFXLElBQUlDLEtBQUs7UUFDMUJQLElBQUFBLGVBQU0sRUFBQ0UsV0FBV0ksV0FBV0wsSUFBSSxDQUFDO0lBQ3BDO0lBRUFOLElBQUFBLFdBQUUsRUFBQyxvQ0FBb0M7UUFDckMsd0JBQXdCO1FBQ3hCLE1BQU1hLGVBQWUsQ0FBQ0MsUUFBa0IsNkJBQTZCQyxJ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