3b7128b30b64b40a3b6e0f09b332ca1f
/**
 * Analytics Error Prevention Tests
 * 
 * Ensures analytics components handle errors gracefully and
 * maintain data integrity across all analytics operations.
 * 
 * Created: January 27, 2025
 * Status: âœ… ACTIVE
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _fs = /*#__PURE__*/ _interop_require_wildcard(require("fs"));
const _glob = /*#__PURE__*/ _interop_require_wildcard(require("glob"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
(0, _globals.describe)("Analytics Error Prevention", ()=>{
    (0, _globals.it)("analytics components should handle errors gracefully", ()=>{
        const analyticsFiles = _glob.sync("web/features/analytics/**/*.{ts,tsx}", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicFiles = [];
        analyticsFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for error boundary patterns
            if (content.includes("try {") && content.includes("catch")) {
                // Should have proper error handling
                if (!content.includes("console.error") && !content.includes("logger.error")) {
                    problematicFiles.push(`${file}: missing error logging in catch blocks`);
                }
            }
            // Check for async operations without error handling
            const asyncMatches = content.match(/async\s+[^{]*\{[^}]*\}/g);
            if (asyncMatches) {
                asyncMatches.forEach((match)=>{
                    if (!match.includes("try") && !match.includes("catch")) {
                        problematicFiles.push(`${file}: async operation without error handling`);
                    }
                });
            }
        });
        if (problematicFiles.length > 0) {
            console.log("Analytics files with missing error handling:", problematicFiles);
        }
        (0, _globals.expect)(problematicFiles).toHaveLength(0);
    });
    (0, _globals.it)("analytics data should be properly typed", ()=>{
        const analyticsFiles = _glob.sync("web/features/analytics/**/*.{ts,tsx}", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicFiles = [];
        analyticsFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for any types in analytics code
            if (content.match(/:\s*any\b/)) {
                problematicFiles.push(`${file}: contains any types`);
            }
            // Check for proper interface definitions
            if (content.includes("interface ") || content.includes("type ")) {
                // Should have proper type definitions
                if (!content.includes("[key: string]: unknown") && content.includes("interface ")) {
                    problematicFiles.push(`${file}: interface may need index signature`);
                }
            }
        });
        if (problematicFiles.length > 0) {
            console.log("Analytics files with type issues:", problematicFiles);
        }
        (0, _globals.expect)(problematicFiles).toHaveLength(0);
    });
    (0, _globals.it)("analytics tracking should not fail silently", ()=>{
        const analyticsFiles = _glob.sync("web/features/analytics/**/*.{ts,tsx}", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicFiles = [];
        analyticsFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for tracking functions
            if (content.includes("track") || content.includes("analytics")) {
                // Should have error handling
                if (!content.includes("try") && !content.includes("catch")) {
                    problematicFiles.push(`${file}: tracking functions should have error handling`);
                }
            }
            // Check for silent failures
            if (content.includes("catch") && !content.includes("console.error") && !content.includes("logger")) {
                problematicFiles.push(`${file}: catch blocks should log errors`);
            }
        });
        if (problematicFiles.length > 0) {
            console.log("Analytics files with silent failures:", problematicFiles);
        }
        (0, _globals.expect)(problematicFiles).toHaveLength(0);
    });
    (0, _globals.it)("analytics state should be properly managed", ()=>{
        const analyticsFiles = _glob.sync("web/features/analytics/**/*.{ts,tsx}", {
            ignore: [
                "**/*.test.*",
                "**/*.spec.*",
                "**/node_modules/**"
            ]
        });
        const problematicFiles = [];
        analyticsFiles.forEach((file)=>{
            const content = _fs.readFileSync(file, "utf8");
            // Check for useState without proper error handling
            if (content.includes("useState") && content.includes("setError")) {
                // Should have proper error state management
                if (!content.includes("error") || !content.includes("setError")) {
                    problematicFiles.push(`${file}: error state not properly managed`);
                }
            }
            // Check for loading states
            if (content.includes("useState") && content.includes("setLoading")) {
                // Should have proper loading state management
                if (!content.includes("loading") || !content.includes("setLoading")) {
                    problematicFiles.push(`${file}: loading state not properly managed`);
                }
            }
        });
        if (problematicFiles.length > 0) {
            console.log("Analytics files with state management issues:", problematicFiles);
        }
        (0, _globals.expect)(problematicFiles).toHaveLength(0);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvYW5hbHl0aWNzL2FuYWx5dGljcy1lcnJvci1wcmV2ZW50aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBbmFseXRpY3MgRXJyb3IgUHJldmVudGlvbiBUZXN0c1xuICogXG4gKiBFbnN1cmVzIGFuYWx5dGljcyBjb21wb25lbnRzIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseSBhbmRcbiAqIG1haW50YWluIGRhdGEgaW50ZWdyaXR5IGFjcm9zcyBhbGwgYW5hbHl0aWNzIG9wZXJhdGlvbnMuXG4gKiBcbiAqIENyZWF0ZWQ6IEphbnVhcnkgMjcsIDIwMjVcbiAqIFN0YXR1czog4pyFIEFDVElWRVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBnbG9iIGZyb20gJ2dsb2InO1xuXG5kZXNjcmliZSgnQW5hbHl0aWNzIEVycm9yIFByZXZlbnRpb24nLCAoKSA9PiB7XG4gIGl0KCdhbmFseXRpY3MgY29tcG9uZW50cyBzaG91bGQgaGFuZGxlIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgIGNvbnN0IGFuYWx5dGljc0ZpbGVzID0gZ2xvYi5zeW5jKCd3ZWIvZmVhdHVyZXMvYW5hbHl0aWNzLyoqLyoue3RzLHRzeH0nLCB7IFxuICAgICAgaWdub3JlOiBbJyoqLyoudGVzdC4qJywgJyoqLyouc3BlYy4qJywgJyoqL25vZGVfbW9kdWxlcy8qKiddIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHByb2JsZW1hdGljRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgYW5hbHl0aWNzRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGVycm9yIGJvdW5kYXJ5IHBhdHRlcm5zXG4gICAgICBpZiAoY29udGVudC5pbmNsdWRlcygndHJ5IHsnKSAmJiBjb250ZW50LmluY2x1ZGVzKCdjYXRjaCcpKSB7XG4gICAgICAgIC8vIFNob3VsZCBoYXZlIHByb3BlciBlcnJvciBoYW5kbGluZ1xuICAgICAgICBpZiAoIWNvbnRlbnQuaW5jbHVkZXMoJ2NvbnNvbGUuZXJyb3InKSAmJiAhY29udGVudC5pbmNsdWRlcygnbG9nZ2VyLmVycm9yJykpIHtcbiAgICAgICAgICBwcm9ibGVtYXRpY0ZpbGVzLnB1c2goYCR7ZmlsZX06IG1pc3NpbmcgZXJyb3IgbG9nZ2luZyBpbiBjYXRjaCBibG9ja3NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgYXN5bmMgb3BlcmF0aW9ucyB3aXRob3V0IGVycm9yIGhhbmRsaW5nXG4gICAgICBjb25zdCBhc3luY01hdGNoZXMgPSBjb250ZW50Lm1hdGNoKC9hc3luY1xccytbXntdKlxce1tefV0qXFx9L2cpO1xuICAgICAgaWYgKGFzeW5jTWF0Y2hlcykge1xuICAgICAgICBhc3luY01hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaC5pbmNsdWRlcygndHJ5JykgJiYgIW1hdGNoLmluY2x1ZGVzKCdjYXRjaCcpKSB7XG4gICAgICAgICAgICBwcm9ibGVtYXRpY0ZpbGVzLnB1c2goYCR7ZmlsZX06IGFzeW5jIG9wZXJhdGlvbiB3aXRob3V0IGVycm9yIGhhbmRsaW5nYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAocHJvYmxlbWF0aWNGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnQW5hbHl0aWNzIGZpbGVzIHdpdGggbWlzc2luZyBlcnJvciBoYW5kbGluZzonLCBwcm9ibGVtYXRpY0ZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgZXhwZWN0KHByb2JsZW1hdGljRmlsZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgfSk7XG5cbiAgaXQoJ2FuYWx5dGljcyBkYXRhIHNob3VsZCBiZSBwcm9wZXJseSB0eXBlZCcsICgpID0+IHtcbiAgICBjb25zdCBhbmFseXRpY3NGaWxlcyA9IGdsb2Iuc3luYygnd2ViL2ZlYXR1cmVzL2FuYWx5dGljcy8qKi8qLnt0cyx0c3h9JywgeyBcbiAgICAgIGlnbm9yZTogWycqKi8qLnRlc3QuKicsICcqKi8qLnNwZWMuKicsICcqKi9ub2RlX21vZHVsZXMvKionXSBcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBwcm9ibGVtYXRpY0ZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGFuYWx5dGljc0ZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4Jyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBhbnkgdHlwZXMgaW4gYW5hbHl0aWNzIGNvZGVcbiAgICAgIGlmIChjb250ZW50Lm1hdGNoKC86XFxzKmFueVxcYi8pKSB7XG4gICAgICAgIHByb2JsZW1hdGljRmlsZXMucHVzaChgJHtmaWxlfTogY29udGFpbnMgYW55IHR5cGVzYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwcm9wZXIgaW50ZXJmYWNlIGRlZmluaXRpb25zXG4gICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnaW50ZXJmYWNlICcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ3R5cGUgJykpIHtcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgcHJvcGVyIHR5cGUgZGVmaW5pdGlvbnNcbiAgICAgICAgaWYgKCFjb250ZW50LmluY2x1ZGVzKCdba2V5OiBzdHJpbmddOiB1bmtub3duJykgJiYgY29udGVudC5pbmNsdWRlcygnaW50ZXJmYWNlICcpKSB7XG4gICAgICAgICAgcHJvYmxlbWF0aWNGaWxlcy5wdXNoKGAke2ZpbGV9OiBpbnRlcmZhY2UgbWF5IG5lZWQgaW5kZXggc2lnbmF0dXJlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAocHJvYmxlbWF0aWNGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnQW5hbHl0aWNzIGZpbGVzIHdpdGggdHlwZSBpc3N1ZXM6JywgcHJvYmxlbWF0aWNGaWxlcyk7XG4gICAgfVxuICAgIFxuICAgIGV4cGVjdChwcm9ibGVtYXRpY0ZpbGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gIH0pO1xuXG4gIGl0KCdhbmFseXRpY3MgdHJhY2tpbmcgc2hvdWxkIG5vdCBmYWlsIHNpbGVudGx5JywgKCkgPT4ge1xuICAgIGNvbnN0IGFuYWx5dGljc0ZpbGVzID0gZ2xvYi5zeW5jKCd3ZWIvZmVhdHVyZXMvYW5hbHl0aWNzLyoqLyoue3RzLHRzeH0nLCB7IFxuICAgICAgaWdub3JlOiBbJyoqLyoudGVzdC4qJywgJyoqLyouc3BlYy4qJywgJyoqL25vZGVfbW9kdWxlcy8qKiddIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHByb2JsZW1hdGljRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgYW5hbHl0aWNzRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHRyYWNraW5nIGZ1bmN0aW9uc1xuICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3RyYWNrJykgfHwgY29udGVudC5pbmNsdWRlcygnYW5hbHl0aWNzJykpIHtcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgaWYgKCFjb250ZW50LmluY2x1ZGVzKCd0cnknKSAmJiAhY29udGVudC5pbmNsdWRlcygnY2F0Y2gnKSkge1xuICAgICAgICAgIHByb2JsZW1hdGljRmlsZXMucHVzaChgJHtmaWxlfTogdHJhY2tpbmcgZnVuY3Rpb25zIHNob3VsZCBoYXZlIGVycm9yIGhhbmRsaW5nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHNpbGVudCBmYWlsdXJlc1xuICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ2NhdGNoJykgJiYgIWNvbnRlbnQuaW5jbHVkZXMoJ2NvbnNvbGUuZXJyb3InKSAmJiAhY29udGVudC5pbmNsdWRlcygnbG9nZ2VyJykpIHtcbiAgICAgICAgcHJvYmxlbWF0aWNGaWxlcy5wdXNoKGAke2ZpbGV9OiBjYXRjaCBibG9ja3Mgc2hvdWxkIGxvZyBlcnJvcnNgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAocHJvYmxlbWF0aWNGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnQW5hbHl0aWNzIGZpbGVzIHdpdGggc2lsZW50IGZhaWx1cmVzOicsIHByb2JsZW1hdGljRmlsZXMpO1xuICAgIH1cbiAgICBcbiAgICBleHBlY3QocHJvYmxlbWF0aWNGaWxlcykudG9IYXZlTGVuZ3RoKDApO1xuICB9KTtcblxuICBpdCgnYW5hbHl0aWNzIHN0YXRlIHNob3VsZCBiZSBwcm9wZXJseSBtYW5hZ2VkJywgKCkgPT4ge1xuICAgIGNvbnN0IGFuYWx5dGljc0ZpbGVzID0gZ2xvYi5zeW5jKCd3ZWIvZmVhdHVyZXMvYW5hbHl0aWNzLyoqLyoue3RzLHRzeH0nLCB7IFxuICAgICAgaWdub3JlOiBbJyoqLyoudGVzdC4qJywgJyoqLyouc3BlYy4qJywgJyoqL25vZGVfbW9kdWxlcy8qKiddIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHByb2JsZW1hdGljRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgYW5hbHl0aWNzRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHVzZVN0YXRlIHdpdGhvdXQgcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICBpZiAoY29udGVudC5pbmNsdWRlcygndXNlU3RhdGUnKSAmJiBjb250ZW50LmluY2x1ZGVzKCdzZXRFcnJvcicpKSB7XG4gICAgICAgIC8vIFNob3VsZCBoYXZlIHByb3BlciBlcnJvciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICAgIGlmICghY29udGVudC5pbmNsdWRlcygnZXJyb3InKSB8fCAhY29udGVudC5pbmNsdWRlcygnc2V0RXJyb3InKSkge1xuICAgICAgICAgIHByb2JsZW1hdGljRmlsZXMucHVzaChgJHtmaWxlfTogZXJyb3Igc3RhdGUgbm90IHByb3Blcmx5IG1hbmFnZWRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbG9hZGluZyBzdGF0ZXNcbiAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCd1c2VTdGF0ZScpICYmIGNvbnRlbnQuaW5jbHVkZXMoJ3NldExvYWRpbmcnKSkge1xuICAgICAgICAvLyBTaG91bGQgaGF2ZSBwcm9wZXIgbG9hZGluZyBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICAgIGlmICghY29udGVudC5pbmNsdWRlcygnbG9hZGluZycpIHx8ICFjb250ZW50LmluY2x1ZGVzKCdzZXRMb2FkaW5nJykpIHtcbiAgICAgICAgICBwcm9ibGVtYXRpY0ZpbGVzLnB1c2goYCR7ZmlsZX06IGxvYWRpbmcgc3RhdGUgbm90IHByb3Blcmx5IG1hbmFnZWRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChwcm9ibGVtYXRpY0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBbmFseXRpY3MgZmlsZXMgd2l0aCBzdGF0ZSBtYW5hZ2VtZW50IGlzc3VlczonLCBwcm9ibGVtYXRpY0ZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgZXhwZWN0KHByb2JsZW1hdGljRmlsZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiYW5hbHl0aWNzRmlsZXMiLCJnbG9iIiwic3luYyIsImlnbm9yZSIsInByb2JsZW1hdGljRmlsZXMiLCJmb3JFYWNoIiwiZmlsZSIsImNvbnRlbnQiLCJmcyIsInJlYWRGaWxlU3luYyIsImluY2x1ZGVzIiwicHVzaCIsImFzeW5jTWF0Y2hlcyIsIm1hdGNoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsImV4cGVjdCIsInRvSGF2ZUxlbmd0aCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7Ozs7eUJBRW9DOzREQUNqQjs4REFDRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXRCQSxJQUFBQSxpQkFBUSxFQUFDLDhCQUE4QjtJQUNyQ0MsSUFBQUEsV0FBRSxFQUFDLHdEQUF3RDtRQUN6RCxNQUFNQyxpQkFBaUJDLE1BQUtDLElBQUksQ0FBQyx3Q0FBd0M7WUFDdkVDLFFBQVE7Z0JBQUM7Z0JBQWU7Z0JBQWU7YUFBcUI7UUFDOUQ7UUFFQSxNQUFNQyxtQkFBNkIsRUFBRTtRQUVyQ0osZUFBZUssT0FBTyxDQUFDQyxDQUFBQTtZQUNyQixNQUFNQyxVQUFVQyxJQUFHQyxZQUFZLENBQUNILE1BQU07WUFFdEMsb0NBQW9DO1lBQ3BDLElBQUlDLFFBQVFHLFFBQVEsQ0FBQyxZQUFZSCxRQUFRRyxRQUFRLENBQUMsVUFBVTtnQkFDMUQsb0NBQW9DO2dCQUNwQyxJQUFJLENBQUNILFFBQVFHLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQ0gsUUFBUUcsUUFBUSxDQUFDLGlCQUFpQjtvQkFDM0VOLGlCQUFpQk8sSUFBSSxDQUFDLENBQUMsRUFBRUwsS0FBSyx1Q0FBdUMsQ0FBQztnQkFDeEU7WUFDRjtZQUVBLG9EQUFvRDtZQUNwRCxNQUFNTSxlQUFlTCxRQUFRTSxLQUFLLENBQUM7WUFDbkMsSUFBSUQs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