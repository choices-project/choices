1af8270a407532a94bdf585f51b76e01
/**
 * UnifiedFeed Accessibility Tests
 * 
 * Comprehensive accessibility testing for the UnifiedFeed component
 * Tests WCAG 2.1 AA compliance and screen reader support
 * 
 * Created: January 19, 2025
 * Status: âœ… PRODUCTION READY
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _jestaxe = require("jest-axe");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../../features/feeds/components/UnifiedFeed"));
const _feedsStore = require("../../../../../lib/stores/feedsStore");
const _useHashtags = require("../../../../../features/hashtags/hooks/useHashtags");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Extend Jest matchers
expect.extend(_jestaxe.toHaveNoViolations);
// Mock the stores
_globals.jest.mock('@/lib/stores/feedsStore', ()=>({
        useFeeds: _globals.jest.fn()
    }));
_globals.jest.mock('@/features/hashtags/hooks/useHashtags', ()=>({
        useHashtags: _globals.jest.fn()
    }));
const mockUseFeeds = _feedsStore.useFeeds;
const mockUseHashtags = _useHashtags.useHashtags;
// Ensure mocks are properly initialized
beforeEach(()=>{
    mockUseFeeds.mockReturnValue([]);
    mockUseHashtags.mockReturnValue({
        hashtags: [],
        trendingHashtags: [],
        userHashtags: [],
        isLoading: false,
        error: null,
        loadTrendingHashtags: _globals.jest.fn(),
        searchHashtags: _globals.jest.fn(),
        followHashtag: _globals.jest.fn(),
        unfollowHashtag: _globals.jest.fn(),
        getTrendingHashtags: _globals.jest.fn(),
        refresh: _globals.jest.fn()
    });
});
// Mock data
const mockFeedData = [
    {
        id: '1',
        type: 'poll',
        title: 'Test Poll',
        description: 'This is a test poll',
        hashtags: [
            'politics',
            'election'
        ],
        created_at: '2025-01-19T10:00:00Z',
        author: 'Test User',
        engagement: {
            likes: 10,
            shares: 5,
            comments: 3
        }
    },
    {
        id: '2',
        type: 'post',
        title: 'Test Post',
        description: 'This is a test post',
        hashtags: [
            'news',
            'update'
        ],
        created_at: '2025-01-19T09:00:00Z',
        author: 'Test User 2',
        engagement: {
            likes: 15,
            shares: 8,
            comments: 12
        }
    }
];
const mockHashtagData = [
    {
        id: '1',
        name: 'politics',
        display_name: 'Politics',
        usage_count: 100,
        follower_count: 50,
        is_trending: true,
        trend_score: 0.8,
        created_at: '2025-01-19T10:00:00Z',
        updated_at: '2025-01-19T10:00:00Z',
        is_verified: false,
        is_featured: false
    }
];
describe('UnifiedFeed Accessibility Tests', ()=>{
    beforeEach(()=>{
        // Mock store implementations
        mockUseFeeds.mockReturnValue({
            feeds: mockFeedData,
            loading: false,
            error: null,
            refreshFeeds: _globals.jest.fn(),
            likeFeed: _globals.jest.fn(),
            shareFeed: _globals.jest.fn(),
            commentFeed: _globals.jest.fn(),
            bookmarkFeed: _globals.jest.fn()
        });
        mockUseHashtags.mockReturnValue({
            hashtags: mockHashtagData,
            loading: false,
            error: null,
            searchHashtags: _globals.jest.fn(),
            followHashtag: _globals.jest.fn(),
            unfollowHashtag: _globals.jest.fn(),
            getTrendingHashtags: _globals.jest.fn()
        });
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('WCAG 2.1 AA Compliance', ()=>{
        test('should have no accessibility violations', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            const results = await (0, _jestaxe.axe)(container);
            expect(results).toHaveNoViolations();
        });
        test('should have proper heading structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for main heading
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toBeInTheDocument();
            expect(mainHeading).toHaveTextContent('Unified Feed');
        });
        test('should have proper color contrast', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            const results = await (0, _jestaxe.axe)(container, {
                rules: {
                    'color-contrast': {
                        enabled: true
                    }
                }
            });
            expect(results).toHaveNoViolations();
        });
        test('should have proper focus management', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check that focusable elements are properly marked
            const focusableElements = _react1.screen.getAllByRole('button');
            focusableElements.forEach((element)=>{
                expect(element).toHaveAttribute('tabIndex');
            });
        });
    });
    describe('Screen Reader Support', ()=>{
        test('should have proper ARIA labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check main feed role and label
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toHaveAttribute('aria-label', 'Unified Feed');
            // Check button labels
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            expect(darkModeButton).toBeInTheDocument();
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(filtersButton).toBeInTheDocument();
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            expect(refreshButton).toBeInTheDocument();
        });
        test('should have proper ARIA live regions', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for live regions
            const liveRegions = _react1.screen.getAllByRole('status');
            expect(liveRegions.length).toBeGreaterThan(0);
            // Check for polite announcements
            const politeRegion = _react1.screen.getByRole('status', {
                name: /feed/i
            });
            expect(politeRegion).toBeInTheDocument();
        });
        test('should announce state changes', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Trigger a state change
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Check for announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/switched to dark mode/i)).toBeInTheDocument();
            });
        });
        test('should have proper form labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for form elements with proper labels
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                const label = _react1.screen.getByLabelText(input.getAttribute('aria-label') || '');
                expect(label).toBeInTheDocument();
            });
        });
    });
    describe('Keyboard Navigation', ()=>{
        test('should support tab navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Start with first focusable element
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            expect(document.activeElement).toBe(firstButton);
            // Tab to next element
            _react1.fireEvent.keyDown(firstButton, {
                key: 'Tab'
            });
            const nextButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(document.activeElement).toBe(nextButton);
        });
        test('should support enter key activation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            darkModeButton.focus();
            // Press Enter
            _react1.fireEvent.keyDown(darkModeButton, {
                key: 'Enter'
            });
            // Check that action was triggered
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByLabelText(/switch to light mode/i)).toBeInTheDocument();
            });
        });
        test('should support escape key for closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that filters panel is open
            expect(_react1.screen.getByText(/advanced filters/i)).toBeInTheDocument();
            // Press Escape
            _react1.fireEvent.keyDown(document, {
                key: 'Escape'
            });
            // Check that filters panel is closed
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/advanced filters/i)).not.toBeInTheDocument();
            });
        });
        test('should support arrow key navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check that arrow keys work for navigation
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            // Arrow right
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowRight'
            });
            // Arrow left
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowLeft'
            });
            // Arrow up
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowUp'
            });
            // Arrow down
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowDown'
            });
            // Should not throw errors
            expect(true).toBe(true);
        });
    });
    describe('Focus Management', ()=>{
        test('should trap focus in modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that focus is trapped in modal
            const modal = _react1.screen.getByRole('dialog');
            expect(modal).toBeInTheDocument();
            // Check that focus is within modal
            const focusedElement = document.activeElement;
            expect(modal.contains(focusedElement)).toBe(true);
        });
        test('should restore focus after closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            filtersButton.focus();
            // Open modal
            _react1.fireEvent.click(filtersButton);
            // Close modal
            _react1.fireEvent.click(filtersButton);
            // Check that focus is restored
            expect(document.activeElement).toBe(filtersButton);
        });
        test('should manage focus for dynamic content', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Trigger content update
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            _react1.fireEvent.click(refreshButton);
            // Check that focus is managed properly
            await (0, _react1.waitFor)(()=>{
                expect(document.activeElement).toBeInTheDocument();
            });
        });
    });
    describe('Semantic HTML', ()=>{
        test('should use proper semantic elements', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for main element
            const main = _react1.screen.getByRole('main');
            expect(main).toBeInTheDocument();
            // Check for header element
            const header = _react1.screen.getByRole('banner');
            expect(header).toBeInTheDocument();
            // Check for navigation elements
            const nav = _react1.screen.getByRole('navigation');
            expect(nav).toBeInTheDocument();
        });
        test('should have proper list structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for list elements
            const lists = _react1.screen.getAllByRole('list');
            expect(lists.length).toBeGreaterThan(0);
            // Check for list items
            const listItems = _react1.screen.getAllByRole('listitem');
            expect(listItems.length).toBeGreaterThan(0);
        });
        test('should have proper button semantics', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check that all buttons have proper roles
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                expect(button).toHaveAttribute('type', 'button');
            });
        });
    });
    describe('Alternative Text', ()=>{
        test('should have alt text for images', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for images with alt text
            const images = _react1.screen.getAllByRole('img');
            images.forEach((image)=>{
                expect(image).toHaveAttribute('alt');
            });
        });
        test('should have descriptive text for icons', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for icons with proper labels
            const icons = _react1.screen.getAllByRole('img');
            icons.forEach((icon)=>{
                const altText = icon.getAttribute('alt');
                expect(altText).toBeTruthy();
                expect(altText?.length).toBeGreaterThan(0);
            });
        });
    });
    describe('Error Handling', ()=>{
        test('should announce errors to screen readers', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Failed to load feeds'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for error announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/failed to load feeds/i)).toBeInTheDocument();
            });
        });
        test('should provide error recovery options', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Network error'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for retry button
            const retryButton = _react1.screen.getByLabelText(/retry/i);
            expect(retryButton).toBeInTheDocument();
            // Check that retry button is accessible
            expect(retryButton).toHaveAttribute('aria-label');
        });
    });
    describe('Loading States', ()=>{
        test('should announce loading states', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for loading announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/loading/i)).toBeInTheDocument();
            });
        });
        test('should provide loading progress information', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check for progress indicator
            const progressIndicator = _react1.screen.getByRole('progressbar');
            expect(progressIndicator).toBeInTheDocument();
        });
    });
    describe('Mobile Accessibility', ()=>{
        test('should support touch gestures with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Simulate touch events
            const feed = _react1.screen.getByRole('main');
            _react1.fireEvent.touchStart(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 100
                    }
                ]
            });
            _react1.fireEvent.touchMove(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            _react1.fireEvent.touchEnd(feed, {
                changedTouches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            // Check that touch events are handled properly
            expect(feed).toBeInTheDocument();
        });
        test('should support haptic feedback with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Mock haptic feedback
            const mockVibrate = _globals.jest.fn();
            Object.defineProperty(navigator, 'vibrate', {
                value: mockVibrate,
                writable: true
            });
            // Trigger haptic feedback
            const likeButton = _react1.screen.getByLabelText(/like/i);
            _react1.fireEvent.click(likeButton);
            // Check that haptic feedback was triggered
            expect(mockVibrate).toHaveBeenCalled();
        });
    });
    describe('Internationalization', ()=>{
        test('should support different languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check that text content is properly structured for translation
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toHaveTextContent('Unified Feed');
            // Check that ARIA labels are properly structured
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                const ariaLabel = button.getAttribute('aria-label');
                expect(ariaLabel).toBeTruthy();
            });
        });
        test('should support right-to-left languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            // Check that layout supports RTL
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toBeInTheDocument();
            // Check that text direction can be changed
            const textElements = _react1.screen.getAllByText(/test/i);
            textElements.forEach((element)=>{
                expect(element).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQuYWNjZXNzaWJpbGl0eS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaWZpZWRGZWVkIEFjY2Vzc2liaWxpdHkgVGVzdHNcbiAqIFxuICogQ29tcHJlaGVuc2l2ZSBhY2Nlc3NpYmlsaXR5IHRlc3RpbmcgZm9yIHRoZSBVbmlmaWVkRmVlZCBjb21wb25lbnRcbiAqIFRlc3RzIFdDQUcgMi4xIEFBIGNvbXBsaWFuY2UgYW5kIHNjcmVlbiByZWFkZXIgc3VwcG9ydFxuICogXG4gKiBDcmVhdGVkOiBKYW51YXJ5IDE5LCAyMDI1XG4gKiBTdGF0dXM6IOKchSBQUk9EVUNUSU9OIFJFQURZXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IGF4ZSwgdG9IYXZlTm9WaW9sYXRpb25zIH0gZnJvbSAnamVzdC1heGUnO1xuaW1wb3J0IFVuaWZpZWRGZWVkIGZyb20gJ0AvZmVhdHVyZXMvZmVlZHMvY29tcG9uZW50cy9VbmlmaWVkRmVlZCc7XG5pbXBvcnQgeyB1c2VGZWVkcyB9IGZyb20gJ0AvbGliL3N0b3Jlcy9mZWVkc1N0b3JlJztcbmltcG9ydCB7IHVzZUhhc2h0YWdzIH0gZnJvbSAnQC9mZWF0dXJlcy9oYXNodGFncy9ob29rcy91c2VIYXNodGFncyc7XG5cbi8vIEV4dGVuZCBKZXN0IG1hdGNoZXJzXG5leHBlY3QuZXh0ZW5kKHRvSGF2ZU5vVmlvbGF0aW9ucyk7XG5cbi8vIE1vY2sgdGhlIHN0b3Jlc1xuamVzdC5tb2NrKCdAL2xpYi9zdG9yZXMvZmVlZHNTdG9yZScsICgpID0+ICh7XG4gIHVzZUZlZWRzOiBqZXN0LmZuKClcbn0pKTtcblxuamVzdC5tb2NrKCdAL2ZlYXR1cmVzL2hhc2h0YWdzL2hvb2tzL3VzZUhhc2h0YWdzJywgKCkgPT4gKHtcbiAgdXNlSGFzaHRhZ3M6IGplc3QuZm4oKVxufSkpO1xuXG5jb25zdCBtb2NrVXNlRmVlZHMgPSB1c2VGZWVkcyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB1c2VGZWVkcz47XG5jb25zdCBtb2NrVXNlSGFzaHRhZ3MgPSB1c2VIYXNodGFncyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB1c2VIYXNodGFncz47XG5cbi8vIEVuc3VyZSBtb2NrcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbmJlZm9yZUVhY2goKCkgPT4ge1xuICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKFtdKTtcbiAgbW9ja1VzZUhhc2h0YWdzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgaGFzaHRhZ3M6IFtdLFxuICAgIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLFxuICAgIHVzZXJIYXNodGFnczogW10sXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBsb2FkVHJlbmRpbmdIYXNodGFnczogamVzdC5mbigpLFxuICAgIHNlYXJjaEhhc2h0YWdzOiBqZXN0LmZuKCksXG4gICAgZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgIHVuZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgIGdldFRyZW5kaW5nSGFzaHRhZ3M6IGplc3QuZm4oKSxcbiAgICByZWZyZXNoOiBqZXN0LmZuKClcbiAgfSk7XG59KTtcblxuXG4vLyBNb2NrIGRhdGFcbmNvbnN0IG1vY2tGZWVkRGF0YSA9IFtcbiAge1xuICAgIGlkOiAnMScsXG4gICAgdHlwZTogJ3BvbGwnLFxuICAgIHRpdGxlOiAnVGVzdCBQb2xsJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoaXMgaXMgYSB0ZXN0IHBvbGwnLFxuICAgIGhhc2h0YWdzOiBbJ3BvbGl0aWNzJywgJ2VsZWN0aW9uJ10sXG4gICAgY3JlYXRlZF9hdDogJzIwMjUtMDEtMTlUMTA6MDA6MDBaJyxcbiAgICBhdXRob3I6ICdUZXN0IFVzZXInLFxuICAgIGVuZ2FnZW1lbnQ6IHtcbiAgICAgIGxpa2VzOiAxMCxcbiAgICAgIHNoYXJlczogNSxcbiAgICAgIGNvbW1lbnRzOiAzXG4gICAgfVxuICB9LFxuICB7XG4gICAgaWQ6ICcyJyxcbiAgICB0eXBlOiAncG9zdCcsXG4gICAgdGl0bGU6ICdUZXN0IFBvc3QnLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBpcyBhIHRlc3QgcG9zdCcsXG4gICAgaGFzaHRhZ3M6IFsnbmV3cycsICd1cGRhdGUnXSxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0xOVQwOTowMDowMFonLFxuICAgIGF1dGhvcjogJ1Rlc3QgVXNlciAyJyxcbiAgICBlbmdhZ2VtZW50OiB7XG4gICAgICBsaWtlczogMTUsXG4gICAgICBzaGFyZXM6IDgsXG4gICAgICBjb21tZW50czogMTJcbiAgICB9XG4gIH1cbl07XG5cbmNvbnN0IG1vY2tIYXNodGFnRGF0YSA9IFtcbiAge1xuICAgIGlkOiAnMScsXG4gICAgbmFtZTogJ3BvbGl0aWNzJyxcbiAgICBkaXNwbGF5X25hbWU6ICdQb2xpdGljcycsXG4gICAgdXNhZ2VfY291bnQ6IDEwMCxcbiAgICBmb2xsb3dlcl9jb3VudDogNTAsXG4gICAgaXNfdHJlbmRpbmc6IHRydWUsXG4gICAgdHJlbmRfc2NvcmU6IDAuOCxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0xOVQxMDowMDowMFonLFxuICAgIHVwZGF0ZWRfYXQ6ICcyMDI1LTAxLTE5VDEwOjAwOjAwWicsXG4gICAgaXNfdmVyaWZpZWQ6IGZhbHNlLFxuICAgIGlzX2ZlYXR1cmVkOiBmYWxzZVxuICB9XG5dO1xuXG5kZXNjcmliZSgnVW5pZmllZEZlZWQgQWNjZXNzaWJpbGl0eSBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gTW9jayBzdG9yZSBpbXBsZW1lbnRhdGlvbnNcbiAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIGZlZWRzOiBtb2NrRmVlZERhdGEsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgcmVmcmVzaEZlZWRzOiBqZXN0LmZuKCksXG4gICAgICBsaWtlRmVlZDogamVzdC5mbigpLFxuICAgICAgc2hhcmVGZWVkOiBqZXN0LmZuKCksXG4gICAgICBjb21tZW50RmVlZDogamVzdC5mbigpLFxuICAgICAgYm9va21hcmtGZWVkOiBqZXN0LmZuKClcbiAgICB9KTtcblxuICAgIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgaGFzaHRhZ3M6IG1vY2tIYXNodGFnRGF0YSxcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBzZWFyY2hIYXNodGFnczogamVzdC5mbigpLFxuICAgICAgZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgICAgdW5mb2xsb3dIYXNodGFnOiBqZXN0LmZuKCksXG4gICAgICBnZXRUcmVuZGluZ0hhc2h0YWdzOiBqZXN0LmZuKClcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1dDQUcgMi4xIEFBIENvbXBsaWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgbm8gYWNjZXNzaWJpbGl0eSB2aW9sYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGF4ZShjb250YWluZXIpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZU5vVmlvbGF0aW9ucygpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGhlYWRpbmcgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBtYWluIGhlYWRpbmdcbiAgICAgIGNvbnN0IG1haW5IZWFkaW5nID0gc2NyZWVuLmdldEJ5Um9sZSgnaGVhZGluZycsIHsgbGV2ZWw6IDEgfSk7XG4gICAgICBleHBlY3QobWFpbkhlYWRpbmcpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3QobWFpbkhlYWRpbmcpLnRvSGF2ZVRleHRDb250ZW50KCdVbmlmaWVkIEZlZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBjb2xvciBjb250cmFzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBheGUoY29udGFpbmVyLCB7XG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgJ2NvbG9yLWNvbnRyYXN0JzogeyBlbmFibGVkOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTm9WaW9sYXRpb25zKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgZm9jdXMgbWFuYWdlbWVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZvY3VzYWJsZSBlbGVtZW50cyBhcmUgcHJvcGVybHkgbWFya2VkXG4gICAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicpO1xuICAgICAgZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQpLnRvSGF2ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2NyZWVuIFJlYWRlciBTdXBwb3J0JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBBUklBIGxhYmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBtYWluIGZlZWQgcm9sZSBhbmQgbGFiZWxcbiAgICAgIGNvbnN0IG1haW5GZWVkID0gc2NyZWVuLmdldEJ5Um9sZSgnbWFpbicpO1xuICAgICAgZXhwZWN0KG1haW5GZWVkKS50b0hhdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnVW5pZmllZCBGZWVkJyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGJ1dHRvbiBsYWJlbHNcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZXhwZWN0KGRhcmtNb2RlQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGV4cGVjdChmaWx0ZXJzQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBjb25zdCByZWZyZXNoQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWZyZXNoIGZlZWQvaSk7XG4gICAgICBleHBlY3QocmVmcmVzaEJ1dHRvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBBUklBIGxpdmUgcmVnaW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbGl2ZSByZWdpb25zXG4gICAgICBjb25zdCBsaXZlUmVnaW9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3N0YXR1cycpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb25zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcG9saXRlIGFubm91bmNlbWVudHNcbiAgICAgIGNvbnN0IHBvbGl0ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycsIHsgbmFtZTogL2ZlZWQvaSB9KTtcbiAgICAgIGV4cGVjdChwb2xpdGVSZWdpb24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYW5ub3VuY2Ugc3RhdGUgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGEgc3RhdGUgY2hhbmdlXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBhbm5vdW5jZW1lbnRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvc3dpdGNoZWQgdG8gZGFyayBtb2RlL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgZm9ybSBsYWJlbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGZvcm0gZWxlbWVudHMgd2l0aCBwcm9wZXIgbGFiZWxzXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KGlucHV0LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpIHx8ICcnKTtcbiAgICAgICAgZXhwZWN0KGxhYmVsKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdLZXlib2FyZCBOYXZpZ2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IHRhYiBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IHdpdGggZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgIGNvbnN0IGZpcnN0QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyc3RCdXR0b24uZm9jdXMoKTtcbiAgICAgIGV4cGVjdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS50b0JlKGZpcnN0QnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gVGFiIHRvIG5leHQgZWxlbWVudFxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnVGFiJyB9KTtcbiAgICAgIGNvbnN0IG5leHRCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgZXhwZWN0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLnRvQmUobmV4dEJ1dHRvbik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBlbnRlciBrZXkgYWN0aXZhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGRhcmtNb2RlQnV0dG9uLmZvY3VzKCk7XG4gICAgICBcbiAgICAgIC8vIFByZXNzIEVudGVyXG4gICAgICBmaXJlRXZlbnQua2V5RG93bihkYXJrTW9kZUJ1dHRvbiwgeyBrZXk6ICdFbnRlcicgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgYWN0aW9uIHdhcyB0cmlnZ2VyZWRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gbGlnaHQgbW9kZS9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgZXNjYXBlIGtleSBmb3IgY2xvc2luZyBtb2RhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gT3BlbiBhZHZhbmNlZCBmaWx0ZXJzXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhmaWx0ZXJzQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmaWx0ZXJzIHBhbmVsIGlzIG9wZW5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9hZHZhbmNlZCBmaWx0ZXJzL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBQcmVzcyBFc2NhcGVcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRvY3VtZW50LCB7IGtleTogJ0VzY2FwZScgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZmlsdGVycyBwYW5lbCBpcyBjbG9zZWRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9hZHZhbmNlZCBmaWx0ZXJzL2kpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgYXJyb3cga2V5IG5hdmlnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhcnJvdyBrZXlzIHdvcmsgZm9yIG5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGZpcnN0QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyc3RCdXR0b24uZm9jdXMoKTtcbiAgICAgIFxuICAgICAgLy8gQXJyb3cgcmlnaHRcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGZpcnN0QnV0dG9uLCB7IGtleTogJ0Fycm93UmlnaHQnIH0pO1xuICAgICAgXG4gICAgICAvLyBBcnJvdyBsZWZ0XG4gICAgICBmaXJlRXZlbnQua2V5RG93bihmaXJzdEJ1dHRvbiwgeyBrZXk6ICdBcnJvd0xlZnQnIH0pO1xuICAgICAgXG4gICAgICAvLyBBcnJvdyB1cFxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnQXJyb3dVcCcgfSk7XG4gICAgICBcbiAgICAgIC8vIEFycm93IGRvd25cbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGZpcnN0QnV0dG9uLCB7IGtleTogJ0Fycm93RG93bicgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3JzXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZvY3VzIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHRyYXAgZm9jdXMgaW4gbW9kYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIE9wZW4gYWR2YW5jZWQgZmlsdGVyc1xuICAgICAgY29uc3QgZmlsdGVyc0J1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvdG9nZ2xlIGFkdmFuY2VkIGZpbHRlcnMvaSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXMgaXMgdHJhcHBlZCBpbiBtb2RhbFxuICAgICAgY29uc3QgbW9kYWwgPSBzY3JlZW4uZ2V0QnlSb2xlKCdkaWFsb2cnKTtcbiAgICAgIGV4cGVjdChtb2RhbCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmb2N1cyBpcyB3aXRoaW4gbW9kYWxcbiAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGV4cGVjdChtb2RhbC5jb250YWlucyhmb2N1c2VkRWxlbWVudCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVzdG9yZSBmb2N1cyBhZnRlciBjbG9zaW5nIG1vZGFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGZpbHRlcnNCdXR0b24uZm9jdXMoKTtcbiAgICAgIFxuICAgICAgLy8gT3BlbiBtb2RhbFxuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDbG9zZSBtb2RhbFxuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZvY3VzIGlzIHJlc3RvcmVkXG4gICAgICBleHBlY3QoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkudG9CZShmaWx0ZXJzQnV0dG9uKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYW5hZ2UgZm9jdXMgZm9yIGR5bmFtaWMgY29udGVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGNvbnRlbnQgdXBkYXRlXG4gICAgICBjb25zdCByZWZyZXNoQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWZyZXNoIGZlZWQvaSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2socmVmcmVzaEJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXMgaXMgbWFuYWdlZCBwcm9wZXJseVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZW1hbnRpYyBIVE1MJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB1c2UgcHJvcGVyIHNlbWFudGljIGVsZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBtYWluIGVsZW1lbnRcbiAgICAgIGNvbnN0IG1haW4gPSBzY3JlZW4uZ2V0QnlSb2xlKCdtYWluJyk7XG4gICAgICBleHBlY3QobWFpbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlciBlbGVtZW50XG4gICAgICBjb25zdCBoZWFkZXIgPSBzY3JlZW4uZ2V0QnlSb2xlKCdiYW5uZXInKTtcbiAgICAgIGV4cGVjdChoZWFkZXIpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBuYXZpZ2F0aW9uIGVsZW1lbnRzXG4gICAgICBjb25zdCBuYXYgPSBzY3JlZW4uZ2V0QnlSb2xlKCduYXZpZ2F0aW9uJyk7XG4gICAgICBleHBlY3QobmF2KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGxpc3Qgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBsaXN0IGVsZW1lbnRzXG4gICAgICBjb25zdCBsaXN0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2xpc3QnKTtcbiAgICAgIGV4cGVjdChsaXN0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3QgaXRlbXNcbiAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2xpc3RpdGVtJyk7XG4gICAgICBleHBlY3QobGlzdEl0ZW1zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGJ1dHRvbiBzZW1hbnRpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhbGwgYnV0dG9ucyBoYXZlIHByb3BlciByb2xlc1xuICAgICAgY29uc3QgYnV0dG9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicpO1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGV4cGVjdChidXR0b24pLnRvSGF2ZUF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWx0ZXJuYXRpdmUgVGV4dCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBhbHQgdGV4dCBmb3IgaW1hZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBpbWFnZXMgd2l0aCBhbHQgdGV4dFxuICAgICAgY29uc3QgaW1hZ2VzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnaW1nJyk7XG4gICAgICBpbWFnZXMuZm9yRWFjaChpbWFnZSA9PiB7XG4gICAgICAgIGV4cGVjdChpbWFnZSkudG9IYXZlQXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgZGVzY3JpcHRpdmUgdGV4dCBmb3IgaWNvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGljb25zIHdpdGggcHJvcGVyIGxhYmVsc1xuICAgICAgY29uc3QgaWNvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdpbWcnKTtcbiAgICAgIGljb25zLmZvckVhY2goaWNvbiA9PiB7XG4gICAgICAgIGNvbnN0IGFsdFRleHQgPSBpY29uLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gICAgICAgIGV4cGVjdChhbHRUZXh0KS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdChhbHRUZXh0Py5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFubm91bmNlIGVycm9ycyB0byBzY3JlZW4gcmVhZGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gbG9hZCBmZWVkcydcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGVycm9yIGFubm91bmNlbWVudFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9mYWlsZWQgdG8gbG9hZCBmZWVkcy9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgZXJyb3IgcmVjb3Zlcnkgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgZXJyb3I6ICdOZXR3b3JrIGVycm9yJ1xuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcmV0cnkgYnV0dG9uXG4gICAgICBjb25zdCByZXRyeUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmV0cnkvaSk7XG4gICAgICBleHBlY3QocmV0cnlCdXR0b24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgcmV0cnkgYnV0dG9uIGlzIGFjY2Vzc2libGVcbiAgICAgIGV4cGVjdChyZXRyeUJ1dHRvbikudG9IYXZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2FkaW5nIFN0YXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYW5ub3VuY2UgbG9hZGluZyBzdGF0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUZlZWRzKCksXG4gICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGxvYWRpbmcgYW5ub3VuY2VtZW50XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2xvYWRpbmcvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwcm92aWRlIGxvYWRpbmcgcHJvZ3Jlc3MgaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUZlZWRzKCksXG4gICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgY29uc3QgcHJvZ3Jlc3NJbmRpY2F0b3IgPSBzY3JlZW4uZ2V0QnlSb2xlKCdwcm9ncmVzc2JhcicpO1xuICAgICAgZXhwZWN0KHByb2dyZXNzSW5kaWNhdG9yKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9iaWxlIEFjY2Vzc2liaWxpdHknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgdG91Y2ggZ2VzdHVyZXMgd2l0aCBhY2Nlc3NpYmlsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHRvdWNoIGV2ZW50c1xuICAgICAgY29uc3QgZmVlZCA9IHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKTtcbiAgICAgIGZpcmVFdmVudC50b3VjaFN0YXJ0KGZlZWQsIHsgdG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAxMDAgfV0gfSk7XG4gICAgICBmaXJlRXZlbnQudG91Y2hNb3ZlKGZlZWQsIHsgdG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAyMDAgfV0gfSk7XG4gICAgICBmaXJlRXZlbnQudG91Y2hFbmQoZmVlZCwgeyBjaGFuZ2VkVG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAyMDAgfV0gfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgdG91Y2ggZXZlbnRzIGFyZSBoYW5kbGVkIHByb3Blcmx5XG4gICAgICBleHBlY3QoZmVlZCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IGhhcHRpYyBmZWVkYmFjayB3aXRoIGFjY2Vzc2liaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBoYXB0aWMgZmVlZGJhY2tcbiAgICAgIGNvbnN0IG1vY2tWaWJyYXRlID0gamVzdC5mbigpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3ZpYnJhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBtb2NrVmlicmF0ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGhhcHRpYyBmZWVkYmFja1xuICAgICAgY29uc3QgbGlrZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvbGlrZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhsaWtlQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBoYXB0aWMgZmVlZGJhY2sgd2FzIHRyaWdnZXJlZFxuICAgICAgZXhwZWN0KG1vY2tWaWJyYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlcm5hdGlvbmFsaXphdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBkaWZmZXJlbnQgbGFuZ3VhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgdGV4dCBjb250ZW50IGlzIHByb3Blcmx5IHN0cnVjdHVyZWQgZm9yIHRyYW5zbGF0aW9uXG4gICAgICBjb25zdCBtYWluSGVhZGluZyA9IHNjcmVlbi5nZXRCeVJvbGUoJ2hlYWRpbmcnLCB7IGxldmVsOiAxIH0pO1xuICAgICAgZXhwZWN0KG1haW5IZWFkaW5nKS50b0hhdmVUZXh0Q29udGVudCgnVW5pZmllZCBGZWVkJyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgQVJJQSBsYWJlbHMgYXJlIHByb3Blcmx5IHN0cnVjdHVyZWRcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nKTtcbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBjb25zdCBhcmlhTGFiZWwgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgIGV4cGVjdChhcmlhTGFiZWwpLnRvQmVUcnV0aHkoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgcmlnaHQtdG8tbGVmdCBsYW5ndWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBsYXlvdXQgc3VwcG9ydHMgUlRMXG4gICAgICBjb25zdCBtYWluRmVlZCA9IHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKTtcbiAgICAgIGV4cGVjdChtYWluRmVlZCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCB0ZXh0IGRpcmVjdGlvbiBjYW4gYmUgY2hhbmdlZFxuICAgICAgY29uc3QgdGV4dEVsZW1lbnRzID0gc2NyZWVuLmdldEFsbEJ5VGV4dCgvdGVzdC9pKTtcbiAgICAgIHRleHRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBleHBlY3QoZWxlbWVudCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImV4cGVjdCIsImV4dGVuZCIsInRvSGF2ZU5vVmlvbGF0aW9ucyIsImplc3QiLCJtb2NrIiwidXNlRmVlZHMiLCJmbiIsInVzZUhhc2h0YWdzIiwibW9ja1VzZUZlZWRzIiwibW9ja1VzZUhhc2h0YWdzIiwiYmVmb3JlRWFjaCIsIm1vY2tSZXR1cm5WYWx1ZSIsImhhc2h0YWdzIiwidHJlbmRpbmdIYXNodGFncyIsInVzZXJIYXNodGFncyIsImlzTG9hZGluZyIsImVycm9yIiwibG9hZFRyZW5kaW5nSGFzaHRhZ3MiLCJzZWFyY2hIYXNodGFncyIsImZvbGxvd0hhc2h0YWciLCJ1bmZvbGxvd0hhc2h0YWciLCJnZXRUcmVuZGluZ0hhc2h0YWdzIiwicmVmcmVzaCIsIm1vY2tGZWVkRGF0YSIsImlkIiwidHlwZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJjcmVhdGVkX2F0IiwiYXV0aG9yIiwiZW5nYWdlbWVudCIsImxpa2VzIiwic2hhcmVzIiwiY29tbWVudHMiLCJtb2NrSGFzaHRhZ0RhdGEiLCJuYW1lIiwiZGlzcGxheV9uYW1lIiwidXNhZ2VfY291bnQiLCJmb2xsb3dlcl9jb3VudCIsImlzX3RyZW5kaW5nIiwidHJlbmRfc2NvcmUiLCJ1cGRhdGVkX2F0IiwiaXNfdmVyaWZpZWQiLCJpc19mZWF0dXJlZCIsImRlc2NyaWJlIiwiZmVlZHMiLCJsb2FkaW5nIiwicmVmcmVzaEZlZWRzIiwibGlrZUZlZWQiLCJzaGFyZUZlZWQiLCJjb21tZW50RmVlZCIsImJvb2ttYXJrRmVlZCIsImFmdGVyRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ0ZXN0IiwiY29udGFpbmVyIiwicmVuZGVyIiwiVW5pZmllZEZlZWQiLCJyZXN1bHRzIiwiYXhlIiwibWFpbkhlYWRpbmciLCJzY3JlZW4iLCJnZXRCeVJvbGUiLCJsZXZlbCIsInRvQmVJblRoZURvY3VtZW50IiwidG9IYXZlVGV4dENvbnRlbnQiLCJydWxlcyIsImVuYWJsZWQiLCJmb2N1c2FibGVFbGVtZW50cyIsImdldEFsbEJ5Um9sZSIsImZvckVhY2giLCJlbGVtZW50IiwidG9IYXZlQXR0cmlidXRlIiwibWFpbkZlZWQiLCJkYXJrTW9kZUJ1dHRvbiIsImdldEJ5TGFiZWxUZXh0IiwiZmlsdGVyc0J1dHRvbiIsInJlZnJlc2hCdXR0b24iLCJsaXZlUmVnaW9ucyIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsInBvbGl0ZVJlZ2lvbiIsImZpcmVFdmVudCIsImNsaWNrIiwid2FpdEZvciIsImdldEJ5VGV4dCIsImlucHV0cyIsImlucHV0IiwibGFiZWwiLCJnZXRBdHRyaWJ1dGUiLCJmaXJzdEJ1dHRvbiIsImZvY3VzIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwidG9CZSIsImtleURvd24iLCJrZXkiLCJuZXh0QnV0dG9uIiwicXVlcnlCeVRleHQiLCJub3QiLCJtb2RhbCIsImZvY3VzZWRFbGVtZW50IiwiY29udGFpbnMiLCJtYWluIiwiaGVhZGVyIiwibmF2IiwibGlzdHMiLCJsaXN0SXRlbXMiLCJidXR0b25zIiwiYnV0dG9uIiwiaW1hZ2VzIiwiaW1hZ2UiLCJpY29ucyIsImljb24iLCJhbHRUZXh0IiwidG9CZVRydXRoeSIsInJldHJ5QnV0dG9uIiwicHJvZ3Jlc3NJbmRpY2F0b3IiLCJmZWVkIiwidG91Y2hTdGFydCIsInRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsInRvdWNoTW92ZSIsInRvdWNoRW5kIiwiY2hhbmdlZFRvdWNoZXMiLCJtb2NrVmlicmF0ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwibmF2aWdhdG9yIiwidmFsdWUiLCJ3cml0YWJsZSIsImxpa2VCdXR0b24iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiYXJpYUxhYmVsIiwidGV4dEVsZW1lbnRzIiwiZ2V0QWxsQnlUZXh0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQzs7Ozs7OERBRWlCO3dCQUNpQzt5QkFDOUI7eUJBQ21CO29FQUNoQjs0QkFDQzs2QkFDRzs7Ozs7O0FBRTVCLHVCQUF1QjtBQUN2QkEsT0FBT0MsTUFBTSxDQUFDQywyQkFBa0I7QUFFaEMsa0JBQWtCO0FBQ2xCQyxhQUFJLENBQUNDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDQyxVQUFVRixhQUFJLENBQUNHLEVBQUU7SUFDbkIsQ0FBQTtBQUVBSCxhQUFJLENBQUNDLElBQUksQ0FBQyx5Q0FBeUMsSUFBTyxDQUFBO1FBQ3hERyxhQUFhSixhQUFJLENBQUNHLEVBQUU7SUFDdEIsQ0FBQTtBQUVBLE1BQU1FLGVBQWVILG9CQUFRO0FBQzdCLE1BQU1JLGtCQUFrQkYsd0JBQVc7QUFFbkMsd0NBQXdDO0FBQ3hDRyxXQUFXO0lBQ1RGLGFBQWFHLGVBQWUsQ0FBQyxFQUFFO0lBQy9CRixnQkFBZ0JFLGVBQWUsQ0FBQztRQUM5QkMsVUFBVSxFQUFFO1FBQ1pDLGtCQUFrQixFQUFFO1FBQ3BCQyxjQUFjLEVBQUU7UUFDaEJDLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxzQkFBc0JkLGFBQUksQ0FBQ0csRUFBRTtRQUM3QlksZ0JBQWdCZixhQUFJLENBQUNHLEVBQUU7UUFDdkJhLGVBQWVoQixhQUFJLENBQUNHLEVBQUU7UUFDdEJjLGlCQUFpQmpCLGFBQUksQ0FBQ0csRUFBRTtRQUN4QmUscUJBQXFCbEIsYUFBSSxDQUFDRyxFQUFFO1FBQzVCZ0IsU0FBU25CLGFBQUksQ0FBQ0csRUFB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