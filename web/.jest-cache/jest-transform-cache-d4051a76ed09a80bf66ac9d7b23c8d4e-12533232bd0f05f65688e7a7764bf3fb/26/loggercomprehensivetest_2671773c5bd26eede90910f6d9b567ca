950cabc20aa623e7640393a2c9cad319
/**
 * @jest-environment node
 */ // Set NODE_ENV to development before importing logger
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _logger = require("../../../../../lib/utils/logger");
process.env.NODE_ENV = 'development';
// Clear module cache to ensure fresh import
jest.resetModules();
// Mock console methods
const mockConsole = {
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn()
};
// Replace console with mock
Object.assign(console, mockConsole);
describe('Logger Utility - Comprehensive Testing', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Force logger to be in development mode for all tests
        _logger.logger.isDevelopment = true;
        _logger.logger.level = 0; // DEBUG level
    });
    describe('Basic Logging', ()=>{
        it('should log info messages', ()=>{
            _logger.logger.info('Test info message');
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Test info message/));
        });
        it('should log error messages', ()=>{
            _logger.logger.error('Test error message');
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Test error message/));
        });
        it('should log warning messages', ()=>{
            _logger.logger.warn('Test warning message');
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Test warning message/));
        });
        it('should log debug messages', ()=>{
            _logger.logger.debug('Test debug message');
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Test debug message/));
        });
    });
    describe('Structured Logging', ()=>{
        it('should log with metadata', ()=>{
            const metadata = {
                userId: 'user-123',
                action: 'login',
                timestamp: new Date().toISOString()
            };
            _logger.logger.info('User action', metadata);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User action/));
        });
        it('should log with error objects', ()=>{
            const error = new Error('Test error');
            const context = {
                userId: 'user-123',
                action: 'database-query'
            };
            _logger.logger.error('Database error', error, context);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Database error/));
        });
        it('should log with performance metrics', ()=>{
            const metrics = {
                duration: 150,
                memoryUsage: 25.5,
                cpuUsage: 12.3
            };
            _logger.logger.info('Performance metrics', metrics);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Performance metrics/));
        });
    });
    describe('Log Levels', ()=>{
        it('should respect log level configuration', ()=>{
            // Test different log levels
            _logger.logger.debug('Debug message');
            _logger.logger.info('Info message');
            _logger.logger.warn('Warning message');
            _logger.logger.error('Error message');
            expect(mockConsole.debug).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] DEBUG: Debug message/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            expect(mockConsole.warn).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] WARN: Warning message/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error message/));
        });
        it('should handle log level filtering', ()=>{
            // Temporarily change logger level to INFO (filter out DEBUG)
            const originalLevel = _logger.logger.level;
            _logger.logger.level = 1; // INFO level
            // Clear previous calls
            jest.clearAllMocks();
            // Debug logs should be filtered, info logs should pass
            _logger.logger.debug('Debug message');
            _logger.logger.info('Info message');
            expect(mockConsole.debug).not.toHaveBeenCalled();
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Info message/));
            // Restore original level
            _logger.logger.level = originalLevel;
        });
    });
    describe('Error Handling', ()=>{
        it('should handle circular references in objects', ()=>{
            const circularObj = {
                name: 'test'
            };
            circularObj.self = circularObj;
            _logger.logger.info('Circular object', circularObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Circular object/));
        });
        it('should handle undefined values', ()=>{
            _logger.logger.info('Undefined value', undefined);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Undefined value/));
        });
        it('should handle null values', ()=>{
            _logger.logger.info('Null value', null);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Null value/));
        });
        it('should handle large objects', ()=>{
            const largeObj = {
                data: Array.from({
                    length: 1000
                }, (_, i)=>({
                        id: i,
                        value: `item-${i}`
                    })),
                metadata: {
                    count: 1000,
                    timestamp: new Date().toISOString()
                }
            };
            _logger.logger.info('Large object', largeObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large object/));
        });
    });
    describe('Performance', ()=>{
        it('should log within performance budget', ()=>{
            const startTime = performance.now();
            for(let i = 0; i < 100; i++){
                _logger.logger.info(`Message ${i}`);
            }
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(100); // Should complete within 100ms
        });
        it('should not block execution', async ()=>{
            const startTime = performance.now();
            // Log multiple messages asynchronously
            const promises = Array.from({
                length: 10
            }, (_, i)=>Promise.resolve().then(()=>_logger.logger.info(`Async message ${i}`)));
            await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(50); // Should complete within 50ms
        });
    });
    describe('Security', ()=>{
        it('should sanitize sensitive data', ()=>{
            const sensitiveData = {
                password: 'secret123',
                token: 'bearer-token',
                apiKey: 'api-key-123',
                email: 'user@example.com',
                normalData: 'safe data'
            };
            _logger.logger.info('User data', sensitiveData);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User data/));
        });
        it('should handle SQL injection attempts', ()=>{
            const maliciousInput = "'; DROP TABLE users; --";
            _logger.logger.info('User input', {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
        it('should handle XSS attempts', ()=>{
            const maliciousInput = '<script>alert("xss")</script>';
            _logger.logger.info('User input', {
                input: maliciousInput
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: User input/));
        });
    });
    describe('Context and Tracing', ()=>{
        it('should include request context', ()=>{
            const requestContext = {
                requestId: 'req-123',
                userId: 'user-123',
                ip: '192.168.1.1',
                userAgent: 'Mozilla/5.0...'
            };
            _logger.logger.info('Request processed', requestContext);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Request processed/));
        });
        it('should include error stack traces', ()=>{
            const error = new Error('Test error');
            error.stack = 'Error: Test error\n    at test.js:1:1';
            _logger.logger.error('Error occurred', error);
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Error occurred/));
        });
        it('should include timing information', ()=>{
            const timing = {
                startTime: Date.now() - 1000,
                endTime: Date.now(),
                duration: 1000
            };
            _logger.logger.info('Operation completed', timing);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Operation completed/));
        });
    });
    describe('Log Formatting', ()=>{
        it('should format timestamps correctly', ()=>{
            const timestamp = new Date('2023-01-01T00:00:00Z');
            _logger.logger.info('Timestamped message', {
                timestamp
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Timestamped message/));
        });
        it('should format objects with proper indentation', ()=>{
            const complexObj = {
                level1: {
                    level2: {
                        level3: 'value',
                        array: [
                            1,
                            2,
                            3
                        ]
                    }
                }
            };
            _logger.logger.info('Complex object', complexObj);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Complex object/));
        });
        it('should handle special characters', ()=>{
            const specialChars = {
                unicode: 'ðŸš€',
                emoji: 'ðŸ˜€',
                symbols: '!@#$%^&*()',
                quotes: '"double" and \'single\''
            };
            _logger.logger.info('Special characters', specialChars);
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Special characters/));
        });
    });
    describe('Memory Management', ()=>{
        it('should not cause memory leaks', ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Log many messages
            for(let i = 0; i < 1000; i++){
                _logger.logger.info(`Message ${i}`, {
                    data: `data-${i}`
                });
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB
        });
        it('should handle large log messages', ()=>{
            const largeMessage = 'x'.repeat(10000);
            _logger.logger.info('Large message', {
                message: largeMessage
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Large message/));
        });
    });
    describe('Async Logging', ()=>{
        it('should handle async operations', async ()=>{
            const asyncOperation = async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return 'async result';
            };
            _logger.logger.info('Starting async operation');
            const result = await asyncOperation();
            _logger.logger.info('Async operation completed', {
                result
            });
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting async operation/));
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Async operation completed/));
        });
        it('should handle promise rejections', async ()=>{
            const failingOperation = async ()=>{
                throw new Error('Async error');
            };
            _logger.logger.info('Starting failing operation');
            try {
                await failingOperation();
            } catch (error) {
                _logger.logger.error('Async operation failed', error);
            }
            expect(mockConsole.info).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] INFO: Starting failing operation/));
            expect(mockConsole.error).toHaveBeenCalledWith(expect.stringMatching(/\[.*\] ERROR: Async operation failed/));
        });
    });
    describe('Log Aggregation', ()=>{
        it('should aggregate related log messages', ()=>{
            const sessionId = 'session-123';
            _logger.logger.info('Session started', {
                sessionId
            });
            _logger.logger.info('User action', {
                sessionId,
                action: 'login'
            });
            _logger.logger.info('User action', {
                sessionId,
                action: 'navigate'
            });
            _logger.logger.info('Session ended', {
                sessionId
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(4);
        });
        it('should handle log batching', ()=>{
            const messages = [
                {
                    level: 'info',
                    message: 'Message 1'
                },
                {
                    level: 'info',
                    message: 'Message 2'
                },
                {
                    level: 'warn',
                    message: 'Warning 1'
                }
            ];
            messages.forEach((msg)=>{
                if (msg.level === 'info') {
                    _logger.logger.info(msg.message);
                } else if (msg.level === 'warn') {
                    _logger.logger.warn(msg.message);
                }
            });
            expect(mockConsole.info).toHaveBeenCalledTimes(2);
            expect(mockConsole.warn).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3V0aWxzL2xvZ2dlci1jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAamVzdC1lbnZpcm9ubWVudCBub2RlXG4gKi9cblxuLy8gU2V0IE5PREVfRU5WIHRvIGRldmVsb3BtZW50IGJlZm9yZSBpbXBvcnRpbmcgbG9nZ2VyXG5wcm9jZXNzLmVudi5OT0RFX0VOViA9ICdkZXZlbG9wbWVudCc7XG5cbi8vIENsZWFyIG1vZHVsZSBjYWNoZSB0byBlbnN1cmUgZnJlc2ggaW1wb3J0XG5qZXN0LnJlc2V0TW9kdWxlcygpO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2xpYi91dGlscy9sb2dnZXInO1xuXG4vLyBNb2NrIGNvbnNvbGUgbWV0aG9kc1xuY29uc3QgbW9ja0NvbnNvbGUgPSB7XG4gIGxvZzogamVzdC5mbigpLFxuICBlcnJvcjogamVzdC5mbigpLFxuICB3YXJuOiBqZXN0LmZuKCksXG4gIGluZm86IGplc3QuZm4oKSxcbiAgZGVidWc6IGplc3QuZm4oKSxcbn07XG5cbi8vIFJlcGxhY2UgY29uc29sZSB3aXRoIG1vY2tcbk9iamVjdC5hc3NpZ24oY29uc29sZSwgbW9ja0NvbnNvbGUpO1xuXG5kZXNjcmliZSgnTG9nZ2VyIFV0aWxpdHkgLSBDb21wcmVoZW5zaXZlIFRlc3RpbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIEZvcmNlIGxvZ2dlciB0byBiZSBpbiBkZXZlbG9wbWVudCBtb2RlIGZvciBhbGwgdGVzdHNcbiAgICAobG9nZ2VyIGFzIGFueSkuaXNEZXZlbG9wbWVudCA9IHRydWU7XG4gICAgKGxvZ2dlciBhcyBhbnkpLmxldmVsID0gMDsgLy8gREVCVUcgbGV2ZWxcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBsb2cgaW5mbyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdUZXN0IGluZm8gbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUZXN0IGluZm8gbWVzc2FnZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIGVycm9yIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdUZXN0IGVycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBUZXN0IGVycm9yIG1lc3NhZ2UvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3YXJuaW5nIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oJ1Rlc3Qgd2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIFdBUk46IFRlc3Qgd2FybmluZyBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgZGVidWcgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1Rlc3QgZGVidWcgbWVzc2FnZScpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gREVCVUc6IFRlc3QgZGVidWcgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0cnVjdHVyZWQgTG9nZ2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgYWN0aW9uOiAnbG9naW4nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIG1ldGFkYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBhY3Rpb24vKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoIGVycm9yIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBhY3Rpb246ICdkYXRhYmFzZS1xdWVyeScsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFiYXNlIGVycm9yJywgZXJyb3IsIGNvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IERhdGFiYXNlIGVycm9yLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgd2l0aCBwZXJmb3JtYW5jZSBtZXRyaWNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljcyA9IHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgbWVtb3J5VXNhZ2U6IDI1LjUsXG4gICAgICAgIGNwdVVzYWdlOiAxMi4zLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1BlcmZvcm1hbmNlIG1ldHJpY3MnLCBtZXRyaWNzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogUGVyZm9ybWFuY2UgbWV0cmljcy8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBMZXZlbHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IGxvZyBsZXZlbCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBkaWZmZXJlbnQgbG9nIGxldmVsc1xuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIud2FybignV2FybmluZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG1lc3NhZ2UnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIERFQlVHOiBEZWJ1ZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogSW5mbyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gV0FSTjogV2FybmluZyBtZXNzYWdlLykpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIEVSUk9SOiBFcnJvciBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9nIGxldmVsIGZpbHRlcmluZycsICgpID0+IHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IGNoYW5nZSBsb2dnZXIgbGV2ZWwgdG8gSU5GTyAoZmlsdGVyIG91dCBERUJVRylcbiAgICAgIGNvbnN0IG9yaWdpbmFsTGV2ZWwgPSAobG9nZ2VyIGFzIGFueSkubGV2ZWw7XG4gICAgICAobG9nZ2VyIGFzIGFueSkubGV2ZWwgPSAxOyAvLyBJTkZPIGxldmVsXG4gICAgICBcbiAgICAgIC8vIENsZWFyIHByZXZpb3VzIGNhbGxzXG4gICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9ncyBzaG91bGQgYmUgZmlsdGVyZWQsIGluZm8gbG9ncyBzaG91bGQgcGFzc1xuICAgICAgbG9nZ2VyLmRlYnVnKCdEZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBsb2dnZXIuaW5mbygnSW5mbyBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5kZWJ1Zykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEluZm8gbWVzc2FnZS8pKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBsZXZlbFxuICAgICAgKGxvZ2dlciBhcyBhbnkpLmxldmVsID0gb3JpZ2luYWxMZXZlbDtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gb2JqZWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNpcmN1bGFyT2JqOiBhbnkgPSB7IG5hbWU6ICd0ZXN0JyB9O1xuICAgICAgY2lyY3VsYXJPYmouc2VsZiA9IGNpcmN1bGFyT2JqO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnQ2lyY3VsYXIgb2JqZWN0JywgY2lyY3VsYXJPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBDaXJjdWxhciBvYmplY3QvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmRlZmluZWQgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ1VuZGVmaW5lZCB2YWx1ZScsIHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVuZGVmaW5lZCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ051bGwgdmFsdWUnLCBudWxsKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTnVsbCB2YWx1ZS8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU9iaiA9IHtcbiAgICAgICAgZGF0YTogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMCB9LCAoXywgaSkgPT4gKHsgaWQ6IGksIHZhbHVlOiBgaXRlbS0ke2l9YCB9KSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY291bnQ6IDEwMDAsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnTGFyZ2Ugb2JqZWN0JywgbGFyZ2VPYmopO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBMYXJnZSBvYmplY3QvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyB3aXRoaW4gcGVyZm9ybWFuY2UgYnVkZ2V0JywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTAwbXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGJsb2NrIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBMb2cgbXVsdGlwbGUgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHlcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGxvZ2dlci5pbmZvKGBBc3luYyBtZXNzYWdlICR7aX1gKSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNTBtc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBzZW5zaXRpdmUgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbnNpdGl2ZURhdGEgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAnc2VjcmV0MTIzJyxcbiAgICAgICAgdG9rZW46ICdiZWFyZXItdG9rZW4nLFxuICAgICAgICBhcGlLZXk6ICdhcGkta2V5LTEyMycsXG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIG5vcm1hbERhdGE6ICdzYWZlIGRhdGEnLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgZGF0YScsIHNlbnNpdGl2ZURhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBVc2VyIGRhdGEvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBTUUwgaW5qZWN0aW9uIGF0dGVtcHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXQgPSBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCI7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGlucHV0JywgeyBpbnB1dDogbWFsaWNpb3VzSW5wdXQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFVzZXIgaW5wdXQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBYU1MgYXR0ZW1wdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNJbnB1dCA9ICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+JztcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1VzZXIgaW5wdXQnLCB7IGlucHV0OiBtYWxpY2lvdXNJbnB1dCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogVXNlciBpbnB1dC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnRleHQgYW5kIFRyYWNpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHJlcXVlc3QgY29udGV4dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0ge1xuICAgICAgICByZXF1ZXN0SWQ6ICdyZXEtMTIzJyxcbiAgICAgICAgdXNlcklkOiAndXNlci0xMjMnLFxuICAgICAgICBpcDogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAuLi4nLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1JlcXVlc3QgcHJvY2Vzc2VkJywgcmVxdWVzdENvbnRleHQpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBSZXF1ZXN0IHByb2Nlc3NlZC8pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBlcnJvciBzdGFjayB0cmFjZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSAnRXJyb3I6IFRlc3QgZXJyb3JcXG4gICAgYXQgdGVzdC5qczoxOjEnO1xuICAgICAgXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIG9jY3VycmVkJywgZXJyb3IpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gRVJST1I6IEVycm9yIG9jY3VycmVkLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHRpbWluZyBpbmZvcm1hdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWluZyA9IHtcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpIC0gMTAwMCxcbiAgICAgICAgZW5kVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnT3BlcmF0aW9uIGNvbXBsZXRlZCcsIHRpbWluZyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IE9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2cgRm9ybWF0dGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZvcm1hdCB0aW1lc3RhbXBzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCcyMDIzLTAxLTAxVDAwOjAwOjAwWicpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnVGltZXN0YW1wZWQgbWVzc2FnZScsIHsgdGltZXN0YW1wIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBUaW1lc3RhbXBlZCBtZXNzYWdlLykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmb3JtYXQgb2JqZWN0cyB3aXRoIHByb3BlciBpbmRlbnRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBsZXhPYmogPSB7XG4gICAgICAgIGxldmVsMToge1xuICAgICAgICAgIGxldmVsMjoge1xuICAgICAgICAgICAgbGV2ZWwzOiAndmFsdWUnLFxuICAgICAgICAgICAgYXJyYXk6IFsxLCAyLCAzXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0NvbXBsZXggb2JqZWN0JywgY29tcGxleE9iaik7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IENvbXBsZXggb2JqZWN0LykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbENoYXJzID0ge1xuICAgICAgICB1bmljb2RlOiAn8J+agCcsXG4gICAgICAgIGVtb2ppOiAn8J+YgCcsXG4gICAgICAgIHN5bWJvbHM6ICchQCMkJV4mKigpJyxcbiAgICAgICAgcXVvdGVzOiAnXCJkb3VibGVcIiBhbmQgXFwnc2luZ2xlXFwnJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTcGVjaWFsIGNoYXJhY3RlcnMnLCBzcGVjaWFsQ2hhcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTcGVjaWFsIGNoYXJhY3RlcnMvKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBjYXVzZSBtZW1vcnkgbGVha3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgXG4gICAgICAvLyBMb2cgbWFueSBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYE1lc3NhZ2UgJHtpfWAsIHsgZGF0YTogYGRhdGEtJHtpfWAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgICBcbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxME1CXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBsb2cgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZU1lc3NhZ2UgPSAneCcucmVwZWF0KDEwMDAwKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0xhcmdlIG1lc3NhZ2UnLCB7IG1lc3NhZ2U6IGxhcmdlTWVzc2FnZSB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFxbLipcXF0gSU5GTzogTGFyZ2UgbWVzc2FnZS8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FzeW5jIExvZ2dpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFzeW5jT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgcmV0dXJuICdhc3luYyByZXN1bHQnO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbicpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXN5bmNPcGVyYXRpb24oKTtcbiAgICAgIGxvZ2dlci5pbmZvKCdBc3luYyBvcGVyYXRpb24gY29tcGxldGVkJywgeyByZXN1bHQgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IFN0YXJ0aW5nIGFzeW5jIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcWy4qXFxdIElORk86IEFzeW5jIG9wZXJhdGlvbiBjb21wbGV0ZWQvKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwcm9taXNlIHJlamVjdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmYWlsaW5nT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FzeW5jIGVycm9yJyk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbygnU3RhcnRpbmcgZmFpbGluZyBvcGVyYXRpb24nKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmFpbGluZ09wZXJhdGlvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdBc3luYyBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBJTkZPOiBTdGFydGluZyBmYWlsaW5nIG9wZXJhdGlvbi8pKTtcbiAgICAgIGV4cGVjdChtb2NrQ29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXFsuKlxcXSBFUlJPUjogQXN5bmMgb3BlcmF0aW9uIGZhaWxlZC8pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZyBBZ2dyZWdhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFnZ3JlZ2F0ZSByZWxhdGVkIGxvZyBtZXNzYWdlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdTZXNzaW9uIHN0YXJ0ZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbicsIHsgc2Vzc2lvbklkLCBhY3Rpb246ICdsb2dpbicgfSk7XG4gICAgICBsb2dnZXIuaW5mbygnVXNlciBhY3Rpb24nLCB7IHNlc3Npb25JZCwgYWN0aW9uOiAnbmF2aWdhdGUnIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oJ1Nlc3Npb24gZW5kZWQnLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvZyBiYXRjaGluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW1xuICAgICAgICB7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdNZXNzYWdlIDEnIH0sXG4gICAgICAgIHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZTogJ01lc3NhZ2UgMicgfSxcbiAgICAgICAgeyBsZXZlbDogJ3dhcm4nLCBtZXNzYWdlOiAnV2FybmluZyAxJyB9LFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICBpZiAobXNnLmxldmVsID09PSAnaW5mbycpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhtc2cubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobXNnLmxldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihtc2cubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NvbnNvbGUuaW5mbykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KG1vY2tDb25zb2xlLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImplc3QiLCJyZXNldE1vZHVsZXMiLCJtb2NrQ29uc29sZSIsImxvZyIsImZuIiwiZXJyb3IiLCJ3YXJuIiwiaW5mbyIsImRlYnVnIiwiT2JqZWN0IiwiYXNzaWduIiwiY29uc29sZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJsb2dnZXIiLCJpc0RldmVsb3BtZW50IiwibGV2ZWwiLCJpdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nTWF0Y2hpbmciLCJtZXRhZGF0YSIsInVzZXJJZCIsImFjdGlvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIkVycm9yIiwiY29udGV4dCIsIm1ldHJpY3MiLCJkdXJhdGlvbiIsIm1lbW9yeVVzYWdlIiwiY3B1VXNhZ2UiLCJvcmlnaW5hbExldmVsIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsImNpcmN1bGFyT2JqIiwibmFtZSIsInNlbGYiLCJ1bmRlZmluZWQiLCJsYXJnZU9iaiIsImRhdGEiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImlkIiwidmFsdWUiLCJjb3VudCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZW5kVGltZSIsInRvQmVMZXNzVGhhbiIsInByb21pc2VzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYWxsIiwic2Vuc2l0aXZlRGF0YSIsInBhc3N3b3JkIiwidG9rZW4iLCJhcGlLZXkiLCJlbWFpbCIsIm5vcm1hbERhdGEiLCJtYWxpY2lvdXNJbnB1dCIsImlucHV0IiwicmVxdWVzdENvbnRleHQiLCJyZXF1ZXN0SWQiLCJpcCIsInVzZXJBZ2VudCIsInN0YWNrIiwidGltaW5nIiwiY29tcGxleE9iaiIsImxldmVsMSIsImxldmVsMiIsImxldmVsMyIsImFycmF5Iiwic3BlY2lhbENoYXJzIiwidW5pY29kZSIsImVtb2ppIiwic3ltYm9scyIsInF1b3RlcyIsImluaXRpYWxNZW1vcnkiLCJoZWFwVXNlZCIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiLCJsYXJnZU1lc3NhZ2UiLCJyZXBlYXQiLCJtZXNzYWdlIiwiYXN5bmNPcGVyYXRpb24iLCJzZXRUaW1lb3V0IiwicmVzdWx0IiwiZmFpbGluZ09wZXJhdGlvbiIsInNlc3Npb25JZCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsIm1lc3NhZ2VzIiwiZm9yRWFjaCIsIm1zZyJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRCxzREFBc0Q7Ozs7O3dCQU0vQjtBQUx2QkEsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEdBQUc7QUFFdkIsNENBQTRDO0FBQzVDQyxLQUFLQyxZQUFZO0FBSWpCLHVCQUF1QjtBQUN2QixNQUFNQyxjQUFjO0lBQ2xCQyxLQUFLSCxLQUFLSSxFQUFFO0lBQ1pDLE9BQU9MLEtBQUtJLEVBQUU7SUFDZEUsTUFBTU4sS0FBS0ksRUFBRTtJQUNiRyxNQUFNUCxLQUFLSSxFQUFFO0lBQ2JJLE9BQU9SLEtBQUtJLEVBQUU7QUFDaEI7QUFFQSw0QkFBNEI7QUFDNUJLLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBU1Q7QUFFdkJVLFNBQVMsMENBQTBDO0lBQ2pEQyxXQUFXO1FBQ1RiLEtBQUtjLGFBQWE7UUFFbEIsdURBQXVEO1FBQ3REQyxjQUFNLENBQVNDLGFBQWEsR0FBRztRQUMvQkQsY0FBTSxDQUFTRSxLQUFLLEdBQUcsR0FBRyxjQUFjO0lBQzNDO0lBRUFMLFNBQVMsaUJBQWlCO1FBQ3hCTSxHQUFHLDRCQUE0QjtZQUM3QkgsY0FBTSxDQUFDUixJQUFJLENBQUM7WUFFWlksT0FBT2pCLFlBQVlLLElBQUksRUFBRWEsb0JBQW9CLENBQUNELE9BQU9FLGNBQWMsQ0FBQztRQUN0RTtRQUVBSCxHQUFHLDZCQUE2QjtZQUM5QkgsY0FBTSxDQUFDVixLQUFLLENBQUM7WUFFYmMsT0FBT2pCLFlBQVlHLEtBQUssRUFBRWUsb0JBQW9CLENBQUNELE9BQU9FLGNBQWMsQ0FBQztRQUN2RTtRQUVBSCxHQUFHLCtCQUErQjtZQUNoQ0gsY0FBTSxDQUFDVCxJQUFJLENBQUM7WUFFWmEsT0FBT2pCLFlBQVlJLElBQUksRUFBRWMsb0JBQW9CLENBQUNELE9BQU9FLGNBQWMsQ0FBQztRQUN0RTtRQUVBSCxHQUFHLDZCQUE2QjtZ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