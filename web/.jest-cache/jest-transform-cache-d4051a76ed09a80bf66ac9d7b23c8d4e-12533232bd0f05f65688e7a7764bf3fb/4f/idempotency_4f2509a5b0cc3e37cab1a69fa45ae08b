37329c46c128e665f88b2ef9b60d0ac0
/**
 * Idempotency Management System
 * Prevents double-submission attacks and ensures data consistency
 * 
 * Features:
 * - UUID-based idempotency keys
 * - Redis-based storage for distributed systems
 * - Automatic cleanup of expired keys
 * - Proper error handling and logging
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get checkIdempotencyKey () {
        return checkIdempotencyKey;
    },
    get cleanupExpiredIdempotencyKeys () {
        return cleanupExpiredIdempotencyKeys;
    },
    get createIdempotencyKey () {
        return createIdempotencyKey;
    },
    get generateIdempotencyKey () {
        return generateIdempotencyKey;
    },
    get getIdempotencyStats () {
        return getIdempotencyStats;
    },
    get storeIdempotencyKey () {
        return storeIdempotencyKey;
    },
    get validateIdempotencyKey () {
        return validateIdempotencyKey;
    },
    get withIdempotency () {
        return withIdempotency;
    }
});
const _logger = require("../../utils/logger");
const _server = require("../../../utils/supabase/server");
const DEFAULT_OPTIONS = {
    ttl: 60 * 60 * 24,
    namespace: 'default'
};
// Initialize Supabase client for idempotency storage
let supabase = null;
const getSupabase = async ()=>{
    if (!supabase) {
        supabase = await (0, _server.getSupabaseServerClient)();
    }
    return supabase;
};
function generateIdempotencyKey() {
    return `idem_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}
function createIdempotencyKey(key, namespace = DEFAULT_OPTIONS.namespace) {
    return `${namespace}:${key}`;
}
async function checkIdempotencyKey(key, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                exists: false,
                error: 'Failed to initialize Supabase client'
            };
        }
        const { data, error } = await supabaseClient.from('idempotency_keys').select('*').eq('key', fullKey).gt('expires_at', new Date().toISOString()).single();
        if (error && error.code !== 'PGRST116') {
            _logger.logger.error('Idempotency key check failed', error, {
                key: fullKey
            });
            return {
                exists: false,
                error: 'Database error'
            };
        }
        return {
            exists: !!data,
            data: data?.result_data
        };
    } catch (error) {
        _logger.logger.error('Idempotency key check exception', error instanceof Error ? error : new Error('Unknown error'), {
            key: fullKey
        });
        return {
            exists: false,
            error: 'System error'
        };
    }
}
async function storeIdempotencyKey(key, resultData, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    const fullKey = createIdempotencyKey(key, opts.namespace);
    const expiresAt = new Date(Date.now() + opts.ttl * 1000).toISOString();
    try {
        const supabaseClient = await getSupabase();
        if (!supabaseClient) {
            return {
                success: false,
                error: 'Failed to initialize Supabase client'
            };
        }
        const { error } = await supabaseClient.from('idempotency_keys').insert({
            key: fullKey,
            result_data: resultData,
            expires_at: expiresAt,
            created_at: new Date().toISOString()
        });
        if (error) {
            _logger.logger.error('Failed to store idempotency key', error, {
                key: fullKey
            });
            return {
                success: false,
                error: 'Storage failed'
            };
        }
        _logger.logger.info('Idempotency key stored', {
            key: fullKey,
            expiresAt
        });
        return {
            success: true
        };
    } catch (error) {
        _logger.logger.error('Idempotency key storage exception', error instanceof Error ? error : new Error('Unknown error'), {
            key: fullKey
        });
        return {
            success: false,
            error: 'System error'
        };
    }
}
async function withIdempotency(key, operation, options = {}) {
    const opts = Object.assign({}, DEFAULT_OPTIONS, options);
    // Check if key already exists
    const checkResult = await checkIdempotencyKey(key, opts);
    if (checkResult.error) {
        return {
            success: false,
            error: checkResult.error,
            isDuplicate: false
        };
    }
    if (checkResult.exists) {
        _logger.logger.info('Idempotency key found, returning cached result', {
            key
        });
        return {
            success: true,
            isDuplicate: true,
            data: checkResult.data
        };
    }
    // Execute operation
    try {
        const result = await operation();
        // Store result for future requests
        const storeResult = await storeIdempotencyKey(key, result, opts);
        if (!storeResult.success) {
            _logger.logger.warn('Failed to store idempotency result, but operation succeeded', {
                key,
                error: storeResult.error
            });
        }
        return {
            success: true,
            data: result,
            isDuplicate: false
        };
    } catch (error) {
        _logger.logger.error('Operation failed during idempotency execution', error instanceof Error ? error : new Error('Unknown error'), {
            key
        });
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Operation failed',
            isDuplicate: false
        };
    }
}
async function cleanupExpiredIdempotencyKeys() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                deleted: 0,
                error: 'Failed to initialize Supabase client'
            };
        }
        const { count, error } = await client.from('idempotency_keys').delete().lt('expires_at', new Date().toISOString()).select('*');
        if (error) {
            _logger.logger.error('Failed to cleanup expired idempotency keys', error);
            return {
                deleted: 0,
                error: 'Cleanup failed'
            };
        }
        _logger.logger.info('Cleaned up expired idempotency keys', {
            deleted: count || 0
        });
        return {
            deleted: count || 0
        };
    } catch (error) {
        _logger.logger.error('Idempotency cleanup exception', error instanceof Error ? error : new Error('Unknown error'));
        return {
            deleted: 0,
            error: 'System error'
        };
    }
}
function validateIdempotencyKey(key) {
    // Basic validation - should be a valid UUID or our custom format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const customRegex = /^idem_\d+_[a-z0-9]+$/i;
    return uuidRegex.test(key) || customRegex.test(key);
}
async function getIdempotencyStats() {
    try {
        const client = await getSupabase();
        if (!client) {
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: 'Failed to initialize Supabase client'
            };
        }
        const now = new Date().toISOString();
        const { count: total, error: totalError } = await client.from('idempotency_keys').select('*', {
            count: 'exact',
            head: true
        });
        if (totalError) {
            _logger.logger.error('Failed to get total idempotency keys', totalError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: 'Query failed'
            };
        }
        const { count: expired, error: expiredError } = await client.from('idempotency_keys').select('*', {
            count: 'exact',
            head: true
        }).lt('expires_at', now);
        if (expiredError) {
            _logger.logger.error('Failed to get expired idempotency keys', expiredError);
            return {
                total: 0,
                expired: 0,
                active: 0,
                error: 'Query failed'
            };
        }
        const active = (total || 0) - (expired || 0);
        return {
            total: total || 0,
            expired: expired || 0,
            active: Math.max(0, active)
        };
    } catch (error) {
        _logger.logger.error('Idempotency stats exception', error instanceof Error ? error : new Error('Unknown error'));
        return {
            total: 0,
            expired: 0,
            active: 0,
            error: 'System error'
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9saWIvY29yZS9hdXRoL2lkZW1wb3RlbmN5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSWRlbXBvdGVuY3kgTWFuYWdlbWVudCBTeXN0ZW1cbiAqIFByZXZlbnRzIGRvdWJsZS1zdWJtaXNzaW9uIGF0dGFja3MgYW5kIGVuc3VyZXMgZGF0YSBjb25zaXN0ZW5jeVxuICogXG4gKiBGZWF0dXJlczpcbiAqIC0gVVVJRC1iYXNlZCBpZGVtcG90ZW5jeSBrZXlzXG4gKiAtIFJlZGlzLWJhc2VkIHN0b3JhZ2UgZm9yIGRpc3RyaWJ1dGVkIHN5c3RlbXNcbiAqIC0gQXV0b21hdGljIGNsZWFudXAgb2YgZXhwaXJlZCBrZXlzXG4gKiAtIFByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZ1xuICovXG5cbmltcG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvbGliL3V0aWxzL2xvZ2dlcidcbmltcG9ydCB7IGdldFN1cGFiYXNlU2VydmVyQ2xpZW50IH0gZnJvbSAnQC91dGlscy9zdXBhYmFzZS9zZXJ2ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbXBvdGVuY3lSZXN1bHQ8VD4ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGRhdGE/OiBUXG4gIGVycm9yPzogc3RyaW5nXG4gIGlzRHVwbGljYXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbXBvdGVuY3lPcHRpb25zIHtcbiAgdHRsPzogbnVtYmVyIC8vIFRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzXG4gIG5hbWVzcGFjZT86IHN0cmluZyAvLyBOYW1lc3BhY2UgZm9yIGtleSBpc29sYXRpb25cbn1cblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBSZXF1aXJlZDxJZGVtcG90ZW5jeU9wdGlvbnM+ID0ge1xuICB0dGw6IDYwICogNjAgKiAyNCwgLy8gMjQgaG91cnNcbiAgbmFtZXNwYWNlOiAnZGVmYXVsdCdcbn1cblxuLy8gSW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQgZm9yIGlkZW1wb3RlbmN5IHN0b3JhZ2VcbmxldCBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQgfCBudWxsID0gbnVsbFxuXG5jb25zdCBnZXRTdXBhYmFzZSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFzdXBhYmFzZSkge1xuICAgIHN1cGFiYXNlID0gYXdhaXQgZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuICB9XG4gIHJldHVybiBzdXBhYmFzZVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW1wb3RlbmN5IGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZGVtcG90ZW5jeUtleSgpOiBzdHJpbmcge1xuICByZXR1cm4gYGlkZW1fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSl9YFxufVxuXG4vKipcbiAqIENyZWF0ZSBpZGVtcG90ZW5jeSBrZXkgd2l0aCBuYW1lc3BhY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlkZW1wb3RlbmN5S2V5KGtleTogc3RyaW5nLCBuYW1lc3BhY2U6IHN0cmluZyA9IERFRkFVTFRfT1BUSU9OUy5uYW1lc3BhY2UpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7bmFtZXNwYWNlfToke2tleX1gXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgaWRlbXBvdGVuY3kga2V5IGV4aXN0cyBhbmQgaXMgdmFsaWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrSWRlbXBvdGVuY3lLZXk8VCA9IHVua25vd24+KFxuICBrZXk6IHN0cmluZywgXG4gIG9wdGlvbnM6IElkZW1wb3RlbmN5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHsgZXhpc3RzOiBib29sZWFuOyBkYXRhPzogVDsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuICBjb25zdCBmdWxsS2V5ID0gY3JlYXRlSWRlbXBvdGVuY3lLZXkoa2V5LCBvcHRzLm5hbWVzcGFjZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlQ2xpZW50ID0gYXdhaXQgZ2V0U3VwYWJhc2UoKVxuICAgIGlmICghc3VwYWJhc2VDbGllbnQpIHtcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQ2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgna2V5JywgZnVsbEtleSlcbiAgICAgIC5ndCgnZXhwaXJlc19hdCcsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHsgLy8gUEdSU1QxMTYgPSBubyByb3dzIHJldHVybmVkXG4gICAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IGtleSBjaGVjayBmYWlsZWQnLCBlcnJvciwgeyBrZXk6IGZ1bGxLZXkgfSlcbiAgICAgIHJldHVybiB7IGV4aXN0czogZmFsc2UsIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpc3RzOiAhIWRhdGEsXG4gICAgICBkYXRhOiBkYXRhPy5yZXN1bHRfZGF0YVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IGtleSBjaGVjayBleGNlcHRpb24nLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKSwgeyBrZXk6IGZ1bGxLZXkgfSlcbiAgICByZXR1cm4geyBleGlzdHM6IGZhbHNlLCBlcnJvcjogJ1N5c3RlbSBlcnJvcicgfVxuICB9XG59XG5cbi8qKlxuICogU3RvcmUgaWRlbXBvdGVuY3kga2V5IHdpdGggcmVzdWx0IGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0b3JlSWRlbXBvdGVuY3lLZXk8VCA9IHVua25vd24+KFxuICBrZXk6IHN0cmluZyxcbiAgcmVzdWx0RGF0YTogVCxcbiAgb3B0aW9uczogSWRlbXBvdGVuY3lPcHRpb25zID0ge31cbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpXG4gIGNvbnN0IGZ1bGxLZXkgPSBjcmVhdGVJZGVtcG90ZW5jeUtleShrZXksIG9wdHMubmFtZXNwYWNlKVxuICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0cy50dGwgKiAxMDAwKS50b0lTT1N0cmluZygpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZUNsaWVudCA9IGF3YWl0IGdldFN1cGFiYXNlKClcbiAgICBpZiAoIXN1cGFiYXNlQ2xpZW50KSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQnIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VDbGllbnRcbiAgICAgIC5mcm9tKCdpZGVtcG90ZW5jeV9rZXlzJylcbiAgICAgIC5pbnNlcnQoe1xuICAgICAgICBrZXk6IGZ1bGxLZXksXG4gICAgICAgIHJlc3VsdF9kYXRhOiByZXN1bHREYXRhLFxuICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgaWRlbXBvdGVuY3kga2V5JywgZXJyb3IsIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTdG9yYWdlIGZhaWxlZCcgfVxuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvKCdJZGVtcG90ZW5jeSBrZXkgc3RvcmVkJywgeyBrZXk6IGZ1bGxLZXksIGV4cGlyZXNBdCB9KVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcignSWRlbXBvdGVuY3kga2V5IHN0b3JhZ2UgZXhjZXB0aW9uJywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyksIHsga2V5OiBmdWxsS2V5IH0pXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGZ1bmN0aW9uIHdpdGggaWRlbXBvdGVuY3kgcHJvdGVjdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aElkZW1wb3RlbmN5PFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBvcHRpb25zOiBJZGVtcG90ZW5jeU9wdGlvbnMgPSB7fVxuKTogUHJvbWlzZTxJZGVtcG90ZW5jeVJlc3VsdDxUPj4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuXG4gIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuICBjb25zdCBjaGVja1Jlc3VsdCA9IGF3YWl0IGNoZWNrSWRlbXBvdGVuY3lLZXk8VD4oa2V5LCBvcHRzKVxuICBcbiAgaWYgKGNoZWNrUmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGNoZWNrUmVzdWx0LmVycm9yLFxuICAgICAgaXNEdXBsaWNhdGU6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrUmVzdWx0LmV4aXN0cykge1xuICAgIGxvZ2dlci5pbmZvKCdJZGVtcG90ZW5jeSBrZXkgZm91bmQsIHJldHVybmluZyBjYWNoZWQgcmVzdWx0JywgeyBrZXkgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGlzRHVwbGljYXRlOiB0cnVlLFxuICAgICAgZGF0YTogY2hlY2tSZXN1bHQuZGF0YVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4ZWN1dGUgb3BlcmF0aW9uXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKClcbiAgICBcbiAgICAvLyBTdG9yZSByZXN1bHQgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgIGNvbnN0IHN0b3JlUmVzdWx0ID0gYXdhaXQgc3RvcmVJZGVtcG90ZW5jeUtleShrZXksIHJlc3VsdCwgb3B0cylcbiAgICBcbiAgICBpZiAoIXN0b3JlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdGYWlsZWQgdG8gc3RvcmUgaWRlbXBvdGVuY3kgcmVzdWx0LCBidXQgb3BlcmF0aW9uIHN1Y2NlZWRlZCcsIHsgXG4gICAgICAgIGtleSwgXG4gICAgICAgIGVycm9yOiBzdG9yZVJlc3VsdC5lcnJvciBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiByZXN1bHQsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdPcGVyYXRpb24gZmFpbGVkIGR1cmluZyBpZGVtcG90ZW5jeSBleGVjdXRpb24nLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKSwgeyBrZXkgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnT3BlcmF0aW9uIGZhaWxlZCcsXG4gICAgICBpc0R1cGxpY2F0ZTogZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhbiB1cCBleHBpcmVkIGlkZW1wb3RlbmN5IGtleXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkSWRlbXBvdGVuY3lLZXlzKCk6IFByb21pc2U8eyBkZWxldGVkOiBudW1iZXI7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgIC5mcm9tKCdpZGVtcG90ZW5jeV9rZXlzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmx0KCdleHBpcmVzX2F0JywgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgLnNlbGVjdCgnKicpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNsZWFudXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgZXJyb3IpXG4gICAgICByZXR1cm4geyBkZWxldGVkOiAwLCBlcnJvcjogJ0NsZWFudXAgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8oJ0NsZWFuZWQgdXAgZXhwaXJlZCBpZGVtcG90ZW5jeSBrZXlzJywgeyBkZWxldGVkOiBjb3VudCB8fCAwIH0pXG4gICAgcmV0dXJuIHsgZGVsZXRlZDogY291bnQgfHwgMCB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdJZGVtcG90ZW5jeSBjbGVhbnVwIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IGRlbGV0ZWQ6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBpZGVtcG90ZW5jeSBrZXkgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlkZW1wb3RlbmN5S2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBzaG91bGQgYmUgYSB2YWxpZCBVVUlEIG9yIG91ciBjdXN0b20gZm9ybWF0XG4gIGNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2lcbiAgY29uc3QgY3VzdG9tUmVnZXggPSAvXmlkZW1fXFxkK19bYS16MC05XSskL2lcbiAgXG4gIHJldHVybiB1dWlkUmVnZXgudGVzdChrZXkpIHx8IGN1c3RvbVJlZ2V4LnRlc3Qoa2V5KVxufVxuXG4vKipcbiAqIEdldCBpZGVtcG90ZW5jeSBrZXkgc3RhdGlzdGljc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWRlbXBvdGVuY3lTdGF0cygpOiBQcm9taXNlPHtcbiAgdG90YWw6IG51bWJlclxuICBleHBpcmVkOiBudW1iZXJcbiAgYWN0aXZlOiBudW1iZXJcbiAgZXJyb3I/OiBzdHJpbmdcbn0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRTdXBhYmFzZSgpXG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50JyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIFxuICAgIGNvbnN0IHsgY291bnQ6IHRvdGFsLCBlcnJvcjogdG90YWxFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXG4gICAgaWYgKHRvdGFsRXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCB0b3RhbCBpZGVtcG90ZW5jeSBrZXlzJywgdG90YWxFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb3VudDogZXhwaXJlZCwgZXJyb3I6IGV4cGlyZWRFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnaWRlbXBvdGVuY3lfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgLmx0KCdleHBpcmVzX2F0Jywgbm93KVxuXG4gICAgaWYgKGV4cGlyZWRFcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGV4cGlyZWQgaWRlbXBvdGVuY3kga2V5cycsIGV4cGlyZWRFcnJvcilcbiAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnUXVlcnkgZmFpbGVkJyB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlID0gKHRvdGFsIHx8IDApIC0gKGV4cGlyZWQgfHwgMClcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbDogdG90YWwgfHwgMCxcbiAgICAgIGV4cGlyZWQ6IGV4cGlyZWQgfHwgMCxcbiAgICAgIGFjdGl2ZTogTWF0aC5tYXgoMCwgYWN0aXZlKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0lkZW1wb3RlbmN5IHN0YXRzIGV4Y2VwdGlvbicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpKVxuICAgIHJldHVybiB7IHRvdGFsOiAwLCBleHBpcmVkOiAwLCBhY3RpdmU6IDAsIGVycm9yOiAnU3lzdGVtIGVycm9yJyB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjaGVja0lkZW1wb3RlbmN5S2V5IiwiY2xlYW51cEV4cGlyZWRJZGVtcG90ZW5jeUtleXMiLCJjcmVhdGVJZGVtcG90ZW5jeUtleSIsImdlbmVyYXRlSWRlbXBvdGVuY3lLZXkiLCJnZXRJZGVtcG90ZW5jeVN0YXRzIiwic3RvcmVJZGVtcG90ZW5jeUtleSIsInZhbGlkYXRlSWRlbXBvdGVuY3lLZXkiLCJ3aXRoSWRlbXBvdGVuY3kiLCJERUZBVUxUX09QVElPTlMiLCJ0dGwiLCJuYW1lc3BhY2UiLCJzdXBhYmFzZSIsImdldFN1cGFiYXNlIiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwia2V5Iiwib3B0aW9ucyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJmdWxsS2V5Iiwic3VwYWJhc2VDbGllbnQiLCJleGlzdHMiLCJlcnJvciIsImRhdGEiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJndCIsInRvSVNPU3RyaW5nIiwic2luZ2xlIiwiY29kZSIsImxvZ2dlciIsInJlc3VsdF9kYXRhIiwiRXJyb3IiLCJyZXN1bHREYXRhIiwiZXhwaXJlc0F0Iiwic3VjY2VzcyIsImluc2VydCIsImV4cGlyZXNfYXQiLCJjcmVhdGVkX2F0IiwiaW5mbyIsIm9wZXJhdGlvbiIsImNoZWNrUmVzdWx0IiwiaXNEdXBsaWNhdGUiLCJyZXN1bHQiLCJzdG9yZVJlc3VsdCIsIndhcm4iLCJtZXNzYWdlIiwiY2xpZW50IiwiZGVsZXRlZCIsImNvdW50IiwiZGVsZXRlIiwibHQiLCJ1dWlkUmVnZXgiLCJjdXN0b21SZWdleCIsInRlc3QiLCJ0b3RhbCIsImV4cGlyZWQiLCJhY3RpdmUiLCJ0b3RhbEVycm9yIiwiaGVhZCIsImV4cGlyZWRFcnJvciIsIm1heCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDOzs7Ozs7Ozs7OztRQW1EcUJBO2VBQUFBOztRQXlJQUM7ZUFBQUE7O1FBaEpOQztlQUFBQTs7UUFQQUM7ZUFBQUE7O1FBK0xNQztlQUFBQTs7UUEzSUFDO2VBQUFBOztRQWdJTkM7ZUFBQUE7O1FBeEZNQztlQUFBQTs7O3dCQTdIQzt3QkFDaUI7QUFjeEMsTUFBTUMsa0JBQWdEO0lBQ3BEQyxLQUFLLEtBQUssS0FBSztJQUNmQyxXQUFXO0FBQ2I7QUFFQSxxREFBcUQ7QUFDckQsSUFBSUMsV0FBa0M7QUFFdEMsTUFBTUMsY0FBYztJQUNsQixJQUFJLENBQUNELFVBQVU7UUFDYkEsV0FBVyxNQUFNRSxJQUFBQSwrQkFBdUI7SUFDMUM7SUFDQSxPQUFPRjtBQUNUO0FBS08sU0FBU1I7SUFDZCxPQUFPLENBQUMsS0FBSyxFQUFFVyxLQUFLQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxLQUFLO0FBQzVFO0FBS08sU0FBU2pCLHFCQUFxQmtCLEdBQVcsRUFBRVYsWUFBb0JGLGdCQUFnQkUsU0FBUztJQUM3RixPQUFPLEdBQUdBLFVBQVUsQ0FBQyxFQUFFVSxLQUFLO0FBQzlCO0FBS08sZUFBZXBCLG9CQUNwQm9CLEdBQVcsRUFDWEMsVUFBOEIsQ0FB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