40eefc94c7d3e5739f5c90ae8265e28a
/**
 * UnifiedFeed Accessibility Tests
 * 
 * Comprehensive accessibility testing for the UnifiedFeed component
 * Tests WCAG 2.1 AA compliance and screen reader support
 * 
 * Created: January 19, 2025
 * Status: âœ… PRODUCTION READY
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _jestaxe = require("jest-axe");
const _UnifiedFeed = require("../../../../../features/feeds/components/UnifiedFeed");
const _feedsStore = require("../../../../../lib/stores/feedsStore");
const _useHashtags = require("../../../../../features/hashtags/hooks/useHashtags");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Extend Jest matchers
expect.extend(_jestaxe.toHaveNoViolations);
// Mock the stores
_globals.jest.mock('@/lib/stores/feedsStore', ()=>({
        useFeeds: _globals.jest.fn()
    }));
_globals.jest.mock('@/features/hashtags/hooks/useHashtags', ()=>({
        useHashtags: _globals.jest.fn()
    }));
const mockUseFeeds = _feedsStore.useFeeds;
const mockUseHashtags = _useHashtags.useHashtags;
// Mock data
const mockFeedData = [
    {
        id: '1',
        type: 'poll',
        title: 'Test Poll',
        description: 'This is a test poll',
        hashtags: [
            'politics',
            'election'
        ],
        created_at: '2025-01-19T10:00:00Z',
        author: 'Test User',
        engagement: {
            likes: 10,
            shares: 5,
            comments: 3
        }
    },
    {
        id: '2',
        type: 'post',
        title: 'Test Post',
        description: 'This is a test post',
        hashtags: [
            'news',
            'update'
        ],
        created_at: '2025-01-19T09:00:00Z',
        author: 'Test User 2',
        engagement: {
            likes: 15,
            shares: 8,
            comments: 12
        }
    }
];
const mockHashtagData = [
    {
        id: '1',
        name: 'politics',
        display_name: 'Politics',
        usage_count: 100,
        follower_count: 50,
        is_trending: true,
        trend_score: 0.8,
        created_at: '2025-01-19T10:00:00Z',
        updated_at: '2025-01-19T10:00:00Z',
        is_verified: false,
        is_featured: false
    }
];
describe('UnifiedFeed Accessibility Tests', ()=>{
    beforeEach(()=>{
        // Mock store implementations
        mockUseFeeds.mockReturnValue({
            feeds: mockFeedData,
            loading: false,
            error: null,
            refreshFeeds: _globals.jest.fn(),
            likeFeed: _globals.jest.fn(),
            shareFeed: _globals.jest.fn(),
            commentFeed: _globals.jest.fn(),
            bookmarkFeed: _globals.jest.fn()
        });
        mockUseHashtags.mockReturnValue({
            hashtags: mockHashtagData,
            loading: false,
            error: null,
            searchHashtags: _globals.jest.fn(),
            followHashtag: _globals.jest.fn(),
            unfollowHashtag: _globals.jest.fn(),
            getTrendingHashtags: _globals.jest.fn()
        });
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('WCAG 2.1 AA Compliance', ()=>{
        test('should have no accessibility violations', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const results = await (0, _jestaxe.axe)(container);
            expect(results).toHaveNoViolations();
        });
        test('should have proper heading structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for main heading
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toBeInTheDocument();
            expect(mainHeading).toHaveTextContent('Unified Feed');
        });
        test('should have proper color contrast', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const results = await (0, _jestaxe.axe)(container, {
                rules: {
                    'color-contrast': {
                        enabled: true
                    }
                }
            });
            expect(results).toHaveNoViolations();
        });
        test('should have proper focus management', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that focusable elements are properly marked
            const focusableElements = _react1.screen.getAllByRole('button');
            focusableElements.forEach((element)=>{
                expect(element).toHaveAttribute('tabIndex');
            });
        });
    });
    describe('Screen Reader Support', ()=>{
        test('should have proper ARIA labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check main feed role and label
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toHaveAttribute('aria-label', 'Unified Feed');
            // Check button labels
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            expect(darkModeButton).toBeInTheDocument();
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(filtersButton).toBeInTheDocument();
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            expect(refreshButton).toBeInTheDocument();
        });
        test('should have proper ARIA live regions', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for live regions
            const liveRegions = _react1.screen.getAllByRole('status');
            expect(liveRegions.length).toBeGreaterThan(0);
            // Check for polite announcements
            const politeRegion = _react1.screen.getByRole('status', {
                name: /feed/i
            });
            expect(politeRegion).toBeInTheDocument();
        });
        test('should announce state changes', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Trigger a state change
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Check for announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/switched to dark mode/i)).toBeInTheDocument();
            });
        });
        test('should have proper form labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for form elements with proper labels
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                const label = _react1.screen.getByLabelText(input.getAttribute('aria-label') || '');
                expect(label).toBeInTheDocument();
            });
        });
    });
    describe('Keyboard Navigation', ()=>{
        test('should support tab navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Start with first focusable element
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            expect(document.activeElement).toBe(firstButton);
            // Tab to next element
            _react1.fireEvent.keyDown(firstButton, {
                key: 'Tab'
            });
            const nextButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(document.activeElement).toBe(nextButton);
        });
        test('should support enter key activation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            darkModeButton.focus();
            // Press Enter
            _react1.fireEvent.keyDown(darkModeButton, {
                key: 'Enter'
            });
            // Check that action was triggered
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByLabelText(/switch to light mode/i)).toBeInTheDocument();
            });
        });
        test('should support escape key for closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that filters panel is open
            expect(_react1.screen.getByText(/advanced filters/i)).toBeInTheDocument();
            // Press Escape
            _react1.fireEvent.keyDown(document, {
                key: 'Escape'
            });
            // Check that filters panel is closed
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/advanced filters/i)).not.toBeInTheDocument();
            });
        });
        test('should support arrow key navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that arrow keys work for navigation
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            // Arrow right
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowRight'
            });
            // Arrow left
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowLeft'
            });
            // Arrow up
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowUp'
            });
            // Arrow down
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowDown'
            });
            // Should not throw errors
            expect(true).toBe(true);
        });
    });
    describe('Focus Management', ()=>{
        test('should trap focus in modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that focus is trapped in modal
            const modal = _react1.screen.getByRole('dialog');
            expect(modal).toBeInTheDocument();
            // Check that focus is within modal
            const focusedElement = document.activeElement;
            expect(modal.contains(focusedElement)).toBe(true);
        });
        test('should restore focus after closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            filtersButton.focus();
            // Open modal
            _react1.fireEvent.click(filtersButton);
            // Close modal
            _react1.fireEvent.click(filtersButton);
            // Check that focus is restored
            expect(document.activeElement).toBe(filtersButton);
        });
        test('should manage focus for dynamic content', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Trigger content update
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            _react1.fireEvent.click(refreshButton);
            // Check that focus is managed properly
            await (0, _react1.waitFor)(()=>{
                expect(document.activeElement).toBeInTheDocument();
            });
        });
    });
    describe('Semantic HTML', ()=>{
        test('should use proper semantic elements', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for main element
            const main = _react1.screen.getByRole('main');
            expect(main).toBeInTheDocument();
            // Check for header element
            const header = _react1.screen.getByRole('banner');
            expect(header).toBeInTheDocument();
            // Check for navigation elements
            const nav = _react1.screen.getByRole('navigation');
            expect(nav).toBeInTheDocument();
        });
        test('should have proper list structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for list elements
            const lists = _react1.screen.getAllByRole('list');
            expect(lists.length).toBeGreaterThan(0);
            // Check for list items
            const listItems = _react1.screen.getAllByRole('listitem');
            expect(listItems.length).toBeGreaterThan(0);
        });
        test('should have proper button semantics', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that all buttons have proper roles
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                expect(button).toHaveAttribute('type', 'button');
            });
        });
    });
    describe('Alternative Text', ()=>{
        test('should have alt text for images', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for images with alt text
            const images = _react1.screen.getAllByRole('img');
            images.forEach((image)=>{
                expect(image).toHaveAttribute('alt');
            });
        });
        test('should have descriptive text for icons', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for icons with proper labels
            const icons = _react1.screen.getAllByRole('img');
            icons.forEach((icon)=>{
                const altText = icon.getAttribute('alt');
                expect(altText).toBeTruthy();
                expect(altText?.length).toBeGreaterThan(0);
            });
        });
    });
    describe('Error Handling', ()=>{
        test('should announce errors to screen readers', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Failed to load feeds'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for error announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/failed to load feeds/i)).toBeInTheDocument();
            });
        });
        test('should provide error recovery options', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Network error'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for retry button
            const retryButton = _react1.screen.getByLabelText(/retry/i);
            expect(retryButton).toBeInTheDocument();
            // Check that retry button is accessible
            expect(retryButton).toHaveAttribute('aria-label');
        });
    });
    describe('Loading States', ()=>{
        test('should announce loading states', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for loading announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/loading/i)).toBeInTheDocument();
            });
        });
        test('should provide loading progress information', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for progress indicator
            const progressIndicator = _react1.screen.getByRole('progressbar');
            expect(progressIndicator).toBeInTheDocument();
        });
    });
    describe('Mobile Accessibility', ()=>{
        test('should support touch gestures with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Simulate touch events
            const feed = _react1.screen.getByRole('main');
            _react1.fireEvent.touchStart(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 100
                    }
                ]
            });
            _react1.fireEvent.touchMove(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            _react1.fireEvent.touchEnd(feed, {
                changedTouches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            // Check that touch events are handled properly
            expect(feed).toBeInTheDocument();
        });
        test('should support haptic feedback with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Mock haptic feedback
            const mockVibrate = _globals.jest.fn();
            Object.defineProperty(navigator, 'vibrate', {
                value: mockVibrate,
                writable: true
            });
            // Trigger haptic feedback
            const likeButton = _react1.screen.getByLabelText(/like/i);
            _react1.fireEvent.click(likeButton);
            // Check that haptic feedback was triggered
            expect(mockVibrate).toHaveBeenCalled();
        });
    });
    describe('Internationalization', ()=>{
        test('should support different languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that text content is properly structured for translation
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toHaveTextContent('Unified Feed');
            // Check that ARIA labels are properly structured
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                const ariaLabel = button.getAttribute('aria-label');
                expect(ariaLabel).toBeTruthy();
            });
        });
        test('should support right-to-left languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that layout supports RTL
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toBeInTheDocument();
            // Check that text direction can be changed
            const textElements = _react1.screen.getAllByText(/test/i);
            textElements.forEach((element)=>{
                expect(element).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQuYWNjZXNzaWJpbGl0eS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaWZpZWRGZWVkIEFjY2Vzc2liaWxpdHkgVGVzdHNcbiAqIFxuICogQ29tcHJlaGVuc2l2ZSBhY2Nlc3NpYmlsaXR5IHRlc3RpbmcgZm9yIHRoZSBVbmlmaWVkRmVlZCBjb21wb25lbnRcbiAqIFRlc3RzIFdDQUcgMi4xIEFBIGNvbXBsaWFuY2UgYW5kIHNjcmVlbiByZWFkZXIgc3VwcG9ydFxuICogXG4gKiBDcmVhdGVkOiBKYW51YXJ5IDE5LCAyMDI1XG4gKiBTdGF0dXM6IOKchSBQUk9EVUNUSU9OIFJFQURZXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IGF4ZSwgdG9IYXZlTm9WaW9sYXRpb25zIH0gZnJvbSAnamVzdC1heGUnO1xuaW1wb3J0IHsgVW5pZmllZEZlZWQgfSBmcm9tICdAL2ZlYXR1cmVzL2ZlZWRzL2NvbXBvbmVudHMvVW5pZmllZEZlZWQnO1xuaW1wb3J0IHsgdXNlRmVlZHMgfSBmcm9tICdAL2xpYi9zdG9yZXMvZmVlZHNTdG9yZSc7XG5pbXBvcnQgeyB1c2VIYXNodGFncyB9IGZyb20gJ0AvZmVhdHVyZXMvaGFzaHRhZ3MvaG9va3MvdXNlSGFzaHRhZ3MnO1xuXG4vLyBFeHRlbmQgSmVzdCBtYXRjaGVyc1xuZXhwZWN0LmV4dGVuZCh0b0hhdmVOb1Zpb2xhdGlvbnMpO1xuXG4vLyBNb2NrIHRoZSBzdG9yZXNcbmplc3QubW9jaygnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnLCAoKSA9PiAoe1xuICB1c2VGZWVkczogamVzdC5mbigpXG59KSk7XG5cbmplc3QubW9jaygnQC9mZWF0dXJlcy9oYXNodGFncy9ob29rcy91c2VIYXNodGFncycsICgpID0+ICh7XG4gIHVzZUhhc2h0YWdzOiBqZXN0LmZuKClcbn0pKTtcblxuY29uc3QgbW9ja1VzZUZlZWRzID0gdXNlRmVlZHMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlRmVlZHM+O1xuY29uc3QgbW9ja1VzZUhhc2h0YWdzID0gdXNlSGFzaHRhZ3MgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlSGFzaHRhZ3M+O1xuXG4vLyBNb2NrIGRhdGFcbmNvbnN0IG1vY2tGZWVkRGF0YSA9IFtcbiAge1xuICAgIGlkOiAnMScsXG4gICAgdHlwZTogJ3BvbGwnLFxuICAgIHRpdGxlOiAnVGVzdCBQb2xsJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoaXMgaXMgYSB0ZXN0IHBvbGwnLFxuICAgIGhhc2h0YWdzOiBbJ3BvbGl0aWNzJywgJ2VsZWN0aW9uJ10sXG4gICAgY3JlYXRlZF9hdDogJzIwMjUtMDEtMTlUMTA6MDA6MDBaJyxcbiAgICBhdXRob3I6ICdUZXN0IFVzZXInLFxuICAgIGVuZ2FnZW1lbnQ6IHtcbiAgICAgIGxpa2VzOiAxMCxcbiAgICAgIHNoYXJlczogNSxcbiAgICAgIGNvbW1lbnRzOiAzXG4gICAgfVxuICB9LFxuICB7XG4gICAgaWQ6ICcyJyxcbiAgICB0eXBlOiAncG9zdCcsXG4gICAgdGl0bGU6ICdUZXN0IFBvc3QnLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBpcyBhIHRlc3QgcG9zdCcsXG4gICAgaGFzaHRhZ3M6IFsnbmV3cycsICd1cGRhdGUnXSxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0xOVQwOTowMDowMFonLFxuICAgIGF1dGhvcjogJ1Rlc3QgVXNlciAyJyxcbiAgICBlbmdhZ2VtZW50OiB7XG4gICAgICBsaWtlczogMTUsXG4gICAgICBzaGFyZXM6IDgsXG4gICAgICBjb21tZW50czogMTJcbiAgICB9XG4gIH1cbl07XG5cbmNvbnN0IG1vY2tIYXNodGFnRGF0YSA9IFtcbiAge1xuICAgIGlkOiAnMScsXG4gICAgbmFtZTogJ3BvbGl0aWNzJyxcbiAgICBkaXNwbGF5X25hbWU6ICdQb2xpdGljcycsXG4gICAgdXNhZ2VfY291bnQ6IDEwMCxcbiAgICBmb2xsb3dlcl9jb3VudDogNTAsXG4gICAgaXNfdHJlbmRpbmc6IHRydWUsXG4gICAgdHJlbmRfc2NvcmU6IDAuOCxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0xOVQxMDowMDowMFonLFxuICAgIHVwZGF0ZWRfYXQ6ICcyMDI1LTAxLTE5VDEwOjAwOjAwWicsXG4gICAgaXNfdmVyaWZpZWQ6IGZhbHNlLFxuICAgIGlzX2ZlYXR1cmVkOiBmYWxzZVxuICB9XG5dO1xuXG5kZXNjcmliZSgnVW5pZmllZEZlZWQgQWNjZXNzaWJpbGl0eSBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gTW9jayBzdG9yZSBpbXBsZW1lbnRhdGlvbnNcbiAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIGZlZWRzOiBtb2NrRmVlZERhdGEsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgcmVmcmVzaEZlZWRzOiBqZXN0LmZuKCksXG4gICAgICBsaWtlRmVlZDogamVzdC5mbigpLFxuICAgICAgc2hhcmVGZWVkOiBqZXN0LmZuKCksXG4gICAgICBjb21tZW50RmVlZDogamVzdC5mbigpLFxuICAgICAgYm9va21hcmtGZWVkOiBqZXN0LmZuKClcbiAgICB9KTtcblxuICAgIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgaGFzaHRhZ3M6IG1vY2tIYXNodGFnRGF0YSxcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBzZWFyY2hIYXNodGFnczogamVzdC5mbigpLFxuICAgICAgZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgICAgdW5mb2xsb3dIYXNodGFnOiBqZXN0LmZuKCksXG4gICAgICBnZXRUcmVuZGluZ0hhc2h0YWdzOiBqZXN0LmZuKClcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1dDQUcgMi4xIEFBIENvbXBsaWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgbm8gYWNjZXNzaWJpbGl0eSB2aW9sYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGF4ZShjb250YWluZXIpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZU5vVmlvbGF0aW9ucygpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGhlYWRpbmcgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBtYWluIGhlYWRpbmdcbiAgICAgIGNvbnN0IG1haW5IZWFkaW5nID0gc2NyZWVuLmdldEJ5Um9sZSgnaGVhZGluZycsIHsgbGV2ZWw6IDEgfSk7XG4gICAgICBleHBlY3QobWFpbkhlYWRpbmcpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3QobWFpbkhlYWRpbmcpLnRvSGF2ZVRleHRDb250ZW50KCdVbmlmaWVkIEZlZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBjb2xvciBjb250cmFzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBheGUoY29udGFpbmVyLCB7XG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgJ2NvbG9yLWNvbnRyYXN0JzogeyBlbmFibGVkOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTm9WaW9sYXRpb25zKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgZm9jdXMgbWFuYWdlbWVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZvY3VzYWJsZSBlbGVtZW50cyBhcmUgcHJvcGVybHkgbWFya2VkXG4gICAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicpO1xuICAgICAgZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQpLnRvSGF2ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2NyZWVuIFJlYWRlciBTdXBwb3J0JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBBUklBIGxhYmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBtYWluIGZlZWQgcm9sZSBhbmQgbGFiZWxcbiAgICAgIGNvbnN0IG1haW5GZWVkID0gc2NyZWVuLmdldEJ5Um9sZSgnbWFpbicpO1xuICAgICAgZXhwZWN0KG1haW5GZWVkKS50b0hhdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnVW5pZmllZCBGZWVkJyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGJ1dHRvbiBsYWJlbHNcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZXhwZWN0KGRhcmtNb2RlQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGV4cGVjdChmaWx0ZXJzQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBjb25zdCByZWZyZXNoQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWZyZXNoIGZlZWQvaSk7XG4gICAgICBleHBlY3QocmVmcmVzaEJ1dHRvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBBUklBIGxpdmUgcmVnaW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbGl2ZSByZWdpb25zXG4gICAgICBjb25zdCBsaXZlUmVnaW9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3N0YXR1cycpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb25zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcG9saXRlIGFubm91bmNlbWVudHNcbiAgICAgIGNvbnN0IHBvbGl0ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycsIHsgbmFtZTogL2ZlZWQvaSB9KTtcbiAgICAgIGV4cGVjdChwb2xpdGVSZWdpb24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYW5ub3VuY2Ugc3RhdGUgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGEgc3RhdGUgY2hhbmdlXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBhbm5vdW5jZW1lbnRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvc3dpdGNoZWQgdG8gZGFyayBtb2RlL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgZm9ybSBsYWJlbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGZvcm0gZWxlbWVudHMgd2l0aCBwcm9wZXIgbGFiZWxzXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KGlucHV0LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpIHx8ICcnKTtcbiAgICAgICAgZXhwZWN0KGxhYmVsKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdLZXlib2FyZCBOYXZpZ2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IHRhYiBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IHdpdGggZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgIGNvbnN0IGZpcnN0QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyc3RCdXR0b24uZm9jdXMoKTtcbiAgICAgIGV4cGVjdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS50b0JlKGZpcnN0QnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gVGFiIHRvIG5leHQgZWxlbWVudFxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnVGFiJyB9KTtcbiAgICAgIGNvbnN0IG5leHRCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgZXhwZWN0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLnRvQmUobmV4dEJ1dHRvbik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBlbnRlciBrZXkgYWN0aXZhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGRhcmtNb2RlQnV0dG9uLmZvY3VzKCk7XG4gICAgICBcbiAgICAgIC8vIFByZXNzIEVudGVyXG4gICAgICBmaXJlRXZlbnQua2V5RG93bihkYXJrTW9kZUJ1dHRvbiwgeyBrZXk6ICdFbnRlcicgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgYWN0aW9uIHdhcyB0cmlnZ2VyZWRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gbGlnaHQgbW9kZS9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgZXNjYXBlIGtleSBmb3IgY2xvc2luZyBtb2RhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gT3BlbiBhZHZhbmNlZCBmaWx0ZXJzXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhmaWx0ZXJzQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmaWx0ZXJzIHBhbmVsIGlzIG9wZW5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9hZHZhbmNlZCBmaWx0ZXJzL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBQcmVzcyBFc2NhcGVcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRvY3VtZW50LCB7IGtleTogJ0VzY2FwZScgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZmlsdGVycyBwYW5lbCBpcyBjbG9zZWRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9hZHZhbmNlZCBmaWx0ZXJzL2kpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgYXJyb3cga2V5IG5hdmlnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhcnJvdyBrZXlzIHdvcmsgZm9yIG5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGZpcnN0QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyc3RCdXR0b24uZm9jdXMoKTtcbiAgICAgIFxuICAgICAgLy8gQXJyb3cgcmlnaHRcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGZpcnN0QnV0dG9uLCB7IGtleTogJ0Fycm93UmlnaHQnIH0pO1xuICAgICAgXG4gICAgICAvLyBBcnJvdyBsZWZ0XG4gICAgICBmaXJlRXZlbnQua2V5RG93bihmaXJzdEJ1dHRvbiwgeyBrZXk6ICdBcnJvd0xlZnQnIH0pO1xuICAgICAgXG4gICAgICAvLyBBcnJvdyB1cFxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnQXJyb3dVcCcgfSk7XG4gICAgICBcbiAgICAgIC8vIEFycm93IGRvd25cbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGZpcnN0QnV0dG9uLCB7IGtleTogJ0Fycm93RG93bicgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3JzXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZvY3VzIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHRyYXAgZm9jdXMgaW4gbW9kYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIE9wZW4gYWR2YW5jZWQgZmlsdGVyc1xuICAgICAgY29uc3QgZmlsdGVyc0J1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvdG9nZ2xlIGFkdmFuY2VkIGZpbHRlcnMvaSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXMgaXMgdHJhcHBlZCBpbiBtb2RhbFxuICAgICAgY29uc3QgbW9kYWwgPSBzY3JlZW4uZ2V0QnlSb2xlKCdkaWFsb2cnKTtcbiAgICAgIGV4cGVjdChtb2RhbCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmb2N1cyBpcyB3aXRoaW4gbW9kYWxcbiAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGV4cGVjdChtb2RhbC5jb250YWlucyhmb2N1c2VkRWxlbWVudCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVzdG9yZSBmb2N1cyBhZnRlciBjbG9zaW5nIG1vZGFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGZpbHRlcnNCdXR0b24uZm9jdXMoKTtcbiAgICAgIFxuICAgICAgLy8gT3BlbiBtb2RhbFxuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDbG9zZSBtb2RhbFxuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZvY3VzIGlzIHJlc3RvcmVkXG4gICAgICBleHBlY3QoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkudG9CZShmaWx0ZXJzQnV0dG9uKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYW5hZ2UgZm9jdXMgZm9yIGR5bmFtaWMgY29udGVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGNvbnRlbnQgdXBkYXRlXG4gICAgICBjb25zdCByZWZyZXNoQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWZyZXNoIGZlZWQvaSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2socmVmcmVzaEJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXMgaXMgbWFuYWdlZCBwcm9wZXJseVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZW1hbnRpYyBIVE1MJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB1c2UgcHJvcGVyIHNlbWFudGljIGVsZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBtYWluIGVsZW1lbnRcbiAgICAgIGNvbnN0IG1haW4gPSBzY3JlZW4uZ2V0QnlSb2xlKCdtYWluJyk7XG4gICAgICBleHBlY3QobWFpbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlciBlbGVtZW50XG4gICAgICBjb25zdCBoZWFkZXIgPSBzY3JlZW4uZ2V0QnlSb2xlKCdiYW5uZXInKTtcbiAgICAgIGV4cGVjdChoZWFkZXIpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBuYXZpZ2F0aW9uIGVsZW1lbnRzXG4gICAgICBjb25zdCBuYXYgPSBzY3JlZW4uZ2V0QnlSb2xlKCduYXZpZ2F0aW9uJyk7XG4gICAgICBleHBlY3QobmF2KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGxpc3Qgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBsaXN0IGVsZW1lbnRzXG4gICAgICBjb25zdCBsaXN0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2xpc3QnKTtcbiAgICAgIGV4cGVjdChsaXN0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3QgaXRlbXNcbiAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2xpc3RpdGVtJyk7XG4gICAgICBleHBlY3QobGlzdEl0ZW1zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGJ1dHRvbiBzZW1hbnRpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhbGwgYnV0dG9ucyBoYXZlIHByb3BlciByb2xlc1xuICAgICAgY29uc3QgYnV0dG9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicpO1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGV4cGVjdChidXR0b24pLnRvSGF2ZUF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWx0ZXJuYXRpdmUgVGV4dCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBhbHQgdGV4dCBmb3IgaW1hZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBpbWFnZXMgd2l0aCBhbHQgdGV4dFxuICAgICAgY29uc3QgaW1hZ2VzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnaW1nJyk7XG4gICAgICBpbWFnZXMuZm9yRWFjaChpbWFnZSA9PiB7XG4gICAgICAgIGV4cGVjdChpbWFnZSkudG9IYXZlQXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgZGVzY3JpcHRpdmUgdGV4dCBmb3IgaWNvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGljb25zIHdpdGggcHJvcGVyIGxhYmVsc1xuICAgICAgY29uc3QgaWNvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdpbWcnKTtcbiAgICAgIGljb25zLmZvckVhY2goaWNvbiA9PiB7XG4gICAgICAgIGNvbnN0IGFsdFRleHQgPSBpY29uLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gICAgICAgIGV4cGVjdChhbHRUZXh0KS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdChhbHRUZXh0Py5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFubm91bmNlIGVycm9ycyB0byBzY3JlZW4gcmVhZGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gbG9hZCBmZWVkcydcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGVycm9yIGFubm91bmNlbWVudFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9mYWlsZWQgdG8gbG9hZCBmZWVkcy9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgZXJyb3IgcmVjb3Zlcnkgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgZXJyb3I6ICdOZXR3b3JrIGVycm9yJ1xuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcmV0cnkgYnV0dG9uXG4gICAgICBjb25zdCByZXRyeUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmV0cnkvaSk7XG4gICAgICBleHBlY3QocmV0cnlCdXR0b24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgcmV0cnkgYnV0dG9uIGlzIGFjY2Vzc2libGVcbiAgICAgIGV4cGVjdChyZXRyeUJ1dHRvbikudG9IYXZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2FkaW5nIFN0YXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYW5ub3VuY2UgbG9hZGluZyBzdGF0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUZlZWRzKCksXG4gICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGxvYWRpbmcgYW5ub3VuY2VtZW50XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2xvYWRpbmcvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwcm92aWRlIGxvYWRpbmcgcHJvZ3Jlc3MgaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUZlZWRzKCksXG4gICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgY29uc3QgcHJvZ3Jlc3NJbmRpY2F0b3IgPSBzY3JlZW4uZ2V0QnlSb2xlKCdwcm9ncmVzc2JhcicpO1xuICAgICAgZXhwZWN0KHByb2dyZXNzSW5kaWNhdG9yKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9iaWxlIEFjY2Vzc2liaWxpdHknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgdG91Y2ggZ2VzdHVyZXMgd2l0aCBhY2Nlc3NpYmlsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHRvdWNoIGV2ZW50c1xuICAgICAgY29uc3QgZmVlZCA9IHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKTtcbiAgICAgIGZpcmVFdmVudC50b3VjaFN0YXJ0KGZlZWQsIHsgdG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAxMDAgfV0gfSk7XG4gICAgICBmaXJlRXZlbnQudG91Y2hNb3ZlKGZlZWQsIHsgdG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAyMDAgfV0gfSk7XG4gICAgICBmaXJlRXZlbnQudG91Y2hFbmQoZmVlZCwgeyBjaGFuZ2VkVG91Y2hlczogW3sgY2xpZW50WDogMTAwLCBjbGllbnRZOiAyMDAgfV0gfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgdG91Y2ggZXZlbnRzIGFyZSBoYW5kbGVkIHByb3Blcmx5XG4gICAgICBleHBlY3QoZmVlZCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IGhhcHRpYyBmZWVkYmFjayB3aXRoIGFjY2Vzc2liaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBoYXB0aWMgZmVlZGJhY2tcbiAgICAgIGNvbnN0IG1vY2tWaWJyYXRlID0gamVzdC5mbigpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3ZpYnJhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBtb2NrVmlicmF0ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGhhcHRpYyBmZWVkYmFja1xuICAgICAgY29uc3QgbGlrZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvbGlrZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhsaWtlQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBoYXB0aWMgZmVlZGJhY2sgd2FzIHRyaWdnZXJlZFxuICAgICAgZXhwZWN0KG1vY2tWaWJyYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlcm5hdGlvbmFsaXphdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBkaWZmZXJlbnQgbGFuZ3VhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgdGV4dCBjb250ZW50IGlzIHByb3Blcmx5IHN0cnVjdHVyZWQgZm9yIHRyYW5zbGF0aW9uXG4gICAgICBjb25zdCBtYWluSGVhZGluZyA9IHNjcmVlbi5nZXRCeVJvbGUoJ2hlYWRpbmcnLCB7IGxldmVsOiAxIH0pO1xuICAgICAgZXhwZWN0KG1haW5IZWFkaW5nKS50b0hhdmVUZXh0Q29udGVudCgnVW5pZmllZCBGZWVkJyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgQVJJQSBsYWJlbHMgYXJlIHByb3Blcmx5IHN0cnVjdHVyZWRcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nKTtcbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBjb25zdCBhcmlhTGFiZWwgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgIGV4cGVjdChhcmlhTGFiZWwpLnRvQmVUcnV0aHkoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgcmlnaHQtdG8tbGVmdCBsYW5ndWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBsYXlvdXQgc3VwcG9ydHMgUlRMXG4gICAgICBjb25zdCBtYWluRmVlZCA9IHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKTtcbiAgICAgIGV4cGVjdChtYWluRmVlZCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCB0ZXh0IGRpcmVjdGlvbiBjYW4gYmUgY2hhbmdlZFxuICAgICAgY29uc3QgdGV4dEVsZW1lbnRzID0gc2NyZWVuLmdldEFsbEJ5VGV4dCgvdGVzdC9pKTtcbiAgICAgIHRleHRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBleHBlY3QoZWxlbWVudCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImV4cGVjdCIsImV4dGVuZCIsInRvSGF2ZU5vVmlvbGF0aW9ucyIsImplc3QiLCJtb2NrIiwidXNlRmVlZHMiLCJmbiIsInVzZUhhc2h0YWdzIiwibW9ja1VzZUZlZWRzIiwibW9ja1VzZUhhc2h0YWdzIiwibW9ja0ZlZWREYXRhIiwiaWQiLCJ0eXBlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhhc2h0YWdzIiwiY3JlYXRlZF9hdCIsImF1dGhvciIsImVuZ2FnZW1lbnQiLCJsaWtlcyIsInNoYXJlcyIsImNvbW1lbnRzIiwibW9ja0hhc2h0YWdEYXRhIiwibmFtZSIsImRpc3BsYXlfbmFtZSIsInVzYWdlX2NvdW50IiwiZm9sbG93ZXJfY291bnQiLCJpc190cmVuZGluZyIsInRyZW5kX3Njb3JlIiwidXBkYXRlZF9hdCIsImlzX3ZlcmlmaWVkIiwiaXNfZmVhdHVyZWQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJtb2NrUmV0dXJuVmFsdWUiLCJmZWVkcyIsImxvYWRpbmciLCJlcnJvciIsInJlZnJlc2hGZWVkcyIsImxpa2VGZWVkIiwic2hhcmVGZWVkIiwiY29tbWVudEZlZWQiLCJib29rbWFya0ZlZWQiLCJzZWFyY2hIYXNodGFncyIsImZvbGxvd0hhc2h0YWciLCJ1bmZvbGxvd0hhc2h0YWciLCJnZXRUcmVuZGluZ0hhc2h0YWdzIiwiYWZ0ZXJFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInRlc3QiLCJjb250YWluZXIiLCJyZW5kZXIiLCJVbmlmaWVkRmVlZCIsInJlc3VsdHMiLCJheGUiLCJtYWluSGVhZGluZyIsInNjcmVlbiIsImdldEJ5Um9sZSIsImxldmVsIiwidG9CZUluVGhlRG9jdW1lbnQiLCJ0b0hhdmVUZXh0Q29udGVudCIsInJ1bGVzIiwiZW5hYmxlZCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiZ2V0QWxsQnlSb2xlIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJ0b0hhdmVBdHRyaWJ1dGUiLCJtYWluRmVlZCIsImRhcmtNb2RlQnV0dG9uIiwiZ2V0QnlMYWJlbFRleHQiLCJmaWx0ZXJzQnV0dG9uIiwicmVmcmVzaEJ1dHRvbiIsImxpdmVSZWdpb25zIiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuIiwicG9saXRlUmVnaW9uIiwiZmlyZUV2ZW50IiwiY2xpY2siLCJ3YWl0Rm9yIiwiZ2V0QnlUZXh0IiwiaW5wdXRzIiwiaW5wdXQiLCJsYWJlbCIsImdldEF0dHJpYnV0ZSIsImZpcnN0QnV0dG9uIiwiZm9jdXMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJ0b0JlIiwia2V5RG93biIsImtleSIsIm5leHRCdXR0b24iLCJxdWVyeUJ5VGV4dCIsIm5vdCIsIm1vZGFsIiwiZm9jdXNlZEVsZW1lbnQiLCJjb250YWlucyIsIm1haW4iLCJoZWFkZXIiLCJuYXYiLCJsaXN0cyIsImxpc3RJdGVtcyIsImJ1dHRvbnMiLCJidXR0b24iLCJpbWFnZXMiLCJpbWFnZSIsImljb25zIiwiaWNvbiIsImFsdFRleHQiLCJ0b0JlVHJ1dGh5IiwicmV0cnlCdXR0b24iLCJwcm9ncmVzc0luZGljYXRvciIsImZlZWQiLCJ0b3VjaFN0YXJ0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwidG91Y2hNb3ZlIiwidG91Y2hFbmQiLCJjaGFuZ2VkVG91Y2hlcyIsIm1vY2tWaWJyYXRlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJuYXZpZ2F0b3IiLCJ2YWx1ZSIsIndyaXRhYmxlIiwibGlrZUJ1dHRvbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJhcmlhTGFiZWwiLCJ0ZXh0RWxlbWVudHMiLCJnZXRBbGxCeVRleHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7Ozs4REFFaUI7d0JBQ2lDO3lCQUM5Qjt5QkFDbUI7NkJBQ1o7NEJBQ0g7NkJBQ0c7Ozs7OztBQUU1Qix1QkFBdUI7QUFDdkJBLE9BQU9DLE1BQU0sQ0FBQ0MsMkJBQWtCO0FBRWhDLGtCQUFrQjtBQUNsQkMsYUFBSSxDQUFDQyxJQUFJLENBQUMsMkJBQTJCLElBQU8sQ0FBQTtRQUMxQ0MsVUFBVUYsYUFBSSxDQUFDRyxFQUFFO0lBQ25CLENBQUE7QUFFQUgsYUFBSSxDQUFDQyxJQUFJLENBQUMseUNBQXlDLElBQU8sQ0FBQTtRQUN4REcsYUFBYUosYUFBSSxDQUFDRyxFQUFFO0lBQ3RCLENBQUE7QUFFQSxNQUFNRSxlQUFlSCxv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