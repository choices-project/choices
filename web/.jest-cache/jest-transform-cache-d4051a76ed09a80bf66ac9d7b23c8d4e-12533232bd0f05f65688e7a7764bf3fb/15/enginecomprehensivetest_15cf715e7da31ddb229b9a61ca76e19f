4a965727139d5e594daf4b458d27c617
/**
 * Comprehensive Vote Engine Tests
 * 
 * Tests the core voting engine with all voting strategies
 * Tests validation, processing, and results calculation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _engine = require("../../../../../lib/vote/engine");
// Mock the logger
_globals.jest.mock('@/lib/utils/logger', ()=>({
        devLog: _globals.jest.fn(),
        logger: {
            info: _globals.jest.fn(),
            error: _globals.jest.fn(),
            warn: _globals.jest.fn(),
            debug: _globals.jest.fn()
        }
    }));
(0, _globals.describe)('VoteEngine', ()=>{
    let engine;
    let config;
    let mockPoll;
    let mockVoteRequest;
    (0, _globals.beforeEach)(()=>{
        config = {
            maxVotesPerPoll: 1,
            allowMultipleVotes: false,
            requireAuthentication: true,
            minTrustTier: 'basic',
            rateLimitPerUser: 10,
            rateLimitWindowMs: 60000
        };
        engine = new _engine.VoteEngine(config);
        mockPoll = {
            id: 'test-poll-id',
            title: 'Test Poll',
            description: 'A test poll',
            votingMethod: 'single',
            options: [
                {
                    id: 'option-1',
                    text: 'Option 1'
                },
                {
                    id: 'option-2',
                    text: 'Option 2'
                }
            ],
            status: 'active',
            createdAt: new Date(),
            closeAt: new Date(Date.now() + 86400000),
            createdBy: 'user-1',
            settings: {
                allowMultipleVotes: false,
                requireAuthentication: true,
                anonymousVoting: false
            }
        };
        mockVoteRequest = {
            pollId: 'test-poll-id',
            userId: 'user-1',
            voteData: {
                choice: 0,
                approvals: null,
                rankings: null,
                allocations: null,
                ratings: null
            },
            metadata: {
                ipAddress: '192.168.1.1',
                userAgent: 'Mozilla/5.0',
                timestamp: new Date()
            }
        };
    });
    (0, _globals.describe)('Initialization', ()=>{
        (0, _globals.it)('should initialize with provided configuration', ()=>{
            (0, _globals.expect)(engine).toBeDefined();
            (0, _globals.expect)(engine).toBeInstanceOf(_engine.VoteEngine);
        });
        (0, _globals.it)('should use default configuration when none provided', ()=>{
            const defaultEngine = new _engine.VoteEngine();
            (0, _globals.expect)(defaultEngine).toBeDefined();
            (0, _globals.expect)(defaultEngine).toBeInstanceOf(_engine.VoteEngine);
        });
    });
    (0, _globals.describe)('Vote Validation', ()=>{
        (0, _globals.it)('should validate single-choice votes correctly', async ()=>{
            const validation = await engine.validateVote(mockVoteRequest, mockPoll);
            (0, _globals.expect)(validation).toBeDefined();
            (0, _globals.expect)(validation.valid).toBe(true);
            (0, _globals.expect)(validation.errors).toHaveLength(0);
        });
        (0, _globals.it)('should reject votes with invalid poll ID', async ()=>{
            const invalidRequest = {
                ...mockVoteRequest,
                pollId: 'invalid-poll'
            };
            const validation = await engine.validateVote(invalidRequest, mockPoll);
            (0, _globals.expect)(validation).toBeDefined();
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain('Poll ID mismatch');
        });
        (0, _globals.it)('should reject votes for closed polls', async ()=>{
            const closedPoll = {
                ...mockPoll,
                status: 'closed'
            };
            const validation = await engine.validateVote(mockVoteRequest, closedPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain('Poll is not active');
        });
        (0, _globals.it)('should reject votes with invalid options', async ()=>{
            const invalidRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: 999,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(invalidRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain('Invalid option selected');
        });
        (0, _globals.it)('should validate ranked-choice votes', async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: 'ranked'
            };
            const rankedRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: [
                        0,
                        1
                    ],
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(rankedRequest, rankedPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
        (0, _globals.it)('should validate approval votes', async ()=>{
            const approvalPoll = {
                ...mockPoll,
                votingMethod: 'approval'
            };
            const approvalRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: [
                        0,
                        1
                    ],
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            };
            const validation = await engine.validateVote(approvalRequest, approvalPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
        (0, _globals.it)('should validate quadratic votes', async ()=>{
            const quadraticPoll = {
                ...mockPoll,
                votingMethod: 'quadratic'
            };
            const quadraticRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: null,
                    allocations: {
                        'option-1': 2,
                        'option-2': 1
                    },
                    ratings: null
                }
            };
            const validation = await engine.validateVote(quadraticRequest, quadraticPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
    });
    (0, _globals.describe)('Vote Processing', ()=>{
        (0, _globals.it)('should process single-choice votes successfully', async ()=>{
            const response = await engine.processVote(mockVoteRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(true);
            (0, _globals.expect)(response.voteId).toBeDefined();
            (0, _globals.expect)(response.auditReceipt).toBeDefined();
        });
        (0, _globals.it)('should process ranked-choice votes successfully', async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: 'ranked-choice'
            };
            const rankedRequest = {
                ...mockVoteRequest,
                voteData: {
                    choice: null,
                    approvals: null,
                    rankings: [
                        0,
                        1
                    ],
                    allocations: null,
                    ratings: null
                }
            };
            const response = await engine.processVote(rankedRequest, rankedPoll);
            (0, _globals.expect)(response.success).toBe(true);
            (0, _globals.expect)(response.voteId).toBeDefined();
        });
        (0, _globals.it)('should handle vote processing errors gracefully', async ()=>{
            // Mock a processing error by creating a poll with invalid voting method
            const invalidPoll = {
                ...mockPoll,
                votingMethod: 'invalid-method'
            };
            const response = await engine.processVote(mockVoteRequest, invalidPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
    });
    (0, _globals.describe)('Results Calculation', ()=>{
        (0, _globals.it)('should calculate single-choice results', async ()=>{
            const votes = [
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 1,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            ];
            const results = await engine.calculateResults(mockPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(3);
            (0, _globals.expect)(results.results.winner).toBe('option-1');
        });
        (0, _globals.it)('should calculate ranked-choice results', async ()=>{
            const rankedPoll = {
                ...mockPoll,
                votingMethod: 'ranked-choice'
            };
            const votes = [
                {
                    id: 'vote-1',
                    pollId: 'test-poll-id',
                    userId: 'user-1',
                    voteData: {
                        rankings: [
                            0,
                            1
                        ]
                    },
                    timestamp: new Date().toISOString(),
                    ipAddress: '192.168.1.1',
                    userAgent: 'Mozilla/5.0'
                },
                {
                    id: 'vote-2',
                    pollId: 'test-poll-id',
                    userId: 'user-2',
                    voteData: {
                        rankings: [
                            1,
                            0
                        ]
                    },
                    timestamp: new Date().toISOString(),
                    ipAddress: '192.168.1.2',
                    userAgent: 'Mozilla/5.0'
                }
            ];
            const results = await engine.calculateResults(rankedPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(2);
        });
        (0, _globals.it)('should handle empty vote sets', async ()=>{
            const results = await engine.calculateResults(mockPoll, []);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(0);
            (0, _globals.expect)(results.results.winner).toBeNull();
        });
        (0, _globals.it)('should handle tie scenarios', async ()=>{
            const votes = [
                {
                    choice: 0,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                },
                {
                    choice: 1,
                    approvals: null,
                    rankings: null,
                    allocations: null,
                    ratings: null
                }
            ];
            const results = await engine.calculateResults(mockPoll, votes);
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(results.totalVotes).toBe(2);
        // In a tie, the result should indicate no clear winner
        });
    });
    (0, _globals.describe)('Rate Limiting', ()=>{
        (0, _globals.it)('should enforce rate limits', async ()=>{
            // Create multiple requests from the same user
            const requests = Array.from({
                length: 15
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: 'user-1',
                    metadata: {
                        ...mockVoteRequest.metadata,
                        timestamp: new Date(Date.now() + i * 1000)
                    }
                }));
            // Process requests and check rate limiting
            const responses = await Promise.all(requests.map((request)=>engine.processVote(request, mockPoll)));
            // Some requests should be rate limited
            const rateLimitedResponses = responses.filter((r)=>!r.success && r.error?.includes('Rate limit exceeded'));
            (0, _globals.expect)(rateLimitedResponses.length).toBeGreaterThan(0);
        });
        (0, _globals.it)('should allow requests within rate limit', async ()=>{
            const requests = Array.from({
                length: 5
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: 'user-1',
                    metadata: {
                        ...mockVoteRequest.metadata,
                        timestamp: new Date(Date.now() + i * 1000)
                    }
                }));
            const responses = await Promise.all(requests.map((request)=>engine.processVote(request, mockPoll)));
            // All requests should succeed within rate limit
            const successfulResponses = responses.filter((r)=>r.success);
            (0, _globals.expect)(successfulResponses.length).toBe(5);
        });
    });
    (0, _globals.describe)('Authentication', ()=>{
        (0, _globals.it)('should require authentication when configured', async ()=>{
            const unauthenticatedRequest = {
                ...mockVoteRequest,
                userId: null
            };
            const validation = await engine.validateVote(unauthenticatedRequest, mockPoll);
            (0, _globals.expect)(validation.valid).toBe(false);
            (0, _globals.expect)(validation.errors).toContain('Authentication required to vote');
        });
        (0, _globals.it)('should allow anonymous voting when configured', async ()=>{
            const anonymousPoll = {
                ...mockPoll,
                settings: {
                    ...mockPoll.settings,
                    anonymousVoting: true
                }
            };
            const anonymousRequest = {
                ...mockVoteRequest,
                userId: null
            };
            const validation = await engine.validateVote(anonymousRequest, anonymousPoll);
            (0, _globals.expect)(validation.valid).toBe(true);
        });
    });
    (0, _globals.describe)('Error Handling', ()=>{
        (0, _globals.it)('should handle malformed vote data', async ()=>{
            const malformedRequest = {
                ...mockVoteRequest,
                voteData: null
            };
            const response = await engine.processVote(malformedRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
        (0, _globals.it)('should handle missing poll data', async ()=>{
            const response = await engine.processVote(mockVoteRequest, null);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
        (0, _globals.it)('should handle network errors gracefully', async ()=>{
            // Create a scenario that would cause a processing error
            const invalidRequest = {
                ...mockVoteRequest,
                voteData: null
            };
            const response = await engine.processVote(invalidRequest, mockPoll);
            (0, _globals.expect)(response.success).toBe(false);
            (0, _globals.expect)(response.error).toBeDefined();
        });
    });
    (0, _globals.describe)('Performance', ()=>{
        (0, _globals.it)('should process votes within reasonable time', async ()=>{
            const startTime = performance.now();
            await engine.processVote(mockVoteRequest, mockPoll);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            // Should process within 100ms
            (0, _globals.expect)(processingTime).toBeLessThan(100);
        });
        (0, _globals.it)('should handle large vote sets efficiently', async ()=>{
            const largeVoteSet = Array.from({
                length: 1000
            }, (_, i)=>({
                    ...mockVoteRequest,
                    userId: `user-${i}`,
                    voteData: {
                        selectedOptions: [
                            'option-1'
                        ],
                        ranking: null,
                        weights: null
                    }
                }));
            const startTime = performance.now();
            const results = await engine.calculateResults(mockPoll, largeVoteSet);
            const endTime = performance.now();
            const processingTime = endTime - startTime;
            (0, _globals.expect)(results).toBeDefined();
            (0, _globals.expect)(processingTime).toBeLessThan(1000); // Should process within 1 second
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL3ZvdGUvZW5naW5lLWNvbXByZWhlbnNpdmUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXByZWhlbnNpdmUgVm90ZSBFbmdpbmUgVGVzdHNcbiAqIFxuICogVGVzdHMgdGhlIGNvcmUgdm90aW5nIGVuZ2luZSB3aXRoIGFsbCB2b3Rpbmcgc3RyYXRlZ2llc1xuICogVGVzdHMgdmFsaWRhdGlvbiwgcHJvY2Vzc2luZywgYW5kIHJlc3VsdHMgY2FsY3VsYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlRWFjaCwgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnXG5pbXBvcnQgeyBWb3RlRW5naW5lLCB0eXBlIFZvdGVFbmdpbmVDb25maWcgfSBmcm9tICdAL2xpYi92b3RlL2VuZ2luZSdcbmltcG9ydCB0eXBlIHsgVm90ZVJlcXVlc3QsIFZvdGVSZXNwb25zZSwgUG9sbERhdGEsIFZvdGluZ01ldGhvZCB9IGZyb20gJ0AvbGliL3ZvdGUvdHlwZXMnXG5cbi8vIE1vY2sgdGhlIGxvZ2dlclxuamVzdC5tb2NrKCdAL2xpYi91dGlscy9sb2dnZXInLCAoKSA9PiAoe1xuICBkZXZMb2c6IGplc3QuZm4oKSxcbiAgbG9nZ2VyOiB7XG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGRlYnVnOiBqZXN0LmZuKClcbiAgfVxufSkpXG5cbmRlc2NyaWJlKCdWb3RlRW5naW5lJywgKCkgPT4ge1xuICBsZXQgZW5naW5lOiBWb3RlRW5naW5lXG4gIGxldCBjb25maWc6IFZvdGVFbmdpbmVDb25maWdcbiAgbGV0IG1vY2tQb2xsOiBQb2xsRGF0YVxuICBsZXQgbW9ja1ZvdGVSZXF1ZXN0OiBWb3RlUmVxdWVzdFxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIG1heFZvdGVzUGVyUG9sbDogMSxcbiAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogZmFsc2UsXG4gICAgICByZXF1aXJlQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICBtaW5UcnVzdFRpZXI6ICdiYXNpYycsXG4gICAgICByYXRlTGltaXRQZXJVc2VyOiAxMCxcbiAgICAgIHJhdGVMaW1pdFdpbmRvd01zOiA2MDAwMFxuICAgIH1cblxuICAgIGVuZ2luZSA9IG5ldyBWb3RlRW5naW5lKGNvbmZpZylcblxuICAgIG1vY2tQb2xsID0ge1xuICAgICAgaWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgICAgZGVzY3JpcHRpb246ICdBIHRlc3QgcG9sbCcsXG4gICAgICB2b3RpbmdNZXRob2Q6ICdzaW5nbGUnIGFzIFZvdGluZ01ldGhvZCxcbiAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgeyBpZDogJ29wdGlvbi0xJywgdGV4dDogJ09wdGlvbiAxJyB9LFxuICAgICAgICB7IGlkOiAnb3B0aW9uLTInLCB0ZXh0OiAnT3B0aW9uIDInIH1cbiAgICAgIF0sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgY2xvc2VBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDg2NDAwMDAwKSwgLy8gMjQgaG91cnMgZnJvbSBub3dcbiAgICAgIGNyZWF0ZWRCeTogJ3VzZXItMScsXG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IGZhbHNlLFxuICAgICAgICByZXF1aXJlQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgICAgIGFub255bW91c1ZvdGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2NrVm90ZVJlcXVlc3QgPSB7XG4gICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtaWQnLFxuICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgIGNob2ljZTogMCwgLy8gSW5kZXggb2Ygb3B0aW9uLTFcbiAgICAgICAgYXBwcm92YWxzOiBudWxsLFxuICAgICAgICByYW5raW5nczogbnVsbCxcbiAgICAgICAgYWxsb2NhdGlvbnM6IG51bGwsXG4gICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgIH0sXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBwcm92aWRlZCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGVuZ2luZSkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGVuZ2luZSkudG9CZUluc3RhbmNlT2YoVm90ZUVuZ2luZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBjb25maWd1cmF0aW9uIHdoZW4gbm9uZSBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRFbmdpbmUgPSBuZXcgVm90ZUVuZ2luZSgpXG4gICAgICBleHBlY3QoZGVmYXVsdEVuZ2luZSkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGRlZmF1bHRFbmdpbmUpLnRvQmVJbnN0YW5jZU9mKFZvdGVFbmdpbmUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVm90ZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgc2luZ2xlLWNob2ljZSB2b3RlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShtb2NrVm90ZVJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbikudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9IYXZlTGVuZ3RoKDApXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGVzIHdpdGggaW52YWxpZCBwb2xsIElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSB7IC4uLm1vY2tWb3RlUmVxdWVzdCwgcG9sbElkOiAnaW52YWxpZC1wb2xsJyB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKGludmFsaWRSZXF1ZXN0LCBtb2NrUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24pLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0NvbnRhaW4oJ1BvbGwgSUQgbWlzbWF0Y2gnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlcyBmb3IgY2xvc2VkIHBvbGxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2VkUG9sbCA9IHsgLi4ubW9ja1BvbGwsIHN0YXR1czogJ2Nsb3NlZCcgYXMgY29uc3QgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShtb2NrVm90ZVJlcXVlc3QsIGNsb3NlZFBvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3JzKS50b0NvbnRhaW4oJ1BvbGwgaXMgbm90IGFjdGl2ZScpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGVzIHdpdGggaW52YWxpZCBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IDk5OSwgLy8gSW52YWxpZCBvcHRpb24gaW5kZXhcbiAgICAgICAgICBhcHByb3ZhbHM6IG51bGwsXG4gICAgICAgICAgcmFua2luZ3M6IG51bGwsXG4gICAgICAgICAgYWxsb2NhdGlvbnM6IG51bGwsXG4gICAgICAgICAgcmF0aW5nczogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKGludmFsaWRSZXF1ZXN0LCBtb2NrUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24udmFsaWQpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcnMpLnRvQ29udGFpbignSW52YWxpZCBvcHRpb24gc2VsZWN0ZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJhbmtlZC1jaG9pY2Ugdm90ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByYW5rZWRQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAncmFua2VkJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgY29uc3QgcmFua2VkUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0LFxuICAgICAgICB2b3RlRGF0YToge1xuICAgICAgICAgIGNob2ljZTogbnVsbCxcbiAgICAgICAgICBhcHByb3ZhbHM6IG51bGwsXG4gICAgICAgICAgcmFua2luZ3M6IFswLCAxXSwgLy8gUmFua2luZ3MgZm9yIG9wdGlvbi0xIGFuZCBvcHRpb24tMlxuICAgICAgICAgIGFsbG9jYXRpb25zOiBudWxsLFxuICAgICAgICAgIHJhdGluZ3M6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShyYW5rZWRSZXF1ZXN0LCByYW5rZWRQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGFwcHJvdmFsIHZvdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwcm92YWxQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAnYXBwcm92YWwnIGFzIFZvdGluZ01ldGhvZCB9XG4gICAgICBjb25zdCBhcHByb3ZhbFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBjaG9pY2U6IG51bGwsXG4gICAgICAgICAgYXBwcm92YWxzOiBbMCwgMV0sIC8vIEFwcHJvdmUgb3B0aW9uLTEgYW5kIG9wdGlvbi0yXG4gICAgICAgICAgcmFua2luZ3M6IG51bGwsXG4gICAgICAgICAgYWxsb2NhdGlvbnM6IG51bGwsXG4gICAgICAgICAgcmF0aW5nczogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKGFwcHJvdmFsUmVxdWVzdCwgYXBwcm92YWxQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHF1YWRyYXRpYyB2b3RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHF1YWRyYXRpY1BvbGwgPSB7IC4uLm1vY2tQb2xsLCB2b3RpbmdNZXRob2Q6ICdxdWFkcmF0aWMnIGFzIFZvdGluZ01ldGhvZCB9XG4gICAgICBjb25zdCBxdWFkcmF0aWNSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHZvdGVEYXRhOiB7XG4gICAgICAgICAgY2hvaWNlOiBudWxsLFxuICAgICAgICAgIGFwcHJvdmFsczogbnVsbCxcbiAgICAgICAgICByYW5raW5nczogbnVsbCxcbiAgICAgICAgICBhbGxvY2F0aW9uczogeyAnb3B0aW9uLTEnOiAyLCAnb3B0aW9uLTInOiAxIH0sXG4gICAgICAgICAgcmF0aW5nczogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKHF1YWRyYXRpY1JlcXVlc3QsIHF1YWRyYXRpY1BvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVm90ZSBQcm9jZXNzaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBzaW5nbGUtY2hvaWNlIHZvdGVzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKG1vY2tWb3RlUmVxdWVzdCwgbW9ja1BvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzcG9uc2Uudm90ZUlkKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVzcG9uc2UuYXVkaXRSZWNlaXB0KS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyByYW5rZWQtY2hvaWNlIHZvdGVzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJhbmtlZFBvbGwgPSB7IC4uLm1vY2tQb2xsLCB2b3RpbmdNZXRob2Q6ICdyYW5rZWQtY2hvaWNlJyBhcyBWb3RpbmdNZXRob2QgfVxuICAgICAgY29uc3QgcmFua2VkUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0LFxuICAgICAgICB2b3RlRGF0YToge1xuICAgICAgICAgIGNob2ljZTogbnVsbCxcbiAgICAgICAgICBhcHByb3ZhbHM6IG51bGwsXG4gICAgICAgICAgcmFua2luZ3M6IFswLCAxXSwgLy8gUmFuayBvcHRpb24tMSBmaXJzdCwgb3B0aW9uLTIgc2Vjb25kXG4gICAgICAgICAgYWxsb2NhdGlvbnM6IG51bGwsXG4gICAgICAgICAgcmF0aW5nczogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKHJhbmtlZFJlcXVlc3QsIHJhbmtlZFBvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzcG9uc2Uudm90ZUlkKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZvdGUgcHJvY2Vzc2luZyBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgYSBwcm9jZXNzaW5nIGVycm9yIGJ5IGNyZWF0aW5nIGEgcG9sbCB3aXRoIGludmFsaWQgdm90aW5nIG1ldGhvZFxuICAgICAgY29uc3QgaW52YWxpZFBvbGwgPSB7IC4uLm1vY2tQb2xsLCB2b3RpbmdNZXRob2Q6ICdpbnZhbGlkLW1ldGhvZCcgYXMgYW55IH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUobW9ja1ZvdGVSZXF1ZXN0LCBpbnZhbGlkUG9sbClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzcG9uc2UuZXJyb3IpLnRvQmVEZWZpbmVkKClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdSZXN1bHRzIENhbGN1bGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2FsY3VsYXRlIHNpbmdsZS1jaG9pY2UgcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZvdGVzID0gW1xuICAgICAgICB7IGNob2ljZTogMCwgYXBwcm92YWxzOiBudWxsLCByYW5raW5nczogbnVsbCwgYWxsb2NhdGlvbnM6IG51bGwsIHJhdGluZ3M6IG51bGwgfSxcbiAgICAgICAgeyBjaG9pY2U6IDAsIGFwcHJvdmFsczogbnVsbCwgcmFua2luZ3M6IG51bGwsIGFsbG9jYXRpb25zOiBudWxsLCByYXRpbmdzOiBudWxsIH0sXG4gICAgICAgIHsgY2hvaWNlOiAxLCBhcHByb3ZhbHM6IG51bGwsIHJhbmtpbmdzOiBudWxsLCBhbGxvY2F0aW9uczogbnVsbCwgcmF0aW5nczogbnVsbCB9XG4gICAgICBdXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhtb2NrUG9sbCwgdm90ZXMpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVzdWx0cy50b3RhbFZvdGVzKS50b0JlKDMpXG4gICAgICBleHBlY3QocmVzdWx0cy5yZXN1bHRzLndpbm5lcikudG9CZSgnb3B0aW9uLTEnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSByYW5rZWQtY2hvaWNlIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByYW5rZWRQb2xsID0geyAuLi5tb2NrUG9sbCwgdm90aW5nTWV0aG9kOiAncmFua2VkLWNob2ljZScgYXMgVm90aW5nTWV0aG9kIH1cbiAgICAgIGNvbnN0IHZvdGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd2b3RlLTEnLFxuICAgICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgICB2b3RlRGF0YTogeyByYW5raW5nczogWzAsIDFdIH0sXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd2b3RlLTInLFxuICAgICAgICAgIHBvbGxJZDogJ3Rlc3QtcG9sbC1pZCcsXG4gICAgICAgICAgdXNlcklkOiAndXNlci0yJyxcbiAgICAgICAgICB2b3RlRGF0YTogeyByYW5raW5nczogWzEsIDBdIH0sXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjInLFxuICAgICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wJ1xuICAgICAgICB9XG4gICAgICBdXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhyYW5rZWRQb2xsLCB2b3RlcylcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXN1bHRzLnRvdGFsVm90ZXMpLnRvQmUoMilcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdm90ZSBzZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGVuZ2luZS5jYWxjdWxhdGVSZXN1bHRzKG1vY2tQb2xsLCBbXSlcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXN1bHRzLnRvdGFsVm90ZXMpLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXN1bHRzLnJlc3VsdHMud2lubmVyKS50b0JlTnVsbCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpZSBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2b3RlcyA9IFtcbiAgICAgICAgeyBjaG9pY2U6IDAsIGFwcHJvdmFsczogbnVsbCwgcmFua2luZ3M6IG51bGwsIGFsbG9jYXRpb25zOiBudWxsLCByYXRpbmdzOiBudWxsIH0sXG4gICAgICAgIHsgY2hvaWNlOiAxLCBhcHByb3ZhbHM6IG51bGwsIHJhbmtpbmdzOiBudWxsLCBhbGxvY2F0aW9uczogbnVsbCwgcmF0aW5nczogbnVsbCB9XG4gICAgICBdXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhtb2NrUG9sbCwgdm90ZXMpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVzdWx0cy50b3RhbFZvdGVzKS50b0JlKDIpXG4gICAgICAvLyBJbiBhIHRpZSwgdGhlIHJlc3VsdCBzaG91bGQgaW5kaWNhdGUgbm8gY2xlYXIgd2lubmVyXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgcmF0ZSBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgcmVxdWVzdHMgZnJvbSB0aGUgc2FtZSB1c2VyXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDE1IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgLi4ubW9ja1ZvdGVSZXF1ZXN0Lm1ldGFkYXRhLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoRGF0ZS5ub3coKSArIGkgKiAxMDAwKVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyByZXF1ZXN0cyBhbmQgY2hlY2sgcmF0ZSBsaW1pdGluZ1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChyZXF1ZXN0ID0+IGVuZ2luZS5wcm9jZXNzVm90ZShyZXF1ZXN0LCBtb2NrUG9sbCkpXG4gICAgICApXG4gICAgICBcbiAgICAgIC8vIFNvbWUgcmVxdWVzdHMgc2hvdWxkIGJlIHJhdGUgbGltaXRlZFxuICAgICAgY29uc3QgcmF0ZUxpbWl0ZWRSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gIXIuc3VjY2VzcyAmJiByLmVycm9yPy5pbmNsdWRlcygnUmF0ZSBsaW1pdCBleGNlZWRlZCcpKVxuICAgICAgZXhwZWN0KHJhdGVMaW1pdGVkUmVzcG9uc2VzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgYWxsb3cgcmVxdWVzdHMgd2l0aGluIHJhdGUgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdXNlcklkOiAndXNlci0xJyxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QubWV0YWRhdGEsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgaSAqIDEwMDApXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVxdWVzdHMubWFwKHJlcXVlc3QgPT4gZW5naW5lLnByb2Nlc3NWb3RlKHJlcXVlc3QsIG1vY2tQb2xsKSlcbiAgICAgIClcbiAgICAgIFxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBzdWNjZWVkIHdpdGhpbiByYXRlIGxpbWl0XG4gICAgICBjb25zdCBzdWNjZXNzZnVsUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+IHIuc3VjY2VzcylcbiAgICAgIGV4cGVjdChzdWNjZXNzZnVsUmVzcG9uc2VzLmxlbmd0aCkudG9CZSg1KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVxdWlyZSBhdXRoZW50aWNhdGlvbiB3aGVuIGNvbmZpZ3VyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1bmF1dGhlbnRpY2F0ZWRSZXF1ZXN0ID0geyAuLi5tb2NrVm90ZVJlcXVlc3QsIHVzZXJJZDogbnVsbCB9XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBlbmdpbmUudmFsaWRhdGVWb3RlKHVuYXV0aGVudGljYXRlZFJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKCdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCB0byB2b3RlJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhbm9ueW1vdXMgdm90aW5nIHdoZW4gY29uZmlndXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFub255bW91c1BvbGwgPSB7XG4gICAgICAgIC4uLm1vY2tQb2xsLFxuICAgICAgICBzZXR0aW5nczogeyAuLi5tb2NrUG9sbC5zZXR0aW5ncywgYW5vbnltb3VzVm90aW5nOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYW5vbnltb3VzUmVxdWVzdCA9IHsgLi4ubW9ja1ZvdGVSZXF1ZXN0LCB1c2VySWQ6IG51bGwgfVxuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgZW5naW5lLnZhbGlkYXRlVm90ZShhbm9ueW1vdXNSZXF1ZXN0LCBhbm9ueW1vdXNQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCB2b3RlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxmb3JtZWRSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5tb2NrVm90ZVJlcXVlc3QsXG4gICAgICAgIHZvdGVEYXRhOiBudWxsXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKG1hbGZvcm1lZFJlcXVlc3QsIG1vY2tQb2xsKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3VjY2VzcykudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChyZXNwb25zZS5lcnJvcikudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIHBvbGwgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5naW5lLnByb2Nlc3NWb3RlKG1vY2tWb3RlUmVxdWVzdCwgbnVsbCBhcyBhbnkpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmVycm9yKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSBzY2VuYXJpbyB0aGF0IHdvdWxkIGNhdXNlIGEgcHJvY2Vzc2luZyBlcnJvclxuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdm90ZURhdGE6IG51bGwgYXMgYW55IC8vIFRoaXMgc2hvdWxkIGNhdXNlIGEgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5wcm9jZXNzVm90ZShpbnZhbGlkUmVxdWVzdCwgbW9ja1BvbGwpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmVycm9yKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHZvdGVzIHdpdGhpbiByZWFzb25hYmxlIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICBhd2FpdCBlbmdpbmUucHJvY2Vzc1ZvdGUobW9ja1ZvdGVSZXF1ZXN0LCBtb2NrUG9sbClcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHByb2Nlc3Mgd2l0aGluIDEwMG1zXG4gICAgICBleHBlY3QocHJvY2Vzc2luZ1RpbWUpLnRvQmVMZXNzVGhhbigxMDApXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIHZvdGUgc2V0cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlVm90ZVNldCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIC4uLm1vY2tWb3RlUmVxdWVzdCxcbiAgICAgICAgdXNlcklkOiBgdXNlci0ke2l9YCxcbiAgICAgICAgdm90ZURhdGE6IHtcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnM6IFsnb3B0aW9uLTEnXSxcbiAgICAgICAgICByYW5raW5nOiBudWxsLFxuICAgICAgICAgIHdlaWdodHM6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbmdpbmUuY2FsY3VsYXRlUmVzdWx0cyhtb2NrUG9sbCwgbGFyZ2VWb3RlU2V0KVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHByb2Nlc3NpbmdUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCkgLy8gU2hvdWxkIHByb2Nlc3Mgd2l0aGluIDEgc2Vjb25kXG4gICAgfSlcbiAgfSlcbn0pXG5cblxuXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkZXZMb2ciLCJmbiIsImxvZ2dlciIsImluZm8iLCJlcnJvciIsIndhcm4iLCJkZWJ1ZyIsImRlc2NyaWJlIiwiZW5naW5lIiwiY29uZmlnIiwibW9ja1BvbGwiLCJtb2NrVm90ZVJlcXVlc3QiLCJiZWZvcmVFYWNoIiwibWF4Vm90ZXNQZXJQb2xsIiwiYWxsb3dNdWx0aXBsZVZvdGVzIiwicmVxdWlyZUF1dGhlbnRpY2F0aW9uIiwibWluVHJ1c3RUaWVyIiwicmF0ZUxpbWl0UGVyVXNlciIsInJhdGVMaW1pdFdpbmRvd01zIiwiVm90ZUVuZ2luZSIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInZvdGluZ01ldGhvZCIsIm9wdGlvbnMiLCJ0ZXh0Iiwic3RhdHVzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsImNsb3NlQXQiLCJub3ciLCJjcmVhdGVkQnkiLCJzZXR0aW5ncyIsImFub255bW91c1ZvdGluZyIsInBvbGxJZCIsInVzZXJJZCIsInZvdGVEYXRhIiwiY2hvaWNlIiwiYXBwcm92YWxzIiwicmFua2luZ3MiLCJhbGxvY2F0aW9ucyIsInJhdGluZ3MiLCJtZXRhZGF0YSIsImlwQWRkcmVzcyIsInVzZXJBZ2VudCIsInRpbWVzdGFtcCIsIml0IiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0JlSW5zdGFuY2VPZiIsImRlZmF1bHRFbmdpbmUiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVWb3RlIiwidmFsaWQiLCJ0b0JlIiwiZXJyb3JzIiwidG9IYXZlTGVuZ3RoIiwiaW52YWxpZFJlcXVlc3QiLCJ0b0NvbnRhaW4iLCJjbG9zZWRQb2xsIiwicmFua2VkUG9sbCIsInJhbmtlZFJlcXVlc3QiLCJhcHByb3ZhbFBvbGwiLCJhcHByb3ZhbFJlcXVlc3QiLCJxdWFkcmF0aWNQb2xsIiwicXVhZHJhdGljUmVxdWVzdCIsInJlc3BvbnNlIiwicHJvY2Vzc1ZvdGUiLCJzdWNjZXNzIiwidm90ZUlkIiwiYXVkaXRSZWNlaXB0IiwiaW52YWxpZFBvbGwiLCJ2b3RlcyIsInJlc3VsdHMiLCJjYWxjdWxhdGVSZXN1bHRzIiwidG90YWxWb3RlcyIsIndpbm5lciIsInRvSVNPU3RyaW5nIiwidG9CZU51bGwiLCJyZXF1ZXN0cyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwicmVzcG9uc2VzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInJlcXVlc3QiLCJyYXRlTGltaXRlZFJlc3BvbnNlcyIsImZpbHRlciIsInIiLCJpbmNsdWRlcyIsInRvQmVHcmVhdGVyVGhhbiIsInN1Y2Nlc3NmdWxSZXNwb25zZXMiLCJ1bmF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwiYW5vbnltb3VzUG9sbCIsImFub255bW91c1JlcXVlc3QiLCJtYWxmb3JtZWRSZXF1ZXN0Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJlbmRUaW1lIiwicHJvY2Vzc2luZ1RpbWUiLCJ0b0JlTGVzc1RoYW4iLCJsYXJnZVZvdGVTZXQiLCJzZWxlY3RlZE9wdGlvbnMiLCJyYW5raW5nIiwid2VpZ2h0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRXNEO3dCQUNMO0FBR2xELGtCQUFrQjtBQUNsQkEsYUFBSSxDQUFDQyxJQUFJLENBQUMsc0JBQXNCLElBQU8sQ0FBQTtRQUNyQ0MsUUFBUUYsYUFBSSxDQUFDRyxFQUFFO1FBQ2ZDLFFBQVE7WUFDTkMsTUFBTUwsYUFBSSxDQUFDRyxFQUFFO1lBQ2JHLE9BQU9OLGFBQUksQ0FBQ0csRUFBRTtZQUNkSSxNQUFNUCxhQUFJLENBQUNHLEVBQUU7WUFDYkssT0FBT1IsYUFBSSxDQUFDRyxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTtBQUVBTSxJQUFBQSxpQkFBUSxFQUFDLGNBQWM7SUFDckIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsSUFBQUEsbUJBQVUsRUFBQztRQUNUSCxTQUFTO1lBQ1BJLGlCQUFpQjtZQUNqQkMsb0JBQW9CO1lBQ3BCQyx1QkFBdUI7WUFDdkJDLGNBQWM7WUFDZEMsa0JBQWtCO1lBQ2xCQyxtQkFBbUI7UUFDckI7UUFFQVYsU0FBUyxJQUFJVyxrQkFBVSxDQUFDVjtRQUV4QkMsV0FBVztZQUNUVSxJQUFJO1lBQ0pDLE9BQU87WUFDUEMsYUFBYTtZQUNiQyxjQUFjO1lBQ2RDLFNBQVM7Z0JBQ1A7b0JBQUVKLElBQUk7b0JBQVlLLE1BQU07Z0JBQVc7Z0JBQ25DO29CQUFFTCxJQUFJO29CQUFZSyxNQUFNO2dCQUFXO2FBQ3BDO1lBQ0RDLFFB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