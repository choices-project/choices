d8ff61a506322dd66799efb3438ce09a
/**
 * Integration Tests - API + Database (20% of tests)
 * 
 * These tests focus on how components work together.
 * Test API endpoints with real database operations.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _route = require("../../../../app/api/polls/route");
const _databasetestutils = require("../../../helpers/database-test-utils");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Use real test database
let supabase;
let testUser;
(0, _globals.describe)('Integration Tests - API + Database', ()=>{
    let testUser;
    let testPollId = null;
    (0, _globals.beforeAll)(async ()=>{
        // Setup real test database with proper integration testing
        supabase = await (0, _databasetestutils.setupTestDatabase)();
        testUser = await (0, _databasetestutils.createTestUser)(supabase);
        console.log('Integration: Test database setup complete');
    });
    (0, _globals.afterAll)(async ()=>{
        // Clean up test database with proper cleanup
        await (0, _databasetestutils.cleanupTestDatabase)(supabase);
        console.log('Integration: Test database cleanup complete');
    });
    (0, _globals.beforeEach)(()=>{
        // Reset test poll ID
        testPollId = null;
    });
    (0, _globals.afterEach)(async ()=>{
        if (!supabase) return;
        // Clean up any test data created during the test
        if (testPollId) {
            await supabase.from('polls').delete().eq('id', testPollId);
            testPollId = null;
        }
    });
    (0, _globals.describe)('API + Database Integration', ()=>{
        (0, _globals.it)('should create poll and retrieve it via API', async ()=>{
            // Integration test: API + Database
            // 1. Create poll via database using actual schema
            const pollData = {
                title: 'Integration Test Poll',
                description: 'A test poll for integration testing',
                options: [
                    'Integration Option 1',
                    'Integration Option 2'
                ],
                voting_method: 'single',
                privacy_level: 'public',
                category: 'test',
                tags: [
                    'integration',
                    'test'
                ],
                created_by: testUser.id,
                status: 'active',
                total_votes: 0,
                participation: 0,
                sponsors: [],
                settings: {},
                hashtags: [],
                poll_settings: {}
            };
            // Use service role key for database operations
            const { createClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("@supabase/supabase-js")));
            const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            if (!supabaseUrl || !supabaseKey) {
                throw new Error('Supabase service role credentials not found');
            }
            const serviceSupabase = createClient(supabaseUrl, supabaseKey);
            const { data: createdPoll, error: createError } = await serviceSupabase.from('polls').insert(pollData).select().single();
            console.log('Poll creation result:', {
                createdPoll,
                createError
            });
            if (createError) {
                console.warn('Database insert error:', createError);
                // Check if it's a schema issue
                if (createError.message.includes('column') || createError.message.includes('relation')) {
                    console.warn('Database schema issue detected:', createError.message);
                    (0, _globals.expect)(createError).toBeDefined();
                    return;
                }
            }
            // Check if data was actually inserted by querying the database
            const { data: allPolls, error: queryError } = await serviceSupabase.from('polls').select('*').eq('title', 'Integration Test Poll');
            console.log('Query result after insert:', {
                allPolls,
                queryError
            });
            (0, _globals.expect)(createError).toBeNull();
            (0, _globals.expect)(queryError).toBeNull();
            // Handle the response format - data might be nested
            const pollsData = Array.isArray(allPolls) ? allPolls : allPolls?.data || [];
            (0, _globals.expect)(pollsData).toBeDefined();
            (0, _globals.expect)(pollsData.length).toBeGreaterThan(0);
            (0, _globals.expect)(pollsData[0].title).toBe('Integration Test Poll');
            // Store for cleanup
            testPollId = createdPoll.id;
            (0, _databasetestutils.trackTestData)('polls', createdPoll.id);
            // 2. Retrieve poll via API
            const request = new _server.NextRequest('http://localhost:3000/api/polls');
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            console.log('Integration: API response:', responseData);
            // 3. Verify integration
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.success).toBe(true);
            (0, _globals.expect)(Array.isArray(responseData.polls)).toBe(true);
            // Check if our created poll is in the results
            const foundPoll = responseData.polls.find((poll)=>poll.poll_id === createdPoll.id);
            (0, _globals.expect)(foundPoll).toBeDefined();
        });
        (0, _globals.it)('should handle poll creation with voting integration', async ()=>{
            if (!supabase) {
                console.warn('Skipping test - Real Supabase credentials not set up');
                return;
            }
            // Integration test: Poll creation + Voting
            // 1. Create poll using actual schema
            const pollData = {
                title: 'Voting Integration Poll',
                description: 'A poll for testing voting integration',
                options: [
                    'Vote Option 1',
                    'Vote Option 2'
                ],
                voting_method: 'single',
                privacy_level: 'public',
                category: 'test',
                tags: [
                    'voting',
                    'integration'
                ],
                created_by: testUser.id,
                status: 'active',
                total_votes: 0,
                participation: 0,
                sponsors: [],
                settings: {},
                hashtags: [],
                poll_settings: {}
            };
            const { data: poll, error: pollError } = await supabase.from('polls').insert(pollData).select().single();
            (0, _globals.expect)(pollError).toBeNull();
            (0, _globals.expect)(poll).toBeDefined();
            // Store for cleanup
            testPollId = poll.id;
            // 2. Add votes using actual schema
            const voteData = {
                poll_id: poll.id,
                user_id: testUser.id,
                choice: 0,
                voting_method: 'single',
                vote_data: {
                    choice: 0
                },
                is_verified: true,
                is_active: true
            };
            const { data: vote, error: voteError } = await supabase.from('votes').insert(voteData).select().single();
            (0, _globals.expect)(voteError).toBeNull();
            (0, _globals.expect)(vote).toBeDefined();
            // 3. Update poll vote count
            const { data: updatedPoll, error: updateError } = await supabase.from('polls').update({
                total_votes: 1
            }).eq('id', poll.id).select().single();
            (0, _globals.expect)(updateError).toBeNull();
            (0, _globals.expect)(updatedPoll.total_votes).toBe(1);
            // 4. Verify integration
            const { data: finalPoll, error: finalError } = await supabase.from('polls').select('*').eq('id', poll.id).single();
            (0, _globals.expect)(finalError).toBeNull();
            (0, _globals.expect)(finalPoll.total_votes).toBe(1);
        });
        (0, _globals.it)('should handle poll results calculation integration', async ()=>{
            if (!supabase) {
                console.warn('Skipping test - Real Supabase credentials not set up');
                return;
            }
            // Integration test: Poll + Votes + Results
            // 1. Create poll using actual schema
            const pollData = {
                title: 'Results Integration Poll',
                description: 'A poll for testing results calculation',
                options: [
                    'Results Option 1',
                    'Results Option 2'
                ],
                voting_method: 'single',
                privacy_level: 'public',
                category: 'test',
                tags: [
                    'results',
                    'integration'
                ],
                created_by: testUser.id,
                status: 'active',
                total_votes: 0,
                participation: 0,
                sponsors: [],
                settings: {},
                hashtags: [],
                poll_settings: {}
            };
            const { data: poll, error: pollError } = await supabase.from('polls').insert(pollData).select().single();
            (0, _globals.expect)(pollError).toBeNull();
            (0, _globals.expect)(poll).toBeDefined();
            // Store for cleanup
            testPollId = poll.id;
            // 2. Add multiple votes using actual schema
            const votes = [
                {
                    poll_id: poll.id,
                    user_id: testUser.id,
                    choice: 0,
                    voting_method: 'single',
                    vote_data: {
                        choice: 0
                    },
                    is_verified: true,
                    is_active: true
                },
                {
                    poll_id: poll.id,
                    user_id: 'user2',
                    choice: 0,
                    voting_method: 'single',
                    vote_data: {
                        choice: 0
                    },
                    is_verified: true,
                    is_active: true
                },
                {
                    poll_id: poll.id,
                    user_id: 'user3',
                    choice: 1,
                    voting_method: 'single',
                    vote_data: {
                        choice: 1
                    },
                    is_verified: true,
                    is_active: true
                }
            ];
            for (const vote of votes){
                const { error: voteError } = await supabase.from('votes').insert(vote);
                (0, _globals.expect)(voteError).toBeNull();
            }
            // 3. Calculate results
            const { data: allVotes, error: votesError } = await supabase.from('votes').select('*').eq('poll_id', poll.id);
            (0, _globals.expect)(votesError).toBeNull();
            (0, _globals.expect)(allVotes).toHaveLength(3);
            // 4. Verify integration
            const option1Votes = allVotes.filter((vote)=>vote.choice === 0).length;
            const option2Votes = allVotes.filter((vote)=>vote.choice === 1).length;
            (0, _globals.expect)(option1Votes).toBe(2);
            (0, _globals.expect)(option2Votes).toBe(1);
        });
    });
    (0, _globals.describe)('API Error Handling Integration', ()=>{
        (0, _globals.it)('should handle database errors gracefully', async ()=>{
            if (!supabase) {
                console.warn('Skipping test - Real Supabase credentials not set up');
                return;
            }
            // Integration test: API error handling
            // 1. Test invalid poll data
            const invalidPollData = {
                // Missing required fields
                options: [
                    {
                        text: 'Invalid Option 1'
                    }
                ],
                created_by: testUser.id
            };
            const { data, error } = await supabase.from('polls').insert(invalidPollData).select().single();
            // 2. Verify error handling
            (0, _globals.expect)(error).not.toBeNull();
            (0, _globals.expect)(error.message).toContain('title');
            // 3. Test API error response
            const request = new _server.NextRequest('http://localhost:3000/api/polls');
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            // API should still work despite database error
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.success).toBe(true);
        });
        (0, _globals.it)('should handle authentication errors integration', async ()=>{
            if (!supabase) {
                console.warn('Skipping test - Real Supabase credentials not set up');
                return;
            }
            // Integration test: Authentication + API
            // 1. Test with invalid user
            const { data, error } = await supabase.auth.signInWithPassword({
                email: 'invalid@example.com',
                password: 'invalidpassword'
            });
            // 2. Verify authentication error
            (0, _globals.expect)(error).not.toBeNull();
            (0, _globals.expect)(error.message).toContain('Invalid login credentials');
            // 3. Test API with invalid authentication
            const request = new _server.NextRequest('http://localhost:3000/api/polls');
            const response = await (0, _route.GET)(request);
            const responseData = await response.json();
            // API should still work (public endpoint)
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(responseData.success).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L2ludGVncmF0aW9uL2FwaS9wb2xscy1pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZWdyYXRpb24gVGVzdHMgLSBBUEkgKyBEYXRhYmFzZSAoMjAlIG9mIHRlc3RzKVxuICogXG4gKiBUaGVzZSB0ZXN0cyBmb2N1cyBvbiBob3cgY29tcG9uZW50cyB3b3JrIHRvZ2V0aGVyLlxuICogVGVzdCBBUEkgZW5kcG9pbnRzIHdpdGggcmVhbCBkYXRhYmFzZSBvcGVyYXRpb25zLlxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVBbGwsIGFmdGVyQWxsLCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgR0VULCBQT1NUIH0gZnJvbSAnQC9hcHAvYXBpL3BvbGxzL3JvdXRlJztcbmltcG9ydCB7IFxuICBzZXR1cFRlc3REYXRhYmFzZSwgXG4gIGNyZWF0ZVRlc3RVc2VyLCBcbiAgdHJhY2tUZXN0RGF0YSxcbiAgY2xlYW51cFRlc3REYXRhYmFzZSBcbn0gZnJvbSAnLi4vLi4vLi4vaGVscGVycy9kYXRhYmFzZS10ZXN0LXV0aWxzJztcblxuLy8gVXNlIHJlYWwgdGVzdCBkYXRhYmFzZVxubGV0IHN1cGFiYXNlOiBhbnk7XG5sZXQgdGVzdFVzZXI6IGFueTtcblxuZGVzY3JpYmUoJ0ludGVncmF0aW9uIFRlc3RzIC0gQVBJICsgRGF0YWJhc2UnLCAoKSA9PiB7XG4gIGxldCB0ZXN0VXNlcjogYW55O1xuICBsZXQgdGVzdFBvbGxJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAvLyBTZXR1cCByZWFsIHRlc3QgZGF0YWJhc2Ugd2l0aCBwcm9wZXIgaW50ZWdyYXRpb24gdGVzdGluZ1xuICAgIHN1cGFiYXNlID0gYXdhaXQgc2V0dXBUZXN0RGF0YWJhc2UoKTtcbiAgICB0ZXN0VXNlciA9IGF3YWl0IGNyZWF0ZVRlc3RVc2VyKHN1cGFiYXNlKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnSW50ZWdyYXRpb246IFRlc3QgZGF0YWJhc2Ugc2V0dXAgY29tcGxldGUnKTtcbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIHRlc3QgZGF0YWJhc2Ugd2l0aCBwcm9wZXIgY2xlYW51cFxuICAgIGF3YWl0IGNsZWFudXBUZXN0RGF0YWJhc2Uoc3VwYWJhc2UpO1xuICAgIGNvbnNvbGUubG9nKCdJbnRlZ3JhdGlvbjogVGVzdCBkYXRhYmFzZSBjbGVhbnVwIGNvbXBsZXRlJyk7XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIFJlc2V0IHRlc3QgcG9sbCBJRFxuICAgIHRlc3RQb2xsSWQgPSBudWxsO1xuICB9KTtcblxuICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc3VwYWJhc2UpIHJldHVybjtcblxuICAgIC8vIENsZWFuIHVwIGFueSB0ZXN0IGRhdGEgY3JlYXRlZCBkdXJpbmcgdGhlIHRlc3RcbiAgICBpZiAodGVzdFBvbGxJZCkge1xuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgncG9sbHMnKS5kZWxldGUoKS5lcSgnaWQnLCB0ZXN0UG9sbElkKTtcbiAgICAgIHRlc3RQb2xsSWQgPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FQSSArIERhdGFiYXNlIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIHBvbGwgYW5kIHJldHJpZXZlIGl0IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG5cbiAgICAgIC8vIEludGVncmF0aW9uIHRlc3Q6IEFQSSArIERhdGFiYXNlXG4gICAgICAvLyAxLiBDcmVhdGUgcG9sbCB2aWEgZGF0YWJhc2UgdXNpbmcgYWN0dWFsIHNjaGVtYVxuICAgICAgY29uc3QgcG9sbERhdGEgPSB7XG4gICAgICAgIHRpdGxlOiAnSW50ZWdyYXRpb24gVGVzdCBQb2xsJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBIHRlc3QgcG9sbCBmb3IgaW50ZWdyYXRpb24gdGVzdGluZycsXG4gICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAnSW50ZWdyYXRpb24gT3B0aW9uIDEnLFxuICAgICAgICAgICdJbnRlZ3JhdGlvbiBPcHRpb24gMidcbiAgICAgICAgXSxcbiAgICAgICAgdm90aW5nX21ldGhvZDogJ3NpbmdsZScsXG4gICAgICAgIHByaXZhY3lfbGV2ZWw6ICdwdWJsaWMnLFxuICAgICAgICBjYXRlZ29yeTogJ3Rlc3QnLFxuICAgICAgICB0YWdzOiBbJ2ludGVncmF0aW9uJywgJ3Rlc3QnXSxcbiAgICAgICAgY3JlYXRlZF9ieTogdGVzdFVzZXIuaWQsXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIHRvdGFsX3ZvdGVzOiAwLFxuICAgICAgICBwYXJ0aWNpcGF0aW9uOiAwLFxuICAgICAgICBzcG9uc29yczogW10sXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgaGFzaHRhZ3M6IFtdLFxuICAgICAgICBwb2xsX3NldHRpbmdzOiB7fVxuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHNlcnZpY2Ugcm9sZSBrZXkgZm9yIGRhdGFiYXNlIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHsgY3JlYXRlQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuICAgICAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9VUkwgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICAgICAgY29uc3Qgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuICAgICAgXG4gICAgICBpZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cGFiYXNlIHNlcnZpY2Ugcm9sZSBjcmVkZW50aWFscyBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2VydmljZVN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSk7XG5cbiAgICAgIGNvbnN0IHsgZGF0YTogY3JlYXRlZFBvbGwsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc2VydmljZVN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwb2xscycpXG4gICAgICAgIC5pbnNlcnQocG9sbERhdGEpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQb2xsIGNyZWF0aW9uIHJlc3VsdDonLCB7IGNyZWF0ZWRQb2xsLCBjcmVhdGVFcnJvciB9KTtcbiAgICAgIFxuICAgICAgaWYgKGNyZWF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGF0YWJhc2UgaW5zZXJ0IGVycm9yOicsIGNyZWF0ZUVycm9yKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHNjaGVtYSBpc3N1ZVxuICAgICAgICBpZiAoY3JlYXRlRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY29sdW1uJykgfHwgY3JlYXRlRXJyb3IubWVzc2FnZS5pbmNsdWRlcygncmVsYXRpb24nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRGF0YWJhc2Ugc2NoZW1hIGlzc3VlIGRldGVjdGVkOicsIGNyZWF0ZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIGV4cGVjdChjcmVhdGVFcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZGF0YSB3YXMgYWN0dWFsbHkgaW5zZXJ0ZWQgYnkgcXVlcnlpbmcgdGhlIGRhdGFiYXNlXG4gICAgICBjb25zdCB7IGRhdGE6IGFsbFBvbGxzLCBlcnJvcjogcXVlcnlFcnJvciB9ID0gYXdhaXQgc2VydmljZVN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwb2xscycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3RpdGxlJywgJ0ludGVncmF0aW9uIFRlc3QgUG9sbCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnUXVlcnkgcmVzdWx0IGFmdGVyIGluc2VydDonLCB7IGFsbFBvbGxzLCBxdWVyeUVycm9yIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QoY3JlYXRlRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocXVlcnlFcnJvcikudG9CZU51bGwoKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHRoZSByZXNwb25zZSBmb3JtYXQgLSBkYXRhIG1pZ2h0IGJlIG5lc3RlZFxuICAgICAgY29uc3QgcG9sbHNEYXRhID0gQXJyYXkuaXNBcnJheShhbGxQb2xscykgPyBhbGxQb2xscyA6IChhbGxQb2xscz8uZGF0YSB8fCBbXSk7XG4gICAgICBleHBlY3QocG9sbHNEYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHBvbGxzRGF0YS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChwb2xsc0RhdGFbMF0udGl0bGUpLnRvQmUoJ0ludGVncmF0aW9uIFRlc3QgUG9sbCcpO1xuXG4gICAgICAvLyBTdG9yZSBmb3IgY2xlYW51cFxuICAgICAgdGVzdFBvbGxJZCA9IGNyZWF0ZWRQb2xsLmlkO1xuICAgICAgdHJhY2tUZXN0RGF0YSgncG9sbHMnLCBjcmVhdGVkUG9sbC5pZCk7XG5cbiAgICAgIC8vIDIuIFJldHJpZXZlIHBvbGwgdmlhIEFQSVxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdJbnRlZ3JhdGlvbjogQVBJIHJlc3BvbnNlOicsIHJlc3BvbnNlRGF0YSk7XG5cbiAgICAgIC8vIDMuIFZlcmlmeSBpbnRlZ3JhdGlvblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzcG9uc2VEYXRhLnBvbGxzKSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgb3VyIGNyZWF0ZWQgcG9sbCBpcyBpbiB0aGUgcmVzdWx0c1xuICAgICAgY29uc3QgZm91bmRQb2xsID0gcmVzcG9uc2VEYXRhLnBvbGxzLmZpbmQoKHBvbGw6IGFueSkgPT4gcG9sbC5wb2xsX2lkID09PSBjcmVhdGVkUG9sbC5pZCk7XG4gICAgICBleHBlY3QoZm91bmRQb2xsKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcG9sbCBjcmVhdGlvbiB3aXRoIHZvdGluZyBpbnRlZ3JhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghc3VwYWJhc2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTa2lwcGluZyB0ZXN0IC0gUmVhbCBTdXBhYmFzZSBjcmVkZW50aWFscyBub3Qgc2V0IHVwJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZWdyYXRpb24gdGVzdDogUG9sbCBjcmVhdGlvbiArIFZvdGluZ1xuICAgICAgLy8gMS4gQ3JlYXRlIHBvbGwgdXNpbmcgYWN0dWFsIHNjaGVtYVxuICAgICAgY29uc3QgcG9sbERhdGEgPSB7XG4gICAgICAgIHRpdGxlOiAnVm90aW5nIEludGVncmF0aW9uIFBvbGwnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0EgcG9sbCBmb3IgdGVzdGluZyB2b3RpbmcgaW50ZWdyYXRpb24nLFxuICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgJ1ZvdGUgT3B0aW9uIDEnLFxuICAgICAgICAgICdWb3RlIE9wdGlvbiAyJ1xuICAgICAgICBdLFxuICAgICAgICB2b3RpbmdfbWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgICAgcHJpdmFjeV9sZXZlbDogJ3B1YmxpYycsXG4gICAgICAgIGNhdGVnb3J5OiAndGVzdCcsXG4gICAgICAgIHRhZ3M6IFsndm90aW5nJywgJ2ludGVncmF0aW9uJ10sXG4gICAgICAgIGNyZWF0ZWRfYnk6IHRlc3RVc2VyLmlkLFxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICB0b3RhbF92b3RlczogMCxcbiAgICAgICAgcGFydGljaXBhdGlvbjogMCxcbiAgICAgICAgc3BvbnNvcnM6IFtdLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIGhhc2h0YWdzOiBbXSxcbiAgICAgICAgcG9sbF9zZXR0aW5nczoge31cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgZGF0YTogcG9sbCwgZXJyb3I6IHBvbGxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BvbGxzJylcbiAgICAgICAgLmluc2VydChwb2xsRGF0YSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgZXhwZWN0KHBvbGxFcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChwb2xsKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBTdG9yZSBmb3IgY2xlYW51cFxuICAgICAgdGVzdFBvbGxJZCA9IHBvbGwuaWQ7XG5cbiAgICAgIC8vIDIuIEFkZCB2b3RlcyB1c2luZyBhY3R1YWwgc2NoZW1hXG4gICAgICBjb25zdCB2b3RlRGF0YSA9IHtcbiAgICAgICAgcG9sbF9pZDogcG9sbC5pZCxcbiAgICAgICAgdXNlcl9pZDogdGVzdFVzZXIuaWQsXG4gICAgICAgIGNob2ljZTogMCxcbiAgICAgICAgdm90aW5nX21ldGhvZDogJ3NpbmdsZScsXG4gICAgICAgIHZvdGVfZGF0YToge1xuICAgICAgICAgIGNob2ljZTogMFxuICAgICAgICB9LFxuICAgICAgICBpc192ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGE6IHZvdGUsIGVycm9yOiB2b3RlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2b3RlcycpXG4gICAgICAgIC5pbnNlcnQodm90ZURhdGEpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGV4cGVjdCh2b3RlRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3Qodm90ZSkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gMy4gVXBkYXRlIHBvbGwgdm90ZSBjb3VudFxuICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkUG9sbCwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncG9sbHMnKVxuICAgICAgICAudXBkYXRlKHsgdG90YWxfdm90ZXM6IDEgfSlcbiAgICAgICAgLmVxKCdpZCcsIHBvbGwuaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGV4cGVjdCh1cGRhdGVFcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVkUG9sbC50b3RhbF92b3RlcykudG9CZSgxKTtcblxuICAgICAgLy8gNC4gVmVyaWZ5IGludGVncmF0aW9uXG4gICAgICBjb25zdCB7IGRhdGE6IGZpbmFsUG9sbCwgZXJyb3I6IGZpbmFsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwb2xscycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcG9sbC5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBleHBlY3QoZmluYWxFcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChmaW5hbFBvbGwudG90YWxfdm90ZXMpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwb2xsIHJlc3VsdHMgY2FsY3VsYXRpb24gaW50ZWdyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXN1cGFiYXNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2tpcHBpbmcgdGVzdCAtIFJlYWwgU3VwYWJhc2UgY3JlZGVudGlhbHMgbm90IHNldCB1cCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVncmF0aW9uIHRlc3Q6IFBvbGwgKyBWb3RlcyArIFJlc3VsdHNcbiAgICAgIC8vIDEuIENyZWF0ZSBwb2xsIHVzaW5nIGFjdHVhbCBzY2hlbWFcbiAgICAgIGNvbnN0IHBvbGxEYXRhID0ge1xuICAgICAgICB0aXRsZTogJ1Jlc3VsdHMgSW50ZWdyYXRpb24gUG9sbCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBwb2xsIGZvciB0ZXN0aW5nIHJlc3VsdHMgY2FsY3VsYXRpb24nLFxuICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgJ1Jlc3VsdHMgT3B0aW9uIDEnLFxuICAgICAgICAgICdSZXN1bHRzIE9wdGlvbiAyJ1xuICAgICAgICBdLFxuICAgICAgICB2b3RpbmdfbWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgICAgcHJpdmFjeV9sZXZlbDogJ3B1YmxpYycsXG4gICAgICAgIGNhdGVnb3J5OiAndGVzdCcsXG4gICAgICAgIHRhZ3M6IFsncmVzdWx0cycsICdpbnRlZ3JhdGlvbiddLFxuICAgICAgICBjcmVhdGVkX2J5OiB0ZXN0VXNlci5pZCxcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgdG90YWxfdm90ZXM6IDAsXG4gICAgICAgIHBhcnRpY2lwYXRpb246IDAsXG4gICAgICAgIHNwb25zb3JzOiBbXSxcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBoYXNodGFnczogW10sXG4gICAgICAgIHBvbGxfc2V0dGluZ3M6IHt9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGE6IHBvbGwsIGVycm9yOiBwb2xsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwb2xscycpXG4gICAgICAgIC5pbnNlcnQocG9sbERhdGEpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGV4cGVjdChwb2xsRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocG9sbCkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gU3RvcmUgZm9yIGNsZWFudXBcbiAgICAgIHRlc3RQb2xsSWQgPSBwb2xsLmlkO1xuXG4gICAgICAvLyAyLiBBZGQgbXVsdGlwbGUgdm90ZXMgdXNpbmcgYWN0dWFsIHNjaGVtYVxuICAgICAgY29uc3Qgdm90ZXMgPSBbXG4gICAgICAgIHsgXG4gICAgICAgICAgcG9sbF9pZDogcG9sbC5pZCwgXG4gICAgICAgICAgdXNlcl9pZDogdGVzdFVzZXIuaWQsIFxuICAgICAgICAgIGNob2ljZTogMCxcbiAgICAgICAgICB2b3RpbmdfbWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgICAgICB2b3RlX2RhdGE6IHsgY2hvaWNlOiAwIH0sXG4gICAgICAgICAgaXNfdmVyaWZpZWQ6IHRydWUsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHsgXG4gICAgICAgICAgcG9sbF9pZDogcG9sbC5pZCwgXG4gICAgICAgICAgdXNlcl9pZDogJ3VzZXIyJywgXG4gICAgICAgICAgY2hvaWNlOiAwLFxuICAgICAgICAgIHZvdGluZ19tZXRob2Q6ICdzaW5nbGUnLFxuICAgICAgICAgIHZvdGVfZGF0YTogeyBjaG9pY2U6IDAgfSxcbiAgICAgICAgICBpc192ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgeyBcbiAgICAgICAgICBwb2xsX2lkOiBwb2xsLmlkLCBcbiAgICAgICAgICB1c2VyX2lkOiAndXNlcjMnLCBcbiAgICAgICAgICBjaG9pY2U6IDEsXG4gICAgICAgICAgdm90aW5nX21ldGhvZDogJ3NpbmdsZScsXG4gICAgICAgICAgdm90ZV9kYXRhOiB7IGNob2ljZTogMSB9LFxuICAgICAgICAgIGlzX3ZlcmlmaWVkOiB0cnVlLFxuICAgICAgICAgIGlzX2FjdGl2ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHZvdGUgb2Ygdm90ZXMpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogdm90ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2b3RlcycpXG4gICAgICAgICAgLmluc2VydCh2b3RlKTtcblxuICAgICAgICBleHBlY3Qodm90ZUVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBDYWxjdWxhdGUgcmVzdWx0c1xuICAgICAgY29uc3QgeyBkYXRhOiBhbGxWb3RlcywgZXJyb3I6IHZvdGVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2b3RlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3BvbGxfaWQnLCBwb2xsLmlkKTtcblxuICAgICAgZXhwZWN0KHZvdGVzRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoYWxsVm90ZXMpLnRvSGF2ZUxlbmd0aCgzKTtcblxuICAgICAgLy8gNC4gVmVyaWZ5IGludGVncmF0aW9uXG4gICAgICBjb25zdCBvcHRpb24xVm90ZXMgPSBhbGxWb3Rlcy5maWx0ZXIoKHZvdGU6IGFueSkgPT4gdm90ZS5jaG9pY2UgPT09IDApLmxlbmd0aDtcbiAgICAgIGNvbnN0IG9wdGlvbjJWb3RlcyA9IGFsbFZvdGVzLmZpbHRlcigodm90ZTogYW55KSA9PiB2b3RlLmNob2ljZSA9PT0gMSkubGVuZ3RoO1xuXG4gICAgICBleHBlY3Qob3B0aW9uMVZvdGVzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KG9wdGlvbjJWb3RlcykudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FQSSBFcnJvciBIYW5kbGluZyBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghc3VwYWJhc2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTa2lwcGluZyB0ZXN0IC0gUmVhbCBTdXBhYmFzZSBjcmVkZW50aWFscyBub3Qgc2V0IHVwJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZWdyYXRpb24gdGVzdDogQVBJIGVycm9yIGhhbmRsaW5nXG4gICAgICAvLyAxLiBUZXN0IGludmFsaWQgcG9sbCBkYXRhXG4gICAgICBjb25zdCBpbnZhbGlkUG9sbERhdGEgPSB7XG4gICAgICAgIC8vIE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzXG4gICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICB7IHRleHQ6ICdJbnZhbGlkIE9wdGlvbiAxJyB9XG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZWRfYnk6IHRlc3RVc2VyLmlkXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncG9sbHMnKVxuICAgICAgICAuaW5zZXJ0KGludmFsaWRQb2xsRGF0YSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgLy8gMi4gVmVyaWZ5IGVycm9yIGhhbmRsaW5nXG4gICAgICBleHBlY3QoZXJyb3IpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbigndGl0bGUnKTtcblxuICAgICAgLy8gMy4gVGVzdCBBUEkgZXJyb3IgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcG9sbHMnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBUEkgc2hvdWxkIHN0aWxsIHdvcmsgZGVzcGl0ZSBkYXRhYmFzZSBlcnJvclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXV0aGVudGljYXRpb24gZXJyb3JzIGludGVncmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFzdXBhYmFzZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIHRlc3QgLSBSZWFsIFN1cGFiYXNlIGNyZWRlbnRpYWxzIG5vdCBzZXQgdXAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlZ3JhdGlvbiB0ZXN0OiBBdXRoZW50aWNhdGlvbiArIEFQSVxuICAgICAgLy8gMS4gVGVzdCB3aXRoIGludmFsaWQgdXNlclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ2ludmFsaWRAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ2ludmFsaWRwYXNzd29yZCdcbiAgICAgIH0pO1xuXG4gICAgICAvLyAyLiBWZXJpZnkgYXV0aGVudGljYXRpb24gZXJyb3JcbiAgICAgIGV4cGVjdChlcnJvcikubm90LnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdJbnZhbGlkIGxvZ2luIGNyZWRlbnRpYWxzJyk7XG5cbiAgICAgIC8vIDMuIFRlc3QgQVBJIHdpdGggaW52YWxpZCBhdXRoZW50aWNhdGlvblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wb2xscycpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFQSSBzaG91bGQgc3RpbGwgd29yayAocHVibGljIGVuZHBvaW50KVxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlRGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwidGVzdFVzZXIiLCJkZXNjcmliZSIsInRlc3RQb2xsSWQiLCJiZWZvcmVBbGwiLCJzZXR1cFRlc3REYXRhYmFzZSIsImNyZWF0ZVRlc3RVc2VyIiwiY29uc29sZSIsImxvZyIsImFmdGVyQWxsIiwiY2xlYW51cFRlc3REYXRhYmFzZSIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJmcm9tIiwiZGVsZXRlIiwiZXEiLCJpdCIsInBvbGxEYXRhIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsIm9wdGlvbnMiLCJ2b3RpbmdfbWV0aG9kIiwicHJpdmFjeV9sZXZlbCIsImNhdGVnb3J5IiwidGFncyIsImNyZWF0ZWRfYnkiLCJpZCIsInN0YXR1cyIsInRvdGFsX3ZvdGVzIiwicGFydGljaXBhdGlvbiIsInNwb25zb3JzIiwic2V0dGluZ3MiLCJoYXNodGFncyIsInBvbGxfc2V0dGluZ3MiLCJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJTVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUtleSIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJFcnJvciIsInNlcnZpY2VTdXBhYmFzZSIsImRhdGEiLCJjcmVhdGVkUG9sbCIsImVycm9yIiwiY3JlYXRlRXJyb3IiLCJpbnNlcnQiLCJzZWxlY3QiLCJzaW5nbGUiLCJ3YXJuIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJhbGxQb2xscyIsInF1ZXJ5RXJyb3IiLCJ0b0JlTnVsbCIsInBvbGxzRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmUiLCJ0cmFja1Rlc3REYXRhIiwicmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwicmVzcG9uc2UiLCJHRVQiLCJyZXNwb25zZURhdGEiLCJqc29uIiwic3VjY2VzcyIsInBvbGxzIiwiZm91bmRQb2xsIiwiZmluZCIsInBvbGwiLCJwb2xsX2lkIiwicG9sbEVycm9yIiwidm90ZURhdGEiLCJ1c2VyX2lkIiwiY2hvaWNlIiwidm90ZV9kYXRhIiwiaXNfdmVyaWZpZWQiLCJpc19hY3RpdmUiLCJ2b3RlIiwidm90ZUVycm9yIiwidXBkYXRlZFBvbGwiLCJ1cGRhdGVFcnJvciIsInVwZGF0ZSIsImZpbmFsUG9sbCIsImZpbmFsRXJyb3IiLCJ2b3RlcyIsImFsbFZvdGVzIiwidm90ZXNFcnJvciIsInRvSGF2ZUxlbmd0aCIsIm9wdGlvbjFWb3RlcyIsImZpbHRlciIsIm9wdGlvbjJWb3RlcyIsImludmFsaWRQb2xsRGF0YSIsInRleHQiLCJub3QiLCJ0b0NvbnRhaW4iLCJhdXRoIiwic2lnbkluV2l0aFBhc3N3b3JkIiwiZW1haWwiLCJwYXNzd29yZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRWdGO3dCQUNyRDt1QkFDRjttQ0FNbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLHlCQUF5QjtBQUN6QixJQUFJQTtBQUNKLElBQUlDO0FBRUpDLElBQUFBLGlCQUFRLEVBQUMsc0NBQXNDO0lBQzdDLElBQUlEO0lBQ0osSUFBSUUsYUFBNEI7SUFFaENDLElBQUFBLGtCQUFTLEVBQUM7UUFDUiwyREFBMkQ7UUFDM0RKLFdBQVcsTUFBTUssSUFBQUEsb0NBQWlCO1FBQ2xDSixXQUFXLE1BQU1LLElBQUFBLGlDQUFjLEVBQUNOO1FBRWhDTyxRQUFRQyxHQUFHLENBQUM7SUFDZDtJQUVBQyxJQUFBQSxpQkFBUSxFQUFDO1FBQ1AsNkNBQTZDO1FBQzdDLE1BQU1DLElBQUFBLHNDQUFtQixFQUFDVjtRQUMxQk8sUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7SUFFQUcsSUFBQUEsbUJBQVUsRUFBQztRQUNULHFCQUFxQjtRQUNyQlIsYUFBYTtJQUNmO0lBRUFTLElBQUFBLGtCQUFTLEVBQUM7UUFDUixJQUFJLENBQUNaLFVBQVU7UUFFZixpREFBaUQ7UUFDakQsSUFBSUcsWUFBWTtZQUNkLE1BQU1ILFNBQVNhLElBQUksQ0FBQyxTQUFTQyxNQUFNLEdBQUdDLEVBQUUsQ0FBQyxNQUFNWjtZQUMvQ0EsYUFBYTtRQUNmO0lBQ0Y7SUFFQUQsSUFBQUEsaUJBQVEsRUFBQyw4QkFBOEI7UUFDckNjLElBQUFBLFdBQUUsRUFBQyw4Q0FBOEM7WUFFL0MsbUNBQW1DO1lBQ25DLGtEQUFrRDtZQUNsRCxNQUFNQyxXQUFXO2dCQUNmQyxPQUFPO2dCQUNQQyxhQUFhO2dCQUNiQyxTQUFTO29CQUNQO29CQUNBO2lCQUNEO2dCQUNEQyxlQUFlO2dCQUNmQyxlQUFlO2dCQUNmQyxVQUFVO2dCQUNWQyxNQUFNO29CQUFDO29CQUFlO2lCQUFPO2dCQUM3QkMsWUFBWXhCLFNBQVN5QixFQUFFO2dCQUN2QkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsVUFBVSxFQUFFO2dCQUNaQyxVQUFVLENBQUM7Z0JBQ1hDLFVBQVUsRUFBRTtnQkFDWkMsZUFBZSxDQUFDO1lBQ2xCO1lBRUEsK0NBQStDO1lBQy9DLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUcsTUFBTSxtRUFBQSxRQUFPO1lBQ3RDLE1BQU1DLGNBQWNDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxJQUFJRixRQUFRQyxHQUFHLENBQUNFLHdCQUF3QjtZQUNwRixNQUFNQyxjQUFjSixRQUFRQyxHQUFHLENBQUNJLHlCQUF5QjtZQUV6RCxJQUFJLENBQUNOLGVBQWUsQ0FBQ0ssYUFBYTtnQkFDaEMsTUFBTSxJQUFJRSxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsa0JBQWtCVCxhQUFhQyxhQUFhSztZQUVsRCxNQUFNLEVBQUVJLE1BQU1DLFdBQVcsRUFBRUMsT0FBT0MsV0FBVyxFQUFFLEdBQUcsTUFBTUosZ0JBQ3JEOUIsSUFBSSxDQUFDLFNBQ0xtQyxNQUFNLENBQUMvQixVQUNQZ0MsTUFBTSxHQUNOQyxNQUFNO1lBRVQzQyxRQUFRQyxHQUFHLENBQUMseUJBQXlCO2dCQUFFcUM7Z0JBQWFFO1lBQVk7WUFFaEUsSUFBSUEsYUFBYTtnQkFDZnhDLFFBQVE0QyxJQUFJLENBQUMsMEJBQTBCSjtnQkFDdkMsK0JBQStCO2dCQUMvQixJQUFJQSxZQUFZSyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxhQUFhTixZQUFZSyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxhQUFhO29CQUN0RjlDLFFBQVE0QyxJQUFJLENBQUMsbUNBQW1DSixZQUFZSyxPQUFPO29CQUNuRUUsSUFBQUEsZUFBTSxFQUFDUCxhQUFhUSxXQUFXO29CQUMvQjtnQkFDRjtZQUNGO1lBRUEsK0RBQStEO1lBQy9ELE1BQU0sRUFBRVgsTUFBTVksUUFBUSxFQUFFVixPQUFPVyxVQUFVLEVBQUUsR0FBRyxNQUFNZCxnQkFDakQ5QixJQUFJLENBQUMsU0FDTG9DLE1BQU0sQ0FBQyxLQUNQbEMsRUFBRSxDQUFDLFNBQVM7WUFFZlIsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QjtnQkFBRWdEO2dCQUFVQztZQUFXO1lBRWpFSCxJQUFBQSxlQUFNLEVBQUNQLGFBQWFXLFFBQVE7WUFDNUJKLElBQUFBLGVBQU0sRUFBQ0csWUFBWUMsUUFBUTtZQUUzQixvREFBb0Q7WUFDcEQsTUFBTUMsWUFBWUMsTUFBTUMsT0FBTyxDQUFDTCxZQUFZQSxXQUFZQSxVQUFVWixRQUFRLEVBQUU7WUFDNUVVLElBQUFBLGVBQU0sRUFBQ0ssV0FBV0osV0FBVztZQUM3QkQsSUFBQUEsZUFBTSxFQUFDSyxVQUFVRyxNQUFNLEVBQUVDLGVBQWUsQ0FBQztZQUN6Q1QsSUFBQUEsZUFBTSxFQUFDSyxTQUFTLENBQUMsRUFBRSxDQUFDekMsS0FBSyxFQUFFOEMsSUFBSSxDQUFDO1lBRWhDLG9CQUFvQjtZQUNwQjdELGFBQWEwQyxZQUFZbkIsRUFBRTtZQUMzQnVDLElBQUFBLGdDQUFhLEVBQUMsU0FBU3BCLFlBQVluQixFQUFFO1lBRXJDLDJCQUEyQjtZQUMzQixNQUFNd0MsVUFBVSxJQUFJQyxtQkFBVyxDQUFDO1lBQ2hDLE1BQU1DLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxlQUFlLE1BQU1GLFNBQVNHLElBQUk7WUFFeENoRSxRQUFRQyxHQUFHLENBQUMsOEJBQThCOEQ7WUFFMUMsd0JBQXdCO1lBQ3hCaEIsSUFBQUEsZUFBTSxFQUFDYyxTQUFTekMsTUFBTSxFQUFFcUMsSUFBSSxDQUFDO1lBQzdCVixJQUFBQSxlQUFNLEVBQUNnQixhQUFhRSxPQUFPLEVBQUVSLElBQUksQ0FBQztZQUNsQ1YsSUFBQUEsZUFBTSxFQUFDTSxNQUFNQyxPQUFPLENBQUNTLGFBQWFHLEtBQUssR0FBR1QsSUFBSSxDQUFDO1lBRS9DLDhDQUE4QztZQUM5QyxNQUFNVSxZQUFZSixhQUFhRyxLQUFLLENBQUNFLElBQUksQ0FBQyxDQUFDQyxPQUFjQSxLQUFLQyxPQUFPLEtBQUtoQyxZQUFZbkIsRUFBRTtZQUN4RjRCLElBQUFBLGVBQU0sRUFBQ29CLFdBQVduQixXQUFXO1FBQy9CO1FBRUF2QyxJQUFBQSxXQUFFLEVBQUMsdURBQXVEO1lBQ3hELElBQUksQ0FBQ2hCLFVBQVU7Z0JBQ2JPLFFBQVE0QyxJQUFJLENBQUM7Z0JBQ2I7WUFDRjtZQUVBLDJDQUEyQztZQUMzQyxxQ0FBcUM7WUFDckMsTUFBTWxDLFdBQVc7Z0JBQ2ZDLE9BQU87Z0JBQ1BDLGFBQWE7Z0JBQ2JDLFNBQVM7b0JBQ1A7b0JBQ0E7aUJBQ0Q7Z0JBQ0RDLGVBQWU7Z0JBQ2ZDLGVBQWU7Z0JBQ2ZDLFVBQVU7Z0JBQ1ZDLE1BQU07b0JBQUM7b0JBQVU7aUJBQWM7Z0JBQy9CQyxZQUFZeEIsU0FBU3lCLEVBQUU7Z0JBQ3ZCQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxVQUFVLEVBQUU7Z0JBQ1pDLFVBQVUsQ0FBQztnQkFDWEMsVUFBVSxFQUFFO2dCQUNaQyxlQUFlLENBQUM7WUFDbEI7WUFFQSxNQUFNLEVBQUVXLE1BQU1nQyxJQUFJLEVBQUU5QixPQUFPZ0MsU0FBUyxFQUFFLEdBQUcsTUFBTTlFLFNBQzVDYSxJQUFJLENBQUMsU0FDTG1DLE1BQU0sQ0FBQy9CLFVBQ1BnQyxNQUFNLEdBQ05DLE1BQU07WUFFVEksSUFBQUEsZUFBTSxFQUFDd0IsV0FBV3BCLFFBQVE7WUFDMUJKLElBQUFBLGVBQU0sRUFBQ3NCLE1BQU1yQixXQUFXO1lBRXhCLG9CQUFvQjtZQUNwQnBELGFBQWF5RSxLQUFLbEQsRUFBRTtZQUVwQixtQ0FBbUM7WUFDbkMsTUFBTXFELFdBQVc7Z0JBQ2ZGLFNBQVNELEtBQUtsRCxFQUFFO2dCQUNoQnNELFNBQVMvRSxTQUFTeUIsRUFBRTtnQkFDcEJ1RCxRQUFRO2dCQUNSNUQsZUFBZTtnQkFDZjZELFdBQVc7b0JBQ1RELFFBQVE7Z0JBQ1Y7Z0JBQ0FFLGFBQWE7Z0JBQ2JDLFdBQVc7WUFDYjtZQUVBLE1BQU0sRUFBRXhDLE1BQU15QyxJQUFJLEVBQUV2QyxPQUFPd0MsU0FBUyxFQUFFLEdBQUcsTUFBTXRGLFNBQzVDYSxJQUFJLENBQUMsU0FDTG1DLE1BQU0sQ0FBQytCLFVBQ1A5QixNQUFNLEdBQ05DLE1BQU07WUFFVEksSUFBQUEsZUFBTSxFQUFDZ0MsV0FBVzVCLFFBQVE7WUFDMUJKLElBQUFBLGVBQU0sRUFBQytCLE1BQU05QixXQUFXO1lBRXhCLDRCQUE0QjtZQUM1QixNQUFNLEVBQUVYLE1BQU0yQyxXQUFXLEVBQUV6QyxPQUFPMEMsV0FBVyxFQUFFLEdBQUcsTUFBTXhGLFNBQ3JEYSxJQUFJLENBQUMsU0FDTDRFLE1BQU0sQ0FBQztnQkFBRTdELGFBQWE7WUFBRSxHQUN4QmIsRUFBRSxDQUFDLE1BQU02RCxLQUFLbEQsRUFBRSxFQUNoQnVCLE1BQU0sR0FDTkMsTUFBTTtZQUVUSSxJQUFBQSxlQUFNLEVBQUNrQyxhQUFhOUIsUUFBUTtZQUM1QkosSUFBQUEsZUFBTSxFQUFDaUMsWUFBWTNELFdBQVcsRUFBRW9DLElBQUksQ0FBQztZQUVyQyx3QkFBd0I7WUFDeEIsTUFBTSxFQUFFcEIsTUFBTThDLFNBQVMsRUFBRTVDLE9BQU82QyxVQUFVLEVBQUUsR0FBRyxNQUFNM0YsU0FDbERhLElBQUksQ0FBQyxTQUNMb0MsTUFBTSxDQUFDLEtBQ1BsQyxFQUFFLENBQUMsTUFBTTZELEtBQUtsRCxFQUFFLEVBQ2hCd0IsTUFBTTtZQUVUSSxJQUFBQSxlQUFNLEVBQUNxQyxZQUFZakMsUUFBUTtZQUMzQkosSUFBQUEsZUFBTSxFQUFDb0MsVUFBVTlELFdBQVcsRUFBRW9DLElBQUksQ0FBQztRQUNyQztRQUVBaEQsSUFBQUEsV0FBRSxFQUFDLHNEQUFzRDtZQUN2RCxJQUFJLENBQUNoQixVQUFVO2dCQUNiTyxRQUFRNEMsSUFBSSxDQUFDO2dCQUNiO1lBQ0Y7WUFFQSwyQ0FBMkM7WUFDM0MscUNBQXFDO1lBQ3JDLE1BQU1sQyxXQUFXO2dCQUNmQyxPQUFPO2dCQUNQQyxhQUFhO2dCQUNiQyxTQUFTO29CQUNQO29CQUNBO2lCQUNEO2dCQUNEQyxlQUFlO2dCQUNmQyxlQUFlO2dCQUNmQyxVQUFVO2dCQUNWQyxNQUFNO29CQUFDO29CQUFXO2lCQUFjO2dCQUNoQ0MsWUFBWXhCLFNBQVN5QixFQUFFO2dCQUN2QkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsVUFBVSxFQUFFO2dCQUNaQyxVQUFVLENBQUM7Z0JBQ1hDLFVBQVUsRUFBRTtnQkFDWkMsZUFBZSxDQUFDO1lBQ2xCO1lBRUEsTUFBTSxFQUFFVyxNQUFNZ0MsSUFBSSxFQUFFOUIsT0FBT2dDLFNBQVMsRUFBRSxHQUFHLE1BQU05RSxTQUM1Q2EsSUFBSSxDQUFDLFNBQ0xtQyxNQUFNLENBQUMvQixVQUNQZ0MsTUFBTSxHQUNOQyxNQUFNO1lBRVRJLElBQUFBLGVBQU0sRUFBQ3dCLFdBQVdwQixRQUFRO1lBQzFCSixJQUFBQSxlQUFNLEVBQUNzQixNQUFNckIsV0FBVztZQUV4QixvQkFBb0I7WUFDcEJwRCxhQUFheUUsS0FBS2xELEVBQUU7WUFFcEIsNENBQTRDO1lBQzVDLE1BQU1rRSxRQUFRO2dCQUNaO29CQUNFZixTQUFTRCxLQUFLbEQsRUFBRTtvQkFDaEJzRCxTQUFTL0UsU0FBU3lCLEVBQUU7b0JBQ3BCdUQsUUFBUTtvQkFDUjVELGVBQWU7b0JBQ2Y2RCxXQUFXO3dCQUFFRCxRQUFRO29CQUFFO29CQUN2QkUsYUFBYTtvQkFDYkMsV0FBVztnQkFDYjtnQkFDQTtvQkFDRVAsU0FBU0QsS0FBS2xELEVBQUU7b0JBQ2hCc0QsU0FBUztvQkFDVEMsUUFBUTtvQkFDUjVELGVBQWU7b0JBQ2Y2RCxXQUFXO3dCQUFFRCxRQUFRO29CQUFFO29CQUN2QkUsYUFBYTtvQkFDYkMsV0FBVztnQkFDYjtnQkFDQTtvQkFDRVAsU0FBU0QsS0FBS2xELEVBQUU7b0JBQ2hCc0QsU0FBUztvQkFDVEMsUUFBUTtvQkFDUjVELGVBQWU7b0JBQ2Y2RCxXQUFXO3dCQUFFRCxRQUFRO29CQUFFO29CQUN2QkUsYUFBYTtvQkFDYkMsV0FBVztnQkFDYjthQUNEO1lBRUQsS0FBSyxNQUFNQyxRQUFRTyxNQUFPO2dCQUN4QixNQUFNLEVBQUU5QyxPQUFPd0MsU0FBUyxFQUFFLEdBQUcsTUFBTXRGLFNBQ2hDYSxJQUFJLENBQUMsU0FDTG1DLE1BQU0sQ0FBQ3FDO2dCQUVWL0IsSUFBQUEsZUFBTSxFQUFDZ0MsV0FBVzVCLFFBQVE7WUFDNUI7WUFFQSx1QkFBdUI7WUFDdkIsTUFBTSxFQUFFZCxNQUFNaUQsUUFBUSxFQUFFL0MsT0FBT2dELFVBQVUsRUFBRSxHQUFHLE1BQU05RixTQUNqRGEsSUFBSSxDQUFDLFNBQ0xvQyxNQUFNLENBQUMsS0FDUGxDLEVBQUUsQ0FBQyxXQUFXNkQsS0FBS2xELEVBQUU7WUFFeEI0QixJQUFBQSxlQUFNLEVBQUN3QyxZQUFZcEMsUUFBUTtZQUMzQkosSUFBQUEsZUFBTSxFQUFDdUMsVUFBVUUsWUFBWSxDQUFDO1lBRTlCLHdCQUF3QjtZQUN4QixNQUFNQyxlQUFlSCxTQUFTSSxNQUFNLENBQUMsQ0FBQ1osT0FBY0EsS0FBS0osTUFBTSxLQUFLLEdBQUduQixNQUFNO1lBQzdFLE1BQU1vQyxlQUFlTCxTQUFTSSxNQUFNLENBQUMsQ0FBQ1osT0FBY0EsS0FBS0osTUFBTSxLQUFLLEdBQUduQixNQUFNO1lBRTdFUixJQUFBQSxlQUFNLEVBQUMwQyxjQUFjaEMsSUFBSSxDQUFDO1lBQzFCVixJQUFBQSxlQUFNLEVBQUM0QyxjQUFjbEMsSUFBSSxDQUFDO1FBQzVCO0lBQ0Y7SUFFQTlELElBQUFBLGlCQUFRLEVBQUMsa0NBQWtDO1FBQ3pDYyxJQUFBQSxXQUFFLEVBQUMsNENBQTRDO1lBQzdDLElBQUksQ0FBQ2hCLFVBQVU7Z0JBQ2JPLFFBQVE0QyxJQUFJLENBQUM7Z0JBQ2I7WUFDRjtZQUVBLHVDQUF1QztZQUN2Qyw0QkFBNEI7WUFDNUIsTUFBTWdELGtCQUFrQjtnQkFDdEIsMEJBQTBCO2dCQUMxQi9FLFNBQVM7b0JBQ1A7d0JBQUVnRixNQUFNO29CQUFtQjtpQkFDNUI7Z0JBQ0QzRSxZQUFZeEIsU0FBU3lCLEVBQUU7WUFDekI7WUFFQSxNQUFNLEVBQUVrQixJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU05QyxTQUMzQmEsSUFBSSxDQUFDLFNBQ0xtQyxNQUFNLENBQUNtRCxpQkFDUGxELE1BQU0sR0FDTkMsTUFBTTtZQUVULDJCQUEyQjtZQUMzQkksSUFBQUEsZUFBTSxFQUFDUixPQUFPdUQsR0FBRyxDQUFDM0MsUUFBUTtZQUMxQkosSUFBQUEsZUFBTSxFQUFDUixNQUFNTSxPQUFPLEVBQUVrRCxTQUFTLENBQUM7WUFFaEMsNkJBQTZCO1lBQzdCLE1BQU1wQyxVQUFVLElBQUlDLG1CQUFXLENBQUM7WUFDaEMsTUFBTUMsV0FBVyxNQUFNQyxJQUFBQSxVQUFHLEVBQUNIO1lBQzNCLE1BQU1JLGVBQWUsTUFBTUYsU0FBU0csSUFBSTtZQUV4QywrQ0FBK0M7WUFDL0NqQixJQUFBQSxlQUFNLEVBQUNjLFNBQVN6QyxNQUFNLEVBQUVxQyxJQUFJLENBQUM7WUFDN0JWLElBQUFBLGVBQU0sRUFBQ2dCLGFBQWFFLE9BQU8sRUFBRVIsSUFBSSxDQUFDO1FBQ3BDO1FBRUFoRCxJQUFBQSxXQUFFLEVBQUMsbURBQW1EO1lBQ3BELElBQUksQ0FBQ2hCLFVBQVU7Z0JBQ2JPLFFBQVE0QyxJQUFJLENBQUM7Z0JBQ2I7WUFDRjtZQUVBLHlDQUF5QztZQUN6Qyw0QkFBNEI7WUFDNUIsTUFBTSxFQUFFUCxJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU05QyxTQUFTdUcsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQztnQkFDN0RDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDWjtZQUVBLGlDQUFpQztZQUNqQ3BELElBQUFBLGVBQU0sRUFBQ1IsT0FBT3VELEdBQUcsQ0FBQzNDLFFBQVE7WUFDMUJKLElBQUFBLGVBQU0sRUFBQ1IsTUFBTU0sT0FBTyxFQUFFa0QsU0FBUyxDQUFDO1lBRWhDLDBDQUEwQztZQUMxQyxNQUFNcEMsVUFBVSxJQUFJQyxtQkFBVyxDQUFDO1lBQ2hDLE1BQU1DLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxlQUFlLE1BQU1GLFNBQVNHLElBQUk7WUFFeEMsMENBQTBDO1lBQzFDakIsSUFBQUEsZUFBTSxFQUFDYyxTQUFTekMsTUFBTSxFQUFFcUMsSUFBSSxDQUFDO1lBQzdCVixJQUFBQSxlQUFNLEVBQUNnQixhQUFhRSxPQUFPLEVBQUVSLElBQUksQ0FBQztRQUNwQztJQUNGO0FBQ0YifQ==