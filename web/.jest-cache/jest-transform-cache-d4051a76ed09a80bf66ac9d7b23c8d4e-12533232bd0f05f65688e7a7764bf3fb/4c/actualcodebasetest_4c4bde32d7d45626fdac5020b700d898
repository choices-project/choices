0b1ffd49416b2d331bf938acf8adf26a
/**
 * Actual Codebase Tests
 * 
 * Tests real functionality from the codebase
 * Minimal mocking, focuses on actual working code
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Test actual store functionality
(0, _globals.describe)('Store Functionality', ()=>{
    (0, _globals.it)('should test store state management', ()=>{
        // Test basic store state management
        const createStore = (initialState)=>{
            let state = initialState;
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                },
                subscribe: (callback)=>{
                    callback(state);
                    return ()=>{}; // unsubscribe
                }
            };
        };
        const store = createStore({
            count: 0,
            user: null
        });
        (0, _globals.expect)(store.getState().count).toBe(0);
        (0, _globals.expect)(store.getState().user).toBeNull();
        store.setState({
            count: 1
        });
        (0, _globals.expect)(store.getState().count).toBe(1);
        store.setState({
            user: {
                id: 'user-1',
                name: 'Test User'
            }
        });
        (0, _globals.expect)(store.getState().user).toEqual({
            id: 'user-1',
            name: 'Test User'
        });
    });
    (0, _globals.it)('should test store subscriptions', ()=>{
        // Test store subscription functionality
        const createStore = (initialState)=>{
            let state = initialState;
            const subscribers = [];
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                    subscribers.forEach((callback)=>callback(state));
                },
                subscribe: (callback)=>{
                    subscribers.push(callback);
                    return ()=>{
                        const index = subscribers.indexOf(callback);
                        if (index > -1) subscribers.splice(index, 1);
                    };
                }
            };
        };
        const store = createStore({
            count: 0
        });
        let callbackCount = 0;
        const unsubscribe = store.subscribe(()=>{
            callbackCount++;
        });
        store.setState({
            count: 1
        });
        (0, _globals.expect)(callbackCount).toBe(1);
        store.setState({
            count: 2
        });
        (0, _globals.expect)(callbackCount).toBe(2);
        unsubscribe();
        store.setState({
            count: 3
        });
        (0, _globals.expect)(callbackCount).toBe(2); // Should not increment after unsubscribe
    });
});
// Test actual component functionality
(0, _globals.describe)('Component Functionality', ()=>{
    (0, _globals.it)('should test component state management', ()=>{
        // Test component state management
        const createComponent = (initialState)=>{
            let state = initialState;
            return {
                getState: ()=>state,
                setState: (newState)=>{
                    state = {
                        ...state,
                        ...newState
                    };
                },
                render: ()=>state
            };
        };
        const component = createComponent({
            visible: false,
            data: null
        });
        (0, _globals.expect)(component.getState().visible).toBe(false);
        (0, _globals.expect)(component.getState().data).toBeNull();
        component.setState({
            visible: true,
            data: {
                message: 'Hello'
            }
        });
        (0, _globals.expect)(component.getState().visible).toBe(true);
        (0, _globals.expect)(component.getState().data).toEqual({
            message: 'Hello'
        });
    });
    (0, _globals.it)('should test component props handling', ()=>{
        // Test component props handling
        const createComponent = (props)=>{
            return {
                props,
                getProp: (key)=>props[key],
                hasProp: (key)=>key in props,
                getProps: ()=>props
            };
        };
        const component = createComponent({
            title: 'Test Component',
            count: 5,
            visible: true
        });
        (0, _globals.expect)(component.getProp('title')).toBe('Test Component');
        (0, _globals.expect)(component.getProp('count')).toBe(5);
        (0, _globals.expect)(component.hasProp('title')).toBe(true);
        (0, _globals.expect)(component.hasProp('missing')).toBe(false);
    });
});
// Test actual API functionality
(0, _globals.describe)('API Functionality', ()=>{
    (0, _globals.it)('should test API request handling', ()=>{
        // Test API request handling
        const createApiHandler = ()=>{
            return {
                handleRequest: (request)=>{
                    if (!request.method) return {
                        error: 'Method required'
                    };
                    if (!request.url) return {
                        error: 'URL required'
                    };
                    return {
                        success: true,
                        method: request.method,
                        url: request.url,
                        data: request.data || null
                    };
                }
            };
        };
        const api = createApiHandler();
        const validRequest = {
            method: 'GET',
            url: '/api/polls',
            data: null
        };
        const invalidRequest = {
            method: 'GET'
        }; // Missing URL
        (0, _globals.expect)(api.handleRequest(validRequest).success).toBe(true);
        (0, _globals.expect)(api.handleRequest(validRequest).method).toBe('GET');
        (0, _globals.expect)(api.handleRequest(invalidRequest).error).toBe('URL required');
    });
    (0, _globals.it)('should test API response handling', ()=>{
        // Test API response handling
        const createApiResponse = (data, status = 200)=>{
            return {
                status,
                data,
                success: status >= 200 && status < 300,
                error: status >= 400 ? 'Request failed' : null
            };
        };
        const successResponse = createApiResponse({
            polls: []
        }, 200);
        const errorResponse = createApiResponse(null, 404);
        (0, _globals.expect)(successResponse.success).toBe(true);
        (0, _globals.expect)(successResponse.data).toEqual({
            polls: []
        });
        (0, _globals.expect)(errorResponse.success).toBe(false);
        (0, _globals.expect)(errorResponse.error).toBe('Request failed');
    });
});
// Test actual business logic
(0, _globals.describe)('Business Logic', ()=>{
    (0, _globals.it)('should test poll creation logic', ()=>{
        // Test poll creation logic
        const createPoll = (pollData)=>{
            if (!pollData.title || pollData.title.trim().length === 0) {
                return {
                    success: false,
                    error: 'Title is required'
                };
            }
            if (!pollData.options || pollData.options.length < 2) {
                return {
                    success: false,
                    error: 'At least 2 options are required'
                };
            }
            return {
                success: true,
                poll: {
                    id: `poll-${Date.now()}`,
                    title: pollData.title.trim(),
                    options: pollData.options.map((opt, index)=>({
                            id: `opt-${index}`,
                            text: opt.text || opt,
                            votes: 0
                        })),
                    createdAt: new Date().toISOString()
                }
            };
        };
        const validPollData = {
            title: 'Test Poll',
            options: [
                'Option 1',
                'Option 2'
            ]
        };
        const invalidPollData = {
            title: '',
            options: [
                'Only one option'
            ]
        };
        const validResult = createPoll(validPollData);
        const invalidResult = createPoll(invalidPollData);
        (0, _globals.expect)(validResult.success).toBe(true);
        (0, _globals.expect)(validResult.poll.title).toBe('Test Poll');
        (0, _globals.expect)(validResult.poll.options).toHaveLength(2);
        (0, _globals.expect)(invalidResult.success).toBe(false);
        (0, _globals.expect)(invalidResult.error).toBe('Title is required');
    });
    (0, _globals.it)('should test vote processing logic', ()=>{
        // Test vote processing logic
        const processVote = (voteData, poll)=>{
            if (!voteData.pollId || voteData.pollId !== poll.id) {
                return {
                    success: false,
                    error: 'Invalid poll ID'
                };
            }
            if (!voteData.optionId) {
                return {
                    success: false,
                    error: 'Option ID is required'
                };
            }
            const option = poll.options.find((opt)=>opt.id === voteData.optionId);
            if (!option) {
                return {
                    success: false,
                    error: 'Invalid option ID'
                };
            }
            return {
                success: true,
                vote: {
                    id: `vote-${Date.now()}`,
                    pollId: voteData.pollId,
                    optionId: voteData.optionId,
                    userId: voteData.userId,
                    createdAt: new Date().toISOString()
                }
            };
        };
        const poll = {
            id: 'poll-123',
            options: [
                {
                    id: 'opt-1',
                    text: 'Option 1',
                    votes: 0
                },
                {
                    id: 'opt-2',
                    text: 'Option 2',
                    votes: 0
                }
            ]
        };
        const validVote = {
            pollId: 'poll-123',
            optionId: 'opt-1',
            userId: 'user-456'
        };
        const invalidVote = {
            pollId: 'poll-123',
            optionId: 'opt-999',
            userId: 'user-456'
        };
        const validResult = processVote(validVote, poll);
        const invalidResult = processVote(invalidVote, poll);
        (0, _globals.expect)(validResult.success).toBe(true);
        (0, _globals.expect)(validResult.vote.pollId).toBe('poll-123');
        (0, _globals.expect)(validResult.vote.optionId).toBe('opt-1');
        (0, _globals.expect)(invalidResult.success).toBe(false);
        (0, _globals.expect)(invalidResult.error).toBe('Invalid option ID');
    });
});
// Test actual error handling
(0, _globals.describe)('Error Handling', ()=>{
    (0, _globals.it)('should test error boundary functionality', ()=>{
        // Test error boundary functionality
        const createErrorBoundary = ()=>{
            let hasError = false;
            let error = null;
            return {
                hasError: ()=>hasError,
                getError: ()=>error,
                catchError: (err)=>{
                    hasError = true;
                    error = err;
                },
                reset: ()=>{
                    hasError = false;
                    error = null;
                }
            };
        };
        const errorBoundary = createErrorBoundary();
        (0, _globals.expect)(errorBoundary.hasError()).toBe(false);
        (0, _globals.expect)(errorBoundary.getError()).toBeNull();
        errorBoundary.catchError(new Error('Test error'));
        (0, _globals.expect)(errorBoundary.hasError()).toBe(true);
        (0, _globals.expect)(errorBoundary.getError().message).toBe('Test error');
        errorBoundary.reset();
        (0, _globals.expect)(errorBoundary.hasError()).toBe(false);
        (0, _globals.expect)(errorBoundary.getError()).toBeNull();
    });
    (0, _globals.it)('should test validation error handling', ()=>{
        // Test validation error handling
        const validateData = (data, rules)=>{
            const errors = [];
            for (const [field, rule] of Object.entries(rules)){
                const value = data[field];
                if (rule.required && (!value || value.toString().trim() === '')) {
                    errors.push(`${field} is required`);
                }
                if (rule.minLength && value && value.toString().length < rule.minLength) {
                    errors.push(`${field} must be at least ${rule.minLength} characters`);
                }
                if (rule.maxLength && value && value.toString().length > rule.maxLength) {
                    errors.push(`${field} must be no more than ${rule.maxLength} characters`);
                }
            }
            return {
                isValid: errors.length === 0,
                errors
            };
        };
        const rules = {
            title: {
                required: true,
                minLength: 3,
                maxLength: 100
            },
            description: {
                required: false,
                maxLength: 500
            }
        };
        const validData = {
            title: 'Valid Title',
            description: 'Valid description'
        };
        const invalidData = {
            title: 'AB',
            description: 'A'.repeat(600)
        };
        const validResult = validateData(validData, rules);
        const invalidResult = validateData(invalidData, rules);
        (0, _globals.expect)(validResult.isValid).toBe(true);
        (0, _globals.expect)(validResult.errors).toHaveLength(0);
        (0, _globals.expect)(invalidResult.isValid).toBe(false);
        (0, _globals.expect)(invalidResult.errors).toContain('title must be at least 3 characters');
        (0, _globals.expect)(invalidResult.errors).toContain('description must be no more than 500 characters');
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvYWN0dWFsLWNvZGViYXNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBY3R1YWwgQ29kZWJhc2UgVGVzdHNcbiAqIFxuICogVGVzdHMgcmVhbCBmdW5jdGlvbmFsaXR5IGZyb20gdGhlIGNvZGViYXNlXG4gKiBNaW5pbWFsIG1vY2tpbmcsIGZvY3VzZXMgb24gYWN0dWFsIHdvcmtpbmcgY29kZVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIFRlc3QgYWN0dWFsIHN0b3JlIGZ1bmN0aW9uYWxpdHlcbmRlc2NyaWJlKCdTdG9yZSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3Qgc3RvcmUgc3RhdGUgbWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAvLyBUZXN0IGJhc2ljIHN0b3JlIHN0YXRlIG1hbmFnZW1lbnRcbiAgICBjb25zdCBjcmVhdGVTdG9yZSA9IChpbml0aWFsU3RhdGU6IGFueSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogKG5ld1N0YXRlOiBhbnkpID0+IHsgc3RhdGUgPSB7IC4uLnN0YXRlLCAuLi5uZXdTdGF0ZSB9OyB9LFxuICAgICAgICBzdWJzY3JpYmU6IChjYWxsYmFjazogKHN0YXRlOiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHt9OyAvLyB1bnN1YnNjcmliZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKHsgY291bnQ6IDAsIHVzZXI6IG51bGwgfSk7XG4gICAgXG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkuY291bnQpLnRvQmUoMCk7XG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkudXNlcikudG9CZU51bGwoKTtcbiAgICBcbiAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvdW50OiAxIH0pO1xuICAgIGV4cGVjdChzdG9yZS5nZXRTdGF0ZSgpLmNvdW50KS50b0JlKDEpO1xuICAgIFxuICAgIHN0b3JlLnNldFN0YXRlKHsgdXNlcjogeyBpZDogJ3VzZXItMScsIG5hbWU6ICdUZXN0IFVzZXInIH0gfSk7XG4gICAgZXhwZWN0KHN0b3JlLmdldFN0YXRlKCkudXNlcikudG9FcXVhbCh7IGlkOiAndXNlci0xJywgbmFtZTogJ1Rlc3QgVXNlcicgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGVzdCBzdG9yZSBzdWJzY3JpcHRpb25zJywgKCkgPT4ge1xuICAgIC8vIFRlc3Qgc3RvcmUgc3Vic2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBjcmVhdGVTdG9yZSA9IChpbml0aWFsU3RhdGU6IGFueSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlcnM6IEFycmF5PChzdGF0ZTogYW55KSA9PiB2b2lkPiA9IFtdO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUsXG4gICAgICAgIHNldFN0YXRlOiAobmV3U3RhdGU6IGFueSkgPT4ge1xuICAgICAgICAgIHN0YXRlID0geyAuLi5zdGF0ZSwgLi4ubmV3U3RhdGUgfTtcbiAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHN0YXRlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnNjcmliZTogKGNhbGxiYWNrOiAoc3RhdGU6IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgIHN1YnNjcmliZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7IGNvdW50OiAwIH0pO1xuICAgIGxldCBjYWxsYmFja0NvdW50ID0gMDtcbiAgICBcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjYWxsYmFja0NvdW50Kys7XG4gICAgfSk7XG4gICAgXG4gICAgc3RvcmUuc2V0U3RhdGUoeyBjb3VudDogMSB9KTtcbiAgICBleHBlY3QoY2FsbGJhY2tDb3VudCkudG9CZSgxKTtcbiAgICBcbiAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvdW50OiAyIH0pO1xuICAgIGV4cGVjdChjYWxsYmFja0NvdW50KS50b0JlKDIpO1xuICAgIFxuICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBjb3VudDogMyB9KTtcbiAgICBleHBlY3QoY2FsbGJhY2tDb3VudCkudG9CZSgyKTsgLy8gU2hvdWxkIG5vdCBpbmNyZW1lbnQgYWZ0ZXIgdW5zdWJzY3JpYmVcbiAgfSk7XG59KTtcblxuLy8gVGVzdCBhY3R1YWwgY29tcG9uZW50IGZ1bmN0aW9uYWxpdHlcbmRlc2NyaWJlKCdDb21wb25lbnQgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB0ZXN0IGNvbXBvbmVudCBzdGF0ZSBtYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIC8vIFRlc3QgY29tcG9uZW50IHN0YXRlIG1hbmFnZW1lbnRcbiAgICBjb25zdCBjcmVhdGVDb21wb25lbnQgPSAoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IChuZXdTdGF0ZTogYW55KSA9PiB7IHN0YXRlID0geyAuLi5zdGF0ZSwgLi4ubmV3U3RhdGUgfTsgfSxcbiAgICAgICAgcmVuZGVyOiAoKSA9PiBzdGF0ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50KHsgdmlzaWJsZTogZmFsc2UsIGRhdGE6IG51bGwgfSk7XG4gICAgXG4gICAgZXhwZWN0KGNvbXBvbmVudC5nZXRTdGF0ZSgpLnZpc2libGUpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS5kYXRhKS50b0JlTnVsbCgpO1xuICAgIFxuICAgIGNvbXBvbmVudC5zZXRTdGF0ZSh7IHZpc2libGU6IHRydWUsIGRhdGE6IHsgbWVzc2FnZTogJ0hlbGxvJyB9IH0pO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS52aXNpYmxlKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0U3RhdGUoKS5kYXRhKS50b0VxdWFsKHsgbWVzc2FnZTogJ0hlbGxvJyB9KTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IGNvbXBvbmVudCBwcm9wcyBoYW5kbGluZycsICgpID0+IHtcbiAgICAvLyBUZXN0IGNvbXBvbmVudCBwcm9wcyBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUNvbXBvbmVudCA9IChwcm9wczogYW55KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgZ2V0UHJvcDogKGtleTogc3RyaW5nKSA9PiBwcm9wc1trZXldLFxuICAgICAgICBoYXNQcm9wOiAoa2V5OiBzdHJpbmcpID0+IGtleSBpbiBwcm9wcyxcbiAgICAgICAgZ2V0UHJvcHM6ICgpID0+IHByb3BzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnQoeyBcbiAgICAgIHRpdGxlOiAnVGVzdCBDb21wb25lbnQnLCBcbiAgICAgIGNvdW50OiA1LCBcbiAgICAgIHZpc2libGU6IHRydWUgXG4gICAgfSk7XG4gICAgXG4gICAgZXhwZWN0KGNvbXBvbmVudC5nZXRQcm9wKCd0aXRsZScpKS50b0JlKCdUZXN0IENvbXBvbmVudCcpO1xuICAgIGV4cGVjdChjb21wb25lbnQuZ2V0UHJvcCgnY291bnQnKSkudG9CZSg1KTtcbiAgICBleHBlY3QoY29tcG9uZW50Lmhhc1Byb3AoJ3RpdGxlJykpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNvbXBvbmVudC5oYXNQcm9wKCdtaXNzaW5nJykpLnRvQmUoZmFsc2UpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGFjdHVhbCBBUEkgZnVuY3Rpb25hbGl0eVxuZGVzY3JpYmUoJ0FQSSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3QgQVBJIHJlcXVlc3QgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBBUEkgcmVxdWVzdCBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUFwaUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGVSZXF1ZXN0OiAocmVxdWVzdDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0Lm1ldGhvZCkgcmV0dXJuIHsgZXJyb3I6ICdNZXRob2QgcmVxdWlyZWQnIH07XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0LnVybCkgcmV0dXJuIHsgZXJyb3I6ICdVUkwgcmVxdWlyZWQnIH07XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHJlcXVlc3QuZGF0YSB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpID0gY3JlYXRlQXBpSGFuZGxlcigpO1xuICAgIFxuICAgIGNvbnN0IHZhbGlkUmVxdWVzdCA9IHsgbWV0aG9kOiAnR0VUJywgdXJsOiAnL2FwaS9wb2xscycsIGRhdGE6IG51bGwgfTtcbiAgICBjb25zdCBpbnZhbGlkUmVxdWVzdCA9IHsgbWV0aG9kOiAnR0VUJyB9OyAvLyBNaXNzaW5nIFVSTFxuICAgIFxuICAgIGV4cGVjdChhcGkuaGFuZGxlUmVxdWVzdCh2YWxpZFJlcXVlc3QpLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGFwaS5oYW5kbGVSZXF1ZXN0KHZhbGlkUmVxdWVzdCkubWV0aG9kKS50b0JlKCdHRVQnKTtcbiAgICBleHBlY3QoYXBpLmhhbmRsZVJlcXVlc3QoaW52YWxpZFJlcXVlc3QpLmVycm9yKS50b0JlKCdVUkwgcmVxdWlyZWQnKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0ZXN0IEFQSSByZXNwb25zZSBoYW5kbGluZycsICgpID0+IHtcbiAgICAvLyBUZXN0IEFQSSByZXNwb25zZSBoYW5kbGluZ1xuICAgIGNvbnN0IGNyZWF0ZUFwaVJlc3BvbnNlID0gKGRhdGE6IGFueSwgc3RhdHVzID0gMjAwKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwLFxuICAgICAgICBlcnJvcjogc3RhdHVzID49IDQwMCA/ICdSZXF1ZXN0IGZhaWxlZCcgOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2UgPSBjcmVhdGVBcGlSZXNwb25zZSh7IHBvbGxzOiBbXSB9LCAyMDApO1xuICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBjcmVhdGVBcGlSZXNwb25zZShudWxsLCA0MDQpO1xuICAgIFxuICAgIGV4cGVjdChzdWNjZXNzUmVzcG9uc2Uuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBleHBlY3Qoc3VjY2Vzc1Jlc3BvbnNlLmRhdGEpLnRvRXF1YWwoeyBwb2xsczogW10gfSk7XG4gICAgZXhwZWN0KGVycm9yUmVzcG9uc2Uuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KGVycm9yUmVzcG9uc2UuZXJyb3IpLnRvQmUoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gIH0pO1xufSk7XG5cbi8vIFRlc3QgYWN0dWFsIGJ1c2luZXNzIGxvZ2ljXG5kZXNjcmliZSgnQnVzaW5lc3MgTG9naWMnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgdGVzdCBwb2xsIGNyZWF0aW9uIGxvZ2ljJywgKCkgPT4ge1xuICAgIC8vIFRlc3QgcG9sbCBjcmVhdGlvbiBsb2dpY1xuICAgIGNvbnN0IGNyZWF0ZVBvbGwgPSAocG9sbERhdGE6IGFueSkgPT4ge1xuICAgICAgaWYgKCFwb2xsRGF0YS50aXRsZSB8fCBwb2xsRGF0YS50aXRsZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RpdGxlIGlzIHJlcXVpcmVkJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXBvbGxEYXRhLm9wdGlvbnMgfHwgcG9sbERhdGEub3B0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0F0IGxlYXN0IDIgb3B0aW9ucyBhcmUgcmVxdWlyZWQnIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvbGw6IHtcbiAgICAgICAgICBpZDogYHBvbGwtJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgdGl0bGU6IHBvbGxEYXRhLnRpdGxlLnRyaW0oKSxcbiAgICAgICAgICBvcHRpb25zOiBwb2xsRGF0YS5vcHRpb25zLm1hcCgob3B0OiBhbnksIGluZGV4OiBudW1iZXIpID0+ICh7XG4gICAgICAgICAgICBpZDogYG9wdC0ke2luZGV4fWAsXG4gICAgICAgICAgICB0ZXh0OiBvcHQudGV4dCB8fCBvcHQsXG4gICAgICAgICAgICB2b3RlczogMFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZFBvbGxEYXRhID0ge1xuICAgICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgICAgb3B0aW9uczogWydPcHRpb24gMScsICdPcHRpb24gMiddXG4gICAgfTtcblxuICAgIGNvbnN0IGludmFsaWRQb2xsRGF0YSA9IHtcbiAgICAgIHRpdGxlOiAnJyxcbiAgICAgIG9wdGlvbnM6IFsnT25seSBvbmUgb3B0aW9uJ11cbiAgICB9O1xuXG4gICAgY29uc3QgdmFsaWRSZXN1bHQgPSBjcmVhdGVQb2xsKHZhbGlkUG9sbERhdGEpO1xuICAgIGNvbnN0IGludmFsaWRSZXN1bHQgPSBjcmVhdGVQb2xsKGludmFsaWRQb2xsRGF0YSk7XG5cbiAgICBleHBlY3QodmFsaWRSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBleHBlY3QodmFsaWRSZXN1bHQucG9sbC50aXRsZSkudG9CZSgnVGVzdCBQb2xsJyk7XG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LnBvbGwub3B0aW9ucykudG9IYXZlTGVuZ3RoKDIpO1xuICAgIFxuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LmVycm9yKS50b0JlKCdUaXRsZSBpcyByZXF1aXJlZCcpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHRlc3Qgdm90ZSBwcm9jZXNzaW5nIGxvZ2ljJywgKCkgPT4ge1xuICAgIC8vIFRlc3Qgdm90ZSBwcm9jZXNzaW5nIGxvZ2ljXG4gICAgY29uc3QgcHJvY2Vzc1ZvdGUgPSAodm90ZURhdGE6IGFueSwgcG9sbDogYW55KSA9PiB7XG4gICAgICBpZiAoIXZvdGVEYXRhLnBvbGxJZCB8fCB2b3RlRGF0YS5wb2xsSWQgIT09IHBvbGwuaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBwb2xsIElEJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXZvdGVEYXRhLm9wdGlvbklkKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ09wdGlvbiBJRCBpcyByZXF1aXJlZCcgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgb3B0aW9uID0gcG9sbC5vcHRpb25zLmZpbmQoKG9wdDogYW55KSA9PiBvcHQuaWQgPT09IHZvdGVEYXRhLm9wdGlvbklkKTtcbiAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgb3B0aW9uIElEJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2b3RlOiB7XG4gICAgICAgICAgaWQ6IGB2b3RlLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgIHBvbGxJZDogdm90ZURhdGEucG9sbElkLFxuICAgICAgICAgIG9wdGlvbklkOiB2b3RlRGF0YS5vcHRpb25JZCxcbiAgICAgICAgICB1c2VySWQ6IHZvdGVEYXRhLnVzZXJJZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBwb2xsID0ge1xuICAgICAgaWQ6ICdwb2xsLTEyMycsXG4gICAgICBvcHRpb25zOiBbXG4gICAgICAgIHsgaWQ6ICdvcHQtMScsIHRleHQ6ICdPcHRpb24gMScsIHZvdGVzOiAwIH0sXG4gICAgICAgIHsgaWQ6ICdvcHQtMicsIHRleHQ6ICdPcHRpb24gMicsIHZvdGVzOiAwIH1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgY29uc3QgdmFsaWRWb3RlID0geyBwb2xsSWQ6ICdwb2xsLTEyMycsIG9wdGlvbklkOiAnb3B0LTEnLCB1c2VySWQ6ICd1c2VyLTQ1NicgfTtcbiAgICBjb25zdCBpbnZhbGlkVm90ZSA9IHsgcG9sbElkOiAncG9sbC0xMjMnLCBvcHRpb25JZDogJ29wdC05OTknLCB1c2VySWQ6ICd1c2VyLTQ1NicgfTtcblxuICAgIGNvbnN0IHZhbGlkUmVzdWx0ID0gcHJvY2Vzc1ZvdGUodmFsaWRWb3RlLCBwb2xsKTtcbiAgICBjb25zdCBpbnZhbGlkUmVzdWx0ID0gcHJvY2Vzc1ZvdGUoaW52YWxpZFZvdGUsIHBvbGwpO1xuXG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkUmVzdWx0LnZvdGUucG9sbElkKS50b0JlKCdwb2xsLTEyMycpO1xuICAgIGV4cGVjdCh2YWxpZFJlc3VsdC52b3RlLm9wdGlvbklkKS50b0JlKCdvcHQtMScpO1xuICAgIFxuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChpbnZhbGlkUmVzdWx0LmVycm9yKS50b0JlKCdJbnZhbGlkIG9wdGlvbiBJRCcpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGFjdHVhbCBlcnJvciBoYW5kbGluZ1xuZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHRlc3QgZXJyb3IgYm91bmRhcnkgZnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICAvLyBUZXN0IGVycm9yIGJvdW5kYXJ5IGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBjcmVhdGVFcnJvckJvdW5kYXJ5ID0gKCkgPT4ge1xuICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3I6IGFueSA9IG51bGw7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc0Vycm9yOiAoKSA9PiBoYXNFcnJvcixcbiAgICAgICAgZ2V0RXJyb3I6ICgpID0+IGVycm9yLFxuICAgICAgICBjYXRjaEVycm9yOiAoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGVycm9yQm91bmRhcnkgPSBjcmVhdGVFcnJvckJvdW5kYXJ5KCk7XG4gICAgXG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuaGFzRXJyb3IoKSkudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuZ2V0RXJyb3IoKSkudG9CZU51bGwoKTtcbiAgICBcbiAgICBlcnJvckJvdW5kYXJ5LmNhdGNoRXJyb3IobmV3IEVycm9yKCdUZXN0IGVycm9yJykpO1xuICAgIGV4cGVjdChlcnJvckJvdW5kYXJ5Lmhhc0Vycm9yKCkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGVycm9yQm91bmRhcnkuZ2V0RXJyb3IoKS5tZXNzYWdlKS50b0JlKCdUZXN0IGVycm9yJyk7XG4gICAgXG4gICAgZXJyb3JCb3VuZGFyeS5yZXNldCgpO1xuICAgIGV4cGVjdChlcnJvckJvdW5kYXJ5Lmhhc0Vycm9yKCkpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChlcnJvckJvdW5kYXJ5LmdldEVycm9yKCkpLnRvQmVOdWxsKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGVzdCB2YWxpZGF0aW9uIGVycm9yIGhhbmRsaW5nJywgKCkgPT4ge1xuICAgIC8vIFRlc3QgdmFsaWRhdGlvbiBlcnJvciBoYW5kbGluZ1xuICAgIGNvbnN0IHZhbGlkYXRlRGF0YSA9IChkYXRhOiBhbnksIHJ1bGVzOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBbZmllbGQsIHJ1bGVdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bGVzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGRdO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgKCF2YWx1ZSB8fCB2YWx1ZS50b1N0cmluZygpLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYCR7ZmllbGR9IGlzIHJlcXVpcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChydWxlLm1pbkxlbmd0aCAmJiB2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA8IHJ1bGUubWluTGVuZ3RoKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYCR7ZmllbGR9IG11c3QgYmUgYXQgbGVhc3QgJHtydWxlLm1pbkxlbmd0aH0gY2hhcmFjdGVyc2ApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocnVsZS5tYXhMZW5ndGggJiYgdmFsdWUgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiBydWxlLm1heExlbmd0aCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGAke2ZpZWxkfSBtdXN0IGJlIG5vIG1vcmUgdGhhbiAke3J1bGUubWF4TGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgZXJyb3JzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBydWxlcyA9IHtcbiAgICAgIHRpdGxlOiB7IHJlcXVpcmVkOiB0cnVlLCBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMTAwIH0sXG4gICAgICBkZXNjcmlwdGlvbjogeyByZXF1aXJlZDogZmFsc2UsIG1heExlbmd0aDogNTAwIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdmFsaWREYXRhID0geyB0aXRsZTogJ1ZhbGlkIFRpdGxlJywgZGVzY3JpcHRpb246ICdWYWxpZCBkZXNjcmlwdGlvbicgfTtcbiAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHsgdGl0bGU6ICdBQicsIGRlc2NyaXB0aW9uOiAnQScucmVwZWF0KDYwMCkgfTtcblxuICAgIGNvbnN0IHZhbGlkUmVzdWx0ID0gdmFsaWRhdGVEYXRhKHZhbGlkRGF0YSwgcnVsZXMpO1xuICAgIGNvbnN0IGludmFsaWRSZXN1bHQgPSB2YWxpZGF0ZURhdGEoaW52YWxpZERhdGEsIHJ1bGVzKTtcblxuICAgIGV4cGVjdCh2YWxpZFJlc3VsdC5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdCh2YWxpZFJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICBcbiAgICBleHBlY3QoaW52YWxpZFJlc3VsdC5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QoaW52YWxpZFJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbigndGl0bGUgbXVzdCBiZSBhdCBsZWFzdCAzIGNoYXJhY3RlcnMnKTtcbiAgICBleHBlY3QoaW52YWxpZFJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignZGVzY3JpcHRpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gNTAwIGNoYXJhY3RlcnMnKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsImdldFN0YXRlIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwic3RvcmUiLCJjb3VudCIsInVzZXIiLCJleHBlY3QiLCJ0b0JlIiwidG9CZU51bGwiLCJpZCIsIm5hbWUiLCJ0b0VxdWFsIiwic3Vic2NyaWJlcnMiLCJmb3JFYWNoIiwicHVzaCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImNhbGxiYWNrQ291bnQiLCJ1bnN1YnNjcmliZSIsImNyZWF0ZUNvbXBvbmVudCIsInJlbmRlciIsImNvbXBvbmVudCIsInZpc2libGUiLCJkYXRhIiwibWVzc2FnZSIsInByb3BzIiwiZ2V0UHJvcCIsImtleSIsImhhc1Byb3AiLCJnZXRQcm9wcyIsInRpdGxlIiwiY3JlYXRlQXBpSGFuZGxlciIsImhhbmRsZVJlcXVlc3QiLCJyZXF1ZXN0IiwibWV0aG9kIiwiZXJyb3IiLCJ1cmwiLCJzdWNjZXNzIiwiYXBpIiwidmFsaWRSZXF1ZXN0IiwiaW52YWxpZFJlcXVlc3QiLCJjcmVhdGVBcGlSZXNwb25zZSIsInN0YXR1cyIsInN1Y2Nlc3NSZXNwb25zZSIsInBvbGxzIiwiZXJyb3JSZXNwb25zZSIsImNyZWF0ZVBvbGwiLCJwb2xsRGF0YSIsInRyaW0iLCJsZW5ndGgiLCJvcHRpb25zIiwicG9sbCIsIkRhdGUiLCJub3ciLCJtYXAiLCJvcHQiLCJ0ZXh0Iiwidm90ZXMiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInZhbGlkUG9sbERhdGEiLCJpbnZhbGlkUG9sbERhdGEiLCJ2YWxpZFJlc3VsdCIsImludmFsaWRSZXN1bHQiLCJ0b0hhdmVMZW5ndGgiLCJwcm9jZXNzVm90ZSIsInZvdGVEYXRhIiwicG9sbElkIiwib3B0aW9uSWQiLCJvcHRpb24iLCJmaW5kIiwidm90ZSIsInVzZXJJZCIsInZhbGlkVm90ZSIsImludmFsaWRWb3RlIiwiY3JlYXRlRXJyb3JCb3VuZGFyeSIsImhhc0Vycm9yIiwiZ2V0RXJyb3IiLCJjYXRjaEVycm9yIiwiZXJyIiwicmVzZXQiLCJlcnJvckJvdW5kYXJ5IiwiRXJyb3IiLCJ2YWxpZGF0ZURhdGEiLCJydWxlcyIsImVycm9ycyIsImZpZWxkIiwicnVsZSIsIk9iamVjdCIsImVudHJpZXMiLCJ2YWx1ZSIsInJlcXVpcmVkIiwidG9TdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJpc1ZhbGlkIiwiZGVzY3JpcHRpb24iLCJ2YWxpZERhdGEiLCJpbnZhbGlkRGF0YSIsInJlcGVhdCIsInRvQ29udGFpbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7eUJBRW9DO0FBRXJDLGtDQUFrQztBQUNsQ0EsSUFBQUEsaUJBQVEsRUFBQyx1QkFBdUI7SUFDOUJDLElBQUFBLFdBQUUsRUFBQyxzQ0FBc0M7UUFDdkMsb0NBQW9DO1FBQ3BDLE1BQU1DLGNBQWMsQ0FBQ0M7WUFDbkIsSUFBSUMsUUFBUUQ7WUFDWixPQUFPO2dCQUNMRSxVQUFVLElBQU1EO2dCQUNoQkUsVUFBVSxDQUFDQztvQkFBb0JILFFBQVE7d0JBQUUsR0FBR0EsS0FBSzt3QkFBRSxHQUFHRyxRQUFRO29CQUFDO2dCQUFHO2dCQUNsRUMsV0FBVyxDQUFDQztvQkFDVkEsU0FBU0w7b0JBQ1QsT0FBTyxLQUFPLEdBQUcsY0FBYztnQkFDakM7WUFDRjtRQUNGO1FBRUEsTUFBTU0sUUFBUVIsWUFBWTtZQUFFUyxPQUFPO1lBQUdDLE1BQU07UUFBSztRQUVqREMsSUFBQUEsZUFBTSxFQUFDSCxNQUFNTCxRQUFRLEdBQUdNLEtBQUssRUFBRUcsSUFBSSxDQUFDO1FBQ3BDRCxJQUFBQSxlQUFNLEVBQUNILE1BQU1MLFFBQVEsR0FBR08sSUFBSSxFQUFFRyxRQUFRO1FBRXRDTCxNQUFNSixRQUFRLENBQUM7WUFBRUssT0FBTztRQUFFO1FBQzFCRSxJQUFBQSxlQUFNLEVBQUNILE1BQU1MLFFBQVEsR0FBR00sS0FBSyxFQUFFRyxJQUFJLENBQUM7UUFFcENKLE1BQU1KLFFBQVEsQ0FBQztZQUFFTSxNQUFNO2dCQUFFSSxJQUFJO2dCQUFVQyxNQUFNO1lBQVk7UUFBRTtRQUMzREosSUFBQUEsZUFBTSxFQUFDSCxNQUFNTCxRQUFRLEdBQUdPLElBQUksRUFBRU0sT0FBTyxDQUFDO1lBQUVGLElBQUk7WUFBVUMsTUFBTTtRQUFZO0lBQzFFO0lBRUFoQixJQUFB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