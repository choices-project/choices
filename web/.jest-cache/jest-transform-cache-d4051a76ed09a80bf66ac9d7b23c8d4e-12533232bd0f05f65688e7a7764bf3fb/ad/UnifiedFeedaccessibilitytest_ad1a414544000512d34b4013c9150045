e8274b859a9a764360638eb14bb1f7d5
/**
 * UnifiedFeed Accessibility Tests
 * 
 * Comprehensive accessibility testing for the UnifiedFeed component
 * Tests WCAG 2.1 AA compliance and screen reader support
 * 
 * Created: January 19, 2025
 * Status: âœ… PRODUCTION READY
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _jestaxe = require("jest-axe");
const _UnifiedFeed = require("../../../../../features/feeds/components/UnifiedFeed");
const _feedsStore = require("../../../../../lib/stores/feedsStore");
const _useHashtags = require("../../../../../features/hashtags/hooks/useHashtags");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Extend Jest matchers
expect.extend(_jestaxe.toHaveNoViolations);
// Mock the stores
_globals.jest.mock('@/lib/stores/feedsStore');
_globals.jest.mock('@/features/hashtags/hooks/useHashtags');
const mockUseFeeds = _feedsStore.useFeeds;
const mockUseHashtags = _useHashtags.useHashtags;
// Mock data
const mockFeedData = [
    {
        id: '1',
        type: 'poll',
        title: 'Test Poll',
        description: 'This is a test poll',
        hashtags: [
            'politics',
            'election'
        ],
        created_at: '2025-01-19T10:00:00Z',
        author: 'Test User',
        engagement: {
            likes: 10,
            shares: 5,
            comments: 3
        }
    },
    {
        id: '2',
        type: 'post',
        title: 'Test Post',
        description: 'This is a test post',
        hashtags: [
            'news',
            'update'
        ],
        created_at: '2025-01-19T09:00:00Z',
        author: 'Test User 2',
        engagement: {
            likes: 15,
            shares: 8,
            comments: 12
        }
    }
];
const mockHashtagData = [
    {
        id: '1',
        name: 'politics',
        display_name: 'Politics',
        usage_count: 100,
        follower_count: 50,
        is_trending: true,
        trend_score: 0.8,
        created_at: '2025-01-19T10:00:00Z',
        updated_at: '2025-01-19T10:00:00Z',
        is_verified: false,
        is_featured: false
    }
];
describe('UnifiedFeed Accessibility Tests', ()=>{
    beforeEach(()=>{
        // Mock store implementations
        mockUseFeeds.mockReturnValue({
            feeds: mockFeedData,
            loading: false,
            error: null,
            refreshFeeds: _globals.jest.fn(),
            likeFeed: _globals.jest.fn(),
            shareFeed: _globals.jest.fn(),
            commentFeed: _globals.jest.fn(),
            bookmarkFeed: _globals.jest.fn()
        });
        mockUseHashtags.mockReturnValue({
            hashtags: mockHashtagData,
            loading: false,
            error: null,
            searchHashtags: _globals.jest.fn(),
            followHashtag: _globals.jest.fn(),
            unfollowHashtag: _globals.jest.fn(),
            getTrendingHashtags: _globals.jest.fn()
        });
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('WCAG 2.1 AA Compliance', ()=>{
        test('should have no accessibility violations', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const results = await (0, _jestaxe.axe)(container);
            expect(results).toHaveNoViolations();
        });
        test('should have proper heading structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for main heading
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toBeInTheDocument();
            expect(mainHeading).toHaveTextContent('Unified Feed');
        });
        test('should have proper color contrast', async ()=>{
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const results = await (0, _jestaxe.axe)(container, {
                rules: {
                    'color-contrast': {
                        enabled: true
                    }
                }
            });
            expect(results).toHaveNoViolations();
        });
        test('should have proper focus management', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that focusable elements are properly marked
            const focusableElements = _react1.screen.getAllByRole('button');
            focusableElements.forEach((element)=>{
                expect(element).toHaveAttribute('tabIndex');
            });
        });
    });
    describe('Screen Reader Support', ()=>{
        test('should have proper ARIA labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check main feed role and label
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toHaveAttribute('aria-label', 'Unified Feed');
            // Check button labels
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            expect(darkModeButton).toBeInTheDocument();
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(filtersButton).toBeInTheDocument();
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            expect(refreshButton).toBeInTheDocument();
        });
        test('should have proper ARIA live regions', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for live regions
            const liveRegions = _react1.screen.getAllByRole('status');
            expect(liveRegions.length).toBeGreaterThan(0);
            // Check for polite announcements
            const politeRegion = _react1.screen.getByRole('status', {
                name: /feed/i
            });
            expect(politeRegion).toBeInTheDocument();
        });
        test('should announce state changes', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Trigger a state change
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Check for announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/switched to dark mode/i)).toBeInTheDocument();
            });
        });
        test('should have proper form labels', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for form elements with proper labels
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                const label = _react1.screen.getByLabelText(input.getAttribute('aria-label') || '');
                expect(label).toBeInTheDocument();
            });
        });
    });
    describe('Keyboard Navigation', ()=>{
        test('should support tab navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Start with first focusable element
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            expect(document.activeElement).toBe(firstButton);
            // Tab to next element
            _react1.fireEvent.keyDown(firstButton, {
                key: 'Tab'
            });
            const nextButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            expect(document.activeElement).toBe(nextButton);
        });
        test('should support enter key activation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            darkModeButton.focus();
            // Press Enter
            _react1.fireEvent.keyDown(darkModeButton, {
                key: 'Enter'
            });
            // Check that action was triggered
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByLabelText(/switch to light mode/i)).toBeInTheDocument();
            });
        });
        test('should support escape key for closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that filters panel is open
            expect(_react1.screen.getByText(/advanced filters/i)).toBeInTheDocument();
            // Press Escape
            _react1.fireEvent.keyDown(document, {
                key: 'Escape'
            });
            // Check that filters panel is closed
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/advanced filters/i)).not.toBeInTheDocument();
            });
        });
        test('should support arrow key navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that arrow keys work for navigation
            const firstButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            firstButton.focus();
            // Arrow right
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowRight'
            });
            // Arrow left
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowLeft'
            });
            // Arrow up
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowUp'
            });
            // Arrow down
            _react1.fireEvent.keyDown(firstButton, {
                key: 'ArrowDown'
            });
            // Should not throw errors
            expect(true).toBe(true);
        });
    });
    describe('Focus Management', ()=>{
        test('should trap focus in modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Open advanced filters
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(filtersButton);
            // Check that focus is trapped in modal
            const modal = _react1.screen.getByRole('dialog');
            expect(modal).toBeInTheDocument();
            // Check that focus is within modal
            const focusedElement = document.activeElement;
            expect(modal.contains(focusedElement)).toBe(true);
        });
        test('should restore focus after closing modals', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            filtersButton.focus();
            // Open modal
            _react1.fireEvent.click(filtersButton);
            // Close modal
            _react1.fireEvent.click(filtersButton);
            // Check that focus is restored
            expect(document.activeElement).toBe(filtersButton);
        });
        test('should manage focus for dynamic content', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Trigger content update
            const refreshButton = _react1.screen.getByLabelText(/refresh feed/i);
            _react1.fireEvent.click(refreshButton);
            // Check that focus is managed properly
            await (0, _react1.waitFor)(()=>{
                expect(document.activeElement).toBeInTheDocument();
            });
        });
    });
    describe('Semantic HTML', ()=>{
        test('should use proper semantic elements', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for main element
            const main = _react1.screen.getByRole('main');
            expect(main).toBeInTheDocument();
            // Check for header element
            const header = _react1.screen.getByRole('banner');
            expect(header).toBeInTheDocument();
            // Check for navigation elements
            const nav = _react1.screen.getByRole('navigation');
            expect(nav).toBeInTheDocument();
        });
        test('should have proper list structure', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for list elements
            const lists = _react1.screen.getAllByRole('list');
            expect(lists.length).toBeGreaterThan(0);
            // Check for list items
            const listItems = _react1.screen.getAllByRole('listitem');
            expect(listItems.length).toBeGreaterThan(0);
        });
        test('should have proper button semantics', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that all buttons have proper roles
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                expect(button).toHaveAttribute('type', 'button');
            });
        });
    });
    describe('Alternative Text', ()=>{
        test('should have alt text for images', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for images with alt text
            const images = _react1.screen.getAllByRole('img');
            images.forEach((image)=>{
                expect(image).toHaveAttribute('alt');
            });
        });
        test('should have descriptive text for icons', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for icons with proper labels
            const icons = _react1.screen.getAllByRole('img');
            icons.forEach((icon)=>{
                const altText = icon.getAttribute('alt');
                expect(altText).toBeTruthy();
                expect(altText?.length).toBeGreaterThan(0);
            });
        });
    });
    describe('Error Handling', ()=>{
        test('should announce errors to screen readers', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Failed to load feeds'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for error announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/failed to load feeds/i)).toBeInTheDocument();
            });
        });
        test('should provide error recovery options', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                error: 'Network error'
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for retry button
            const retryButton = _react1.screen.getByLabelText(/retry/i);
            expect(retryButton).toBeInTheDocument();
            // Check that retry button is accessible
            expect(retryButton).toHaveAttribute('aria-label');
        });
    });
    describe('Loading States', ()=>{
        test('should announce loading states', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for loading announcement
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/loading/i)).toBeInTheDocument();
            });
        });
        test('should provide loading progress information', async ()=>{
            mockUseFeeds.mockReturnValue({
                ...mockUseFeeds(),
                loading: true
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check for progress indicator
            const progressIndicator = _react1.screen.getByRole('progressbar');
            expect(progressIndicator).toBeInTheDocument();
        });
    });
    describe('Mobile Accessibility', ()=>{
        test('should support touch gestures with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Simulate touch events
            const feed = _react1.screen.getByRole('main');
            _react1.fireEvent.touchStart(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 100
                    }
                ]
            });
            _react1.fireEvent.touchMove(feed, {
                touches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            _react1.fireEvent.touchEnd(feed, {
                changedTouches: [
                    {
                        clientX: 100,
                        clientY: 200
                    }
                ]
            });
            // Check that touch events are handled properly
            expect(feed).toBeInTheDocument();
        });
        test('should support haptic feedback with accessibility', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Mock haptic feedback
            const mockVibrate = _globals.jest.fn();
            Object.defineProperty(navigator, 'vibrate', {
                value: mockVibrate,
                writable: true
            });
            // Trigger haptic feedback
            const likeButton = _react1.screen.getByLabelText(/like/i);
            _react1.fireEvent.click(likeButton);
            // Check that haptic feedback was triggered
            expect(mockVibrate).toHaveBeenCalled();
        });
    });
    describe('Internationalization', ()=>{
        test('should support different languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that text content is properly structured for translation
            const mainHeading = _react1.screen.getByRole('heading', {
                level: 1
            });
            expect(mainHeading).toHaveTextContent('Unified Feed');
            // Check that ARIA labels are properly structured
            const buttons = _react1.screen.getAllByRole('button');
            buttons.forEach((button)=>{
                const ariaLabel = button.getAttribute('aria-label');
                expect(ariaLabel).toBeTruthy();
            });
        });
        test('should support right-to-left languages', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.UnifiedFeed, {}));
            // Check that layout supports RTL
            const mainFeed = _react1.screen.getByRole('main');
            expect(mainFeed).toBeInTheDocument();
            // Check that text direction can be changed
            const textElements = _react1.screen.getAllByText(/test/i);
            textElements.forEach((element)=>{
                expect(element).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQuYWNjZXNzaWJpbGl0eS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaWZpZWRGZWVkIEFjY2Vzc2liaWxpdHkgVGVzdHNcbiAqIFxuICogQ29tcHJlaGVuc2l2ZSBhY2Nlc3NpYmlsaXR5IHRlc3RpbmcgZm9yIHRoZSBVbmlmaWVkRmVlZCBjb21wb25lbnRcbiAqIFRlc3RzIFdDQUcgMi4xIEFBIGNvbXBsaWFuY2UgYW5kIHNjcmVlbiByZWFkZXIgc3VwcG9ydFxuICogXG4gKiBDcmVhdGVkOiBKYW51YXJ5IDE5LCAyMDI1XG4gKiBTdGF0dXM6IOKchSBQUk9EVUNUSU9OIFJFQURZXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IGF4ZSwgdG9IYXZlTm9WaW9sYXRpb25zIH0gZnJvbSAnamVzdC1heGUnO1xuaW1wb3J0IHsgVW5pZmllZEZlZWQgfSBmcm9tICdAL2ZlYXR1cmVzL2ZlZWRzL2NvbXBvbmVudHMvVW5pZmllZEZlZWQnO1xuaW1wb3J0IHsgdXNlRmVlZHMgfSBmcm9tICdAL2xpYi9zdG9yZXMvZmVlZHNTdG9yZSc7XG5pbXBvcnQgeyB1c2VIYXNodGFncyB9IGZyb20gJ0AvZmVhdHVyZXMvaGFzaHRhZ3MvaG9va3MvdXNlSGFzaHRhZ3MnO1xuXG4vLyBFeHRlbmQgSmVzdCBtYXRjaGVyc1xuZXhwZWN0LmV4dGVuZCh0b0hhdmVOb1Zpb2xhdGlvbnMpO1xuXG4vLyBNb2NrIHRoZSBzdG9yZXNcbmplc3QubW9jaygnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnKTtcbmplc3QubW9jaygnQC9mZWF0dXJlcy9oYXNodGFncy9ob29rcy91c2VIYXNodGFncycpO1xuXG5jb25zdCBtb2NrVXNlRmVlZHMgPSB1c2VGZWVkcyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB1c2VGZWVkcz47XG5jb25zdCBtb2NrVXNlSGFzaHRhZ3MgPSB1c2VIYXNodGFncyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB1c2VIYXNodGFncz47XG5cbi8vIE1vY2sgZGF0YVxuY29uc3QgbW9ja0ZlZWREYXRhID0gW1xuICB7XG4gICAgaWQ6ICcxJyxcbiAgICB0eXBlOiAncG9sbCcsXG4gICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBpcyBhIHRlc3QgcG9sbCcsXG4gICAgaGFzaHRhZ3M6IFsncG9saXRpY3MnLCAnZWxlY3Rpb24nXSxcbiAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0xOVQxMDowMDowMFonLFxuICAgIGF1dGhvcjogJ1Rlc3QgVXNlcicsXG4gICAgZW5nYWdlbWVudDoge1xuICAgICAgbGlrZXM6IDEwLFxuICAgICAgc2hhcmVzOiA1LFxuICAgICAgY29tbWVudHM6IDNcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJzInLFxuICAgIHR5cGU6ICdwb3N0JyxcbiAgICB0aXRsZTogJ1Rlc3QgUG9zdCcsXG4gICAgZGVzY3JpcHRpb246ICdUaGlzIGlzIGEgdGVzdCBwb3N0JyxcbiAgICBoYXNodGFnczogWyduZXdzJywgJ3VwZGF0ZSddLFxuICAgIGNyZWF0ZWRfYXQ6ICcyMDI1LTAxLTE5VDA5OjAwOjAwWicsXG4gICAgYXV0aG9yOiAnVGVzdCBVc2VyIDInLFxuICAgIGVuZ2FnZW1lbnQ6IHtcbiAgICAgIGxpa2VzOiAxNSxcbiAgICAgIHNoYXJlczogOCxcbiAgICAgIGNvbW1lbnRzOiAxMlxuICAgIH1cbiAgfVxuXTtcblxuY29uc3QgbW9ja0hhc2h0YWdEYXRhID0gW1xuICB7XG4gICAgaWQ6ICcxJyxcbiAgICBuYW1lOiAncG9saXRpY3MnLFxuICAgIGRpc3BsYXlfbmFtZTogJ1BvbGl0aWNzJyxcbiAgICB1c2FnZV9jb3VudDogMTAwLFxuICAgIGZvbGxvd2VyX2NvdW50OiA1MCxcbiAgICBpc190cmVuZGluZzogdHJ1ZSxcbiAgICB0cmVuZF9zY29yZTogMC44LFxuICAgIGNyZWF0ZWRfYXQ6ICcyMDI1LTAxLTE5VDEwOjAwOjAwWicsXG4gICAgdXBkYXRlZF9hdDogJzIwMjUtMDEtMTlUMTA6MDA6MDBaJyxcbiAgICBpc192ZXJpZmllZDogZmFsc2UsXG4gICAgaXNfZmVhdHVyZWQ6IGZhbHNlXG4gIH1cbl07XG5cbmRlc2NyaWJlKCdVbmlmaWVkRmVlZCBBY2Nlc3NpYmlsaXR5IFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBNb2NrIHN0b3JlIGltcGxlbWVudGF0aW9uc1xuICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgZmVlZHM6IG1vY2tGZWVkRGF0YSxcbiAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICByZWZyZXNoRmVlZHM6IGplc3QuZm4oKSxcbiAgICAgIGxpa2VGZWVkOiBqZXN0LmZuKCksXG4gICAgICBzaGFyZUZlZWQ6IGplc3QuZm4oKSxcbiAgICAgIGNvbW1lbnRGZWVkOiBqZXN0LmZuKCksXG4gICAgICBib29rbWFya0ZlZWQ6IGplc3QuZm4oKVxuICAgIH0pO1xuXG4gICAgbW9ja1VzZUhhc2h0YWdzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBoYXNodGFnczogbW9ja0hhc2h0YWdEYXRhLFxuICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIHNlYXJjaEhhc2h0YWdzOiBqZXN0LmZuKCksXG4gICAgICBmb2xsb3dIYXNodGFnOiBqZXN0LmZuKCksXG4gICAgICB1bmZvbGxvd0hhc2h0YWc6IGplc3QuZm4oKSxcbiAgICAgIGdldFRyZW5kaW5nSGFzaHRhZ3M6IGplc3QuZm4oKVxuICAgIH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnV0NBRyAyLjEgQUEgQ29tcGxpYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBubyBhY2Nlc3NpYmlsaXR5IHZpb2xhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgYXhlKGNvbnRhaW5lcik7XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTm9WaW9sYXRpb25zKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgaGVhZGluZyBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIG1haW4gaGVhZGluZ1xuICAgICAgY29uc3QgbWFpbkhlYWRpbmcgPSBzY3JlZW4uZ2V0QnlSb2xlKCdoZWFkaW5nJywgeyBsZXZlbDogMSB9KTtcbiAgICAgIGV4cGVjdChtYWluSGVhZGluZykudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChtYWluSGVhZGluZykudG9IYXZlVGV4dENvbnRlbnQoJ1VuaWZpZWQgRmVlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIGNvbG9yIGNvbnRyYXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGF4ZShjb250YWluZXIsIHtcbiAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAnY29sb3ItY29udHJhc3QnOiB7IGVuYWJsZWQ6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVOb1Zpb2xhdGlvbnMoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBmb2N1cyBtYW5hZ2VtZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXNhYmxlIGVsZW1lbnRzIGFyZSBwcm9wZXJseSBtYXJrZWRcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJyk7XG4gICAgICBmb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBleHBlY3QoZWxlbWVudCkudG9IYXZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTY3JlZW4gUmVhZGVyIFN1cHBvcnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIEFSSUEgbGFiZWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIG1haW4gZmVlZCByb2xlIGFuZCBsYWJlbFxuICAgICAgY29uc3QgbWFpbkZlZWQgPSBzY3JlZW4uZ2V0QnlSb2xlKCdtYWluJyk7XG4gICAgICBleHBlY3QobWFpbkZlZWQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdVbmlmaWVkIEZlZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYnV0dG9uIGxhYmVsc1xuICAgICAgY29uc3QgZGFya01vZGVCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBkYXJrIG1vZGUvaSk7XG4gICAgICBleHBlY3QoZGFya01vZGVCdXR0b24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbHRlcnNCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgZXhwZWN0KGZpbHRlcnNCdXR0b24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlZnJlc2hCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3JlZnJlc2ggZmVlZC9pKTtcbiAgICAgIGV4cGVjdChyZWZyZXNoQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhdmUgcHJvcGVyIEFSSUEgbGl2ZSByZWdpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBsaXZlIHJlZ2lvbnNcbiAgICAgIGNvbnN0IGxpdmVSZWdpb25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnc3RhdHVzJyk7XG4gICAgICBleHBlY3QobGl2ZVJlZ2lvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwb2xpdGUgYW5ub3VuY2VtZW50c1xuICAgICAgY29uc3QgcG9saXRlUmVnaW9uID0gc2NyZWVuLmdldEJ5Um9sZSgnc3RhdHVzJywgeyBuYW1lOiAvZmVlZC9pIH0pO1xuICAgICAgZXhwZWN0KHBvbGl0ZVJlZ2lvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbm5vdW5jZSBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2VcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGRhcmtNb2RlQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGFubm91bmNlbWVudFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9zd2l0Y2hlZCB0byBkYXJrIG1vZGUvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBmb3JtIGxhYmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZm9ybSBlbGVtZW50cyB3aXRoIHByb3BlciBsYWJlbHNcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoaW5wdXQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgfHwgJycpO1xuICAgICAgICBleHBlY3QobGFiZWwpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0tleWJvYXJkIE5hdmlnYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgdGFiIG5hdmlnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgd2l0aCBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAgY29uc3QgZmlyc3RCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBkYXJrIG1vZGUvaSk7XG4gICAgICBmaXJzdEJ1dHRvbi5mb2N1cygpO1xuICAgICAgZXhwZWN0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLnRvQmUoZmlyc3RCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBUYWIgdG8gbmV4dCBlbGVtZW50XG4gICAgICBmaXJlRXZlbnQua2V5RG93bihmaXJzdEJ1dHRvbiwgeyBrZXk6ICdUYWInIH0pO1xuICAgICAgY29uc3QgbmV4dEJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvdG9nZ2xlIGFkdmFuY2VkIGZpbHRlcnMvaSk7XG4gICAgICBleHBlY3QoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkudG9CZShuZXh0QnV0dG9uKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IGVudGVyIGtleSBhY3RpdmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZGFya01vZGVCdXR0b24uZm9jdXMoKTtcbiAgICAgIFxuICAgICAgLy8gUHJlc3MgRW50ZXJcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRhcmtNb2RlQnV0dG9uLCB7IGtleTogJ0VudGVyJyB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhY3Rpb24gd2FzIHRyaWdnZXJlZFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBsaWdodCBtb2RlL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBlc2NhcGUga2V5IGZvciBjbG9zaW5nIG1vZGFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBPcGVuIGFkdmFuY2VkIGZpbHRlcnNcbiAgICAgIGNvbnN0IGZpbHRlcnNCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZpbHRlcnMgcGFuZWwgaXMgb3BlblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2FkdmFuY2VkIGZpbHRlcnMvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIFByZXNzIEVzY2FwZVxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZG9jdW1lbnQsIHsga2V5OiAnRXNjYXBlJyB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmaWx0ZXJzIHBhbmVsIGlzIGNsb3NlZFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoL2FkdmFuY2VkIGZpbHRlcnMvaSkpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBhcnJvdyBrZXkgbmF2aWdhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGFycm93IGtleXMgd29yayBmb3IgbmF2aWdhdGlvblxuICAgICAgY29uc3QgZmlyc3RCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBkYXJrIG1vZGUvaSk7XG4gICAgICBmaXJzdEJ1dHRvbi5mb2N1cygpO1xuICAgICAgXG4gICAgICAvLyBBcnJvdyByaWdodFxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnQXJyb3dSaWdodCcgfSk7XG4gICAgICBcbiAgICAgIC8vIEFycm93IGxlZnRcbiAgICAgIGZpcmVFdmVudC5rZXlEb3duKGZpcnN0QnV0dG9uLCB7IGtleTogJ0Fycm93TGVmdCcgfSk7XG4gICAgICBcbiAgICAgIC8vIEFycm93IHVwXG4gICAgICBmaXJlRXZlbnQua2V5RG93bihmaXJzdEJ1dHRvbiwgeyBrZXk6ICdBcnJvd1VwJyB9KTtcbiAgICAgIFxuICAgICAgLy8gQXJyb3cgZG93blxuICAgICAgZmlyZUV2ZW50LmtleURvd24oZmlyc3RCdXR0b24sIHsga2V5OiAnQXJyb3dEb3duJyB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvcnNcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRm9jdXMgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdHJhcCBmb2N1cyBpbiBtb2RhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gT3BlbiBhZHZhbmNlZCBmaWx0ZXJzXG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhmaWx0ZXJzQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmb2N1cyBpcyB0cmFwcGVkIGluIG1vZGFsXG4gICAgICBjb25zdCBtb2RhbCA9IHNjcmVlbi5nZXRCeVJvbGUoJ2RpYWxvZycpO1xuICAgICAgZXhwZWN0KG1vZGFsKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGZvY3VzIGlzIHdpdGhpbiBtb2RhbFxuICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgZXhwZWN0KG1vZGFsLmNvbnRhaW5zKGZvY3VzZWRFbGVtZW50KSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXN0b3JlIGZvY3VzIGFmdGVyIGNsb3NpbmcgbW9kYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbHRlcnNCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgZmlsdGVyc0J1dHRvbi5mb2N1cygpO1xuICAgICAgXG4gICAgICAvLyBPcGVuIG1vZGFsXG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENsb3NlIG1vZGFsXG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZm9jdXMgaXMgcmVzdG9yZWRcbiAgICAgIGV4cGVjdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS50b0JlKGZpbHRlcnNCdXR0b24pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIG1hbmFnZSBmb2N1cyBmb3IgZHluYW1pYyBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgY29udGVudCB1cGRhdGVcbiAgICAgIGNvbnN0IHJlZnJlc2hCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3JlZnJlc2ggZmVlZC9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhyZWZyZXNoQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBmb2N1cyBpcyBtYW5hZ2VkIHByb3Blcmx5XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlbWFudGljIEhUTUwnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHVzZSBwcm9wZXIgc2VtYW50aWMgZWxlbWVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIG1haW4gZWxlbWVudFxuICAgICAgY29uc3QgbWFpbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKTtcbiAgICAgIGV4cGVjdChtYWluKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaGVhZGVyIGVsZW1lbnRcbiAgICAgIGNvbnN0IGhlYWRlciA9IHNjcmVlbi5nZXRCeVJvbGUoJ2Jhbm5lcicpO1xuICAgICAgZXhwZWN0KGhlYWRlcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIG5hdmlnYXRpb24gZWxlbWVudHNcbiAgICAgIGNvbnN0IG5hdiA9IHNjcmVlbi5nZXRCeVJvbGUoJ25hdmlnYXRpb24nKTtcbiAgICAgIGV4cGVjdChuYXYpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgbGlzdCBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3QgZWxlbWVudHNcbiAgICAgIGNvbnN0IGxpc3RzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnbGlzdCcpO1xuICAgICAgZXhwZWN0KGxpc3RzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdCBpdGVtc1xuICAgICAgY29uc3QgbGlzdEl0ZW1zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnbGlzdGl0ZW0nKTtcbiAgICAgIGV4cGVjdChsaXN0SXRlbXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBwcm9wZXIgYnV0dG9uIHNlbWFudGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGFsbCBidXR0b25zIGhhdmUgcHJvcGVyIHJvbGVzXG4gICAgICBjb25zdCBidXR0b25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJyk7XG4gICAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgZXhwZWN0KGJ1dHRvbikudG9IYXZlQXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBbHRlcm5hdGl2ZSBUZXh0JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIGFsdCB0ZXh0IGZvciBpbWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGltYWdlcyB3aXRoIGFsdCB0ZXh0XG4gICAgICBjb25zdCBpbWFnZXMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdpbWcnKTtcbiAgICAgIGltYWdlcy5mb3JFYWNoKGltYWdlID0+IHtcbiAgICAgICAgZXhwZWN0KGltYWdlKS50b0hhdmVBdHRyaWJ1dGUoJ2FsdCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGF2ZSBkZXNjcmlwdGl2ZSB0ZXh0IGZvciBpY29ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgaWNvbnMgd2l0aCBwcm9wZXIgbGFiZWxzXG4gICAgICBjb25zdCBpY29ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2ltZycpO1xuICAgICAgaWNvbnMuZm9yRWFjaChpY29uID0+IHtcbiAgICAgICAgY29uc3QgYWx0VGV4dCA9IGljb24uZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgICAgZXhwZWN0KGFsdFRleHQpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgZXhwZWN0KGFsdFRleHQ/Lmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYW5ub3VuY2UgZXJyb3JzIHRvIHNjcmVlbiByZWFkZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIC4uLm1vY2tVc2VGZWVkcygpLFxuICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBsb2FkIGZlZWRzJ1xuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZXJyb3IgYW5ub3VuY2VtZW50XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2ZhaWxlZCB0byBsb2FkIGZlZWRzL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcHJvdmlkZSBlcnJvciByZWNvdmVyeSBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIC4uLm1vY2tVc2VGZWVkcygpLFxuICAgICAgICBlcnJvcjogJ05ldHdvcmsgZXJyb3InXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciByZXRyeSBidXR0b25cbiAgICAgIGNvbnN0IHJldHJ5QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZXRyeS9pKTtcbiAgICAgIGV4cGVjdChyZXRyeUJ1dHRvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCByZXRyeSBidXR0b24gaXMgYWNjZXNzaWJsZVxuICAgICAgZXhwZWN0KHJldHJ5QnV0dG9uKS50b0hhdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvYWRpbmcgU3RhdGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhbm5vdW5jZSBsb2FkaW5nIHN0YXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgbG9hZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbG9hZGluZyBhbm5vdW5jZW1lbnRcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvbG9hZGluZy9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgbG9hZGluZyBwcm9ncmVzcyBpbmZvcm1hdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlRmVlZHMoKSxcbiAgICAgICAgbG9hZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICBjb25zdCBwcm9ncmVzc0luZGljYXRvciA9IHNjcmVlbi5nZXRCeVJvbGUoJ3Byb2dyZXNzYmFyJyk7XG4gICAgICBleHBlY3QocHJvZ3Jlc3NJbmRpY2F0b3IpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNb2JpbGUgQWNjZXNzaWJpbGl0eScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCB0b3VjaCBnZXN0dXJlcyB3aXRoIGFjY2Vzc2liaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgdG91Y2ggZXZlbnRzXG4gICAgICBjb25zdCBmZWVkID0gc2NyZWVuLmdldEJ5Um9sZSgnbWFpbicpO1xuICAgICAgZmlyZUV2ZW50LnRvdWNoU3RhcnQoZmVlZCwgeyB0b3VjaGVzOiBbeyBjbGllbnRYOiAxMDAsIGNsaWVudFk6IDEwMCB9XSB9KTtcbiAgICAgIGZpcmVFdmVudC50b3VjaE1vdmUoZmVlZCwgeyB0b3VjaGVzOiBbeyBjbGllbnRYOiAxMDAsIGNsaWVudFk6IDIwMCB9XSB9KTtcbiAgICAgIGZpcmVFdmVudC50b3VjaEVuZChmZWVkLCB7IGNoYW5nZWRUb3VjaGVzOiBbeyBjbGllbnRYOiAxMDAsIGNsaWVudFk6IDIwMCB9XSB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCB0b3VjaCBldmVudHMgYXJlIGhhbmRsZWQgcHJvcGVybHlcbiAgICAgIGV4cGVjdChmZWVkKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgaGFwdGljIGZlZWRiYWNrIHdpdGggYWNjZXNzaWJpbGl0eScsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBNb2NrIGhhcHRpYyBmZWVkYmFja1xuICAgICAgY29uc3QgbW9ja1ZpYnJhdGUgPSBqZXN0LmZuKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAndmlicmF0ZScsIHtcbiAgICAgICAgdmFsdWU6IG1vY2tWaWJyYXRlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgaGFwdGljIGZlZWRiYWNrXG4gICAgICBjb25zdCBsaWtlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9saWtlL2kpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGxpa2VCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGhhcHRpYyBmZWVkYmFjayB3YXMgdHJpZ2dlcmVkXG4gICAgICBleHBlY3QobW9ja1ZpYnJhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVybmF0aW9uYWxpemF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBzdXBwb3J0IGRpZmZlcmVudCBsYW5ndWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCB0ZXh0IGNvbnRlbnQgaXMgcHJvcGVybHkgc3RydWN0dXJlZCBmb3IgdHJhbnNsYXRpb25cbiAgICAgIGNvbnN0IG1haW5IZWFkaW5nID0gc2NyZWVuLmdldEJ5Um9sZSgnaGVhZGluZycsIHsgbGV2ZWw6IDEgfSk7XG4gICAgICBleHBlY3QobWFpbkhlYWRpbmcpLnRvSGF2ZVRleHRDb250ZW50KCdVbmlmaWVkIEZlZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBBUklBIGxhYmVscyBhcmUgcHJvcGVybHkgc3RydWN0dXJlZFxuICAgICAgY29uc3QgYnV0dG9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicpO1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGNvbnN0IGFyaWFMYWJlbCA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICAgICAgZXhwZWN0KGFyaWFMYWJlbCkudG9CZVRydXRoeSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCByaWdodC10by1sZWZ0IGxhbmd1YWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGxheW91dCBzdXBwb3J0cyBSVExcbiAgICAgIGNvbnN0IG1haW5GZWVkID0gc2NyZWVuLmdldEJ5Um9sZSgnbWFpbicpO1xuICAgICAgZXhwZWN0KG1haW5GZWVkKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IHRleHQgZGlyZWN0aW9uIGNhbiBiZSBjaGFuZ2VkXG4gICAgICBjb25zdCB0ZXh0RWxlbWVudHMgPSBzY3JlZW4uZ2V0QWxsQnlUZXh0KC90ZXN0L2kpO1xuICAgICAgdGV4dEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZXhwZWN0IiwiZXh0ZW5kIiwidG9IYXZlTm9WaW9sYXRpb25zIiwiamVzdCIsIm1vY2siLCJtb2NrVXNlRmVlZHMiLCJ1c2VGZWVkcyIsIm1vY2tVc2VIYXNodGFncyIsInVzZUhhc2h0YWdzIiwibW9ja0ZlZWREYXRhIiwiaWQiLCJ0eXBlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhhc2h0YWdzIiwiY3JlYXRlZF9hdCIsImF1dGhvciIsImVuZ2FnZW1lbnQiLCJsaWtlcyIsInNoYXJlcyIsImNvbW1lbnRzIiwibW9ja0hhc2h0YWdEYXRhIiwibmFtZSIsImRpc3BsYXlfbmFtZSIsInVzYWdlX2NvdW50IiwiZm9sbG93ZXJfY291bnQiLCJpc190cmVuZGluZyIsInRyZW5kX3Njb3JlIiwidXBkYXRlZF9hdCIsImlzX3ZlcmlmaWVkIiwiaXNfZmVhdHVyZWQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJtb2NrUmV0dXJuVmFsdWUiLCJmZWVkcyIsImxvYWRpbmciLCJlcnJvciIsInJlZnJlc2hGZWVkcyIsImZuIiwibGlrZUZlZWQiLCJzaGFyZUZlZWQiLCJjb21tZW50RmVlZCIsImJvb2ttYXJrRmVlZCIsInNlYXJjaEhhc2h0YWdzIiwiZm9sbG93SGFzaHRhZyIsInVuZm9sbG93SGFzaHRhZyIsImdldFRyZW5kaW5nSGFzaHRhZ3MiLCJhZnRlckVhY2giLCJjbGVhckFsbE1vY2tzIiwidGVzdCIsImNvbnRhaW5lciIsInJlbmRlciIsIlVuaWZpZWRGZWVkIiwicmVzdWx0cyIsImF4ZSIsIm1haW5IZWFkaW5nIiwic2NyZWVuIiwiZ2V0QnlSb2xlIiwibGV2ZWwiLCJ0b0JlSW5UaGVEb2N1bWVudCIsInRvSGF2ZVRleHRDb250ZW50IiwicnVsZXMiLCJlbmFibGVkIiwiZm9jdXNhYmxlRWxlbWVudHMiLCJnZXRBbGxCeVJvbGUiLCJmb3JFYWNoIiwiZWxlbWVudCIsInRvSGF2ZUF0dHJpYnV0ZSIsIm1haW5GZWVkIiwiZGFya01vZGVCdXR0b24iLCJnZXRCeUxhYmVsVGV4dCIsImZpbHRlcnNCdXR0b24iLCJyZWZyZXNoQnV0dG9uIiwibGl2ZVJlZ2lvbnMiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJwb2xpdGVSZWdpb24iLCJmaXJlRXZlbnQiLCJjbGljayIsIndhaXRGb3IiLCJnZXRCeVRleHQiLCJpbnB1dHMiLCJpbnB1dCIsImxhYmVsIiwiZ2V0QXR0cmlidXRlIiwiZmlyc3RCdXR0b24iLCJmb2N1cyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsInRvQmUiLCJrZXlEb3duIiwia2V5IiwibmV4dEJ1dHRvbiIsInF1ZXJ5QnlUZXh0Iiwibm90IiwibW9kYWwiLCJmb2N1c2VkRWxlbWVudCIsImNvbnRhaW5zIiwibWFpbiIsImhlYWRlciIsIm5hdiIsImxpc3RzIiwibGlzdEl0ZW1zIiwiYnV0dG9ucyIsImJ1dHRvbiIsImltYWdlcyIsImltYWdlIiwiaWNvbnMiLCJpY29uIiwiYWx0VGV4dCIsInRvQmVUcnV0aHkiLCJyZXRyeUJ1dHRvbiIsInByb2dyZXNzSW5kaWNhdG9yIiwiZmVlZCIsInRvdWNoU3RhcnQiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJ0b3VjaE1vdmUiLCJ0b3VjaEVuZCIsImNoYW5nZWRUb3VjaGVzIiwibW9ja1ZpYnJhdGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIm5hdmlnYXRvciIsInZhbHVlIiwid3JpdGFibGUiLCJsaWtlQnV0dG9uIiwidG9IYXZlQmVlbkNhbGxlZCIsImFyaWFMYWJlbCIsInRleHRFbGVtZW50cyIsImdldEFsbEJ5VGV4dCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7Ozs7OzhEQUVpQjt3QkFDaUM7eUJBQzlCO3lCQUNtQjs2QkFDWjs0QkFDSDs2QkFDRzs7Ozs7O0FBRTVCLHVCQUF1QjtBQUN2QkEsT0FBT0MsTUFBTSxDQUFDQywyQkFBa0I7QUFFaEMsa0JBQWtCO0FBQ2xCQyxhQUFJLENBQUNDLElBQUksQ0FBQztBQUNWRCxhQUFJLENBQUNDLElBQUksQ0FBQztBQUVWLE1BQU1DLGVBQWVDLG9CQUFRO0FBQzdCLE1BQU1DLGtCQUFrQkMsd0JBQVc7QUFFbkMsWUFBWTtBQUNaLE1BQU1DLGVBQWU7SUFDbkI7UUFDRUMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsYUFBYTtRQUNiQyxVQUFVO1lBQUM7WUFBWTtTQUFXO1FBQ2xDQyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsWUFBWTtZQUNWQyxPQUFPO1lBQ1BDLFFBQVE7WUFD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