202b1da71550f5d03140d80759531ccf
/**
 * Jest Setup - Simple and Clean
 * 
 * This setup file provides minimal configuration for testing.
 * We use real Supabase credentials and real test users instead of complex mocks.
 */ // Import testing library matchers
"use strict";
// Mock Next.js router
jest.mock('next/navigation', ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                prefetch: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                pathname: '/',
                route: '/',
                query: {},
                asPath: '/'
            }),
        usePathname: ()=>'/',
        useSearchParams: ()=>new URLSearchParams()
    }));
require('@testing-library/jest-dom');
// Load environment variables from .env.local
require('dotenv').config({
    path: '.env.local'
});
// Simple environment setup for testing
process.env.NODE_ENV = 'test';
process.env.NEXTAUTH_SECRET = 'test-secret';
process.env.NEXTAUTH_URL = 'http://localhost:3000';
// Set up privacy pepper environment variables for testing
process.env.PRIVACY_PEPPER_DEV = 'dev-pepper-consistent-for-testing-12345678901234567890';
process.env.PRIVACY_PEPPER_CURRENT = 'hex:' + 'ab'.repeat(32);
// Browser API mocks (only for jsdom environment)
if (typeof window !== 'undefined') {
    // Mock window.matchMedia for responsive components
    Object.defineProperty(window, 'matchMedia', {
        writable: true,
        value: jest.fn().mockImplementation((query)=>({
                matches: false,
                media: query,
                onchange: null,
                addListener: jest.fn(),
                removeListener: jest.fn(),
                addEventListener: jest.fn(),
                removeEventListener: jest.fn(),
                dispatchEvent: jest.fn()
            }))
    });
    // Mock navigator.onLine for offline functionality
    Object.defineProperty(navigator, 'onLine', {
        writable: true,
        value: true
    });
    // Mock service worker
    Object.defineProperty(navigator, 'serviceWorker', {
        writable: true,
        value: {
            register: jest.fn(()=>Promise.resolve()),
            ready: Promise.resolve()
        }
    });
    // Mock PushManager
    Object.defineProperty(window, 'PushManager', {
        writable: true,
        value: {
            supportedContentEncodings: [
                'aesgcm'
            ]
        }
    });
    // Mock Notification
    Object.defineProperty(window, 'Notification', {
        writable: true,
        value: class Notification {
            constructor(title, options = {}){
                this.title = title;
                this.options = options;
            }
            static{
                this.requestPermission = jest.fn(()=>Promise.resolve('granted'));
            }
            static{
                this.permission = 'granted';
            }
        }
    });
    // Mock IntersectionObserver for components using infinite scroll
    if (typeof window.IntersectionObserver === 'undefined') {
        class MockIntersectionObserver {
            constructor(callback, options){
                this.callback = callback;
                this.options = options;
            }
            observe() {}
            unobserve() {}
            disconnect() {}
            takeRecords() {
                return [];
            }
        }
        Object.defineProperty(window, 'IntersectionObserver', {
            writable: true,
            configurable: true,
            value: MockIntersectionObserver
        });
    }
}
// Enhanced fetch polyfill for Node.js (for Supabase compatibility)
if (typeof global.fetch === 'undefined') {
    // Create a comprehensive fetch mock that works with Supabase
    global.fetch = jest.fn().mockImplementation(async (url, options = {})=>{
        // Mock successful response for Supabase requests
        const mockResponse = {
            ok: true,
            status: 200,
            statusText: 'OK',
            headers: new Map([
                [
                    'content-type',
                    'application/json'
                ]
            ]),
            json: async ()=>({
                    data: [],
                    error: null
                }),
            text: async ()=>'{"data":[],"error":null}',
            url: url,
            type: 'basic',
            redirected: false,
            clone: ()=>global.fetch(url, options)
        };
        return Promise.resolve(mockResponse);
    });
}
// Simple Response polyfill for Node.js (minimal)
if (typeof global.Response === 'undefined') {
    global.Response = class Response {
        constructor(body, options = {}){
            this.body = body;
            this.status = options.status || 200;
            this.statusText = options.statusText || 'OK';
            this.headers = new Map();
            if (options.headers) {
                Object.entries(options.headers).forEach(([key, value])=>{
                    this.headers.set(key.toLowerCase(), value);
                });
            }
        }
        async json() {
            return JSON.parse(this.body || '{}');
        }
        async text() {
            return this.body || '';
        }
        static json(data, options = {}) {
            return new Response(JSON.stringify(data), {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });
        }
    };
}
// Simple Headers polyfill for Node.js (minimal)
if (typeof global.Headers === 'undefined') {
    global.Headers = class Headers1 {
        constructor(init = {}){
            this.map = new Map();
            if (init) {
                Object.entries(init).forEach(([key, value])=>{
                    this.map.set(key.toLowerCase(), value);
                });
            }
        }
        get(name) {
            return this.map.get(name.toLowerCase());
        }
        set(name, value) {
            this.map.set(name.toLowerCase(), value);
        }
        has(name) {
            return this.map.has(name.toLowerCase());
        }
        delete(name) {
            this.map.delete(name.toLowerCase());
        }
    };
}
// Simple Request polyfill for Node.js (minimal)
if (typeof global.Request === 'undefined') {
    global.Request = class Request {
        constructor(input, init = {}){
            // Use Object.defineProperty to make url writable
            Object.defineProperty(this, 'url', {
                value: input,
                writable: true,
                enumerable: true,
                configurable: true
            });
            this.method = init.method || 'GET';
            this.headers = new Headers(init.headers);
            this.body = init.body;
        }
    };
}
// TextEncoder/TextDecoder polyfills for Node.js
if (typeof global.TextEncoder === 'undefined') {
    const { TextEncoder, TextDecoder } = require('util');
    global.TextEncoder = TextEncoder;
    global.TextDecoder = TextDecoder;
}
// Per-suite mocks should be declared within tests. Avoid global virtual mocks for app modules.
// Enhanced fetch polyfill for Node.js (for Supabase compatibility)
if (typeof global.fetch === 'undefined') {
    // Create a comprehensive fetch mock that works with Supabase
    global.fetch = jest.fn().mockImplementation(async (url, options = {})=>{
        // Mock successful response for Supabase requests
        const mockResponse = {
            ok: true,
            status: 200,
            statusText: 'OK',
            headers: new Map([
                [
                    'content-type',
                    'application/json'
                ]
            ]),
            json: async ()=>({
                    data: [],
                    error: null
                }),
            text: async ()=>'{"data":[],"error":null}',
            url: url,
            type: 'basic',
            redirected: false,
            clone: ()=>global.fetch(url, options)
        };
        return Promise.resolve(mockResponse);
    });
} // lucide-react is mocked via moduleNameMapper in jest.config.js

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9qZXN0LnNldHVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmVzdCBTZXR1cCAtIFNpbXBsZSBhbmQgQ2xlYW5cbiAqIFxuICogVGhpcyBzZXR1cCBmaWxlIHByb3ZpZGVzIG1pbmltYWwgY29uZmlndXJhdGlvbiBmb3IgdGVzdGluZy5cbiAqIFdlIHVzZSByZWFsIFN1cGFiYXNlIGNyZWRlbnRpYWxzIGFuZCByZWFsIHRlc3QgdXNlcnMgaW5zdGVhZCBvZiBjb21wbGV4IG1vY2tzLlxuICovXG5cbi8vIEltcG9ydCB0ZXN0aW5nIGxpYnJhcnkgbWF0Y2hlcnNcbnJlcXVpcmUoJ0B0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb20nKTtcblxuLy8gTG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52LmxvY2FsXG5yZXF1aXJlKCdkb3RlbnYnKS5jb25maWcoeyBwYXRoOiAnLmVudi5sb2NhbCcgfSk7XG5cbi8vIFNpbXBsZSBlbnZpcm9ubWVudCBzZXR1cCBmb3IgdGVzdGluZ1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAndGVzdCc7XG5wcm9jZXNzLmVudi5ORVhUQVVUSF9TRUNSRVQgPSAndGVzdC1zZWNyZXQnO1xucHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG5cbi8vIFNldCB1cCBwcml2YWN5IHBlcHBlciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHRlc3RpbmdcbnByb2Nlc3MuZW52LlBSSVZBQ1lfUEVQUEVSX0RFViA9ICdkZXYtcGVwcGVyLWNvbnNpc3RlbnQtZm9yLXRlc3RpbmctMTIzNDU2Nzg5MDEyMzQ1Njc4OTAnO1xucHJvY2Vzcy5lbnYuUFJJVkFDWV9QRVBQRVJfQ1VSUkVOVCA9ICdoZXg6JyArICdhYicucmVwZWF0KDMyKTtcblxuLy8gQnJvd3NlciBBUEkgbW9ja3MgKG9ubHkgZm9yIGpzZG9tIGVudmlyb25tZW50KVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIE1vY2sgd2luZG93Lm1hdGNoTWVkaWEgZm9yIHJlc3BvbnNpdmUgY29tcG9uZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbWF0Y2hNZWRpYScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihxdWVyeSA9PiAoe1xuICAgICAgbWF0Y2hlczogZmFsc2UsXG4gICAgICBtZWRpYTogcXVlcnksXG4gICAgICBvbmNoYW5nZTogbnVsbCxcbiAgICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxuICAgIH0pKSxcbiAgfSk7XG5cbiAgLy8gTW9jayBuYXZpZ2F0b3Iub25MaW5lIGZvciBvZmZsaW5lIGZ1bmN0aW9uYWxpdHlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ29uTGluZScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gTW9jayBzZXJ2aWNlIHdvcmtlclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAnc2VydmljZVdvcmtlcicsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZToge1xuICAgICAgcmVnaXN0ZXI6IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpLFxuICAgICAgcmVhZHk6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIE1vY2sgUHVzaE1hbmFnZXJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1B1c2hNYW5hZ2VyJywge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7XG4gICAgICBzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzOiBbJ2Flc2djbSddLFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIE1vY2sgTm90aWZpY2F0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdOb3RpZmljYXRpb24nLCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNsYXNzIE5vdGlmaWNhdGlvbiB7XG4gICAgICBjb25zdHJ1Y3Rvcih0aXRsZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RhdGljIHJlcXVlc3RQZXJtaXNzaW9uID0gamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2dyYW50ZWQnKSk7XG4gICAgICBzdGF0aWMgcGVybWlzc2lvbiA9ICdncmFudGVkJztcbiAgICB9LFxuICB9KTtcblxuICAvLyBNb2NrIEludGVyc2VjdGlvbk9ic2VydmVyIGZvciBjb21wb25lbnRzIHVzaW5nIGluZmluaXRlIHNjcm9sbFxuICBpZiAodHlwZW9mIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjbGFzcyBNb2NrSW50ZXJzZWN0aW9uT2JzZXJ2ZXIge1xuICAgICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgb2JzZXJ2ZSgpIHt9XG4gICAgICB1bm9ic2VydmUoKSB7fVxuICAgICAgZGlzY29ubmVjdCgpIHt9XG4gICAgICB0YWtlUmVjb3JkcygpIHsgcmV0dXJuIFtdOyB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdJbnRlcnNlY3Rpb25PYnNlcnZlcicsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IE1vY2tJbnRlcnNlY3Rpb25PYnNlcnZlcixcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBFbmhhbmNlZCBmZXRjaCBwb2x5ZmlsbCBmb3IgTm9kZS5qcyAoZm9yIFN1cGFiYXNlIGNvbXBhdGliaWxpdHkpXG5pZiAodHlwZW9mIGdsb2JhbC5mZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQ3JlYXRlIGEgY29tcHJlaGVuc2l2ZSBmZXRjaCBtb2NrIHRoYXQgd29ya3Mgd2l0aCBTdXBhYmFzZVxuICBnbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCByZXNwb25zZSBmb3IgU3VwYWJhc2UgcmVxdWVzdHNcbiAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICBbJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJ11cbiAgICAgIF0pLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZGF0YTogW10sIGVycm9yOiBudWxsIH0pLFxuICAgICAgdGV4dDogYXN5bmMgKCkgPT4gJ3tcImRhdGFcIjpbXSxcImVycm9yXCI6bnVsbH0nLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICB0eXBlOiAnYmFzaWMnLFxuICAgICAgcmVkaXJlY3RlZDogZmFsc2UsXG4gICAgICBjbG9uZTogKCkgPT4gZ2xvYmFsLmZldGNoKHVybCwgb3B0aW9ucylcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobW9ja1Jlc3BvbnNlKTtcbiAgfSk7XG59XG5cbi8vIFNpbXBsZSBSZXNwb25zZSBwb2x5ZmlsbCBmb3IgTm9kZS5qcyAobWluaW1hbClcbmlmICh0eXBlb2YgZ2xvYmFsLlJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICBnbG9iYWwuUmVzcG9uc2UgPSBjbGFzcyBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IoYm9keSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyB8fCAyMDA7XG4gICAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgfHwgJ09LJztcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KGtleS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGpzb24oKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHkgfHwgJ3t9Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgdGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkgfHwgJyc7XG4gICAgfVxuXG4gICAgc3RhdGljIGpzb24oZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFNpbXBsZSBIZWFkZXJzIHBvbHlmaWxsIGZvciBOb2RlLmpzIChtaW5pbWFsKVxuaWYgKHR5cGVvZiBnbG9iYWwuSGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsLkhlYWRlcnMgPSBjbGFzcyBIZWFkZXJzIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0ID0ge30pIHtcbiAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5pdCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0KGtleS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLm1hcC5zZXQobmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUobmFtZSkge1xuICAgICAgdGhpcy5tYXAuZGVsZXRlKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBTaW1wbGUgUmVxdWVzdCBwb2x5ZmlsbCBmb3IgTm9kZS5qcyAobWluaW1hbClcbmlmICh0eXBlb2YgZ2xvYmFsLlJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbC5SZXF1ZXN0ID0gY2xhc3MgUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgICAgLy8gVXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBtYWtlIHVybCB3cml0YWJsZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1cmwnLCB7XG4gICAgICAgIHZhbHVlOiBpbnB1dCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1ldGhvZCA9IGluaXQubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKTtcbiAgICAgIHRoaXMuYm9keSA9IGluaXQuYm9keTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRleHRFbmNvZGVyL1RleHREZWNvZGVyIHBvbHlmaWxscyBmb3IgTm9kZS5qc1xuaWYgKHR5cGVvZiBnbG9iYWwuVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd1dGlsJyk7XG4gIGdsb2JhbC5UZXh0RW5jb2RlciA9IFRleHRFbmNvZGVyO1xuICBnbG9iYWwuVGV4dERlY29kZXIgPSBUZXh0RGVjb2Rlcjtcbn1cblxuLy8gTW9jayBOZXh0LmpzIHJvdXRlclxuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xuICB1c2VSb3V0ZXI6ICgpID0+ICh7XG4gICAgcHVzaDogamVzdC5mbigpLFxuICAgIHJlcGxhY2U6IGplc3QuZm4oKSxcbiAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICAgIGJhY2s6IGplc3QuZm4oKSxcbiAgICBmb3J3YXJkOiBqZXN0LmZuKCksXG4gICAgcmVmcmVzaDogamVzdC5mbigpLFxuICAgIHBhdGhuYW1lOiAnLycsXG4gICAgcm91dGU6ICcvJyxcbiAgICBxdWVyeToge30sXG4gICAgYXNQYXRoOiAnLycsXG4gIH0pLFxuICB1c2VQYXRobmFtZTogKCkgPT4gJy8nLFxuICB1c2VTZWFyY2hQYXJhbXM6ICgpID0+IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSxcbn0pKTtcblxuLy8gUGVyLXN1aXRlIG1vY2tzIHNob3VsZCBiZSBkZWNsYXJlZCB3aXRoaW4gdGVzdHMuIEF2b2lkIGdsb2JhbCB2aXJ0dWFsIG1vY2tzIGZvciBhcHAgbW9kdWxlcy5cblxuLy8gRW5oYW5jZWQgZmV0Y2ggcG9seWZpbGwgZm9yIE5vZGUuanMgKGZvciBTdXBhYmFzZSBjb21wYXRpYmlsaXR5KVxuaWYgKHR5cGVvZiBnbG9iYWwuZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIENyZWF0ZSBhIGNvbXByZWhlbnNpdmUgZmV0Y2ggbW9jayB0aGF0IHdvcmtzIHdpdGggU3VwYWJhc2VcbiAgZ2xvYmFsLmZldGNoID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZm9yIFN1cGFiYXNlIHJlcXVlc3RzXG4gICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcbiAgICAgICAgWydjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbiddXG4gICAgICBdKSxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgIHRleHQ6IGFzeW5jICgpID0+ICd7XCJkYXRhXCI6W10sXCJlcnJvclwiOm51bGx9JyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgdHlwZTogJ2Jhc2ljJyxcbiAgICAgIHJlZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgY2xvbmU6ICgpID0+IGdsb2JhbC5mZXRjaCh1cmwsIG9wdGlvbnMpXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vY2tSZXNwb25zZSk7XG4gIH0pO1xufVxuXG4vLyBsdWNpZGUtcmVhY3QgaXMgbW9ja2VkIHZpYSBtb2R1bGVOYW1lTWFwcGVyIGluIGplc3QuY29uZmlnLmpzIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwidXNlUm91dGVyIiwicHVzaCIsImZuIiwicmVwbGFjZSIsInByZWZldGNoIiwiYmFjayIsImZvcndhcmQiLCJyZWZyZXNoIiwicGF0aG5hbWUiLCJyb3V0ZSIsInF1ZXJ5IiwiYXNQYXRoIiwidXNlUGF0aG5hbWUiLCJ1c2VTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJyZXF1aXJlIiwiY29uZmlnIiwicGF0aCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIk5FWFRBVVRIX1NFQ1JFVCIsIk5FWFRBVVRIX1VSTCIsIlBSSVZBQ1lfUEVQUEVSX0RFViIsIlBSSVZBQ1lfUEVQUEVSX0NVUlJFTlQiLCJyZXBlYXQiLCJ3aW5kb3ciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtYXRjaGVzIiwibWVkaWEiLCJvbmNoYW5nZSIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJuYXZpZ2F0b3IiLCJyZWdpc3RlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVhZHkiLCJzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzIiwiTm90aWZpY2F0aW9uIiwidGl0bGUiLCJvcHRpb25zIiwicmVxdWVzdFBlcm1pc3Npb24iLCJwZXJtaXNzaW9uIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJNb2NrSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJjYWxsYmFjayIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJkaXNjb25uZWN0IiwidGFrZVJlY29yZHMiLCJjb25maWd1cmFibGUiLCJnbG9iYWwiLCJmZXRjaCIsInVybCIsIm1vY2tSZXNwb25zZSIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImhlYWRlcnMiLCJNYXAiLCJqc29uIiwiZGF0YSIsImVycm9yIiwidGV4dCIsInR5cGUiLCJyZWRpcmVjdGVkIiwiY2xvbmUiLCJSZXNwb25zZSIsImJvZHkiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInNldCIsInRvTG93ZXJDYXNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiSGVhZGVycyIsImluaXQiLCJtYXAiLCJnZXQiLCJuYW1lIiwiaGFzIiwiZGVsZXRlIiwiUmVxdWVzdCIsImlucHV0IiwiZW51bWVyYWJsZSIsIm1ldGhvZCIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQsa0NBQWtDOztBQTJNbEMsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsV0FBVyxJQUFPLENBQUE7Z0JBQ2hCQyxNQUFNSCxLQUFLSSxFQUFFO2dCQUNiQyxTQUFTTCxLQUFLSSxFQUFFO2dCQUNoQkUsVUFBVU4sS0FBS0ksRUFBRTtnQkFDakJHLE1BQU1QLEtBQUtJLEVBQUU7Z0JBQ2JJLFNBQVNSLEtBQUtJLEVBQUU7Z0JBQ2hCSyxTQUFTVCxLQUFLSSxFQUFFO2dCQUNoQk0sVUFBVTtnQkFDVkMsT0FBTztnQkFDUEMsT0FBTyxDQUFDO2dCQUNSQyxRQUFRO1lBQ1YsQ0FBQTtRQUNBQyxhQUFhLElBQU07UUFDbkJDLGlCQUFpQixJQUFNLElBQUlDO0lBQzdCLENBQUE7QUExTkFDLFFBQVE7QUFFUiw2Q0FBNkM7QUFDN0NBLFFBQVEsVUFBVUMsTUFBTSxDQUFDO0lBQUVDLE1BQU07QUFBYTtBQUU5Qyx1Q0FBdUM7QUFDdkNDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxHQUFHO0FBQ3ZCRixRQUFRQyxHQUFHLENBQUNFLGVBQWUsR0FBRztBQUM5QkgsUUFBUUMsR0FBRyxDQUFDRyxZQUFZLEdBQUc7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