267a82baa6ac6a3b2973849fcdbfaa13
/**
 * VoteValidator Unit Tests
 * 
 * Comprehensive unit tests for vote validation functionality
 * 
 * Created: January 15, 2025
 * Updated: January 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _validator = require("../../../../lib/vote/validator");
const _setup = require("../../setup");
// Mock the logger
_globals.jest.mock('@/lib/utils/logger', ()=>({
        devLog: _globals.jest.fn()
    }));
const mockSetup = (0, _setup.getMS)();
const { when, client: mockSupabaseClient } = mockSetup;
_globals.jest.mock('@/utils/supabase/server', ()=>({
        getSupabaseServerClient: _globals.jest.fn(()=>Promise.resolve(mockSupabaseClient))
    }));
(0, _globals.describe)('VoteValidator', ()=>{
    let validator;
    let mockPoll;
    let mockVoteData;
    (0, _globals.beforeEach)(()=>{
        // Reset all mocks before each test
        _globals.jest.clearAllMocks();
        // Reset mock routes to ensure clean state
        mockSetup.resetAllMocks();
        validator = new _validator.VoteValidator();
        mockPoll = {
            id: 'test-poll-123',
            title: 'Test Poll',
            description: 'A test poll for unit testing',
            votingMethod: 'single',
            options: [
                {
                    id: 'option-1',
                    text: 'Option 1'
                },
                {
                    id: 'option-2',
                    text: 'Option 2'
                },
                {
                    id: 'option-3',
                    text: 'Option 3'
                }
            ],
            status: 'active',
            startTime: new Date('2025-01-01T00:00:00Z'),
            endTime: new Date('2025-12-31T23:59:59Z'),
            createdBy: 'admin-user',
            createdAt: new Date('2025-01-01T00:00:00Z'),
            updatedAt: new Date('2025-01-01T00:00:00Z'),
            votingConfig: {
                allowMultipleVotes: false,
                maxChoices: 1,
                requireVerification: false,
                quadraticCredits: 100,
                rangeMin: 0,
                rangeMax: 10
            }
        };
        mockVoteData = {
            id: 'vote-123',
            pollId: 'test-poll-123',
            userId: 'user-1',
            choice: 0,
            privacyLevel: 'public',
            timestamp: new Date(),
            auditReceipt: 'audit-123'
        };
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.describe)('Basic Validation', ()=>{
        (0, _globals.it)('should validate valid vote data', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
            (0, _globals.expect)(validation.requiresAuthentication).toBe(true);
            (0, _globals.expect)(validation.requiresTokens).toBe(false);
        });
        (0, _globals.it)('should reject null vote data', async ()=>{
            const validation = await validator.validateVote(null, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject undefined vote data', async ()=>{
            const validation = await validator.validateVote(undefined, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject non-object vote data', async ()=>{
            const validation = await validator.validateVote('invalid', mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject null poll data', async ()=>{
            const validation = await validator.validateVote(mockVoteData, null, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll data is required');
        });
        (0, _globals.it)('should reject poll data without id', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                id: ''
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
        (0, _globals.it)('should reject poll data without voting method', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                votingMethod: undefined
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
    });
    (0, _globals.describe)('Business Rules Validation', ()=>{
        (0, _globals.it)('should reject vote for inactive poll', async ()=>{
            const inactivePoll = Object.assign({}, mockPoll, {
                status: 'closed'
            });
            const validation = await validator.validateVote(mockVoteData, inactivePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for draft poll', async ()=>{
            const draftPoll = Object.assign({}, mockPoll, {
                status: 'draft'
            });
            const validation = await validator.validateVote(mockVoteData, draftPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for expired poll', async ()=>{
            const expiredPoll = Object.assign({}, mockPoll, {
                endTime: new Date('2024-12-31T23:59:59Z') // Past date
            });
            const validation = await validator.validateVote(mockVoteData, expiredPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll has ended');
        });
        (0, _globals.it)('should accept vote for poll without end time', async ()=>{
            const { endTime, ...noEndTimePoll } = mockPoll;
            const validation = await validator.validateVote(mockVoteData, noEndTimePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote for locked poll', async ()=>{
            const lockedPoll = Object.assign({}, mockPoll, {
                lockedAt: new Date('2025-01-01T12:00:00Z')
            });
            const validation = await validator.validateVote(mockVoteData, lockedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is locked');
        });
    });
    (0, _globals.describe)('Single Choice Validation', ()=>{
        (0, _globals.it)('should validate valid single choice vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing choice', async ()=>{
            const { choice, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with null choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: null
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with non-integer choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 1.5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be a valid integer');
        });
        (0, _globals.it)('should reject vote with negative choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: -1
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with choice exceeding options', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
    });
    (0, _globals.describe)('Approval Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'approval';
            mockPoll.votingConfig = {
                ...mockPoll.votingConfig,
                maxChoices: 3,
                allowMultipleVotes: true
            };
            const { choice, ...approvalVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, approvalVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
        });
        (0, _globals.it)('should validate valid approval vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing approvals', async ()=>{
            const { approvals, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with empty approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: []
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must be approved');
        });
        (0, _globals.it)('should reject vote with non-array approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: 'invalid'
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with invalid approval indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approval index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    0
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate approvals are not allowed');
        });
        (0, _globals.it)('should respect max choices limit', async ()=>{
            const limitedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    maxChoices: 1
                })
            });
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, limitedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Maximum 1 approvals allowed');
        });
    });
    (0, _globals.describe)('Ranked Choice Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'ranked';
            const { choice, approvals, ...rankedVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rankedVoteData, {
                rankings: [
                    0,
                    1,
                    2
                ]
            });
        });
        (0, _globals.it)('should validate valid ranked vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing rankings', async ()=>{
            const { rankings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rankings array is required for ranked choice voting');
        });
        (0, _globals.it)('should reject vote with incomplete rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be ranked');
        });
        (0, _globals.it)('should reject vote with invalid ranking indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ranking index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate rankings are not allowed');
        });
    });
    (0, _globals.describe)('Quadratic Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'quadratic';
            const { choice, approvals, rankings, ...quadraticVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, quadraticVoteData, {
                allocations: {
                    '0': 5,
                    '1': 3
                }
            });
        });
        (0, _globals.it)('should validate valid quadratic vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing allocations', async ()=>{
            const { allocations, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Allocations object is required for quadratic voting');
        });
        (0, _globals.it)('should reject vote with negative allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': -5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote with non-integer allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 5.5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote exceeding credit limit', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 11
                } // 11^2 = 121 > 100
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toContain('exceeds available credits');
        });
        (0, _globals.it)('should reject vote with no allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must receive votes');
        });
    });
    (0, _globals.describe)('Range Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'range';
            const { choice, approvals, rankings, allocations, ...rangeVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rangeVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6,
                    '2': 4
                }
            });
        });
        (0, _globals.it)('should validate valid range vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing ratings', async ()=>{
            const { ratings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ratings object is required for range voting');
        });
        (0, _globals.it)('should reject vote with ratings outside range', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 15
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rating must be between 0 and 10');
        });
        (0, _globals.it)('should reject vote with incomplete ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be rated');
        });
        (0, _globals.it)('should reject vote with all minimum ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must have a rating above the minimum');
        });
    });
    (0, _globals.describe)('Security Validation', ()=>{
        (0, _globals.it)('should require authentication when verification is required', async ()=>{
            const verifiedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    requireVerification: true
                })
            });
            const validation = await validator.validateVote(mockVoteData, verifiedPoll);
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Authentication required for this poll');
        });
        (0, _globals.it)('should accept vote when verification is not required', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll);
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should check trust tier requirements', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T2',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock no existing vote (user can vote)
            when().table('votes').op('select').eq('poll_id', 'test-poll-123').eq('user_id', 'user-1').returnsList([]);
            // Mock getUserTrustTier to return T1 (insufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T1'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
        });
        (0, _globals.it)('should accept vote with sufficient trust tier', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock getUserTrustTier to return T2 (sufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T2'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // The validation should pass since T2 >= T1
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
    });
    (0, _globals.describe)('Error Handling', ()=>{
        (0, _globals.it)('should handle validation errors gracefully', async ()=>{
            // Mock a method to throw an error
            const originalValidateBasicVoteData = validator.validateBasicVoteData;
            validator.validateBasicVoteData = _globals.jest.fn().mockImplementation(()=>{
                throw new Error('Validation error');
            });
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Validation error');
            // Restore original method
            validator.validateBasicVoteData = originalValidateBasicVoteData;
        });
        (0, _globals.it)('should handle database errors gracefully', async ()=>{
            // Create a new validator instance to avoid interference with other tests
            const testValidator = new _validator.VoteValidator();
            // Mock the getUserTrustTier method to return T0 (default fallback)
            const originalGetUserTrustTier = testValidator.getUserTrustTier;
            const mockGetUserTrustTier = _globals.jest.fn();
            mockGetUserTrustTier.mockResolvedValue('T0');
            testValidator.getUserTrustTier = mockGetUserTrustTier;
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            const validation = await testValidator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // Should fall back to default trust tier (T0) and fail
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
            // Restore original method
            testValidator.getUserTrustTier = originalGetUserTrustTier;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvdm90ZS92b3RlLXZhbGlkYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVm90ZVZhbGlkYXRvciBVbml0IFRlc3RzXG4gKiBcbiAqIENvbXByZWhlbnNpdmUgdW5pdCB0ZXN0cyBmb3Igdm90ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAqIFxuICogQ3JlYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICogVXBkYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IFZvdGVWYWxpZGF0b3IgfSBmcm9tICdAL2xpYi92b3RlL3ZhbGlkYXRvcic7XG5pbXBvcnQgdHlwZSB7IFxuICBWb3RlRGF0YSwgXG4gIFBvbGxEYXRhLCBcbiAgVm90ZVZhbGlkYXRpb24gXG59IGZyb20gJ0AvbGliL3ZvdGUvdHlwZXMnO1xuXG4vLyBNb2NrIHRoZSBsb2dnZXJcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgZGV2TG9nOiBqZXN0LmZuKClcbn0pKTtcblxuLy8gSW1wb3J0IFYyIHRlc3Qgc2V0dXBcbmltcG9ydCB7IGdldE1TIH0gZnJvbSAnLi4vLi4vc2V0dXAnO1xuY29uc3QgbW9ja1NldHVwID0gZ2V0TVMoKTtcbmNvbnN0IHsgd2hlbiwgY2xpZW50OiBtb2NrU3VwYWJhc2VDbGllbnQgfSA9IG1vY2tTZXR1cDtcblxuamVzdC5tb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlU2VydmVyQ2xpZW50OiBqZXN0LmZuKCgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VwYWJhc2VDbGllbnQpKVxufSkpO1xuXG5kZXNjcmliZSgnVm90ZVZhbGlkYXRvcicsICgpID0+IHtcbiAgbGV0IHZhbGlkYXRvcjogVm90ZVZhbGlkYXRvcjtcbiAgbGV0IG1vY2tQb2xsOiBQb2xsRGF0YTtcbiAgbGV0IG1vY2tWb3RlRGF0YTogVm90ZURhdGE7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzZXQgYWxsIG1vY2tzIGJlZm9yZSBlYWNoIHRlc3RcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyBSZXNldCBtb2NrIHJvdXRlcyB0byBlbnN1cmUgY2xlYW4gc3RhdGVcbiAgICBtb2NrU2V0dXAucmVzZXRBbGxNb2NrcygpO1xuICAgIHZhbGlkYXRvciA9IG5ldyBWb3RlVmFsaWRhdG9yKCk7XG4gICAgXG4gICAgbW9ja1BvbGwgPSB7XG4gICAgICBpZDogJ3Rlc3QtcG9sbC0xMjMnLFxuICAgICAgdGl0bGU6ICdUZXN0IFBvbGwnLFxuICAgICAgZGVzY3JpcHRpb246ICdBIHRlc3QgcG9sbCBmb3IgdW5pdCB0ZXN0aW5nJyxcbiAgICAgIHZvdGluZ01ldGhvZDogJ3NpbmdsZScsXG4gICAgICBvcHRpb25zOiBbXG4gICAgICAgIHsgaWQ6ICdvcHRpb24tMScsIHRleHQ6ICdPcHRpb24gMScgfSxcbiAgICAgICAgeyBpZDogJ29wdGlvbi0yJywgdGV4dDogJ09wdGlvbiAyJyB9LFxuICAgICAgICB7IGlkOiAnb3B0aW9uLTMnLCB0ZXh0OiAnT3B0aW9uIDMnIH1cbiAgICAgIF0sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQwMDowMDowMFonKSxcbiAgICAgIGVuZFRpbWU6IG5ldyBEYXRlKCcyMDI1LTEyLTMxVDIzOjU5OjU5WicpLFxuICAgICAgY3JlYXRlZEJ5OiAnYWRtaW4tdXNlcicsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwWicpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQwMDowMDowMFonKSxcbiAgICAgIHZvdGluZ0NvbmZpZzoge1xuICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IGZhbHNlLFxuICAgICAgICBtYXhDaG9pY2VzOiAxLFxuICAgICAgICByZXF1aXJlVmVyaWZpY2F0aW9uOiBmYWxzZSxcbiAgICAgICAgcXVhZHJhdGljQ3JlZGl0czogMTAwLFxuICAgICAgICByYW5nZU1pbjogMCxcbiAgICAgICAgcmFuZ2VNYXg6IDEwXG4gICAgICB9XG4gICAgfTtcblxuICAgIG1vY2tWb3RlRGF0YSA9IHtcbiAgICAgIGlkOiAndm90ZS0xMjMnLFxuICAgICAgcG9sbElkOiAndGVzdC1wb2xsLTEyMycsXG4gICAgICB1c2VySWQ6ICd1c2VyLTEnLFxuICAgICAgY2hvaWNlOiAwLFxuICAgICAgcHJpdmFjeUxldmVsOiAncHVibGljJyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIGF1ZGl0UmVjZWlwdDogJ2F1ZGl0LTEyMydcbiAgICB9O1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHZvdGUgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnJlcXVpcmVzQXV0aGVudGljYXRpb24pLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5yZXF1aXJlc1Rva2VucykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBudWxsIHZvdGUgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG51bGwgYXMgYW55LCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdWb3RlIGRhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHVuZGVmaW5lZCB2b3RlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZSh1bmRlZmluZWQgYXMgYW55LCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdWb3RlIGRhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IG5vbi1vYmplY3Qgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoJ2ludmFsaWQnIGFzIGFueSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnVm90ZSBkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBudWxsIHBvbGwgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbnVsbCBhcyBhbnksICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUG9sbCBkYXRhIGlzIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBwb2xsIGRhdGEgd2l0aG91dCBpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgaWQ6ICcnIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBpbnZhbGlkUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdJbnZhbGlkIHBvbGwgZGF0YScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgcG9sbCBkYXRhIHdpdGhvdXQgdm90aW5nIG1ldGhvZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgdm90aW5nTWV0aG9kOiB1bmRlZmluZWQgYXMgYW55IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBpbnZhbGlkUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdJbnZhbGlkIHBvbGwgZGF0YScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQnVzaW5lc3MgUnVsZXMgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIGZvciBpbmFjdGl2ZSBwb2xsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5hY3RpdmVQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgc3RhdHVzOiAnY2xvc2VkJyBhcyBjb25zdCB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaW5hY3RpdmVQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1BvbGwgaXMgbm90IGFjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSBmb3IgZHJhZnQgcG9sbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0UG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IHN0YXR1czogJ2RyYWZ0JyBhcyBjb25zdCB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgZHJhZnRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1BvbGwgaXMgbm90IGFjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSBmb3IgZXhwaXJlZCBwb2xsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwaXJlZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgZW5kVGltZTogbmV3IERhdGUoJzIwMjQtMTItMzFUMjM6NTk6NTlaJykgLy8gUGFzdCBkYXRlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgZXhwaXJlZFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUG9sbCBoYXMgZW5kZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IHZvdGUgZm9yIHBvbGwgd2l0aG91dCBlbmQgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZW5kVGltZSwgLi4ubm9FbmRUaW1lUG9sbCB9ID0gbW9ja1BvbGw7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG5vRW5kVGltZVBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgZm9yIGxvY2tlZCBwb2xsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9ja2VkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICBsb2NrZWRBdDogbmV3IERhdGUoJzIwMjUtMDEtMDFUMTI6MDA6MDBaJykgXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbG9ja2VkUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdQb2xsIGlzIGxvY2tlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2luZ2xlIENob2ljZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgc2luZ2xlIGNob2ljZSB2b3RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG1pc3NpbmcgY2hvaWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjaG9pY2UsIC4uLmludmFsaWRWb3RlIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQ2hvaWNlIGlzIHJlcXVpcmVkIGZvciBzaW5nbGUgY2hvaWNlIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG51bGwgY2hvaWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgY2hvaWNlOiBudWxsIGFzIGFueSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdDaG9pY2UgaXMgcmVxdWlyZWQgZm9yIHNpbmdsZSBjaG9pY2Ugdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbm9uLWludGVnZXIgY2hvaWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgY2hvaWNlOiAxLjUgYXMgYW55IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0Nob2ljZSBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5lZ2F0aXZlIGNob2ljZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGNob2ljZTogLTEgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQ2hvaWNlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggY2hvaWNlIGV4Y2VlZGluZyBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgY2hvaWNlOiA1IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0Nob2ljZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXBwcm92YWwgVm90aW5nIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrUG9sbC52b3RpbmdNZXRob2QgPSAnYXBwcm92YWwnO1xuICAgICAgbW9ja1BvbGwudm90aW5nQ29uZmlnID0ge1xuICAgICAgICAuLi5tb2NrUG9sbC52b3RpbmdDb25maWcsXG4gICAgICAgIG1heENob2ljZXM6IDMsIC8vIEFsbG93IG11bHRpcGxlIGFwcHJvdmFsc1xuICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCB7IGNob2ljZSwgLi4uYXBwcm92YWxWb3RlRGF0YSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgbW9ja1ZvdGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgYXBwcm92YWxWb3RlRGF0YSwge1xuICAgICAgICBhcHByb3ZhbHM6IFswLCAxXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIGFwcHJvdmFsIHZvdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbWlzc2luZyBhcHByb3ZhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGFwcHJvdmFscywgLi4uaW52YWxpZFZvdGUgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBcHByb3ZhbHMgYXJyYXkgaXMgcmVxdWlyZWQgZm9yIGFwcHJvdmFsIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGVtcHR5IGFwcHJvdmFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGFwcHJvdmFsczogW10gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXQgbGVhc3Qgb25lIG9wdGlvbiBtdXN0IGJlIGFwcHJvdmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbm9uLWFycmF5IGFwcHJvdmFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGFwcHJvdmFsczogJ2ludmFsaWQnIGFzIGFueSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBcHByb3ZhbHMgYXJyYXkgaXMgcmVxdWlyZWQgZm9yIGFwcHJvdmFsIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGludmFsaWQgYXBwcm92YWwgaW5kaWNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGFwcHJvdmFsczogWzAsIDVdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FwcHJvdmFsIGluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggZHVwbGljYXRlIGFwcHJvdmFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGFwcHJvdmFsczogWzAsIDBdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0R1cGxpY2F0ZSBhcHByb3ZhbHMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc3BlY3QgbWF4IGNob2ljZXMgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsaW1pdGVkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IHZvdGluZ0NvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwudm90aW5nQ29uZmlnLCB7IG1heENob2ljZXM6IDEgfSkgfSk7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBhcHByb3ZhbHM6IFswLCAxXSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBsaW1pdGVkUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdNYXhpbXVtIDEgYXBwcm92YWxzIGFsbG93ZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhbmtlZCBDaG9pY2UgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tQb2xsLnZvdGluZ01ldGhvZCA9ICdyYW5rZWQnO1xuICAgICAgY29uc3QgeyBjaG9pY2UsIGFwcHJvdmFscywgLi4ucmFua2VkVm90ZURhdGEgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIG1vY2tWb3RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHJhbmtlZFZvdGVEYXRhLCB7XG4gICAgICAgIHJhbmtpbmdzOiBbMCwgMSwgMl1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB2YWxpZCByYW5rZWQgdm90ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBtaXNzaW5nIHJhbmtpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByYW5raW5ncywgLi4uaW52YWxpZFZvdGUgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdSYW5raW5ncyBhcnJheSBpcyByZXF1aXJlZCBmb3IgcmFua2VkIGNob2ljZSB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBpbmNvbXBsZXRlIHJhbmtpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgcmFua2luZ3M6IFswLCAxXSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBbGwgb3B0aW9ucyBtdXN0IGJlIHJhbmtlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGludmFsaWQgcmFua2luZyBpbmRpY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgcmFua2luZ3M6IFswLCAxLCA1XSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdSYW5raW5nIGluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggZHVwbGljYXRlIHJhbmtpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgcmFua2luZ3M6IFswLCAwLCAxXSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdEdXBsaWNhdGUgcmFua2luZ3MgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdRdWFkcmF0aWMgVm90aW5nIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrUG9sbC52b3RpbmdNZXRob2QgPSAncXVhZHJhdGljJztcbiAgICAgIGNvbnN0IHsgY2hvaWNlLCBhcHByb3ZhbHMsIHJhbmtpbmdzLCAuLi5xdWFkcmF0aWNWb3RlRGF0YSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgbW9ja1ZvdGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgcXVhZHJhdGljVm90ZURhdGEsIHtcbiAgICAgICAgYWxsb2NhdGlvbnM6IHtcbiAgICAgICAgICAnMCc6IDUsXG4gICAgICAgICAgJzEnOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB2YWxpZCBxdWFkcmF0aWMgdm90ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBtaXNzaW5nIGFsbG9jYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBhbGxvY2F0aW9ucywgLi4uaW52YWxpZFZvdGUgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBbGxvY2F0aW9ucyBvYmplY3QgaXMgcmVxdWlyZWQgZm9yIHF1YWRyYXRpYyB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBuZWdhdGl2ZSBhbGxvY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICBhbGxvY2F0aW9uczogeyAnMCc6IC01IH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBbGwgYWxsb2NhdGlvbnMgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlcnMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBub24taW50ZWdlciBhbGxvY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICBhbGxvY2F0aW9uczogeyAnMCc6IDUuNSB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQWxsIGFsbG9jYXRpb25zIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXJzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIGV4Y2VlZGluZyBjcmVkaXQgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgYWxsb2NhdGlvbnM6IHsgJzAnOiAxMSB9IC8vIDExXjIgPSAxMjEgPiAxMDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQ29udGFpbignZXhjZWVkcyBhdmFpbGFibGUgY3JlZGl0cycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5vIGFsbG9jYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIGFsbG9jYXRpb25zOiB7ICcwJzogMCwgJzEnOiAwLCAnMic6IDAgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0F0IGxlYXN0IG9uZSBvcHRpb24gbXVzdCByZWNlaXZlIHZvdGVzJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSYW5nZSBWb3RpbmcgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tQb2xsLnZvdGluZ01ldGhvZCA9ICdyYW5nZSc7XG4gICAgICBjb25zdCB7IGNob2ljZSwgYXBwcm92YWxzLCByYW5raW5ncywgYWxsb2NhdGlvbnMsIC4uLnJhbmdlVm90ZURhdGEgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIG1vY2tWb3RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHJhbmdlVm90ZURhdGEsIHtcbiAgICAgICAgcmF0aW5nczoge1xuICAgICAgICAgICcwJzogOCxcbiAgICAgICAgICAnMSc6IDYsXG4gICAgICAgICAgJzInOiA0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB2YWxpZCByYW5nZSB2b3RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG1pc3NpbmcgcmF0aW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmF0aW5ncywgLi4uaW52YWxpZFZvdGUgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdSYXRpbmdzIG9iamVjdCBpcyByZXF1aXJlZCBmb3IgcmFuZ2Ugdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggcmF0aW5ncyBvdXRzaWRlIHJhbmdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIHJhdGluZ3M6IHsgJzAnOiAxNSB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUmF0aW5nIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGluY29tcGxldGUgcmF0aW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICByYXRpbmdzOiB7ICcwJzogOCwgJzEnOiA2IH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBbGwgb3B0aW9ucyBtdXN0IGJlIHJhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggYWxsIG1pbmltdW0gcmF0aW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICByYXRpbmdzOiB7ICcwJzogMCwgJzEnOiAwLCAnMic6IDAgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0F0IGxlYXN0IG9uZSBvcHRpb24gbXVzdCBoYXZlIGEgcmF0aW5nIGFib3ZlIHRoZSBtaW5pbXVtJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVxdWlyZSBhdXRoZW50aWNhdGlvbiB3aGVuIHZlcmlmaWNhdGlvbiBpcyByZXF1aXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZlcmlmaWVkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICB2b3RpbmdDb25maWc6IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLnZvdGluZ0NvbmZpZywgeyByZXF1aXJlVmVyaWZpY2F0aW9uOiB0cnVlIH0pIFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIHZlcmlmaWVkUG9sbCk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkIGZvciB0aGlzIHBvbGwnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IHZvdGUgd2hlbiB2ZXJpZmljYXRpb24gaXMgbm90IHJlcXVpcmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNoZWNrIHRydXN0IHRpZXIgcmVxdWlyZW1lbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaGlnaFRydXN0UG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICB2b3RpbmdDb25maWc6IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLnZvdGluZ0NvbmZpZywgeyBcbiAgICAgICAgICBtaW5UcnVzdFRpZXI6ICdUMicsXG4gICAgICAgICAgYWxsb3dNdWx0aXBsZVZvdGVzOiB0cnVlIC8vIEFsbG93IG11bHRpcGxlIHZvdGVzIHRvIGF2b2lkIGV4aXN0aW5nIHZvdGUgY2hlY2tcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBNb2NrIG5vIGV4aXN0aW5nIHZvdGUgKHVzZXIgY2FuIHZvdGUpXG4gICAgICB3aGVuKCkudGFibGUoJ3ZvdGVzJykub3AoJ3NlbGVjdCcpLmVxKCdwb2xsX2lkJywgJ3Rlc3QtcG9sbC0xMjMnKS5lcSgndXNlcl9pZCcsICd1c2VyLTEnKS5yZXR1cm5zTGlzdChbXSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgZ2V0VXNlclRydXN0VGllciB0byByZXR1cm4gVDEgKGluc3VmZmljaWVudClcbiAgICAgIHdoZW4oKS50YWJsZSgndXNlcl9wcm9maWxlcycpLm9wKCdzZWxlY3QnKS5zZWxlY3QoJ3RydXN0X3RpZXInKS5lcSgndXNlcl9pZCcsICd1c2VyLTEnKS5yZXR1cm5zU2luZ2xlKHsgdHJ1c3RfdGllcjogJ1QxJyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBoaWdoVHJ1c3RQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0luc3VmZmljaWVudCB0cnVzdCB0aWVyIGZvciB0aGlzIHBvbGwnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjZXB0IHZvdGUgd2l0aCBzdWZmaWNpZW50IHRydXN0IHRpZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBoaWdoVHJ1c3RQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIHZvdGluZ0NvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwudm90aW5nQ29uZmlnLCB7IFxuICAgICAgICAgIG1pblRydXN0VGllcjogJ1QxJyxcbiAgICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IHRydWUgLy8gQWxsb3cgbXVsdGlwbGUgdm90ZXMgdG8gYXZvaWQgZXhpc3Rpbmcgdm90ZSBjaGVja1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgZ2V0VXNlclRydXN0VGllciB0byByZXR1cm4gVDIgKHN1ZmZpY2llbnQpXG4gICAgICB3aGVuKCkudGFibGUoJ3VzZXJfcHJvZmlsZXMnKS5vcCgnc2VsZWN0Jykuc2VsZWN0KCd0cnVzdF90aWVyJykuZXEoJ3VzZXJfaWQnLCAndXNlci0xJykucmV0dXJuc1NpbmdsZSh7IHRydXN0X3RpZXI6ICdUMicgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaGlnaFRydXN0UG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICAvLyBUaGUgdmFsaWRhdGlvbiBzaG91bGQgcGFzcyBzaW5jZSBUMiA+PSBUMVxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGEgbWV0aG9kIHRvIHRocm93IGFuIGVycm9yXG4gICAgICBjb25zdCBvcmlnaW5hbFZhbGlkYXRlQmFzaWNWb3RlRGF0YSA9ICh2YWxpZGF0b3IgYXMgYW55KS52YWxpZGF0ZUJhc2ljVm90ZURhdGE7XG4gICAgICAodmFsaWRhdG9yIGFzIGFueSkudmFsaWRhdGVCYXNpY1ZvdGVEYXRhID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbiBlcnJvcicpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnVmFsaWRhdGlvbiBlcnJvcicpO1xuXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgKHZhbGlkYXRvciBhcyBhbnkpLnZhbGlkYXRlQmFzaWNWb3RlRGF0YSA9IG9yaWdpbmFsVmFsaWRhdGVCYXNpY1ZvdGVEYXRhO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgdmFsaWRhdG9yIGluc3RhbmNlIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIG90aGVyIHRlc3RzXG4gICAgICBjb25zdCB0ZXN0VmFsaWRhdG9yID0gbmV3IFZvdGVWYWxpZGF0b3IoKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayB0aGUgZ2V0VXNlclRydXN0VGllciBtZXRob2QgdG8gcmV0dXJuIFQwIChkZWZhdWx0IGZhbGxiYWNrKVxuICAgICAgY29uc3Qgb3JpZ2luYWxHZXRVc2VyVHJ1c3RUaWVyID0gKHRlc3RWYWxpZGF0b3IgYXMgYW55KS5nZXRVc2VyVHJ1c3RUaWVyO1xuICAgICAgY29uc3QgbW9ja0dldFVzZXJUcnVzdFRpZXIgPSBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjwoKSA9PiBQcm9taXNlPHN0cmluZz4+O1xuICAgICAgbW9ja0dldFVzZXJUcnVzdFRpZXIubW9ja1Jlc29sdmVkVmFsdWUoJ1QwJyk7XG4gICAgICAodGVzdFZhbGlkYXRvciBhcyBhbnkpLmdldFVzZXJUcnVzdFRpZXIgPSBtb2NrR2V0VXNlclRydXN0VGllcjtcblxuICAgICAgY29uc3QgaGlnaFRydXN0UG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICB2b3RpbmdDb25maWc6IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLnZvdGluZ0NvbmZpZywgeyBcbiAgICAgICAgICBtaW5UcnVzdFRpZXI6ICdUMScsXG4gICAgICAgICAgYWxsb3dNdWx0aXBsZVZvdGVzOiB0cnVlIC8vIEFsbG93IG11bHRpcGxlIHZvdGVzIHRvIGF2b2lkIGV4aXN0aW5nIHZvdGUgY2hlY2tcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdGVzdFZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBoaWdoVHJ1c3RQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBmYWxsIGJhY2sgdG8gZGVmYXVsdCB0cnVzdCB0aWVyIChUMCkgYW5kIGZhaWxcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0luc3VmZmljaWVudCB0cnVzdCB0aWVyIGZvciB0aGlzIHBvbGwnKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgICh0ZXN0VmFsaWRhdG9yIGFzIGFueSkuZ2V0VXNlclRydXN0VGllciA9IG9yaWdpbmFsR2V0VXNlclRydXN0VGllcjtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImRldkxvZyIsImZuIiwibW9ja1NldHVwIiwiZ2V0TVMiLCJ3aGVuIiwiY2xpZW50IiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiZ2V0U3VwYWJhc2VTZXJ2ZXJDbGllbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImRlc2NyaWJlIiwidmFsaWRhdG9yIiwibW9ja1BvbGwiLCJtb2NrVm90ZURhdGEiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInJlc2V0QWxsTW9ja3MiLCJWb3RlVmFsaWRhdG9yIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidm90aW5nTWV0aG9kIiwib3B0aW9ucyIsInRleHQiLCJzdGF0dXMiLCJzdGFydFRpbWUiLCJEYXRlIiwiZW5kVGltZSIsImNyZWF0ZWRCeSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInZvdGluZ0NvbmZpZyIsImFsbG93TXVsdGlwbGVWb3RlcyIsIm1heENob2ljZXMiLCJyZXF1aXJlVmVyaWZpY2F0aW9uIiwicXVhZHJhdGljQ3JlZGl0cyIsInJhbmdlTWluIiwicmFuZ2VNYXgiLCJwb2xsSWQiLCJ1c2VySWQiLCJjaG9pY2UiLCJwcml2YWN5TGV2ZWwiLCJ0aW1lc3RhbXAiLCJhdWRpdFJlY2VpcHQiLCJhZnRlckVhY2giLCJpdCIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZVZvdGUiLCJleHBlY3QiLCJpc1ZhbGlkIiwidG9CZSIsInJlcXVpcmVzQXV0aGVudGljYXRpb24iLCJyZXF1aXJlc1Rva2VucyIsImVycm9yIiwidW5kZWZpbmVkIiwiaW52YWxpZFBvbGwiLCJPYmplY3QiLCJhc3NpZ24iLCJpbmFjdGl2ZVBvbGwiLCJkcmFmdFBvbGwiLCJleHBpcmVkUG9sbCIsIm5vRW5kVGltZVBvbGwiLCJsb2NrZWRQb2xsIiwibG9ja2VkQXQiLCJpbnZhbGlkVm90ZSIsImFwcHJvdmFsVm90ZURhdGEiLCJhcHByb3ZhbHMiLCJsaW1pdGVkUG9sbCIsInJhbmtlZFZvdGVEYXRhIiwicmFua2luZ3MiLCJxdWFkcmF0aWNWb3RlRGF0YSIsImFsbG9jYXRpb25zIiwidG9Db250YWluIiwicmFuZ2VWb3RlRGF0YSIsInJhdGluZ3MiLCJ2ZXJpZmllZFBvbGwiLCJoaWdoVHJ1c3RQb2xsIiwibWluVHJ1c3RUaWVyIiwidGFibGUiLCJvcCIsImVxIiwicmV0dXJuc0xpc3QiLCJzZWxlY3QiLCJyZXR1cm5zU2luZ2xlIiwidHJ1c3RfdGllciIsIm9yaWdpbmFsVmFsaWRhdGVCYXNpY1ZvdGVEYXRhIiwidmFsaWRhdGVCYXNpY1ZvdGVEYXRhIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiRXJyb3IiLCJ0ZXN0VmFsaWRhdG9yIiwib3JpZ2luYWxHZXRVc2VyVHJ1c3RUaWVyIiwiZ2V0VXNlclRydXN0VGllciIsIm1vY2tHZXRVc2VyVHJ1c3RUaWVy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