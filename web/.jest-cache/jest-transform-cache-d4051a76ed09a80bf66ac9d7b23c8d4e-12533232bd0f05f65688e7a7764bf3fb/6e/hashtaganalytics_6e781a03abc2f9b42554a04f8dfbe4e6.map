{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/features/hashtags/lib/hashtag-analytics.ts"],"sourcesContent":["/**\n * Hashtag Analytics Service\n * \n * Advanced analytics and trending algorithms for hashtag performance tracking\n * Includes cross-feature discovery, engagement analysis, and predictive insights\n * \n * Created: October 10, 2025\n * Updated: October 11, 2025\n * Status: âœ… ACTIVE\n */\n\nimport { createClient } from '@supabase/supabase-js';\n\nimport { logger } from '../../../lib/utils/logger';\n\n\nimport type {\n  Hashtag,\n  HashtagAnalytics,\n  TrendingHashtag,\n  HashtagCategory\n} from '../types';\nimport {\n  calculateEngagementRate,\n  calculateGrowthRate,\n  calculateTrendingScore,\n  getHashtagPerformanceLevel\n} from '../utils/hashtag-utils';\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\n// ============================================================================\n// ANALYTICS CORE FUNCTIONS\n// ============================================================================\n\n/**\n * Calculate comprehensive hashtag analytics\n */\nexport async function calculateHashtagAnalytics(\n  hashtagId: string,\n  period: '24h' | '7d' | '30d' | '90d' | '1y' = '7d'\n): Promise<HashtagAnalytics> {\n  try {\n    const startDate = getPeriodStartDate(period);\n    const endDate = new Date().toISOString();\n\n    // Get usage data\n    const usageData = await getHashtagUsageData(hashtagId, startDate, endDate);\n    \n    // Get engagement data\n    const engagementData = await getHashtagEngagementData(hashtagId, startDate, endDate);\n    \n    // Get user data\n    const userData = await getHashtagUserData(hashtagId, startDate, endDate);\n    \n    // Get content data\n    const contentData = await getHashtagContentData(hashtagId, startDate, endDate);\n    \n    // Calculate metrics\n    const metrics = {\n      usage_count: usageData.totalUsage,\n      unique_users: userData.uniqueUsers,\n      engagement_rate: calculateEngagementRate(Number(usageData.totalViews), Number(engagementData.totalInteractions)),\n      growth_rate: calculateGrowthRate(usageData.currentUsage, usageData.previousUsage),\n      peak_usage: usageData.peakUsage,\n      average_usage: usageData.averageUsage,\n      top_content: contentData.topContent,\n      top_users: userData.topUsers as string[],\n      related_hashtags: await getRelatedHashtags(hashtagId),\n      sentiment_distribution: await getSentimentDistribution(hashtagId, startDate, endDate),\n      geographic_distribution: await getGeographicDistribution(hashtagId, startDate, endDate),\n      demographic_distribution: await getDemographicDistribution(hashtagId, startDate, endDate)\n    };\n\n    return {\n      hashtag_id: hashtagId,\n      period,\n      metrics,\n      generated_at: new Date().toISOString()\n    };\n  } catch (error) {\n    logger.error('Failed to calculate hashtag analytics:', error instanceof Error ? error : new Error(String(error)));\n    throw error;\n  }\n}\n\n/**\n * Calculate trending hashtags with advanced algorithms\n */\nexport async function calculateTrendingHashtags(\n  category?: HashtagCategory,\n  limit = 20\n): Promise<TrendingHashtag[]> {\n  try {\n    const timeWindow = 24; // hours\n    const now = new Date();\n    const startTime = new Date(now.getTime() - timeWindow * 60 * 60 * 1000);\n\n    // Get hashtag usage data\n    const { data: usageData, error: usageError } = await supabase\n      .from('hashtag_usage')\n      .select('hashtag_id, created_at, user_id')\n      .gte('created_at', startTime.toISOString())\n      .order('created_at', { ascending: false });\n\n    if (usageError) throw usageError;\n\n    // Group by hashtag and calculate metrics\n    const hashtagMetrics = new Map<string, {\n      usageCount: number;\n      uniqueUsers: Set<string>;\n      recentUsage: number[];\n      peakUsage: number;\n    }>();\n\n    usageData?.forEach(usage => {\n      const hashtagId = usage.hashtag_id;\n      if (!hashtagMetrics.has(hashtagId)) {\n        hashtagMetrics.set(hashtagId, {\n          usageCount: 0,\n          uniqueUsers: new Set(),\n          recentUsage: [],\n          peakUsage: 0\n        });\n      }\n\n      const metrics = hashtagMetrics.get(hashtagId)!;\n      metrics.usageCount++;\n      metrics.uniqueUsers.add(String(usage.user_id ?? 'anonymous'));\n      metrics.recentUsage.push(1);\n      metrics.peakUsage = Math.max(metrics.peakUsage, metrics.usageCount);\n    });\n\n    // Get hashtag details\n    const hashtagIds = Array.from(hashtagMetrics.keys());\n    const { data: hashtags, error: hashtagError } = await supabase\n      .from('hashtags')\n      .select('*')\n      .in('id', hashtagIds);\n\n    if (hashtagError) throw hashtagError;\n\n    // Calculate trending scores and create trending hashtags\n    const trendingHashtags: TrendingHashtag[] = [];\n\n    for (const hashtag of hashtags || []) {\n      if (category && String(hashtag.category) !== category) continue;\n\n      const metrics = hashtagMetrics.get(hashtag.id);\n      if (!metrics) continue;\n\n      const growthRate = calculateGrowthRate(metrics.usageCount, 0); // Simplified for now\n      const engagementRate = calculateEngagementRate(metrics.usageCount, metrics.usageCount);\n      const recency = 1; // Simplified for now\n      \n      const trendScore = calculateTrendingScore(\n        metrics.usageCount,\n        growthRate,\n        recency,\n        engagementRate\n      );\n\n      trendingHashtags.push({\n        hashtag,\n        trend_score: trendScore,\n        growth_rate: growthRate,\n        usage_count_24h: metrics.usageCount,\n        usage_count_7d: await getUsageCount(hashtag.id, 7),\n        peak_position: await calculatePeakPosition(hashtag.id),\n        current_position: await calculateCurrentPosition(hashtag.id),\n        related_hashtags: await getRelatedHashtags(hashtag.id),\n        trending_since: metrics.recentUsage.length > 0 ? \n          new Date(Math.min(...metrics.recentUsage.map((_, i) => \n            new Date(now.getTime() - i * 60 * 60 * 1000).getTime()\n          ))).toISOString() : hashtag.created_at,\n        category_trends: await getCategoryTrends(hashtag.category) as Record<string, number>\n      });\n    }\n\n    // Sort by trend score and return top results\n    return trendingHashtags\n      .sort((a, b) => b.trend_score - a.trend_score)\n      .slice(0, limit);\n  } catch (error) {\n    console.error('Failed to calculate trending hashtags:', error);\n    throw error;\n  }\n}\n\n/**\n * Get hashtag performance insights\n */\nexport async function getHashtagPerformanceInsights(hashtagId: string): Promise<{\n  performance: 'low' | 'medium' | 'high' | 'viral';\n  insights: string[];\n  recommendations: string[];\n  benchmarks: {\n    category: string;\n    average: number;\n    top: number;\n    current: number;\n  };\n}> {\n  try {\n    const analytics = await calculateHashtagAnalytics(hashtagId, '7d');\n    const performance = getHashtagPerformanceLevel(analytics.metrics.engagement_rate);\n    \n    const insights: string[] = [];\n    const recommendations: string[] = [];\n\n    // Generate insights based on performance\n    if (analytics.metrics.engagement_rate > 0.1) {\n      insights.push('High engagement rate indicates strong user interest');\n    } else if (analytics.metrics.engagement_rate < 0.01) {\n      insights.push('Low engagement suggests need for content optimization');\n    }\n\n    if (analytics.metrics.growth_rate > 50) {\n      insights.push('Rapid growth indicates trending potential');\n    } else if (analytics.metrics.growth_rate < 0) {\n      insights.push('Declining usage may indicate waning interest');\n    }\n\n    if (analytics.metrics.unique_users > 100) {\n      insights.push('Broad user base suggests good reach');\n    } else if (analytics.metrics.unique_users < 10) {\n      insights.push('Limited user base may need promotion');\n    }\n\n    // Generate recommendations\n    if (performance === 'low') {\n      recommendations.push('Consider creating more engaging content');\n      recommendations.push('Promote hashtag through cross-feature integration');\n      recommendations.push('Analyze top-performing hashtags for inspiration');\n    } else if (performance === 'high' || performance === 'viral') {\n      recommendations.push('Leverage current momentum for maximum impact');\n      recommendations.push('Consider creating related content');\n      recommendations.push('Monitor for potential moderation needs');\n    }\n\n    // Get benchmark data\n    const benchmarks = await getHashtagBenchmarks(hashtagId);\n\n    return {\n      performance,\n      insights,\n      recommendations,\n      benchmarks: {\n        category: benchmarks.category,\n        average: benchmarks.usage.average,\n        top: benchmarks.usage.top,\n        current: benchmarks.usage.current\n      }\n    };\n  } catch (error) {\n    console.error('Failed to get hashtag performance insights:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// CROSS-FEATURE DISCOVERY\n// ============================================================================\n\n/**\n * Get cross-feature hashtag discovery\n */\nexport async function getCrossFeatureDiscovery(\n  userId: string,\n  limit = 10\n): Promise<{\n  profileSuggestions: Hashtag[];\n  pollSuggestions: Hashtag[];\n  feedSuggestions: Hashtag[];\n  trendingSuggestions: Hashtag[];\n}> {\n  try {\n    // Get user's current hashtags\n    const { data: userHashtags } = await supabase\n      .from('user_hashtags')\n      .select('hashtag_id, hashtag:hashtags(*)')\n      .eq('user_id', userId);\n\n    const currentHashtagIds = userHashtags?.map(uh => uh.hashtag_id) || [];\n\n    // Get profile-based suggestions\n    const profileSuggestions = await getProfileBasedSuggestions(userId, currentHashtagIds, limit);\n    \n    // Get poll-based suggestions\n    const pollSuggestions = await getPollBasedSuggestions(userId, currentHashtagIds, limit);\n    \n    // Get feed-based suggestions\n    const feedSuggestions = await getFeedBasedSuggestions(userId, currentHashtagIds, limit);\n    \n    // Get trending suggestions\n    const trendingSuggestions = await getTrendingSuggestions(currentHashtagIds, limit);\n\n    return {\n      profileSuggestions: profileSuggestions.map(h => h.hashtag),\n      pollSuggestions: pollSuggestions.map(h => h.hashtag),\n      feedSuggestions: feedSuggestions.map(h => h.hashtag),\n      trendingSuggestions: trendingSuggestions.map(th => th.hashtag)\n    };\n  } catch (error) {\n    console.error('Failed to get cross-feature discovery:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction getPeriodStartDate(period: string): string {\n  const now = new Date();\n  const periods = {\n    '24h': 24 * 60 * 60 * 1000,\n    '7d': 7 * 24 * 60 * 60 * 1000,\n    '30d': 30 * 24 * 60 * 60 * 1000,\n    '90d': 90 * 24 * 60 * 60 * 1000,\n    '1y': 365 * 24 * 60 * 60 * 1000\n  };\n  \n  const startTime = new Date(now.getTime() - (periods[period as keyof typeof periods] || periods['7d']));\n  return startTime.toISOString();\n}\n\nasync function getHashtagUsageData(hashtagId: string, startDate: string, endDate: string) {\n  const { data, error } = await supabase\n    .from('hashtag_usage')\n    .select('*')\n    .eq('hashtag_id', hashtagId)\n    .gte('created_at', startDate)\n    .lte('created_at', endDate);\n\n  if (error) throw error;\n\n  return {\n    totalUsage: data?.length || 0,\n    totalViews: data?.reduce((sum, usage) => sum + (usage.views || 0), 0) || 0,\n    currentUsage: data?.length || 0,\n    previousUsage: await getPreviousPeriodUsage(hashtagId, startDate, endDate),\n    peakUsage: Math.max(...(data?.map(_d => 1) || [0])),\n    averageUsage: data?.length || 0\n  };\n}\n\nasync function getHashtagEngagementData(_hashtagId: string, _startDate: string, _endDate: string) {\n  const { data, error } = await supabase\n    .from('hashtag_engagement')\n    .select('*')\n    .eq('hashtag_id', _hashtagId)\n    .gte('timestamp', _startDate)\n    .lte('timestamp', _endDate);\n\n  if (error) throw error;\n\n  return {\n    totalInteractions: data?.length || 0,\n    clicks: data?.filter(d => d.engagement_type === 'click').length || 0,\n    shares: data?.filter(d => d.engagement_type === 'share').length || 0,\n    views: data?.filter(d => d.engagement_type === 'view').length || 0\n  };\n}\n\nasync function getHashtagUserData(hashtagId: string, startDate: string, endDate: string) {\n  const { data, error } = await supabase\n    .from('hashtag_usage')\n    .select('user_id')\n    .eq('hashtag_id', hashtagId)\n    .gte('created_at', startDate)\n    .lte('created_at', endDate);\n\n  if (error) throw error;\n\n  const uniqueUsers = new Set(data?.map(d => d.user_id).filter(Boolean));\n  \n  return {\n    uniqueUsers: uniqueUsers.size,\n    topUsers: Array.from(uniqueUsers).slice(0, 10)\n  };\n}\n\nasync function getHashtagContentData(hashtagId: string, startDate: string, endDate: string) {\n  const { data, error } = await supabase\n    .from('hashtag_content')\n    .select('content_id, engagement_score')\n    .eq('hashtag_id', hashtagId)\n    .gte('created_at', startDate)\n    .lte('created_at', endDate)\n    .order('engagement_score', { ascending: false })\n    .limit(10);\n\n  if (error) throw error;\n\n  return {\n    topContent: data?.map(d => d.content_id) || []\n  };\n}\n\nasync function getRelatedHashtags(hashtagId: string): Promise<string[]> {\n  try {\n    // Get hashtag details\n    const { data: hashtag, error: hashtagError } = await supabase\n      .from('hashtags')\n      .select('name, category')\n      .eq('id', hashtagId)\n      .single();\n\n    if (hashtagError) throw hashtagError;\n\n    // Find related hashtags by category and co-occurrence\n    const { data: relatedHashtags, error: relatedError } = await supabase\n      .from('hashtags')\n      .select('name')\n      .eq('category', hashtag.category)\n      .neq('id', hashtagId)\n      .order('usage_count', { ascending: false })\n      .limit(5);\n\n    if (relatedError) throw relatedError;\n\n    // Find hashtags that often appear together\n    const { data: coOccurringHashtags, error: coOccurringError } = await supabase\n      .from('hashtag_usage')\n      .select('hashtag_id, hashtag:hashtags(name)')\n      .neq('hashtag_id', hashtagId)\n      .limit(10);\n\n    if (coOccurringError) throw coOccurringError;\n\n    // Combine and deduplicate results\n    const relatedNames = new Set<string>();\n    \n    // Add category-based related hashtags\n    relatedHashtags?.forEach((h: any) => relatedNames.add(h.name));\n    \n    // Add co-occurring hashtags\n    coOccurringHashtags?.forEach((h: any) => {\n      if (h.hashtag?.name) {\n        relatedNames.add(h.hashtag.name);\n      }\n    });\n\n    return Array.from(relatedNames).slice(0, 8);\n  } catch (error) {\n    console.error('Failed to get related hashtags:', error);\n    return [];\n  }\n}\n\nasync function getSentimentDistribution(hashtagId: string, startDate: string, endDate: string) {\n  try {\n    // Get hashtag usage data with sentiment information\n    const { data: usageData, error } = await supabase\n      .from('hashtag_usage')\n      .select('sentiment')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', startDate)\n      .lte('created_at', endDate)\n      .not('sentiment', 'is', null);\n\n    if (error) throw error;\n\n    // Calculate sentiment distribution\n    const sentimentCounts = {\n      positive: 0,\n      neutral: 0,\n      negative: 0\n    };\n\n    usageData?.forEach(usage => {\n      if (usage.sentiment === 'positive') sentimentCounts.positive++;\n      else if (usage.sentiment === 'neutral') sentimentCounts.neutral++;\n      else if (usage.sentiment === 'negative') sentimentCounts.negative++;\n    });\n\n    const total = sentimentCounts.positive + sentimentCounts.neutral + sentimentCounts.negative;\n    \n    if (total === 0) {\n      return {\n        positive: 0.6,\n        neutral: 0.3,\n        negative: 0.1\n      };\n    }\n\n    return {\n      positive: sentimentCounts.positive / total,\n      neutral: sentimentCounts.neutral / total,\n      negative: sentimentCounts.negative / total\n    };\n  } catch (error) {\n    console.error('Failed to get sentiment distribution:', error);\n    return {\n      positive: 0.6,\n      neutral: 0.3,\n      negative: 0.1\n    };\n  }\n}\n\nasync function getGeographicDistribution(hashtagId: string, startDate: string, endDate: string) {\n  try {\n    // Get hashtag usage data with geographic information\n    const { data: usageData, error } = await supabase\n      .from('hashtag_usage')\n      .select('metadata')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', startDate)\n      .lte('created_at', endDate)\n      .not('metadata', 'is', null);\n\n    if (error) throw error;\n\n    // Extract geographic data from metadata\n    const geographicCounts: Record<string, number> = {};\n    let totalCount = 0;\n\n    usageData?.forEach(usage => {\n      if (usage.metadata?.geographic_region) {\n        const region = usage.metadata.geographic_region;\n        geographicCounts[region] = (geographicCounts[region] || 0) + 1;\n        totalCount++;\n      }\n    });\n\n    // Convert counts to percentages\n    const distribution: Record<string, number> = {};\n    Object.entries(geographicCounts).forEach(([region, count]) => {\n      distribution[region] = count / totalCount;\n    });\n\n    // If no geographic data, return default distribution\n    if (totalCount === 0) {\n      return {\n        'US': 0.7,\n        'CA': 0.2,\n        'UK': 0.1\n      };\n    }\n\n    return distribution;\n  } catch (error) {\n    console.error('Failed to get geographic distribution:', error);\n    return {\n      'US': 0.7,\n      'CA': 0.2,\n      'UK': 0.1\n    };\n  }\n}\n\nasync function getDemographicDistribution(hashtagId: string, startDate: string, endDate: string) {\n  try {\n    // Get hashtag usage data with user demographic information\n    const { data: usageData, error } = await supabase\n      .from('hashtag_usage')\n      .select('user_id, metadata')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', startDate)\n      .lte('created_at', endDate);\n\n    if (error) throw error;\n\n    // Get user demographic data\n    const userIds = usageData?.map(u => u.user_id).filter(Boolean) || [];\n    if (userIds.length === 0) {\n      return {\n        '18-24': 0.3,\n        '25-34': 0.4,\n        '35-44': 0.2,\n        '45+': 0.1\n      };\n    }\n\n    const { data: userData, error: userError } = await supabase\n      .from('profiles')\n      .select('age_group, demographic_data')\n      .in('id', userIds);\n\n    if (userError) throw userError;\n\n    // Calculate demographic distribution\n    const demographicCounts: Record<string, number> = {};\n    let totalCount = 0;\n\n    userData?.forEach(user => {\n      const ageGroup = user.age_group || user.demographic_data?.age_group;\n      if (ageGroup) {\n        demographicCounts[ageGroup] = (demographicCounts[ageGroup] || 0) + 1;\n        totalCount++;\n      }\n    });\n\n    // Convert counts to percentages\n    const distribution: Record<string, number> = {};\n    Object.entries(demographicCounts).forEach(([ageGroup, count]) => {\n      distribution[ageGroup] = count / totalCount;\n    });\n\n    // If no demographic data, return default distribution\n    if (totalCount === 0) {\n      return {\n        '18-24': 0.3,\n        '25-34': 0.4,\n        '35-44': 0.2,\n        '45+': 0.1\n      };\n    }\n\n    return distribution;\n  } catch (error) {\n    console.error('Failed to get demographic distribution:', error);\n    return {\n      '18-24': 0.3,\n      '25-34': 0.4,\n      '35-44': 0.2,\n      '45+': 0.1\n    };\n  }\n}\n\nasync function getUsageCount(hashtagId: string, days: number): Promise<number> {\n  const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n  \n  const { data, error } = await supabase\n    .from('hashtag_usage')\n    .select('id')\n    .eq('hashtag_id', hashtagId)\n    .gte('created_at', startDate.toISOString());\n\n  if (error) throw error;\n  return data?.length || 0;\n}\n\nasync function getCategoryTrends(category: string) {\n  try {\n    // Get trending hashtags in the same category\n    const { data: categoryHashtags, error } = await supabase\n      .from('hashtags')\n      .select('id, name, trend_score, usage_count')\n      .eq('category', category)\n      .eq('is_trending', true)\n      .order('trend_score', { ascending: false })\n      .limit(10);\n\n    if (error) throw error;\n\n    // Calculate category trend metrics\n    const totalTrendScore = categoryHashtags?.reduce((sum, h) => sum + h.trend_score, 0) || 0;\n    const totalUsage = categoryHashtags?.reduce((sum, h) => sum + h.usage_count, 0) || 0;\n    const averageTrendScore = categoryHashtags?.length ? totalTrendScore / categoryHashtags.length : 0;\n    const averageUsage = categoryHashtags?.length ? totalUsage / categoryHashtags.length : 0;\n\n    return {\n      category,\n      trending_hashtags: categoryHashtags?.length || 0,\n      total_trend_score: totalTrendScore,\n      total_usage: totalUsage,\n      average_trend_score: averageTrendScore,\n      average_usage: averageUsage,\n      top_hashtags: categoryHashtags?.slice(0, 5).map(h => h.name) || []\n    };\n  } catch (error) {\n    console.error('Failed to get category trends:', error);\n    return {};\n  }\n}\n\nasync function getHashtagBenchmarks(hashtagId: string) {\n  try {\n    // Get hashtag details\n    const { data: hashtag, error: hashtagError } = await supabase\n      .from('hashtags')\n      .select('category, usage_count, trend_score')\n      .eq('id', hashtagId)\n      .single();\n\n    if (hashtagError) throw hashtagError;\n\n    // Get category benchmarks\n    const { data: categoryHashtags, error: categoryError } = await supabase\n      .from('hashtags')\n      .select('usage_count, trend_score')\n      .eq('category', hashtag.category)\n      .order('usage_count', { ascending: false });\n\n    if (categoryError) throw categoryError;\n\n    // Calculate benchmarks\n    const usageCounts = categoryHashtags?.map(h => h.usage_count) || [];\n    const trendScores = categoryHashtags?.map(h => h.trend_score) || [];\n\n    const averageUsage = usageCounts.length ? usageCounts.reduce((sum, count) => sum + count, 0) / usageCounts.length : 0;\n    const topUsage = usageCounts.length ? Math.max(...usageCounts) : 0;\n    const currentUsage = hashtag.usage_count;\n\n    const averageTrend = trendScores.length ? trendScores.reduce((sum, score) => sum + score, 0) / trendScores.length : 0;\n    const topTrend = trendScores.length ? Math.max(...trendScores) : 0;\n    const currentTrend = hashtag.trend_score;\n\n    return {\n      category: hashtag.category || 'custom',\n      usage: {\n        average: Math.round(averageUsage),\n        top: topUsage,\n        current: currentUsage\n      },\n      trending: {\n        average: Math.round(averageTrend * 100) / 100,\n        top: topTrend,\n        current: currentTrend\n      },\n      performance: {\n        usage_percentile: usageCounts.length ? (usageCounts.filter(c => c <= currentUsage).length / usageCounts.length) * 100 : 0,\n        trend_percentile: trendScores.length ? (trendScores.filter(s => s <= currentTrend).length / trendScores.length) * 100 : 0\n      }\n    };\n  } catch (error) {\n    console.error('Failed to get hashtag benchmarks:', error);\n    return {\n      category: 'custom',\n      usage: {\n        average: 50,\n        top: 200,\n        current: 75\n      },\n      trending: {\n        average: 0.5,\n        top: 1.0,\n        current: 0.75\n      },\n      performance: {\n        usage_percentile: 75,\n        trend_percentile: 75\n      }\n    };\n  }\n}\n\nasync function getProfileBasedSuggestions(userId: string, currentHashtagIds: string[], limit: number) {\n  try {\n    // Get user's profile data\n    const { data: profile, error: profileError } = await supabase\n      .from('profiles')\n      .select('interests, demographics, preferences')\n      .eq('id', userId)\n      .single();\n\n    if (profileError) throw profileError;\n\n    // Get hashtags based on user interests\n    const interests = profile?.interests || [];\n    const suggestions: any[] = [];\n\n    if (interests.length > 0) {\n      const { data: interestHashtags, error: hashtagError } = await supabase\n        .from('hashtags')\n        .select('*, hashtag:hashtags(*)')\n        .in('category', interests)\n        .not('id', 'in', `(${currentHashtagIds.join(',')})`)\n        .order('usage_count', { ascending: false })\n        .limit(limit);\n\n      if (!hashtagError && interestHashtags) {\n        suggestions.push(...interestHashtags);\n      }\n    }\n\n    // Get hashtags based on user demographics\n    const demographics = profile?.demographics || {};\n    if (demographics.age_group) {\n      const { data: demographicHashtags, error: demoError } = await supabase\n        .from('hashtags')\n        .select('*, hashtag:hashtags(*)')\n        .eq('category', demographics.age_group)\n        .not('id', 'in', `(${currentHashtagIds.join(',')})`)\n        .order('usage_count', { ascending: false })\n        .limit(Math.ceil(limit / 2));\n\n      if (!demoError && demographicHashtags) {\n        suggestions.push(...demographicHashtags);\n      }\n    }\n\n    return suggestions.slice(0, limit);\n  } catch (error) {\n    console.error('Failed to get profile-based suggestions:', error);\n    return [];\n  }\n}\n\nasync function getPollBasedSuggestions(userId: string, currentHashtagIds: string[], limit: number) {\n  try {\n    // Get user's poll interactions\n    const { data: pollInteractions, error: pollError } = await supabase\n      .from('poll_votes')\n      .select('poll_id, polls(hashtags)')\n      .eq('user_id', userId)\n      .limit(50);\n\n    if (pollError) throw pollError;\n\n    // Extract hashtags from poll interactions\n    const pollHashtags = new Set<string>();\n    pollInteractions?.forEach((interaction: any) => {\n      if (interaction.polls?.hashtags) {\n        interaction.polls.hashtags.forEach((tag: string) => {\n          if (!currentHashtagIds.includes(tag)) {\n            pollHashtags.add(tag);\n          }\n        });\n      }\n    });\n\n    // Get hashtag details for poll-based suggestions\n    const hashtagNames = Array.from(pollHashtags);\n    if (hashtagNames.length === 0) return [];\n\n    const { data: pollHashtagData, error: hashtagError } = await supabase\n      .from('hashtags')\n      .select('*, hashtag:hashtags(*)')\n      .in('name', hashtagNames)\n      .order('usage_count', { ascending: false })\n      .limit(limit);\n\n    if (hashtagError) throw hashtagError;\n\n    return pollHashtagData || [];\n  } catch (error) {\n    console.error('Failed to get poll-based suggestions:', error);\n    return [];\n  }\n}\n\nasync function getFeedBasedSuggestions(userId: string, currentHashtagIds: string[], limit: number) {\n  try {\n    // Get user's feed interactions\n    const { data: feedInteractions, error: feedError } = await supabase\n      .from('feed_interactions')\n      .select('content_id, content_type, hashtags')\n      .eq('user_id', userId)\n      .limit(50);\n\n    if (feedError) throw feedError;\n\n    // Extract hashtags from feed interactions\n    const feedHashtags = new Set<string>();\n    feedInteractions?.forEach(interaction => {\n      if (interaction.hashtags) {\n        interaction.hashtags.forEach((tag: string) => {\n          if (!currentHashtagIds.includes(tag)) {\n            feedHashtags.add(tag);\n          }\n        });\n      }\n    });\n\n    // Get hashtag details for feed-based suggestions\n    const hashtagNames = Array.from(feedHashtags);\n    if (hashtagNames.length === 0) return [];\n\n    const { data: feedHashtagData, error: hashtagError } = await supabase\n      .from('hashtags')\n      .select('*, hashtag:hashtags(*)')\n      .in('name', hashtagNames)\n      .order('usage_count', { ascending: false })\n      .limit(limit);\n\n    if (hashtagError) throw hashtagError;\n\n    return feedHashtagData || [];\n  } catch (error) {\n    console.error('Failed to get feed-based suggestions:', error);\n    return [];\n  }\n}\n\nasync function getTrendingSuggestions(currentHashtagIds: string[], limit: number) {\n  try {\n    // Get trending hashtags that are not already followed\n    const { data: trendingHashtags, error } = await supabase\n      .from('hashtags')\n      .select('*, hashtag:hashtags(*)')\n      .eq('is_trending', true)\n      .not('id', 'in', `(${currentHashtagIds.join(',')})`)\n      .order('trend_score', { ascending: false })\n      .limit(limit);\n\n    if (error) throw error;\n\n    return trendingHashtags || [];\n  } catch (error) {\n    console.error('Failed to get trending suggestions:', error);\n    return [];\n  }\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Calculate peak position for a hashtag based on historical data\n */\nasync function calculatePeakPosition(hashtagId: string): Promise<number> {\n  try {\n    // Get historical usage data for the last 30 days\n    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n    \n    const { data, error } = await supabase\n      .from('hashtag_usage')\n      .select('created_at')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', thirtyDaysAgo.toISOString())\n      .order('created_at', { ascending: true });\n\n    if (error) throw error;\n\n    if (data?.length === 0) return 1;\n\n    // Calculate daily usage counts\n    const dailyUsage = new Map<string, number>();\n    data.forEach(usage => {\n      const date = usage.created_at.split('T')[0];\n      dailyUsage.set(date, (dailyUsage.get(date) || 0) + 1);\n    });\n\n    // Find the day with peak usage\n    let peakUsage = 0;\n    for (const count of dailyUsage.values()) {\n      if (count > peakUsage) {\n        peakUsage = count;\n      }\n    }\n\n    // Calculate position based on peak usage (simplified ranking)\n    return Math.max(1, Math.min(10, Math.ceil(peakUsage / 10)));\n  } catch (error) {\n    console.error('Failed to calculate peak position:', error);\n    return 1;\n  }\n}\n\n/**\n * Calculate current position for a hashtag based on recent usage\n */\nasync function calculateCurrentPosition(hashtagId: string): Promise<number> {\n  try {\n    // Get current usage data for the last 24 hours\n    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n    \n    const { data, error } = await supabase\n      .from('hashtag_usage')\n      .select('id')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', twentyFourHoursAgo.toISOString());\n\n    if (error) throw error;\n\n    const currentUsage = data?.length || 0;\n\n    // Calculate position based on current usage (simplified ranking)\n    if (currentUsage === 0) return 10;\n    if (currentUsage >= 100) return 1;\n    if (currentUsage >= 50) return 2;\n    if (currentUsage >= 25) return 3;\n    if (currentUsage >= 10) return 4;\n    if (currentUsage >= 5) return 5;\n    return Math.min(10, Math.ceil(10 - currentUsage));\n  } catch (error) {\n    console.error('Failed to calculate current position:', error);\n    return 5;\n  }\n}\n\n/**\n * Get previous period usage for comparison\n */\nasync function getPreviousPeriodUsage(hashtagId: string, startDate: string, endDate: string): Promise<number> {\n  try {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    const periodLength = end.getTime() - start.getTime();\n    \n    // Calculate previous period dates\n    const previousEnd = new Date(start.getTime() - 1);\n    const previousStart = new Date(previousEnd.getTime() - periodLength);\n\n    const { data, error } = await supabase\n      .from('hashtag_usage')\n      .select('id')\n      .eq('hashtag_id', hashtagId)\n      .gte('created_at', previousStart.toISOString())\n      .lte('created_at', previousEnd.toISOString());\n\n    if (error) throw error;\n\n    return data?.length || 0;\n  } catch (error) {\n    console.error('Failed to get previous period usage:', error);\n    return 0;\n  }\n}\n"],"names":["calculateHashtagAnalytics","calculateTrendingHashtags","getCrossFeatureDiscovery","getHashtagPerformanceInsights","supabase","createClient","process","env","NEXT_PUBLIC_SUPABASE_URL","NEXT_PUBLIC_SUPABASE_ANON_KEY","hashtagId","period","startDate","getPeriodStartDate","endDate","Date","toISOString","usageData","getHashtagUsageData","engagementData","getHashtagEngagementData","userData","getHashtagUserData","contentData","getHashtagContentData","metrics","usage_count","totalUsage","unique_users","uniqueUsers","engagement_rate","calculateEngagementRate","Number","totalViews","totalInteractions","growth_rate","calculateGrowthRate","currentUsage","previousUsage","peak_usage","peakUsage","average_usage","averageUsage","top_content","topContent","top_users","topUsers","related_hashtags","getRelatedHashtags","sentiment_distribution","getSentimentDistribution","geographic_distribution","getGeographicDistribution","demographic_distribution","getDemographicDistribution","hashtag_id","generated_at","error","logger","Error","String","category","limit","timeWindow","now","startTime","getTime","data","usageError","from","select","gte","order","ascending","hashtagMetrics","Map","forEach","usage","has","set","usageCount","Set","recentUsage","get","add","user_id","push","Math","max","hashtagIds","Array","keys","hashtags","hashtagError","in","trendingHashtags","hashtag","id","growthRate","engagementRate","recency","trendScore","calculateTrendingScore","trend_score","usage_count_24h","usage_count_7d","getUsageCount","peak_position","calculatePeakPosition","current_position","calculateCurrentPosition","trending_since","length","min","map","_","i","created_at","category_trends","getCategoryTrends","sort","a","b","slice","console","analytics","performance","getHashtagPerformanceLevel","insights","recommendations","benchmarks","getHashtagBenchmarks","average","top","current","userId","userHashtags","eq","currentHashtagIds","uh","profileSuggestions","getProfileBasedSuggestions","pollSuggestions","getPollBasedSuggestions","feedSuggestions","getFeedBasedSuggestions","trendingSuggestions","getTrendingSuggestions","h","th","periods","lte","reduce","sum","views","getPreviousPeriodUsage","_d","_hashtagId","_startDate","_endDate","clicks","filter","d","engagement_type","shares","Boolean","size","content_id","single","relatedHashtags","relatedError","neq","coOccurringHashtags","coOccurringError","relatedNames","name","not","sentimentCounts","positive","neutral","negative","sentiment","total","geographicCounts","totalCount","metadata","geographic_region","region","distribution","Object","entries","count","userIds","u","userError","demographicCounts","user","ageGroup","age_group","demographic_data","days","categoryHashtags","totalTrendScore","averageTrendScore","trending_hashtags","total_trend_score","total_usage","average_trend_score","top_hashtags","categoryError","usageCounts","trendScores","topUsage","averageTrend","score","topTrend","currentTrend","round","trending","usage_percentile","c","trend_percentile","s","profile","profileError","interests","suggestions","interestHashtags","join","demographics","demographicHashtags","demoError","ceil","pollInteractions","pollError","pollHashtags","interaction","polls","tag","includes","hashtagNames","pollHashtagData","feedInteractions","feedError","feedHashtags","feedHashtagData","thirtyDaysAgo","dailyUsage","date","split","values","twentyFourHoursAgo","start","end","periodLength","previousEnd","previousStart"],"mappings":"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"}