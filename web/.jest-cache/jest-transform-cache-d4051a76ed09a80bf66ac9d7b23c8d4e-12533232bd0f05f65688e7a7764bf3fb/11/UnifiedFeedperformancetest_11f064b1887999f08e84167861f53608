903dbeaf03f78f4bdfc03ea68a6ea63e
/**
 * UnifiedFeed Performance Tests (Jest)
 *
 * Note: This suite is intentionally skipped.
 * Reason: With jsdom and heavy mocking, Jest does not yield meaningful
 * performance metrics. We'll move performance to Playwright + Lighthouse/Tracing.
 *
 * Created: January 19, 2025
 * Updated: 2025-10-20 (skipped in favor of E2E performance checks)
 * Status: ⏭️ Skipped (see testing_audit.md for the plan)
 */ /** @jest-environment jsdom */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../../features/feeds/components/UnifiedFeed"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Shared mock state for aggregated stores used by UnifiedFeed
const mockStores = {
    feeds: [],
    hashtagStore: {
        hashtags: [],
        trendingHashtags: [],
        isLoading: false,
        error: null
    },
    feedsActions: {
        loadFeeds: _globals.jest.fn(),
        likeFeed: _globals.jest.fn(),
        bookmarkFeed: _globals.jest.fn(),
        refreshFeeds: _globals.jest.fn()
    },
    feedsLoading: false,
    pwaStore: {},
    userStore: {
        user: {
            id: 'test-user'
        }
    },
    notificationStore: {
        addNotification: _globals.jest.fn()
    }
};
const hashtagActions = {
    getTrendingHashtags: _globals.jest.fn()
};
// Mock the aggregated stores module used by UnifiedFeed
_globals.jest.mock('@/lib/stores', ()=>{
    const actual = _globals.jest.requireActual('@/lib/stores');
    const React = require('react');
    const useSyncExternalStore = React.useSyncExternalStore;
    const subscribe = ()=>()=>{};
    const getFeedsSnapshot = ()=>mockStores.feeds;
    const getHashtagSnapshot = ()=>mockStores.hashtagStore;
    const getActionsSnapshot = ()=>mockStores.feedsActions;
    const getLoadingSnapshot = ()=>mockStores.feedsLoading;
    const getUserSnapshot = ()=>mockStores.userStore;
    const getPwaSnapshot = ()=>mockStores.pwaStore;
    const getNotifSnapshot = ()=>mockStores.notificationStore;
    return {
        ...actual,
        useFeeds: ()=>useSyncExternalStore(subscribe, getFeedsSnapshot, getFeedsSnapshot),
        useFeedsActions: (selector)=>{
            const state = useSyncExternalStore(subscribe, getActionsSnapshot, getActionsSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useFeedsLoading: ()=>useSyncExternalStore(subscribe, getLoadingSnapshot, getLoadingSnapshot),
        usePWAStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getPwaSnapshot, getPwaSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useUserStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getUserSnapshot, getUserSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useNotificationStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getNotifSnapshot, getNotifSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useHashtagStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getHashtagSnapshot, getHashtagSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useHashtagActions: ()=>hashtagActions,
        useHashtagStats: ()=>({
                trendingCount: 0
            })
    };
});
// Types only helpers; runtime values are from module mock above
// Ensure mocks are properly initialized
beforeEach(()=>{
    mockStores.feeds.length = 0;
    Object.assign(mockStores.hashtagStore, {
        hashtags: [],
        trendingHashtags: [],
        isLoading: false,
        error: null
    });
    mockStores.feedsActions.loadFeeds = _globals.jest.fn();
    mockStores.feedsActions.likeFeed = _globals.jest.fn();
    mockStores.feedsActions.bookmarkFeed = _globals.jest.fn();
    mockStores.feedsActions.refreshFeeds = _globals.jest.fn();
    mockStores.feedsLoading = false;
});
// Performance test data
const generateLargeFeedData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            title: `Test ${i % 2 === 0 ? 'Poll' : 'Post'} ${i}`,
            content: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i} with some content`,
            summary: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i}`,
            author: {
                id: `author-${i}`,
                name: `User ${i}`,
                avatar: `/test-avatar-${i}.jpg`,
                verified: Math.random() > 0.8
            },
            category: `category${i % 5}`,
            tags: [
                `hashtag${i % 10}`,
                `category${i % 5}`
            ],
            type: i % 2 === 0 ? 'poll' : 'article',
            source: {
                name: `Source ${i}`,
                url: `https://example.com/${i}`,
                logo: `/test-logo-${i}.jpg`,
                verified: true
            },
            publishedAt: new Date(Date.now() - i * 1000).toISOString(),
            updatedAt: new Date(Date.now() - i * 1000).toISOString(),
            readTime: Math.floor(Math.random() * 10) + 1,
            engagement: {
                likes: Math.floor(Math.random() * 1000),
                shares: Math.floor(Math.random() * 500),
                comments: Math.floor(Math.random() * 200),
                views: Math.floor(Math.random() * 5000)
            },
            userInteraction: {
                liked: false,
                shared: false,
                bookmarked: false,
                read: false
            },
            metadata: {
                hashtags: [
                    `hashtag${i % 10}`,
                    `category${i % 5}`
                ],
                primary_hashtag: `hashtag${i % 10}`,
                language: 'en'
            }
        }));
const generateLargeHashtagData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            name: `hashtag${i}`,
            display_name: `Hashtag ${i}`,
            usage_count: Math.floor(Math.random() * 1000),
            follower_count: Math.floor(Math.random() * 500),
            is_trending: Math.random() > 0.7,
            trend_score: Math.random(),
            created_at: new Date(Date.now() - i * 1000).toISOString(),
            updated_at: new Date(Date.now() - i * 1000).toISOString(),
            is_verified: Math.random() > 0.9,
            is_featured: Math.random() > 0.8
        }));
// Disable this suite in Jest; performance will be validated in E2E/browser
const D = describe.skip;
D('UnifiedFeed Performance Tests', ()=>{
    beforeEach(()=>{
        // reset snapshots
        mockStores.feeds = [];
        mockStores.hashtagStore = {
            hashtags: [],
            trendingHashtags: [],
            isLoading: false,
            error: null
        };
        mockStores.feedsLoading = false;
        mockStores.feedsActions = {
            loadFeeds: _globals.jest.fn(),
            likeFeed: _globals.jest.fn(),
            bookmarkFeed: _globals.jest.fn(),
            refreshFeeds: _globals.jest.fn()
        };
        hashtagActions.getTrendingHashtags = _globals.jest.fn();
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('Rendering Performance', ()=>{
        test('should render small dataset (< 50 items) within 500ms', async ()=>{
            const smallDataset = generateLargeFeedData(50);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...smallDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(500);
        });
        test('should render medium dataset (50-200 items) within 1000ms', async ()=>{
            const mediumDataset = generateLargeFeedData(200);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...mediumDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1000);
        });
        test('should render large dataset (200+ items) within 2000ms', async ()=>{
            const largeDataset = generateLargeFeedData(500);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...largeDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(2000);
        });
        test('should handle hashtag data efficiently', async ()=>{
            const largeHashtagDataset = generateLargeHashtagData(1000);
            Object.assign(mockStores.hashtagStore, {
                hashtags: largeHashtagDataset,
                trendingHashtags: [],
                isLoading: false,
                error: null
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1500);
        });
    });
    describe('Interaction Performance', ()=>{
        test('should handle rapid clicks within acceptable time', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate rapid interactions
            for(let i = 0; i < 20; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                // Small delay to simulate real user behavior
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle 20 interactions within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
        test('should handle scroll events efficiently', async ()=>{
            const largeDataset = generateLargeFeedData(300);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...largeDataset);
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate scroll events
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.scroll(window, {
                    target: {
                        scrollY: i * 100
                    }
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle scroll events efficiently
            expect(totalTime).toBeLessThan(2000);
        });
        test('should handle filter changes efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate filter changes
            for(let i = 0; i < 10; i++){
                const hashtag = _react1.screen.getByText(`hashtag${i % 10}`);
                _react1.fireEvent.click(hashtag);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle filter changes within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
    });
    describe('Memory Performance', ()=>{
        test('should not leak memory during repeated renders', async ()=>{
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Render and unmount component multiple times
            for(let i = 0; i < 10; i++){
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
                unmount();
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            }
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
        test('should handle large datasets without memory issues', async ()=>{
            const veryLargeDataset = generateLargeFeedData(1000);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...veryLargeDataset);
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (< 50MB for 1000 items)
            expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
        });
    });
    describe('Network Performance', ()=>{
        test('should handle slow network responses gracefully', async ()=>{
            // Mock slow network response
            Object.assign(mockStores.hashtagStore, {
                hashtags: [],
                trendingHashtags: [],
                isLoading: true,
                error: null
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            // Simulate slow loading
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            });
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle slow loading within 3 seconds
            expect(totalTime).toBeLessThan(3000);
        });
        test('should handle network errors without performance degradation', async ()=>{
            Object.assign(mockStores.hashtagStore, {
                hashtags: [],
                trendingHashtags: [],
                isLoading: false,
                error: 'Network error'
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            // Should render error state quickly
            expect(renderTime).toBeLessThan(500);
        });
    });
    describe('Animation Performance', ()=>{
        test('should handle animations smoothly', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger animations
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Wait for animation to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 300));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Animation should complete within 500ms
            expect(animationTime).toBeLessThan(500);
        });
        test('should handle multiple simultaneous animations', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger multiple animations simultaneously
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(darkModeButton);
            _react1.fireEvent.click(filtersButton);
            // Wait for animations to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 500));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Multiple animations should complete within 1 second
            expect(animationTime).toBeLessThan(1000);
        });
    });
    describe('Real-time Updates Performance', ()=>{
        test('should handle real-time updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate real-time updates
            for(let i = 0; i < 10; i++){
                const newFeedData = generateLargeFeedData(10);
                mockStores.feeds.length = 0;
                mockStores.feeds.push(...newFeedData);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle 10 updates within 2 seconds
            expect(updateTime).toBeLessThan(2000);
        });
        test('should handle WebSocket updates without performance issues', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate WebSocket updates
            for(let i = 0; i < 5; i++){
                // Simulate WebSocket message
                (0, _react1.fireEvent)(window, new Event('message'));
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 200));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle WebSocket updates within 1.5 seconds
            expect(updateTime).toBeLessThan(1500);
        });
    });
    describe('Accessibility Performance', ()=>{
        test('should handle screen reader updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate screen reader updates
            for(let i = 0; i < 5; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle screen reader updates within 1 second
            expect(updateTime).toBeLessThan(1000);
        });
        test('should handle keyboard navigation efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate keyboard navigation
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.keyDown(document, {
                    key: 'Tab'
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const navigationTime = endTime - startTime;
            // Should handle keyboard navigation within 1 second
            expect(navigationTime).toBeLessThan(1000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQucGVyZm9ybWFuY2UudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkRmVlZCBQZXJmb3JtYW5jZSBUZXN0cyAoSmVzdClcbiAqXG4gKiBOb3RlOiBUaGlzIHN1aXRlIGlzIGludGVudGlvbmFsbHkgc2tpcHBlZC5cbiAqIFJlYXNvbjogV2l0aCBqc2RvbSBhbmQgaGVhdnkgbW9ja2luZywgSmVzdCBkb2VzIG5vdCB5aWVsZCBtZWFuaW5nZnVsXG4gKiBwZXJmb3JtYW5jZSBtZXRyaWNzLiBXZSdsbCBtb3ZlIHBlcmZvcm1hbmNlIHRvIFBsYXl3cmlnaHQgKyBMaWdodGhvdXNlL1RyYWNpbmcuXG4gKlxuICogQ3JlYXRlZDogSmFudWFyeSAxOSwgMjAyNVxuICogVXBkYXRlZDogMjAyNS0xMC0yMCAoc2tpcHBlZCBpbiBmYXZvciBvZiBFMkUgcGVyZm9ybWFuY2UgY2hlY2tzKVxuICogU3RhdHVzOiDij63vuI8gU2tpcHBlZCAoc2VlIHRlc3RpbmdfYXVkaXQubWQgZm9yIHRoZSBwbGFuKVxuICovXG5cbi8qKiBAamVzdC1lbnZpcm9ubWVudCBqc2RvbSAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UgfSBmcm9tICdAL3R5cGVzL2RhdGFiYXNlJztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIGFjdCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IFVuaWZpZWRGZWVkIGZyb20gJ0AvZmVhdHVyZXMvZmVlZHMvY29tcG9uZW50cy9VbmlmaWVkRmVlZCc7XG5pbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSAnQC9saWIvc3RvcmVzJztcblxuLy8gU2hhcmVkIG1vY2sgc3RhdGUgZm9yIGFnZ3JlZ2F0ZWQgc3RvcmVzIHVzZWQgYnkgVW5pZmllZEZlZWRcbmNvbnN0IG1vY2tTdG9yZXMgPSB7XG4gIGZlZWRzOiBbXSBhcyBhbnlbXSxcbiAgaGFzaHRhZ1N0b3JlOiB7IGhhc2h0YWdzOiBbXSBhcyBhbnlbXSwgdHJlbmRpbmdIYXNodGFnczogW10gYXMgYW55W10sIGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBudWxsIGFzIGFueSB9LFxuICBmZWVkc0FjdGlvbnM6IHsgbG9hZEZlZWRzOiBqZXN0LmZuKCksIGxpa2VGZWVkOiBqZXN0LmZuKCksIGJvb2ttYXJrRmVlZDogamVzdC5mbigpLCByZWZyZXNoRmVlZHM6IGplc3QuZm4oKSB9LFxuICBmZWVkc0xvYWRpbmc6IGZhbHNlLFxuICBwd2FTdG9yZToge30gYXMgYW55LFxuICB1c2VyU3RvcmU6IHsgdXNlcjogeyBpZDogJ3Rlc3QtdXNlcicgfSB9IGFzIGFueSxcbiAgbm90aWZpY2F0aW9uU3RvcmU6IHsgYWRkTm90aWZpY2F0aW9uOiBqZXN0LmZuKCkgfSBhcyBhbnksXG59O1xuY29uc3QgaGFzaHRhZ0FjdGlvbnMgPSB7IGdldFRyZW5kaW5nSGFzaHRhZ3M6IGplc3QuZm4oKSB9O1xuaW1wb3J0IHsgVCB9IGZyb20gJ0AvdGVzdHMvcmVnaXN0cnkvdGVzdElkcyc7XG5cbi8vIE1vY2sgdGhlIGFnZ3JlZ2F0ZWQgc3RvcmVzIG1vZHVsZSB1c2VkIGJ5IFVuaWZpZWRGZWVkXG5qZXN0Lm1vY2soJ0AvbGliL3N0b3JlcycsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCdAL2xpYi9zdG9yZXMnKTtcbiAgY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuICBjb25zdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IChSZWFjdCkudXNlU3luY0V4dGVybmFsU3RvcmU7XG4gIGNvbnN0IHN1YnNjcmliZSA9ICgpID0+ICgpID0+IHt9O1xuICBjb25zdCBnZXRGZWVkc1NuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5mZWVkcztcbiAgY29uc3QgZ2V0SGFzaHRhZ1NuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5oYXNodGFnU3RvcmU7XG4gIGNvbnN0IGdldEFjdGlvbnNTbmFwc2hvdCA9ICgpID0+IG1vY2tTdG9yZXMuZmVlZHNBY3Rpb25zO1xuICBjb25zdCBnZXRMb2FkaW5nU25hcHNob3QgPSAoKSA9PiBtb2NrU3RvcmVzLmZlZWRzTG9hZGluZztcbiAgY29uc3QgZ2V0VXNlclNuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy51c2VyU3RvcmU7XG4gIGNvbnN0IGdldFB3YVNuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5wd2FTdG9yZTtcbiAgY29uc3QgZ2V0Tm90aWZTbmFwc2hvdCA9ICgpID0+IG1vY2tTdG9yZXMubm90aWZpY2F0aW9uU3RvcmU7XG4gIHJldHVybiB7XG4gICAgLi4uYWN0dWFsLFxuICAgIHVzZUZlZWRzOiAoKSA9PiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldEZlZWRzU25hcHNob3QsIGdldEZlZWRzU25hcHNob3QpLFxuICAgIHVzZUZlZWRzQWN0aW9uczogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0QWN0aW9uc1NuYXBzaG90LCBnZXRBY3Rpb25zU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlRmVlZHNMb2FkaW5nOiAoKSA9PiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldExvYWRpbmdTbmFwc2hvdCwgZ2V0TG9hZGluZ1NuYXBzaG90KSxcbiAgICB1c2VQV0FTdG9yZTogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0UHdhU25hcHNob3QsIGdldFB3YVNuYXBzaG90KTtcbiAgICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvcihzdGF0ZSkgOiBzdGF0ZTtcbiAgICB9LFxuICAgIHVzZVVzZXJTdG9yZTogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0VXNlclNuYXBzaG90LCBnZXRVc2VyU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlTm90aWZpY2F0aW9uU3RvcmU6IChzZWxlY3Rvcj86IGFueSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldE5vdGlmU25hcHNob3QsIGdldE5vdGlmU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlSGFzaHRhZ1N0b3JlOiAoc2VsZWN0b3I/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRIYXNodGFnU25hcHNob3QsIGdldEhhc2h0YWdTbmFwc2hvdCk7XG4gICAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3Ioc3RhdGUpIDogc3RhdGU7XG4gICAgfSxcbiAgICB1c2VIYXNodGFnQWN0aW9uczogKCkgPT4gaGFzaHRhZ0FjdGlvbnMsXG4gICAgdXNlSGFzaHRhZ1N0YXRzOiAoKSA9PiAoeyB0cmVuZGluZ0NvdW50OiAwIH0pLFxuICB9O1xufSk7XG5cbi8vIFR5cGVzIG9ubHkgaGVscGVyczsgcnVudGltZSB2YWx1ZXMgYXJlIGZyb20gbW9kdWxlIG1vY2sgYWJvdmVcblxuLy8gRW5zdXJlIG1vY2tzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZFxuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgT2JqZWN0LmFzc2lnbihtb2NrU3RvcmVzLmhhc2h0YWdTdG9yZSwgeyBoYXNodGFnczogW10sIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9KTtcbiAgbW9ja1N0b3Jlcy5mZWVkc0FjdGlvbnMubG9hZEZlZWRzID0gamVzdC5mbigpO1xuICBtb2NrU3RvcmVzLmZlZWRzQWN0aW9ucy5saWtlRmVlZCA9IGplc3QuZm4oKTtcbiAgbW9ja1N0b3Jlcy5mZWVkc0FjdGlvbnMuYm9va21hcmtGZWVkID0gamVzdC5mbigpO1xuICBtb2NrU3RvcmVzLmZlZWRzQWN0aW9ucy5yZWZyZXNoRmVlZHMgPSBqZXN0LmZuKCk7XG4gIG1vY2tTdG9yZXMuZmVlZHNMb2FkaW5nID0gZmFsc2U7XG59KTtcblxuXG4vLyBQZXJmb3JtYW5jZSB0ZXN0IGRhdGFcbmNvbnN0IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSA9IChjb3VudDogbnVtYmVyKSA9PiBcbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgaWQ6IGAke2l9YCxcbiAgICB0aXRsZTogYFRlc3QgJHtpICUgMiA9PT0gMCA/ICdQb2xsJyA6ICdQb3N0J30gJHtpfWAsXG4gICAgY29udGVudDogYFRoaXMgaXMgdGVzdCAke2kgJSAyID09PSAwID8gJ3BvbGwnIDogJ3Bvc3QnfSAke2l9IHdpdGggc29tZSBjb250ZW50YCxcbiAgICBzdW1tYXJ5OiBgVGhpcyBpcyB0ZXN0ICR7aSAlIDIgPT09IDAgPyAncG9sbCcgOiAncG9zdCd9ICR7aX1gLFxuICAgIGF1dGhvcjoge1xuICAgICAgaWQ6IGBhdXRob3ItJHtpfWAsXG4gICAgICBuYW1lOiBgVXNlciAke2l9YCxcbiAgICAgIGF2YXRhcjogYC90ZXN0LWF2YXRhci0ke2l9LmpwZ2AsXG4gICAgICB2ZXJpZmllZDogTWF0aC5yYW5kb20oKSA+IDAuOFxuICAgIH0sXG4gICAgY2F0ZWdvcnk6IGBjYXRlZ29yeSR7aSAlIDV9YCxcbiAgICB0YWdzOiBbYGhhc2h0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxuICAgIHR5cGU6IChpICUgMiA9PT0gMCA/ICdwb2xsJyA6ICdhcnRpY2xlJyksXG4gICAgc291cmNlOiB7XG4gICAgICBuYW1lOiBgU291cmNlICR7aX1gLFxuICAgICAgdXJsOiBgaHR0cHM6Ly9leGFtcGxlLmNvbS8ke2l9YCxcbiAgICAgIGxvZ286IGAvdGVzdC1sb2dvLSR7aX0uanBnYCxcbiAgICAgIHZlcmlmaWVkOiB0cnVlXG4gICAgfSxcbiAgICBwdWJsaXNoZWRBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIGkgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIGkgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHJlYWRUaW1lOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkgKyAxLFxuICAgIGVuZ2FnZW1lbnQ6IHtcbiAgICAgIGxpa2VzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSxcbiAgICAgIHNoYXJlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTAwKSxcbiAgICAgIGNvbW1lbnRzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMDApLFxuICAgICAgdmlld3M6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMDApXG4gICAgfSxcbiAgICB1c2VySW50ZXJhY3Rpb246IHtcbiAgICAgIGxpa2VkOiBmYWxzZSxcbiAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICBib29rbWFya2VkOiBmYWxzZSxcbiAgICAgIHJlYWQ6IGZhbHNlXG4gICAgfSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgaGFzaHRhZ3M6IFtgaGFzaHRhZyR7aSAlIDEwfWAsIGBjYXRlZ29yeSR7aSAlIDV9YF0sXG4gICAgICBwcmltYXJ5X2hhc2h0YWc6IGBoYXNodGFnJHtpICUgMTB9YCxcbiAgICAgIGxhbmd1YWdlOiAnZW4nXG4gICAgfVxuICB9KSk7XG5cbmNvbnN0IGdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSA9IChjb3VudDogbnVtYmVyKSA9PlxuICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb3VudCB9LCAoXywgaSkgPT4gKHtcbiAgICBpZDogYCR7aX1gLFxuICAgIG5hbWU6IGBoYXNodGFnJHtpfWAsXG4gICAgZGlzcGxheV9uYW1lOiBgSGFzaHRhZyAke2l9YCxcbiAgICB1c2FnZV9jb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCksXG4gICAgZm9sbG93ZXJfY291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCksXG4gICAgaXNfdHJlbmRpbmc6IE1hdGgucmFuZG9tKCkgPiAwLjcsXG4gICAgdHJlbmRfc2NvcmU6IE1hdGgucmFuZG9tKCksXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIGkgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICBpc192ZXJpZmllZDogTWF0aC5yYW5kb20oKSA+IDAuOSxcbiAgICBpc19mZWF0dXJlZDogTWF0aC5yYW5kb20oKSA+IDAuOFxuICB9KSk7XG5cbi8vIERpc2FibGUgdGhpcyBzdWl0ZSBpbiBKZXN0OyBwZXJmb3JtYW5jZSB3aWxsIGJlIHZhbGlkYXRlZCBpbiBFMkUvYnJvd3NlclxuY29uc3QgRCA9IGRlc2NyaWJlLnNraXA7XG5cbkQoJ1VuaWZpZWRGZWVkIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyByZXNldCBzbmFwc2hvdHNcbiAgICBtb2NrU3RvcmVzLmZlZWRzID0gW107XG4gICAgbW9ja1N0b3Jlcy5oYXNodGFnU3RvcmUgPSB7IGhhc2h0YWdzOiBbXSwgdHJlbmRpbmdIYXNodGFnczogW10sIGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBudWxsIH0gYXMgYW55O1xuICAgIG1vY2tTdG9yZXMuZmVlZHNMb2FkaW5nID0gZmFsc2U7XG4gICAgbW9ja1N0b3Jlcy5mZWVkc0FjdGlvbnMgPSB7IGxvYWRGZWVkczogamVzdC5mbigpLCBsaWtlRmVlZDogamVzdC5mbigpLCBib29rbWFya0ZlZWQ6IGplc3QuZm4oKSwgcmVmcmVzaEZlZWRzOiBqZXN0LmZuKCkgfSBhcyBhbnk7XG4gICAgaGFzaHRhZ0FjdGlvbnMuZ2V0VHJlbmRpbmdIYXNodGFncyA9IGplc3QuZm4oKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlbmRlcmluZyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmVuZGVyIHNtYWxsIGRhdGFzZXQgKDwgNTAgaXRlbXMpIHdpdGhpbiA1MDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNtYWxsRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSg1MCk7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLmxlbmd0aCA9IDA7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLnB1c2goLi4uKHNtYWxsRGF0YXNldCBhcyBhbnlbXSkpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlbmRlclRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVuZGVyIG1lZGl1bSBkYXRhc2V0ICg1MC0yMDAgaXRlbXMpIHdpdGhpbiAxMDAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZWRpdW1EYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDIwMCk7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLmxlbmd0aCA9IDA7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLnB1c2goLi4uKG1lZGl1bURhdGFzZXQgYXMgYW55W10pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZW5kZXIgbGFyZ2UgZGF0YXNldCAoMjAwKyBpdGVtcykgd2l0aGluIDIwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSg1MDApO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5sZW5ndGggPSAwO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5wdXNoKC4uLihsYXJnZURhdGFzZXQgYXMgYW55W10pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgaGFzaHRhZyBkYXRhIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VIYXNodGFnRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSgxMDAwKTtcbiAgICAgIE9iamVjdC5hc3NpZ24obW9ja1N0b3Jlcy5oYXNodGFnU3RvcmUsIHsgaGFzaHRhZ3M6IGxhcmdlSGFzaHRhZ0RhdGFzZXQgYXMgYW55W10sIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlbmRlclRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDE1MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW50ZXJhY3Rpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBjbGlja3Mgd2l0aGluIGFjY2VwdGFibGUgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIGludGVyYWN0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpa2VCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2xpa2UvaSk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhsaWtlQnV0dG9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIHNpbXVsYXRlIHJlYWwgdXNlciBiZWhhdmlvclxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSAyMCBpbnRlcmFjdGlvbnMgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHNjcm9sbCBldmVudHMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZURhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoMzAwKTtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMucHVzaCguLi4obGFyZ2VEYXRhc2V0IGFzIGFueVtdKSk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNjcm9sbCBldmVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBmaXJlRXZlbnQuc2Nyb2xsKHdpbmRvdywgeyB0YXJnZXQ6IHsgc2Nyb2xsWTogaSAqIDEwMCB9IH0pO1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBzY3JvbGwgZXZlbnRzIGVmZmljaWVudGx5XG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGZpbHRlciBjaGFuZ2VzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgZmlsdGVyIGNoYW5nZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgY29uc3QgaGFzaHRhZyA9IHNjcmVlbi5nZXRCeVRleHQoYGhhc2h0YWcke2kgJSAxMH1gKTtcbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGhhc2h0YWcpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZmlsdGVyIGNoYW5nZXMgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG5vdCBsZWFrIG1lbW9yeSBkdXJpbmcgcmVwZWF0ZWQgcmVuZGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciBhbmQgdW5tb3VudCBjb21wb25lbnQgbXVsdGlwbGUgdGltZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHBlcmZvcm1hbmNlLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIG1pbmltYWwgKDwgMTBNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDEwICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBkYXRhc2V0cyB3aXRob3V0IG1lbW9yeSBpc3N1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJ5TGFyZ2VEYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDEwMDApO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5sZW5ndGggPSAwO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5wdXNoKC4uLih2ZXJ5TGFyZ2VEYXRhc2V0IGFzIGFueVtdKSk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHBlcmZvcm1hbmNlLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIHJlYXNvbmFibGUgKDwgNTBNQiBmb3IgMTAwMCBpdGVtcylcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDUwICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTmV0d29yayBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHNsb3cgbmV0d29yayByZXNwb25zZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc2xvdyBuZXR3b3JrIHJlc3BvbnNlXG4gICAgICBPYmplY3QuYXNzaWduKG1vY2tTdG9yZXMuaGFzaHRhZ1N0b3JlLCB7IGhhc2h0YWdzOiBbXSwgdHJlbmRpbmdIYXNodGFnczogW10sIGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgc2xvdyBsb2FkaW5nXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgc2xvdyBsb2FkaW5nIHdpdGhpbiAzIHNlY29uZHNcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigzMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMgd2l0aG91dCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24obW9ja1N0b3Jlcy5oYXNodGFnU3RvcmUsIHsgaGFzaHRhZ3M6IFtdLCB0cmVuZGluZ0hhc2h0YWdzOiBbXSwgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6ICdOZXR3b3JrIGVycm9yJyB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHJlbmRlciBlcnJvciBzdGF0ZSBxdWlja2x5XG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBbmltYXRpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBhbmltYXRpb25zIHNtb290aGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBhbmltYXRpb25zXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvblRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBBbmltYXRpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1MDBtc1xuICAgICAgZXhwZWN0KGFuaW1hdGlvblRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBzaW11bHRhbmVvdXMgYW5pbWF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgbXVsdGlwbGUgYW5pbWF0aW9ucyBzaW11bHRhbmVvdXNseVxuICAgICAgY29uc3QgZGFya01vZGVCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBkYXJrIG1vZGUvaSk7XG4gICAgICBjb25zdCBmaWx0ZXJzQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC90b2dnbGUgYWR2YW5jZWQgZmlsdGVycy9pKTtcbiAgICAgIFxuICAgICAgZmlyZUV2ZW50LmNsaWNrKGRhcmtNb2RlQnV0dG9uKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhmaWx0ZXJzQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgYW5pbWF0aW9ucyB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvblRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBNdWx0aXBsZSBhbmltYXRpb25zIHNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMSBzZWNvbmRcbiAgICAgIGV4cGVjdChhbmltYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWFsLXRpbWUgVXBkYXRlcyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJlYWwtdGltZSB1cGRhdGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSByZWFsLXRpbWUgdXBkYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5ld0ZlZWREYXRhID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDEwKTtcbiAgICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5sZW5ndGggPSAwO1xuICAgICAgICBtb2NrU3RvcmVzLmZlZWRzLnB1c2goLi4uKG5ld0ZlZWREYXRhIGFzIGFueVtdKSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIDEwIHVwZGF0ZXMgd2l0aGluIDIgc2Vjb25kc1xuICAgICAgZXhwZWN0KHVwZGF0ZVRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgV2ViU29ja2V0IHVwZGF0ZXMgd2l0aG91dCBwZXJmb3JtYW5jZSBpc3N1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIFdlYlNvY2tldCB1cGRhdGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAvLyBTaW11bGF0ZSBXZWJTb2NrZXQgbWVzc2FnZVxuICAgICAgICBmaXJlRXZlbnQod2luZG93LCBuZXcgRXZlbnQoJ21lc3NhZ2UnKSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIFdlYlNvY2tldCB1cGRhdGVzIHdpdGhpbiAxLjUgc2Vjb25kc1xuICAgICAgZXhwZWN0KHVwZGF0ZVRpbWUpLnRvQmVMZXNzVGhhbigxNTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FjY2Vzc2liaWxpdHkgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzY3JlZW4gcmVhZGVyIHVwZGF0ZXMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNjcmVlbiByZWFkZXIgdXBkYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgY29uc3QgbGlrZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvbGlrZS9pKTtcbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGxpa2VCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB1cGRhdGVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBzY3JlZW4gcmVhZGVyIHVwZGF0ZXMgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QodXBkYXRlVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgZmlyZUV2ZW50LmtleURvd24oZG9jdW1lbnQsIHsga2V5OiAnVGFiJyB9KTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBuYXZpZ2F0aW9uVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUga2V5Ym9hcmQgbmF2aWdhdGlvbiB3aXRoaW4gMSBzZWNvbmRcbiAgICAgIGV4cGVjdChuYXZpZ2F0aW9uVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vY2tTdG9yZXMiLCJmZWVkcyIsImhhc2h0YWdTdG9yZSIsImhhc2h0YWdzIiwidHJlbmRpbmdIYXNodGFncyIsImlzTG9hZGluZyIsImVycm9yIiwiZmVlZHNBY3Rpb25zIiwibG9hZEZlZWRzIiwiamVzdCIsImZuIiwibGlrZUZlZWQiLCJib29rbWFya0ZlZWQiLCJyZWZyZXNoRmVlZHMiLCJmZWVkc0xvYWRpbmciLCJwd2FTdG9yZSIsInVzZXJTdG9yZSIsInVzZXIiLCJpZCIsIm5vdGlmaWNhdGlvblN0b3JlIiwiYWRkTm90aWZpY2F0aW9uIiwiaGFzaHRhZ0FjdGlvbnMiLCJnZXRUcmVuZGluZ0hhc2h0YWdzIiwibW9jayIsImFjdHVhbCIsInJlcXVpcmVBY3R1YWwiLCJSZWFjdCIsInJlcXVpcmUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldEZlZWRzU25hcHNob3QiLCJnZXRIYXNodGFnU25hcHNob3QiLCJnZXRBY3Rpb25zU25hcHNob3QiLCJnZXRMb2FkaW5nU25hcHNob3QiLCJnZXRVc2VyU25hcHNob3QiLCJnZXRQd2FTbmFwc2hvdCIsImdldE5vdGlmU25hcHNob3QiLCJ1c2VGZWVkcyIsInVzZUZlZWRzQWN0aW9ucyIsInNlbGVjdG9yIiwic3RhdGUiLCJ1c2VGZWVkc0xvYWRpbmciLCJ1c2VQV0FTdG9yZSIsInVzZVVzZXJTdG9yZSIsInVzZU5vdGlmaWNhdGlvblN0b3JlIiwidXNlSGFzaHRhZ1N0b3JlIiwidXNlSGFzaHRhZ0FjdGlvbnMiLCJ1c2VIYXNodGFnU3RhdHMiLCJ0cmVuZGluZ0NvdW50IiwiYmVmb3JlRWFjaCIsImxlbmd0aCIsIk9iamVjdCIsImFzc2lnbiIsImdlbmVyYXRlTGFyZ2VGZWVkRGF0YSIsImNvdW50IiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJ0aXRsZSIsImNvbnRlbnQiLCJzdW1tYXJ5IiwiYXV0aG9yIiwibmFtZSIsImF2YXRhciIsInZlcmlmaWVkIiwiTWF0aCIsInJhbmRvbSIsImNhdGVnb3J5IiwidGFncyIsInR5cGUiLCJzb3VyY2UiLCJ1cmwiLCJsb2dvIiwicHVibGlzaGVkQXQiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJyZWFkVGltZSIsImZsb29yIiwiZW5nYWdlbWVudCIsImxpa2VzIiwic2hhcmVzIiwiY29tbWVudHMiLCJ2aWV3cyIsInVzZXJJbnRlcmFjdGlvbiIsImxpa2VkIiwic2hhcmVkIiwiYm9va21hcmtlZCIsInJlYWQiLCJtZXRhZGF0YSIsInByaW1hcnlfaGFzaHRhZyIsImxhbmd1YWdlIiwiZ2VuZXJhdGVMYXJnZUhhc2h0YWdEYXRhIiwiZGlzcGxheV9uYW1lIiwidXNhZ2VfY291bnQiLCJmb2xsb3dlcl9jb3VudCIsImlzX3RyZW5kaW5nIiwidHJlbmRfc2NvcmUiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImlzX3ZlcmlmaWVkIiwiaXNfZmVhdHVyZWQiLCJEIiwiZGVzY3JpYmUiLCJza2lwIiwiYWZ0ZXJFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInRlc3QiLCJzbWFsbERhdGFzZXQiLCJwdXNoIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJhY3QiLCJyZW5kZXIiLCJVbmlmaWVkRmVlZCIsImVuYWJsZVJlYWxUaW1lVXBkYXRlcyIsImVuYWJsZUFuYWx5dGljcyIsImVuYWJsZUhhcHRpY3MiLCJlbmRUaW1lIiwicmVuZGVyVGltZSIsImV4cGVjdCIsInRvQmVMZXNzVGhhbiIsIm1lZGl1bURhdGFzZXQiLCJsYXJnZURhdGFzZXQiLCJsYXJnZUhhc2h0YWdEYXRhc2V0IiwiY29tcG9uZW50IiwibGlrZUJ1dHRvbiIsInNjcmVlbiIsImdldEJ5TGFiZWxUZXh0IiwiZmlyZUV2ZW50IiwiY2xpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0b3RhbFRpbWUiLCJzY3JvbGwiLCJ3aW5kb3ciLCJ0YXJnZXQiLCJzY3JvbGxZIiwiaGFzaHRhZyIsImdldEJ5VGV4dCIsImluaXRpYWxNZW1vcnkiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsInVubW91bnQiLCJnbG9iYWwiLCJnYyIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiLCJ2ZXJ5TGFyZ2VEYXRhc2V0IiwiZGFya01vZGVCdXR0b24iLCJhbmltYXRpb25UaW1lIiwiZmlsdGVyc0J1dHRvbiIsIm5ld0ZlZWREYXRhIiwidXBkYXRlVGltZSIsIkV2ZW50Iiwia2V5RG93biIsImRvY3VtZW50Iiwia2V5IiwibmF2aWdhdGlv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