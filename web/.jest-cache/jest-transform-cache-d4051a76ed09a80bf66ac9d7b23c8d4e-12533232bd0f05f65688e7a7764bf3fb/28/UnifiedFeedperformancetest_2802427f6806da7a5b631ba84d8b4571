37bda7a85a4928b334ce414b1b6015c6
/**
 * UnifiedFeed Performance Tests
 * 
 * Comprehensive performance testing for the UnifiedFeed component
 * Tests real performance metrics and optimization
 * 
 * Created: January 19, 2025
 * Status: âœ… PRODUCTION READY
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../../features/feeds/components/UnifiedFeed"));
const _feedsStore = require("../../../../../lib/stores/feedsStore");
const _useHashtags = require("../../../../../features/hashtags/hooks/useHashtags");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock the stores
_globals.jest.mock('@/lib/stores/feedsStore', ()=>({
        useFeeds: _globals.jest.fn()
    }));
_globals.jest.mock('@/features/hashtags/hooks/useHashtags', ()=>({
        useHashtags: _globals.jest.fn()
    }));
const mockUseFeeds = _feedsStore.useFeeds;
const mockUseHashtags = _useHashtags.useHashtags;
// Ensure mocks are properly initialized
beforeEach(()=>{
    mockUseFeeds.mockReturnValue([]);
    mockUseHashtags.mockReturnValue({
        hashtags: [],
        trendingHashtags: [],
        userHashtags: [],
        isLoading: false,
        error: null,
        loadTrendingHashtags: _globals.jest.fn(),
        searchHashtags: _globals.jest.fn(),
        followHashtag: _globals.jest.fn(),
        unfollowHashtag: _globals.jest.fn(),
        getTrendingHashtags: _globals.jest.fn(),
        refresh: _globals.jest.fn()
    });
});
// Performance test data
const generateLargeFeedData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            title: `Test ${i % 2 === 0 ? 'Poll' : 'Post'} ${i}`,
            content: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i} with some content`,
            summary: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i}`,
            author: {
                id: `author-${i}`,
                name: `User ${i}`,
                avatar: `/test-avatar-${i}.jpg`,
                verified: Math.random() > 0.8
            },
            category: `category${i % 5}`,
            tags: [
                `hashtag${i % 10}`,
                `category${i % 5}`
            ],
            type: i % 2 === 0 ? 'poll' : 'article',
            source: {
                name: `Source ${i}`,
                url: `https://example.com/${i}`,
                logo: `/test-logo-${i}.jpg`,
                verified: true
            },
            publishedAt: new Date(Date.now() - i * 1000).toISOString(),
            updatedAt: new Date(Date.now() - i * 1000).toISOString(),
            readTime: Math.floor(Math.random() * 10) + 1,
            engagement: {
                likes: Math.floor(Math.random() * 1000),
                shares: Math.floor(Math.random() * 500),
                comments: Math.floor(Math.random() * 200),
                views: Math.floor(Math.random() * 5000)
            },
            userInteraction: {
                liked: false,
                shared: false,
                bookmarked: false,
                read: false
            },
            metadata: {
                hashtags: [
                    `hashtag${i % 10}`,
                    `category${i % 5}`
                ],
                primary_hashtag: `hashtag${i % 10}`,
                language: 'en'
            }
        }));
const generateLargeHashtagData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            name: `hashtag${i}`,
            display_name: `Hashtag ${i}`,
            usage_count: Math.floor(Math.random() * 1000),
            follower_count: Math.floor(Math.random() * 500),
            is_trending: Math.random() > 0.7,
            trend_score: Math.random(),
            created_at: new Date(Date.now() - i * 1000).toISOString(),
            updated_at: new Date(Date.now() - i * 1000).toISOString(),
            is_verified: Math.random() > 0.9,
            is_featured: Math.random() > 0.8
        }));
describe('UnifiedFeed Performance Tests', ()=>{
    beforeEach(()=>{
        // Mock store implementations
        mockUseFeeds.mockReturnValue([]);
        mockUseHashtags.mockReturnValue({
            hashtags: [],
            trendingHashtags: [],
            userHashtags: [],
            isLoading: false,
            error: null,
            loadTrendingHashtags: _globals.jest.fn(),
            searchHashtags: _globals.jest.fn(),
            followHashtag: _globals.jest.fn(),
            unfollowHashtag: _globals.jest.fn(),
            getTrendingHashtags: _globals.jest.fn(),
            refresh: _globals.jest.fn()
        });
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('Rendering Performance', ()=>{
        test('should render small dataset (< 50 items) within 500ms', async ()=>{
            const smallDataset = generateLargeFeedData(50);
            mockUseFeeds.mockReturnValue(smallDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(500);
        });
        test('should render medium dataset (50-200 items) within 1000ms', async ()=>{
            const mediumDataset = generateLargeFeedData(200);
            mockUseFeeds.mockReturnValue(mediumDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1000);
        });
        test('should render large dataset (200+ items) within 2000ms', async ()=>{
            const largeDataset = generateLargeFeedData(500);
            mockUseFeeds.mockReturnValue(largeDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(2000);
        });
        test('should handle hashtag data efficiently', async ()=>{
            const largeHashtagDataset = generateLargeHashtagData(1000);
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                hashtags: largeHashtagDataset
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1500);
        });
    });
    describe('Interaction Performance', ()=>{
        test('should handle rapid clicks within acceptable time', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate rapid interactions
            for(let i = 0; i < 20; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                // Small delay to simulate real user behavior
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle 20 interactions within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
        test('should handle scroll events efficiently', async ()=>{
            const largeDataset = generateLargeFeedData(300);
            mockUseFeeds.mockReturnValue(largeDataset);
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate scroll events
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.scroll(window, {
                    target: {
                        scrollY: i * 100
                    }
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle scroll events efficiently
            expect(totalTime).toBeLessThan(2000);
        });
        test('should handle filter changes efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate filter changes
            for(let i = 0; i < 10; i++){
                const hashtag = _react1.screen.getByText(`hashtag${i % 10}`);
                _react1.fireEvent.click(hashtag);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle filter changes within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
    });
    describe('Memory Performance', ()=>{
        test('should not leak memory during repeated renders', async ()=>{
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Render and unmount component multiple times
            for(let i = 0; i < 10; i++){
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
                unmount();
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            }
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
        test('should handle large datasets without memory issues', async ()=>{
            const veryLargeDataset = generateLargeFeedData(1000);
            mockUseFeeds.mockReturnValue(veryLargeDataset);
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (< 50MB for 1000 items)
            expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
        });
    });
    describe('Network Performance', ()=>{
        test('should handle slow network responses gracefully', async ()=>{
            // Mock slow network response
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                isLoading: true
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            // Simulate slow loading
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            });
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle slow loading within 3 seconds
            expect(totalTime).toBeLessThan(3000);
        });
        test('should handle network errors without performance degradation', async ()=>{
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                error: 'Network error'
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            // Should render error state quickly
            expect(renderTime).toBeLessThan(500);
        });
    });
    describe('Animation Performance', ()=>{
        test('should handle animations smoothly', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger animations
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Wait for animation to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 300));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Animation should complete within 500ms
            expect(animationTime).toBeLessThan(500);
        });
        test('should handle multiple simultaneous animations', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger multiple animations simultaneously
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(darkModeButton);
            _react1.fireEvent.click(filtersButton);
            // Wait for animations to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 500));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Multiple animations should complete within 1 second
            expect(animationTime).toBeLessThan(1000);
        });
    });
    describe('Real-time Updates Performance', ()=>{
        test('should handle real-time updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate real-time updates
            for(let i = 0; i < 10; i++){
                const newFeedData = generateLargeFeedData(10);
                mockUseFeeds.mockReturnValue(newFeedData);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle 10 updates within 2 seconds
            expect(updateTime).toBeLessThan(2000);
        });
        test('should handle WebSocket updates without performance issues', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate WebSocket updates
            for(let i = 0; i < 5; i++){
                // Simulate WebSocket message
                (0, _react1.fireEvent)(window, new Event('message'));
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 200));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle WebSocket updates within 1.5 seconds
            expect(updateTime).toBeLessThan(1500);
        });
    });
    describe('Accessibility Performance', ()=>{
        test('should handle screen reader updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate screen reader updates
            for(let i = 0; i < 5; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle screen reader updates within 1 second
            expect(updateTime).toBeLessThan(1000);
        });
        test('should handle keyboard navigation efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate keyboard navigation
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.keyDown(document, {
                    key: 'Tab'
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const navigationTime = endTime - startTime;
            // Should handle keyboard navigation within 1 second
            expect(navigationTime).toBeLessThan(1000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQucGVyZm9ybWFuY2UudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkRmVlZCBQZXJmb3JtYW5jZSBUZXN0c1xuICogXG4gKiBDb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIHRlc3RpbmcgZm9yIHRoZSBVbmlmaWVkRmVlZCBjb21wb25lbnRcbiAqIFRlc3RzIHJlYWwgcGVyZm9ybWFuY2UgbWV0cmljcyBhbmQgb3B0aW1pemF0aW9uXG4gKiBcbiAqIENyZWF0ZWQ6IEphbnVhcnkgMTksIDIwMjVcbiAqIFN0YXR1czog4pyFIFBST0RVQ1RJT04gUkVBRFlcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgYWN0IH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgVW5pZmllZEZlZWQgZnJvbSAnQC9mZWF0dXJlcy9mZWVkcy9jb21wb25lbnRzL1VuaWZpZWRGZWVkJztcbmltcG9ydCB7IHVzZUZlZWRzIH0gZnJvbSAnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnO1xuaW1wb3J0IHsgdXNlSGFzaHRhZ3MgfSBmcm9tICdAL2ZlYXR1cmVzL2hhc2h0YWdzL2hvb2tzL3VzZUhhc2h0YWdzJztcbmltcG9ydCB7IFQgfSBmcm9tICdAL2xpYi90ZXN0aW5nL3Rlc3RJZHMnO1xuXG4vLyBNb2NrIHRoZSBzdG9yZXNcbmplc3QubW9jaygnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnLCAoKSA9PiAoe1xuICB1c2VGZWVkczogamVzdC5mbigpXG59KSk7XG5cbmplc3QubW9jaygnQC9mZWF0dXJlcy9oYXNodGFncy9ob29rcy91c2VIYXNodGFncycsICgpID0+ICh7XG4gIHVzZUhhc2h0YWdzOiBqZXN0LmZuKClcbn0pKTtcblxuY29uc3QgbW9ja1VzZUZlZWRzID0gdXNlRmVlZHMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlRmVlZHM+O1xuY29uc3QgbW9ja1VzZUhhc2h0YWdzID0gdXNlSGFzaHRhZ3MgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlSGFzaHRhZ3M+O1xuXG4vLyBFbnN1cmUgbW9ja3MgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG5iZWZvcmVFYWNoKCgpID0+IHtcbiAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG4gIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgIGhhc2h0YWdzOiBbXSxcbiAgICB0cmVuZGluZ0hhc2h0YWdzOiBbXSxcbiAgICB1c2VySGFzaHRhZ3M6IFtdLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgbG9hZFRyZW5kaW5nSGFzaHRhZ3M6IGplc3QuZm4oKSxcbiAgICBzZWFyY2hIYXNodGFnczogamVzdC5mbigpLFxuICAgIGZvbGxvd0hhc2h0YWc6IGplc3QuZm4oKSxcbiAgICB1bmZvbGxvd0hhc2h0YWc6IGplc3QuZm4oKSxcbiAgICBnZXRUcmVuZGluZ0hhc2h0YWdzOiBqZXN0LmZuKCksXG4gICAgcmVmcmVzaDogamVzdC5mbigpXG4gIH0pO1xufSk7XG5cblxuLy8gUGVyZm9ybWFuY2UgdGVzdCBkYXRhXG5jb25zdCBnZW5lcmF0ZUxhcmdlRmVlZERhdGEgPSAoY291bnQ6IG51bWJlcikgPT4gXG4gIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiAoe1xuICAgIGlkOiBgJHtpfWAsXG4gICAgdGl0bGU6IGBUZXN0ICR7aSAlIDIgPT09IDAgPyAnUG9sbCcgOiAnUG9zdCd9ICR7aX1gLFxuICAgIGNvbnRlbnQ6IGBUaGlzIGlzIHRlc3QgJHtpICUgMiA9PT0gMCA/ICdwb2xsJyA6ICdwb3N0J30gJHtpfSB3aXRoIHNvbWUgY29udGVudGAsXG4gICAgc3VtbWFyeTogYFRoaXMgaXMgdGVzdCAke2kgJSAyID09PSAwID8gJ3BvbGwnIDogJ3Bvc3QnfSAke2l9YCxcbiAgICBhdXRob3I6IHtcbiAgICAgIGlkOiBgYXV0aG9yLSR7aX1gLFxuICAgICAgbmFtZTogYFVzZXIgJHtpfWAsXG4gICAgICBhdmF0YXI6IGAvdGVzdC1hdmF0YXItJHtpfS5qcGdgLFxuICAgICAgdmVyaWZpZWQ6IE1hdGgucmFuZG9tKCkgPiAwLjhcbiAgICB9LFxuICAgIGNhdGVnb3J5OiBgY2F0ZWdvcnkke2kgJSA1fWAsXG4gICAgdGFnczogW2BoYXNodGFnJHtpICUgMTB9YCwgYGNhdGVnb3J5JHtpICUgNX1gXSxcbiAgICB0eXBlOiAoaSAlIDIgPT09IDAgPyAncG9sbCcgOiAnYXJ0aWNsZScpIGFzICdwb2xsJyB8ICdhcnRpY2xlJyxcbiAgICBzb3VyY2U6IHtcbiAgICAgIG5hbWU6IGBTb3VyY2UgJHtpfWAsXG4gICAgICB1cmw6IGBodHRwczovL2V4YW1wbGUuY29tLyR7aX1gLFxuICAgICAgbG9nbzogYC90ZXN0LWxvZ28tJHtpfS5qcGdgLFxuICAgICAgdmVyaWZpZWQ6IHRydWVcbiAgICB9LFxuICAgIHB1Ymxpc2hlZEF0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaSAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaSAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgcmVhZFRpbWU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSArIDEsXG4gICAgZW5nYWdlbWVudDoge1xuICAgICAgbGlrZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApLFxuICAgICAgc2hhcmVzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDApLFxuICAgICAgY29tbWVudHM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwMCksXG4gICAgICB2aWV3czogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTAwMClcbiAgICB9LFxuICAgIHVzZXJJbnRlcmFjdGlvbjoge1xuICAgICAgbGlrZWQ6IGZhbHNlLFxuICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgIGJvb2ttYXJrZWQ6IGZhbHNlLFxuICAgICAgcmVhZDogZmFsc2VcbiAgICB9LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBoYXNodGFnczogW2BoYXNodGFnJHtpICUgMTB9YCwgYGNhdGVnb3J5JHtpICUgNX1gXSxcbiAgICAgIHByaW1hcnlfaGFzaHRhZzogYGhhc2h0YWcke2kgJSAxMH1gLFxuICAgICAgbGFuZ3VhZ2U6ICdlbidcbiAgICB9XG4gIH0pKTtcblxuY29uc3QgZ2VuZXJhdGVMYXJnZUhhc2h0YWdEYXRhID0gKGNvdW50OiBudW1iZXIpID0+XG4gIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiAoe1xuICAgIGlkOiBgJHtpfWAsXG4gICAgbmFtZTogYGhhc2h0YWcke2l9YCxcbiAgICBkaXNwbGF5X25hbWU6IGBIYXNodGFnICR7aX1gLFxuICAgIHVzYWdlX2NvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSxcbiAgICBmb2xsb3dlcl9jb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTAwKSxcbiAgICBpc190cmVuZGluZzogTWF0aC5yYW5kb20oKSA+IDAuNyxcbiAgICB0cmVuZF9zY29yZTogTWF0aC5yYW5kb20oKSxcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaSAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIGkgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIGlzX3ZlcmlmaWVkOiBNYXRoLnJhbmRvbSgpID4gMC45LFxuICAgIGlzX2ZlYXR1cmVkOiBNYXRoLnJhbmRvbSgpID4gMC44XG4gIH0pKTtcblxuZGVzY3JpYmUoJ1VuaWZpZWRGZWVkIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBNb2NrIHN0b3JlIGltcGxlbWVudGF0aW9uc1xuICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUoW10pO1xuXG4gICAgbW9ja1VzZUhhc2h0YWdzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBoYXNodGFnczogW10sXG4gICAgICB0cmVuZGluZ0hhc2h0YWdzOiBbXSxcbiAgICAgIHVzZXJIYXNodGFnczogW10sXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBsb2FkVHJlbmRpbmdIYXNodGFnczogamVzdC5mbigpLFxuICAgICAgc2VhcmNoSGFzaHRhZ3M6IGplc3QuZm4oKSxcbiAgICAgIGZvbGxvd0hhc2h0YWc6IGplc3QuZm4oKSxcbiAgICAgIHVuZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgICAgZ2V0VHJlbmRpbmdIYXNodGFnczogamVzdC5mbigpLFxuICAgICAgcmVmcmVzaDogamVzdC5mbigpXG4gICAgfSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZW5kZXJpbmcgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlbmRlciBzbWFsbCBkYXRhc2V0ICg8IDUwIGl0ZW1zKSB3aXRoaW4gNTAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzbWFsbERhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoNTApO1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShzbWFsbERhdGFzZXQpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oNTAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZW5kZXIgbWVkaXVtIGRhdGFzZXQgKDUwLTIwMCBpdGVtcykgd2l0aGluIDEwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lZGl1bURhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoMjAwKTtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUobWVkaXVtRGF0YXNldCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZW5kZXIgbGFyZ2UgZGF0YXNldCAoMjAwKyBpdGVtcykgd2l0aGluIDIwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSg1MDApO1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShsYXJnZURhdGFzZXQpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGhhc2h0YWcgZGF0YSBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlSGFzaHRhZ0RhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlSGFzaHRhZ0RhdGEoMTAwMCk7XG4gICAgICBtb2NrVXNlSGFzaHRhZ3MubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUhhc2h0YWdzKCksXG4gICAgICAgIGhhc2h0YWdzOiBsYXJnZUhhc2h0YWdEYXRhc2V0XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlbmRlclRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDE1MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW50ZXJhY3Rpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBjbGlja3Mgd2l0aGluIGFjY2VwdGFibGUgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcmFwaWQgaW50ZXJhY3Rpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGlrZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvbGlrZS9pKTtcbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGxpa2VCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gc2ltdWxhdGUgcmVhbCB1c2VyIGJlaGF2aW9yXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIDIwIGludGVyYWN0aW9ucyB3aXRoaW4gMSBzZWNvbmRcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2Nyb2xsIGV2ZW50cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgzMDApO1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShsYXJnZURhdGFzZXQpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNjcm9sbCBldmVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBmaXJlRXZlbnQuc2Nyb2xsKHdpbmRvdywgeyB0YXJnZXQ6IHsgc2Nyb2xsWTogaSAqIDEwMCB9IH0pO1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBzY3JvbGwgZXZlbnRzIGVmZmljaWVudGx5XG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGZpbHRlciBjaGFuZ2VzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBmaWx0ZXIgY2hhbmdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhhc2h0YWcgPSBzY3JlZW4uZ2V0QnlUZXh0KGBoYXNodGFnJHtpICUgMTB9YCk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhoYXNodGFnKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGZpbHRlciBjaGFuZ2VzIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBub3QgbGVhayBtZW1vcnkgZHVyaW5nIHJlcGVhdGVkIHJlbmRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICAvLyBSZW5kZXIgYW5kIHVubW91bnQgY29tcG9uZW50IG11bHRpcGxlIHRpbWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSBtaW5pbWFsICg8IDEwTUIpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgZGF0YXNldHMgd2l0aG91dCBtZW1vcnkgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmVyeUxhcmdlRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgxMDAwKTtcbiAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUodmVyeUxhcmdlRGF0YXNldCk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgICBcbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgcmVhc29uYWJsZSAoPCA1ME1CIGZvciAxMDAwIGl0ZW1zKVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oNTAgKiAxMDI0ICogMTAyNCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdOZXR3b3JrIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2xvdyBuZXR3b3JrIHJlc3BvbnNlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBzbG93IG5ldHdvcmsgcmVzcG9uc2VcbiAgICAgIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlSGFzaHRhZ3MoKSxcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNsb3cgbG9hZGluZ1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHNsb3cgbG9hZGluZyB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMzAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzIHdpdGhvdXQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlSGFzaHRhZ3MubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgLi4ubW9ja1VzZUhhc2h0YWdzKCksXG4gICAgICAgIGVycm9yOiAnTmV0d29yayBlcnJvcidcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCByZW5kZXIgZXJyb3Igc3RhdGUgcXVpY2tseVxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQW5pbWF0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYW5pbWF0aW9ucyBzbW9vdGhseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBhbmltYXRpb25zXG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvblRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBBbmltYXRpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1MDBtc1xuICAgICAgZXhwZWN0KGFuaW1hdGlvblRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBzaW11bHRhbmVvdXMgYW5pbWF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBtdWx0aXBsZSBhbmltYXRpb25zIHNpbXVsdGFuZW91c2x5XG4gICAgICBjb25zdCBkYXJrTW9kZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3dpdGNoIHRvIGRhcmsgbW9kZS9pKTtcbiAgICAgIGNvbnN0IGZpbHRlcnNCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3RvZ2dsZSBhZHZhbmNlZCBmaWx0ZXJzL2kpO1xuICAgICAgXG4gICAgICBmaXJlRXZlbnQuY2xpY2soZGFya01vZGVCdXR0b24pO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGZpbHRlcnNCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBhbmltYXRpb25zIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgYW5pbWF0aW9uVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIE11bHRpcGxlIGFuaW1hdGlvbnMgc2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KGFuaW1hdGlvblRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtdGltZSBVcGRhdGVzIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcmVhbC10aW1lIHVwZGF0ZXMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHJlYWwtdGltZSB1cGRhdGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV3RmVlZERhdGEgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoMTApO1xuICAgICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKG5ld0ZlZWREYXRhKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgMTAgdXBkYXRlcyB3aXRoaW4gMiBzZWNvbmRzXG4gICAgICBleHBlY3QodXBkYXRlVGltZSkudG9CZUxlc3NUaGFuKDIwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBXZWJTb2NrZXQgdXBkYXRlcyB3aXRob3V0IHBlcmZvcm1hbmNlIGlzc3VlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgV2ViU29ja2V0IHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIC8vIFNpbXVsYXRlIFdlYlNvY2tldCBtZXNzYWdlXG4gICAgICAgIGZpcmVFdmVudCh3aW5kb3csIG5ldyBFdmVudCgnbWVzc2FnZScpKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgV2ViU29ja2V0IHVwZGF0ZXMgd2l0aGluIDEuNSBzZWNvbmRzXG4gICAgICBleHBlY3QodXBkYXRlVGltZSkudG9CZUxlc3NUaGFuKDE1MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHNjcmVlbiByZWFkZXIgdXBkYXRlcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgc2NyZWVuIHJlYWRlciB1cGRhdGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBjb25zdCBsaWtlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9saWtlL2kpO1xuICAgICAgICBmaXJlRXZlbnQuY2xpY2sobGlrZUJ1dHRvbik7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHNjcmVlbiByZWFkZXIgdXBkYXRlcyB3aXRoaW4gMSBzZWNvbmRcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb24gZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBmaXJlRXZlbnQua2V5RG93bihkb2N1bWVudCwgeyBrZXk6ICdUYWInIH0pO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IG5hdmlnYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KG5hdmlnYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VGZWVkcyIsImZuIiwidXNlSGFzaHRhZ3MiLCJtb2NrVXNlRmVlZHMiLCJtb2NrVXNlSGFzaHRhZ3MiLCJiZWZvcmVFYWNoIiwibW9ja1JldHVyblZhbHVlIiwiaGFzaHRhZ3MiLCJ0cmVuZGluZ0hhc2h0YWdzIiwidXNlckhhc2h0YWdzIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJsb2FkVHJlbmRpbmdIYXNodGFncyIsInNlYXJjaEhhc2h0YWdzIiwiZm9sbG93SGFzaHRhZyIsInVuZm9sbG93SGFzaHRhZyIsImdldFRyZW5kaW5nSGFzaHRhZ3MiLCJyZWZyZXNoIiwiZ2VuZXJhdGVMYXJnZUZlZWREYXRhIiwiY291bnQiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImlkIiwidGl0bGUiLCJjb250ZW50Iiwic3VtbWFyeSIsImF1dGhvciIsIm5hbWUiLCJhdmF0YXIiLCJ2ZXJpZmllZCIsIk1hdGgiLCJyYW5kb20iLCJjYXRlZ29yeSIsInRhZ3MiLCJ0eXBlIiwic291cmNlIiwidXJsIiwibG9nbyIsInB1Ymxpc2hlZEF0IiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwicmVhZFRpbWUiLCJmbG9vciIsImVuZ2FnZW1lbnQiLCJsaWtlcyIsInNoYXJlcyIsImNvbW1lbnRzIiwidmlld3MiLCJ1c2VySW50ZXJhY3Rpb24iLCJsaWtlZCIsInNoYXJlZCIsImJvb2ttYXJrZWQiLCJyZWFkIiwibWV0YWRhdGEiLCJwcmltYXJ5X2hhc2h0YWciLCJsYW5ndWFnZSIsImdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSIsImRpc3BsYXlfbmFtZSIsInVzYWdlX2NvdW50IiwiZm9sbG93ZXJfY291bnQiLCJpc190cmVuZGluZyIsInRyZW5kX3Njb3JlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpc192ZXJpZmllZCIsImlzX2ZlYXR1cmVkIiwiZGVzY3JpYmUiLCJhZnRlckVhY2giLCJjbGVhckFsbE1vY2tzIiwidGVzdCIsInNtYWxsRGF0YXNldCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwiYWN0IiwicmVuZGVyIiwiVW5pZmllZEZlZWQiLCJlbmRUaW1lIiwicmVuZGVyVGltZSIsImV4cGVjdCIsInRvQmVMZXNzVGhhbiIsIm1lZGl1bURhdGFzZXQiLCJsYXJnZURhdGFzZXQiLCJsYXJnZUhhc2h0YWdEYXRhc2V0IiwiY29tcG9uZW50IiwibGlrZUJ1dHRvbiIsInNjcmVlbiIsImdldEJ5TGFiZWxUZXh0IiwiZmlyZUV2ZW50IiwiY2xpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0b3RhbFRpbWUiLCJzY3JvbGwiLCJ3aW5kb3ciLCJ0YXJnZXQiLCJzY3JvbGxZIiwiaGFzaHRhZyIsImdldEJ5VGV4dCIsImluaXRpYWxNZW1vcnkiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsInVubW91bnQiLCJnbG9iYWwiLCJnYyIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiLCJ2ZXJ5TGFyZ2VEYXRhc2V0IiwiZGFya01vZGVCdXR0b24iLCJhbmltYXRpb25UaW1lIiwiZmlsdGVyc0J1dHRvbiIsIm5ld0ZlZWREYXRhIiwidXBkYXRlVGltZSIsIkV2ZW50Iiwia2V5RG93biIsImRvY3VtZW50Iiwia2V5IiwibmF2aWdhdGlvblRpbWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDOzs7Ozs4REFFaUI7d0JBQzZCO3lCQUMxQjtvRUFDRzs0QkFDQzs2QkFDRzs7Ozs7O0FBRzVCLGtCQUFrQjtBQUNsQkEsYUFBSSxDQUFDQyxJQUFJLENBQUMsMkJBQTJCLElBQU8sQ0FBQTtRQUMxQ0MsVUFBVUYsYUFBSSxDQUFDRyxFQUFFO0lBQ25CLENBQUE7QUFFQUgsYUFBSSxDQUFDQyxJQUFJLENBQUMseUNBQXlDLElBQU8sQ0FBQTtRQUN4REcsYUFBYUosYUFBSSxDQUFDRyxFQUFFO0lBQ3RCLENBQUE7QUFFQSxNQUFNRSxlQUFlSCxvQkFBUTtBQUM3QixNQUFNSSxrQkFBa0JGLHdCQUFXO0FBRW5DLHdDQUF3QztBQUN4Q0csV0FBVztJQUNURixhQUFhRyxlQUFlLENBQUMsRUFBRTtJQUMvQkYsZ0JBQWdCRSxlQUFlLENBQUM7UUFDOUJDLFVBQVUsRUFBRTtRQUNaQyxrQkFBa0IsRUFBRTtRQUNwQkMsY0FBYyxFQUFFO1FBQ2hCQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsc0JBQXNCZCxhQUFJLENBQUNHLEVBQUU7UUFDN0JZLGdCQUFnQmYsYUFBSSxDQUFDRyxFQUFFO1FBQ3ZCYSxlQUFlaEIsYUFBSSxDQUFDRyxFQUFFO1FBQ3RCYyxpQkFBaUJqQixhQUFJLENBQUNHLEVBQUU7UUFDeEJlLHFCQUFxQmxCLGFBQUksQ0FBQ0csRUFBRTtRQUM1QmdCLFNBQVNuQixhQUFJLENBQUNHLEVBQUU7SUFDbEI7QUFDRjtBQUdBLHdCQUF3QjtBQUN4QixNQUFNaUIsd0JBQXdCLENBQUNDLFFBQzdCQyxNQUFNQyxJQUFJLENBQUM7UUFBRUMsUUFBUUg7SUFBTSxHQUFHLENBQUNJLEdBQUdDLElBQU8sQ0FBQTtZQUN2Q0MsSUFBSSxHQUFHRCxHQUFHO1lBQ1ZFLE9BQU8sQ0FBQyxLQUFLLEVBQUVGLElBQUksTUFBTSxJQUFJLFNBQVMsT0FBTyxDQUFDLEVBQUVBLEdBQUc7WUFDbkRHLFNBQVMsQ0FBQyxhQUFhLEVBQUVILElBQUksTUFBTSxJQUFJLFNBQVMsT0FBTyxDQUFDLEVBQUVBLEVBQUUsa0JBQWtCLENBQUM7WUFDL0VJLFNBQVMsQ0FBQyxhQUFhLEVBQUVKLElBQUksTUFBTSxJQUFJLFNBQVMsT0FBTyxDQUFDLEVBQUVBLEdBQUc7WUFDN0RLLFFBQVE7Z0JBQ05KLElBQUksQ0FBQyxPQUFPLEVBQUVELEdBQUc7Z0JBQ2pCTSxNQUFNLENBQUMsS0FBSyxFQUFFTixHQUFHO2dCQUNqQk8sUUFBUSxDQUFDLGFBQWEsRUFBRVAsRUFBRSxJQUFJLENBQUM7Z0JBQy9CUSxVQUFVQyxLQUFLQyxNQUFNLEtBQUs7WUFDNUI7WUFDQUMsVUFBVSxDQUFDLFFBQVEsRUFBRVgsSUFBSSxHQUFHO1lBQzVCWSxNQUFNO2dCQUFDLENBQUMsT0FBTyxFQUFFWixJQUFJLElBQUk7Z0JBQUUsQ0FBQyxRQUFRLEVBQUVBLElBQUksR0FBRzthQUFDO1lBQzlDYSxNQUFPYixJQUFJLE1BQU0sSUFBSSxTQUFTO1lBQzlCYyxRQUFRO2dCQUNOUixNQUFNLENBQUMsT0FBTyxFQUFFTixHQUFHO2dCQUNuQmUsS0FBSyxDQUFDLG9CQUFvQixFQUFFZixHQUFHO2dCQUMvQmdCLE1BQU0sQ0FBQyxXQUFXLEVBQUVoQixFQUFFLElBQUksQ0FBQztnQkFDM0JRLFVBQVU7WUFDWjtZQUNBUyxhQUFhLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBS25CLElBQUksTUFBTW9CLFdBQVc7WUFDeERDLFdBQVcsSUFBSUgsS0FBS0EsS0FBS0MsR0FBRyxLQUFLbkIsSUFBSSxNQUFNb0IsV0FBVztZQUN0REUsVUFBVWIsS0FBS2MsS0FBSyxDQUFDZCxLQUFLQyxNQUFNLEtBQUssTUFBTTtZQUMzQ2MsWUFBWTtnQkFDVkMsT0FBT2hCLEtBQUtjLEtBQUssQ0FBQ2QsS0FBS0MsTUFBTSxLQUFLO2dCQUNsQ2dCLFFBQVFqQixLQUFLYyxLQUFLLENBQUNkLEtBQUtDLE1BQU0sS0FBSztnQkFDbkNpQixVQUFVbEIsS0FBS2MsS0FBSyxDQUFDZCxLQUFLQyxNQUFNLEtBQUs7Z0JBQ3JDa0IsT0FBT25CLEtBQUtjLEtBQUssQ0FBQ2QsS0FBS0MsTUFBTSxLQUFLO1lBQ3BDO1lBQ0FtQixpQkFBaUI7Z0JBQ2ZDLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLE1BQU07WUFDUjtZQUNBQyxVQUFVO2dCQUNSbkQsVUFBVTtvQkFBQyxDQUFDLE9BQU8sRUFBRWlCLElBQUksSUFBSTtvQkFBRSxDQUFDLFFBQVEsRUFBRUEsSUFBSSxHQUFHO2lCQUFDO2dCQUNsRG1DLGlCQUFpQixDQUFDLE9BQU8sRUFBRW5DLElBQUksSUFBSTtnQkFDbkNvQyxVQUFVO1lBQ1o7UUFDRixDQUFBO0FBRUYsTUFBTUMsMkJBQTJCLENBQUMxQyxRQUNoQ0MsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFIO0lBQU0sR0FBRyxDQUFDSSxHQUFHQyxJQUFPLENBQUE7WUFDdkNDLElBQUksR0FBR0QsR0FBRztZQUNWTSxNQUFNLENBQUMsT0FBTyxFQUFFTixHQUFHO1lBQ25Cc0MsY0FBYyxDQUFDLFFBQVEsRUFBRXRDLEdBQUc7WUFDNUJ1QyxhQUFhOUIsS0FBS2MsS0FBSyxDQUFDZCxLQUFLQyxNQUFNLEtBQUs7WUFDeEM4QixnQkFBZ0IvQixLQUFLYyxLQUFLLENBQUNkLEtBQUtDLE1BQU0sS0FBSztZQUMzQytCLGFBQWFoQyxLQUFLQyxNQUFNLEtBQUs7WUFDN0JnQyxhQUFhakMsS0FBS0MsTUFBTTtZQUN4QmlDLFlBQVksSUFBSXpCLEtBQUtBLEtBQUtDLEdBQUcsS0FBS25CLElBQUksTUFBTW9CLFdBQVc7WUFDdkR3QixZQUFZLElBQUkxQixLQUFLQSxLQUFLQyxHQUFHLEtBQUtuQixJQUFJLE1BQU1vQixXQUFXO1lBQ3ZEeUIsYUFBYXBDLEtBQUtDLE1BQU0sS0FBSztZQUM3Qm9DLGFBQWFyQyxLQUFLQyxNQUFNLEtBQUs7UUFDL0IsQ0FBQTtBQUVGcUMsU0FBUyxpQ0FBaUM7SUFDeENsRSxXQUFXO1FBQ1QsNkJBQTZCO1FBQzdCRixhQUFhRyxlQUFlLENBQUMsRUFBRTtRQUUvQkYsZ0JBQWdCRSxlQUFlLENBQUM7WUFDOUJDLFVBQVUsRUFBRTtZQUNaQyxrQkFBa0IsRUFBRTtZQUNwQkMsY0FBYyxFQUFFO1lBQ2hCQyxXQUFXO1lBQ1hDLE9BQU87WUFDUEMsc0JBQXNCZCxhQUFJLENBQUNHLEVBQUU7WUFDN0JZLGdCQUFnQmYsYUFBSSxDQUFDRyxFQUFFO1lBQ3ZCYSxlQUFlaEIsYUFBSSxDQUFDRyxFQUFFO1lBQ3RCYyxpQkFBaUJqQixhQUFJLENBQUNHLEVBQUU7WUFDeEJlLHFCQUFxQmxCLGFBQUksQ0FBQ0csRUFBRTtZQUM1QmdCLFNBQVNuQixhQUFJLENBQUNHLEVBQUU7UUFDbEI7SUFDRjtJQUVBdUUsVUFBVTtRQUNSMUUsYUFBSSxDQUFDMkUsYUFBYTtJQUNwQjtJQUVBRixTQUFTLHlCQUF5QjtRQUNoQ0csS0FBSyx5REFBeUQ7WUFDNUQsTUFBTUMsZUFBZXpELHNCQUFzQjtZQUMzQ2YsYUFBYUcsZUFBZSxDQUFDcUU7WUFFN0IsTUFBTUMsWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsTUFBTW1DLElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSxNQUFNQyxVQUFVSixZQUFZbEMsR0FBRztZQUMvQixNQUFNdUMsYUFBYUQsVUFBVUw7WUFFN0JPLE9BQU9ELFlBQVlFLFlBQVksQ0FBQztRQUNsQztRQUVBVixLQUFLLDZEQUE2RDtZQUNoRSxNQUFNVyxnQkFBZ0JuRSxzQkFBc0I7WUFDNUNmLGFBQWFHLGVBQWUsQ0FBQytFO1lBRTdCLE1BQU1ULFlBQVlDLFlBQVlsQyxHQUFHO1lBRWpDLE1BQU1tQyxJQUFBQSxXQUFHLEVBQUM7Z0JBQ1JDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLG9CQUFXO1lBQ3JCO1lBRUEsTUFBTUMsVUFBVUosWUFBWWxDLEdBQUc7WUFDL0IsTUFBTXVDLGFBQWFELFVBQVVMO1lBRTdCTyxPQUFPRCxZQUFZRSxZQUFZLENBQUM7UUFDbEM7UUFFQVYsS0FBSywwREFBMEQ7WUFDN0QsTUFBTVksZUFBZXBFLHNCQUFzQjtZQUMzQ2YsYUFBYUcsZUFBZSxDQUFDZ0Y7WUFFN0IsTUFBTVYsWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsTUFBTW1DLElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSxNQUFNQyxVQUFVSixZQUFZbEMsR0FBRztZQUMvQixNQUFNdUMsYUFBYUQsVUFBVUw7WUFFN0JPLE9BQU9ELFlBQVlFLFlBQVksQ0FBQztRQUNsQztRQUVBVixLQUFLLDBDQUEwQztZQUM3QyxNQUFNYSxzQkFBc0IxQix5QkFBeUI7WUFDckR6RCxnQkFBZ0JFLGVBQWUsQ0FBQztnQkFDOUIsR0FBR0YsaUJBQWlCO2dCQUNwQkcsVUFBVWdGO1lBQ1o7WUFFQSxNQUFNWCxZQUFZQyxZQUFZbEMsR0FBRztZQUVqQyxNQUFNbUMsSUFBQUEsV0FBRyxFQUFDO2dCQUNSQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztZQUNyQjtZQUVBLE1BQU1DLFVBQVVKLFlBQVlsQyxHQUFHO1lBQy9CLE1BQU11QyxhQUFhRCxVQUFVTDtZQUU3Qk8sT0FBT0QsWUFBWUUsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQWIsU0FBUywyQkFBMkI7UUFDbENHLEtBQUsscURBQXFEO1lBQ3hELE1BQU1jLDBCQUFZLHFCQUFDUixvQkFBVztZQUM5QkQsSUFBQUEsY0FBTSxFQUFDUztZQUVQLE1BQU1aLFlBQVlDLFlBQVlsQyxHQUFHO1lBRWpDLDhCQUE4QjtZQUM5QixJQUFLLElBQUluQixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztnQkFDM0IsTUFBTWlFLGFBQWFDLGNBQU0sQ0FBQ0MsY0FBYyxDQUFDO2dCQUN6Q0MsaUJBQVMsQ0FBQ0MsS0FBSyxDQUFDSjtnQkFFaEIsNkNBQTZDO2dCQUM3QyxNQUFNWCxJQUFBQSxXQUFHLEVBQUM7b0JBQ1IsTUFBTSxJQUFJZ0IsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztnQkFDbkQ7WUFDRjtZQUVBLE1BQU1kLFVBQVVKLFlBQVlsQyxHQUFHO1lBQy9CLE1BQU1zRCxZQUFZaEIsVUFBVUw7WUFFNUIsZ0RBQWdEO1lBQ2hETyxPQUFPYyxXQUFXYixZQUFZLENBQUM7UUFDakM7UUFFQVYsS0FBSywyQ0FBMkM7WUFDOUMsTUFBTVksZUFBZXBFLHNCQUFzQjtZQUMzQ2YsYUFBYUcsZUFBZSxDQUFDZ0Y7WUFFN0IsTUFBTUUsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMseUJBQXlCO1lBQ3pCLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQm9FLGlCQUFTLENBQUNNLE1BQU0sQ0FBQ0MsUUFBUTtvQkFBRUMsUUFBUTt3QkFBRUMsU0FBUzdFLElBQUk7b0JBQUk7Z0JBQUU7Z0JBQ3hELE1BQU1zRCxJQUFBQSxXQUFHLEVBQUM7b0JBQ1IsTUFBTSxJQUFJZ0IsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztnQkFDbkQ7WUFDRjtZQUVBLE1BQU1kLFVBQVVKLFlBQVlsQyxHQUFHO1lBQy9CLE1BQU1zRCxZQUFZaEIsVUFBVUw7WUFFNUIsMENBQTBDO1lBQzFDTyxPQUFPYyxXQUFXYixZQUFZLENBQUM7UUFDakM7UUFFQVYsS0FBSyw0Q0FBNEM7WUFDL0MsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsMEJBQTBCO1lBQzFCLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQixNQUFNOEUsVUFBVVosY0FBTSxDQUFDYSxTQUFTLENBQUMsQ0FBQyxPQUFPLEVBQUUvRSxJQUFJLElBQUk7Z0JBQ25Eb0UsaUJBQVMsQ0FBQ0MsS0FBSyxDQUFDUztnQkFFaEIsTUFBTXhCLElBQUFBLFdBQUcsRUFBQztvQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNuRDtZQUNGO1lBRUEsTUFBTWQsVUFBVUosWUFBWWxDLEdBQUc7WUFDL0IsTUFBTXNELFlBQVloQixVQUFVTDtZQUU1QiwrQ0FBK0M7WUFDL0NPLE9BQU9jLFdBQVdiLFlBQVksQ0FBQztRQUNqQztJQUNGO0lBRUFiLFNBQVMsc0JBQXNCO1FBQzdCRyxLQUFLLGtEQUFrRDtZQUNyRCxNQUFNOEIsZ0JBQWdCLEFBQUMzQixZQUFvQjRCLE1BQU0sRUFBRUMsa0JBQWtCO1lBRXJFLDhDQUE4QztZQUM5QyxJQUFLLElBQUlsRixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztnQkFDM0IsTUFBTSxFQUFFbUYsT0FBTyxFQUFFLEdBQUc1QixJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztnQkFDdkMyQjtnQkFFQSx3Q0FBd0M7Z0JBQ3hDLElBQUlDLE9BQU9DLEVBQUUsRUFBRTtvQkFDYkQsT0FBT0MsRUFBRTtnQkFDWDtZQUNGO1lBRUEsTUFBTUMsY0FBYyxBQUFDakMsWUFBb0I0QixNQUFNLEVBQUVDLGtCQUFrQjtZQUNuRSxNQUFNSyxpQkFBaUJELGNBQWNOO1lBRXJDLDZDQUE2QztZQUM3Q3JCLE9BQU80QixnQkFBZ0IzQixZQUFZLENBQUMsS0FBSyxPQUFPO1FBQ2xEO1FBRUFWLEtBQUssc0RBQXNEO1lBQ3pELE1BQU1zQyxtQkFBbUI5RixzQkFBc0I7WUFDL0NmLGFBQWFHLGVBQWUsQ0FBQzBHO1lBRTdCLE1BQU1SLGdCQUFnQixBQUFDM0IsWUFBb0I0QixNQUFNLEVBQUVDLGtCQUFrQjtZQUVyRSxNQUFNNUIsSUFBQUEsV0FBRyxFQUFDO2dCQUNSQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztZQUNyQjtZQUVBLE1BQU04QixjQUFjLEFBQUNqQyxZQUFvQjRCLE1BQU0sRUFBRUMsa0JBQWtCO1lBQ25FLE1BQU1LLGlCQUFpQkQsY0FBY047WUFFckMsK0RBQStEO1lBQy9EckIsT0FBTzRCLGdCQUFnQjNCLFlBQVksQ0FBQyxLQUFLLE9BQU87UUFDbEQ7SUFDRjtJQUVBYixTQUFTLHVCQUF1QjtRQUM5QkcsS0FBSyxtREFBbUQ7WUFDdEQsNkJBQTZCO1lBQzdCdEUsZ0JBQWdCRSxlQUFlLENBQUM7Z0JBQzlCLEdBQUdGLGlCQUFpQjtnQkFDcEJNLFdBQVc7WUFDYjtZQUVBLE1BQU1rRSxZQUFZQyxZQUFZbEMsR0FBRztZQUVqQyxNQUFNbUMsSUFBQUEsV0FBRyxFQUFDO2dCQUNSQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztZQUNyQjtZQUVBLHdCQUF3QjtZQUN4QixNQUFNRixJQUFBQSxXQUFHLEVBQUM7Z0JBQ1IsTUFBTSxJQUFJZ0IsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztZQUNuRDtZQUVBLE1BQU1kLFVBQVVKLFlBQVlsQyxHQUFHO1lBQy9CLE1BQU1zRCxZQUFZaEIsVUFBVUw7WUFFNUIsOENBQThDO1lBQzlDTyxPQUFPYyxXQUFXYixZQUFZLENBQUM7UUFDakM7UUFFQVYsS0FBSyxnRUFBZ0U7WUFDbkV0RSxnQkFBZ0JFLGVBQWUsQ0FBQztnQkFDOUIsR0FBR0YsaUJBQWlCO2dCQUNwQk8sT0FBTztZQUNUO1lBRUEsTUFBTWlFLFlBQVlDLFlBQVlsQyxHQUFHO1lBRWpDLE1BQU1tQyxJQUFBQSxXQUFHLEVBQUM7Z0JBQ1JDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLG9CQUFXO1lBQ3JCO1lBRUEsTUFBTUMsVUFBVUosWUFBWWxDLEdBQUc7WUFDL0IsTUFBTXVDLGFBQWFELFVBQVVMO1lBRTdCLG9DQUFvQztZQUNwQ08sT0FBT0QsWUFBWUUsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQWIsU0FBUyx5QkFBeUI7UUFDaENHLEtBQUsscUNBQXFDO1lBQ3hDLE1BQU1jLDBCQUFZLHFCQUFDUixvQkFBVztZQUM5QkQsSUFBQUEsY0FBTSxFQUFDUztZQUVQLE1BQU1aLFlBQVlDLFlBQVlsQyxHQUFHO1lBRWpDLHFCQUFxQjtZQUNyQixNQUFNc0UsaUJBQWlCdkIsY0FBTSxDQUFDQyxjQUFjLENBQUM7WUFDN0NDLGlCQUFTLENBQUNDLEtBQUssQ0FBQ29CO1lBRWhCLGlDQUFpQztZQUNqQyxNQUFNbkMsSUFBQUEsV0FBRyxFQUFDO2dCQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFDbkQ7WUFFQSxNQUFNZCxVQUFVSixZQUFZbEMsR0FBRztZQUMvQixNQUFNdUUsZ0JBQWdCakMsVUFBVUw7WUFFaEMseUNBQXlDO1lBQ3pDTyxPQUFPK0IsZUFBZTlCLFlBQVksQ0FBQztRQUNyQztRQUVBVixLQUFLLGtEQUFrRDtZQUNyRCxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZbEMsR0FBRztZQUVqQyw2Q0FBNkM7WUFDN0MsTUFBTXNFLGlCQUFpQnZCLGNBQU0sQ0FBQ0MsY0FBYyxDQUFDO1lBQzdDLE1BQU13QixnQkFBZ0J6QixjQUFNLENBQUNDLGNBQWMsQ0FBQztZQUU1Q0MsaUJBQVMsQ0FBQ0MsS0FBSyxDQUFDb0I7WUFDaEJyQixpQkFBUyxDQUFDQyxLQUFLLENBQUNzQjtZQUVoQixrQ0FBa0M7WUFDbEMsTUFBTXJDLElBQUFBLFdBQUcsRUFBQztnQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBQ25EO1lBRUEsTUFBTWQsVUFBVUosWUFBWWxDLEdBQUc7WUFDL0IsTUFBTXVFLGdCQUFnQmpDLFVBQVVMO1lBRWhDLHNEQUFzRDtZQUN0RE8sT0FBTytCLGVBQWU5QixZQUFZLENBQUM7UUFDckM7SUFDRjtJQUVBYixTQUFTLGlDQUFpQztRQUN4Q0csS0FBSywrQ0FBK0M7WUFDbEQsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsNkJBQTZCO1lBQzdCLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQixNQUFNNEYsY0FBY2xHLHNCQUFzQjtnQkFDMUNmLGFBQWFHLGVBQWUsQ0FBQzhHO2dCQUU3QixNQUFNdEMsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZbEMsR0FBRztZQUMvQixNQUFNMEUsYUFBYXBDLFVBQVVMO1lBRTdCLDRDQUE0QztZQUM1Q08sT0FBT2tDLFlBQVlqQyxZQUFZLENBQUM7UUFDbEM7UUFFQVYsS0FBSyw4REFBOEQ7WUFDakUsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsNkJBQTZCO1lBQzdCLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQiw2QkFBNkI7Z0JBQzdCb0UsSUFBQUEsaUJBQVMsRUFBQ08sUUFBUSxJQUFJbUIsTUFBTTtnQkFFNUIsTUFBTXhDLElBQUFBLFdBQUcsRUFBQztvQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNuRDtZQUNGO1lBRUEsTUFBTWQsVUFBVUosWUFBWWxDLEdBQUc7WUFDL0IsTUFBTTBFLGFBQWFwQyxVQUFVTDtZQUU3QixxREFBcUQ7WUFDckRPLE9BQU9rQyxZQUFZakMsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQWIsU0FBUyw2QkFBNkI7UUFDcENHLEtBQUssbURBQW1EO1lBQ3RELE1BQU1jLDBCQUFZLHFCQUFDUixvQkFBVztZQUM5QkQsSUFBQUEsY0FBTSxFQUFDUztZQUVQLE1BQU1aLFlBQVlDLFlBQVlsQyxHQUFHO1lBRWpDLGlDQUFpQztZQUNqQyxJQUFLLElBQUluQixJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztnQkFDMUIsTUFBTWlFLGFBQWFDLGNBQU0sQ0FBQ0MsY0FBYyxDQUFDO2dCQUN6Q0MsaUJBQVMsQ0FBQ0MsS0FBSyxDQUFDSjtnQkFFaEIsTUFBTVgsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZbEMsR0FBRztZQUMvQixNQUFNMEUsYUFBYXBDLFVBQVVMO1lBRTdCLHNEQUFzRDtZQUN0RE8sT0FBT2tDLFlBQVlqQyxZQUFZLENBQUM7UUFDbEM7UUFFQVYsS0FBSyxpREFBaUQ7WUFDcEQsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWWxDLEdBQUc7WUFFakMsK0JBQStCO1lBQy9CLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQm9FLGlCQUFTLENBQUMyQixPQUFPLENBQUNDLFVBQVU7b0JBQUVDLEtBQUs7Z0JBQU07Z0JBRXpDLE1BQU0zQyxJQUFBQSxXQUFHLEVBQUM7b0JBQ1IsTUFBTSxJQUFJZ0IsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztnQkFDbkQ7WUFDRjtZQUVBLE1BQU1kLFVBQVVKLFlBQVlsQyxHQUFHO1lBQy9CLE1BQU0rRSxpQkFBaUJ6QyxVQUFVTDtZQUVqQyxvREFBb0Q7WUFDcERPLE9BQU91QyxnQkFBZ0J0QyxZQUFZLENBQUM7UUFDdEM7SUFDRjtBQUNGIn0=