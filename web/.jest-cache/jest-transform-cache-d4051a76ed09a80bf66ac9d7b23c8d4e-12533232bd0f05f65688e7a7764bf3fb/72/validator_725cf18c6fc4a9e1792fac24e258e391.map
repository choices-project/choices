{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/vote/validator.ts"],"sourcesContent":["/**\n * Vote Validator\n * \n * Provides comprehensive validation for votes across all voting methods.\n * Handles business logic validation, security checks, and data integrity.\n * \n * Created: September 15, 2025\n * Updated: September 15, 2025\n */\n\nimport { devLog } from '@/lib/utils/logger';\n\nimport { getSupabaseServerClient } from '../../utils/supabase/server';\n\nimport type { \n  VoteData, \n  PollData, \n  VoteValidation\n} from './types';\n\nexport class VoteValidator {\n  private supabase: Awaited<ReturnType<typeof getSupabaseServerClient>> | null = null;\n\n  constructor() {\n    // Supabase client will be initialized lazily when needed\n  }\n\n  private async getSupabaseClient() {\n    if (!this.supabase) {\n      this.supabase = await getSupabaseServerClient();\n    }\n    return this.supabase;\n  }\n\n  /**\n   * Validate a vote request comprehensively\n   */\n  async validateVote(\n    voteData: VoteData, \n    poll: PollData, \n    userId?: string\n  ): Promise<VoteValidation> {\n    try {\n      // Basic validation\n      const basicValidation = this.validateBasicVoteData(voteData, poll);\n      if (!basicValidation.valid) {\n        return basicValidation;\n      }\n\n      // Method-specific validation\n      const methodValidation = this.validateVotingMethod(voteData, poll);\n      if (!methodValidation.valid) {\n        return methodValidation;\n      }\n\n      // Business logic validation\n      const businessValidation = await this.validateBusinessRules(voteData, poll, userId);\n      if (!businessValidation.valid) {\n        return businessValidation;\n      }\n\n      // Security validation\n      const securityValidation = await this.validateSecurity(voteData, poll, userId);\n      if (!securityValidation.valid) {\n        return securityValidation;\n      }\n\n      devLog('Vote validation passed', {\n        pollId: poll.id,\n        votingMethod: poll.votingMethod,\n        userId\n      });\n\n      return {\n        valid: true,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n\n    } catch (error) {\n      devLog('Vote validation error:', { error: error instanceof Error ? error.message : String(error) });\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Validation failed',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n  }\n\n  /**\n   * Validate basic vote data structure\n   */\n  private validateBasicVoteData(voteData: VoteData, poll: PollData): VoteValidation {\n    if (!voteData || typeof voteData !== 'object') {\n      return {\n        valid: false,\n        error: 'Vote data must be an object',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (!poll || typeof poll !== 'object') {\n      return {\n        valid: false,\n        error: 'Poll data is required',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (!poll.id || !poll.votingMethod) {\n      return {\n        valid: false,\n        error: 'Invalid poll data',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate voting method specific data\n   */\n  private validateVotingMethod(voteData: VoteData, poll: PollData): VoteValidation {\n    const method = poll.votingMethod;\n\n    switch (method) {\n      case 'single':\n        return this.validateSingleChoice(voteData, poll);\n      case 'approval':\n        return this.validateApproval(voteData, poll);\n      case 'ranked':\n        return this.validateRanked(voteData, poll);\n      case 'quadratic':\n        return this.validateQuadratic(voteData, poll);\n      case 'range':\n        return this.validateRange(voteData, poll);\n      default:\n        return {\n          valid: false,\n          error: `Unsupported voting method: ${method}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n    }\n  }\n\n  /**\n   * Validate business rules\n   */\n  private async validateBusinessRules(\n    voteData: VoteData, \n    poll: PollData, \n    userId?: string\n  ): Promise<VoteValidation> {\n    // Check if poll is active\n    if (poll.status !== 'active') {\n      return {\n        valid: false,\n        error: 'Poll is not active',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    // Check poll end time\n    if (poll.endTime && new Date(poll.endTime) < new Date()) {\n      return {\n        valid: false,\n        error: 'Poll has ended',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    // Check if poll is locked\n    if (poll.lockedAt) {\n      return {\n        valid: false,\n        error: 'Poll is locked',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    // Check if user has already voted (if not allowing multiple votes)\n    if (userId && !poll.votingConfig.allowMultipleVotes) {\n      const hasVoted = await this.checkExistingVote(poll.id, userId);\n      if (hasVoted) {\n        return {\n          valid: false,\n          error: 'You have already voted on this poll',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate security constraints\n   */\n  private async validateSecurity(\n    voteData: VoteData, \n    poll: PollData, \n    userId?: string\n  ): Promise<VoteValidation> {\n    // Check authentication requirements\n    if (poll.votingConfig.requireVerification && !userId) {\n      return {\n        valid: false,\n        error: 'Authentication required for this poll',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    // Check trust tier requirements\n    if (userId && poll.votingConfig.minTrustTier) {\n      const userTier = await this.getUserTrustTier(userId);\n      if (!this.isTrustTierSufficient(userTier, poll.votingConfig.minTrustTier)) {\n        return {\n          valid: false,\n          error: 'Insufficient trust tier for this poll',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    // Rate limiting check\n    if (userId) {\n      const isRateLimited = this.checkRateLimit(userId);\n      if (isRateLimited) {\n        return {\n          valid: false,\n          error: 'Rate limit exceeded. Please try again later.',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate single choice vote\n   */\n  private validateSingleChoice(voteData: VoteData, poll: PollData): VoteValidation {\n    if (voteData.choice === undefined || voteData.choice === null) {\n      return {\n        valid: false,\n        error: 'Choice is required for single choice voting',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (typeof voteData.choice !== 'number' || !Number.isInteger(voteData.choice)) {\n      return {\n        valid: false,\n        error: 'Choice must be a valid integer',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (voteData.choice < 0 || voteData.choice >= poll.options.length) {\n      return {\n        valid: false,\n        error: `Choice must be between 0 and ${poll.options.length - 1}`,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate approval vote\n   */\n  private validateApproval(voteData: VoteData, poll: PollData): VoteValidation {\n    if (!voteData.approvals || !Array.isArray(voteData.approvals)) {\n      return {\n        valid: false,\n        error: 'Approvals array is required for approval voting',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (voteData.approvals.length === 0) {\n      return {\n        valid: false,\n        error: 'At least one option must be approved',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    const maxApprovals = poll.votingConfig.maxChoices || poll.options.length;\n    if (voteData.approvals.length > maxApprovals) {\n      return {\n        valid: false,\n        error: `Maximum ${maxApprovals} approvals allowed`,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    for (const approval of voteData.approvals) {\n      if (typeof approval !== 'number' || !Number.isInteger(approval)) {\n        return {\n          valid: false,\n          error: 'All approvals must be valid integers',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      if (approval < 0 || approval >= poll.options.length) {\n        return {\n          valid: false,\n          error: `Approval index must be between 0 and ${poll.options.length - 1}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    // Check for duplicates\n    const uniqueApprovals = new Set(voteData.approvals);\n    if (uniqueApprovals.size !== voteData.approvals.length) {\n      return {\n        valid: false,\n        error: 'Duplicate approvals are not allowed',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate ranked vote\n   */\n  private validateRanked(voteData: VoteData, poll: PollData): VoteValidation {\n    if (!voteData.rankings || !Array.isArray(voteData.rankings)) {\n      return {\n        valid: false,\n        error: 'Rankings array is required for ranked choice voting',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    if (voteData.rankings.length !== poll.options.length) {\n      return {\n        valid: false,\n        error: 'All options must be ranked',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    for (const ranking of voteData.rankings) {\n      if (typeof ranking !== 'number' || !Number.isInteger(ranking)) {\n        return {\n          valid: false,\n          error: 'All rankings must be valid integers',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      if (ranking < 0 || ranking >= poll.options.length) {\n        return {\n          valid: false,\n          error: `Ranking index must be between 0 and ${poll.options.length - 1}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    // Check for duplicates\n    const uniqueRankings = new Set(voteData.rankings);\n    if (uniqueRankings.size !== voteData.rankings.length) {\n      return {\n        valid: false,\n        error: 'Duplicate rankings are not allowed',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate quadratic vote\n   */\n  private validateQuadratic(voteData: VoteData, poll: PollData): VoteValidation {\n    if (!voteData.allocations || typeof voteData.allocations !== 'object') {\n      return {\n        valid: false,\n        error: 'Allocations object is required for quadratic voting',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    const totalCredits = poll.votingConfig.quadraticCredits || 100;\n    let totalSpent = 0;\n\n    for (const [optionIndex, credits] of Object.entries(voteData.allocations)) {\n      if (typeof credits !== 'number' || !Number.isInteger(credits) || credits < 0) {\n        return {\n          valid: false,\n          error: 'All allocations must be non-negative integers',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      const optionIdx = parseInt(optionIndex);\n      if (optionIdx < 0 || optionIdx >= poll.options.length) {\n        return {\n          valid: false,\n          error: `Invalid option index: ${optionIndex}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      const cost = credits * credits;\n      totalSpent += cost;\n    }\n\n    if (totalSpent > totalCredits) {\n      return {\n        valid: false,\n        error: `Total spending (${totalSpent}) exceeds available credits (${totalCredits})`,\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    const hasVotes = Object.values(voteData.allocations).some(credits => credits > 0);\n    if (!hasVotes) {\n      return {\n        valid: false,\n        error: 'At least one option must receive votes',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Validate range vote\n   */\n  private validateRange(voteData: VoteData, poll: PollData): VoteValidation {\n    if (!voteData.ratings || typeof voteData.ratings !== 'object') {\n      return {\n        valid: false,\n        error: 'Ratings object is required for range voting',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    const rangeMin = poll.votingConfig.rangeMin || 0;\n    const rangeMax = poll.votingConfig.rangeMax || 10;\n\n    for (const [optionIndex, rating] of Object.entries(voteData.ratings)) {\n      if (typeof rating !== 'number' || isNaN(rating)) {\n        return {\n          valid: false,\n          error: 'All ratings must be valid numbers',\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      if (rating < rangeMin || rating > rangeMax) {\n        return {\n          valid: false,\n          error: `Rating must be between ${rangeMin} and ${rangeMax}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n\n      const optionIdx = parseInt(optionIndex);\n      if (optionIdx < 0 || optionIdx >= poll.options.length) {\n        return {\n          valid: false,\n          error: `Invalid option index: ${optionIndex}`,\n          requiresAuthentication: true,\n          requiresTokens: false\n        };\n      }\n    }\n\n    if (Object.keys(voteData.ratings).length !== poll.options.length) {\n      return {\n        valid: false,\n        error: 'All options must be rated',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    const hasNonZeroRating = Object.values(voteData.ratings).some(rating => rating > rangeMin);\n    if (!hasNonZeroRating) {\n      return {\n        valid: false,\n        error: 'At least one option must have a rating above the minimum',\n        requiresAuthentication: true,\n        requiresTokens: false\n      };\n    }\n\n    return {\n      valid: true,\n      requiresAuthentication: true,\n      requiresTokens: false\n    };\n  }\n\n  /**\n   * Check if user has already voted\n   */\n  private async checkExistingVote(pollId: string, userId: string): Promise<boolean> {\n    try {\n      const supabaseClient = await this.getSupabaseClient();\n      if (!supabaseClient) return false;\n\n      const { data } = await supabaseClient\n        .from('votes')\n        .select('id')\n        .eq('poll_id', pollId)\n        .eq('user_id', userId)\n        .single();\n\n      return !!data;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get user trust tier\n   */\n  private async getUserTrustTier(userId: string): Promise<string> {\n    try {\n      const supabaseClient = await this.getSupabaseClient();\n      if (!supabaseClient) return 'T0';\n\n      const { data } = await supabaseClient\n        .from('user_profiles')\n        .select('trust_tier')\n        .eq('user_id', userId)\n        .single();\n\n      return data?.trust_tier || 'T0';\n    } catch {\n      return 'T0';\n    }\n  }\n\n  /**\n   * Check if trust tier is sufficient\n   */\n  private isTrustTierSufficient(userTier: string, requiredTier: string): boolean {\n    const tiers = ['T0', 'T1', 'T2', 'T3'];\n    const userIndex = tiers.indexOf(userTier);\n    const requiredIndex = tiers.indexOf(requiredTier);\n    \n    return userIndex >= requiredIndex;\n  }\n\n  /**\n   * Check rate limit for user\n   */\n  private checkRateLimit(_userId: string): boolean {\n    // This would implement actual rate limiting logic\n    // For now, return false (no rate limiting)\n    return false;\n  }\n}\n"],"names":["VoteValidator","supabase","getSupabaseClient","getSupabaseServerClient","validateVote","voteData","poll","userId","basicValidation","validateBasicVoteData","valid","methodValidation","validateVotingMethod","businessValidation","validateBusinessRules","securityValidation","validateSecurity","devLog","pollId","id","votingMethod","requiresAuthentication","requiresTokens","error","Error","message","String","method","validateSingleChoice","validateApproval","validateRanked","validateQuadratic","validateRange","status","endTime","Date","lockedAt","votingConfig","allowMultipleVotes","hasVoted","checkExistingVote","requireVerification","minTrustTier","userTier","getUserTrustTier","isTrustTierSufficient","isRateLimited","checkRateLimit","choice","undefined","Number","isInteger","options","length","approvals","Array","isArray","maxApprovals","maxChoices","approval","uniqueApprovals","Set","size","rankings","ranking","uniqueRankings","allocations","totalCredits","quadraticCredits","totalSpent","optionIndex","credits","Object","entries","optionIdx","parseInt","cost","hasVotes","values","some","ratings","rangeMin","rangeMax","rating","isNaN","keys","hasNonZeroRating","supabaseClient","data","from","select","eq","single","trust_tier","requiredTier","tiers","userIndex","indexOf","requiredIndex","_userId"],"mappings":"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"}