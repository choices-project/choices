e85ee87ad95439fd10e3c283310f3bfc
/**
 * Jest Setup - Simple and Clean
 * 
 * This setup file provides minimal configuration for testing.
 * We use real Supabase credentials and real test users instead of complex mocks.
 */ // Import testing library matchers
"use strict";
// Mock Next.js router
jest.mock('next/navigation', ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                prefetch: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                pathname: '/',
                route: '/',
                query: {},
                asPath: '/'
            }),
        usePathname: ()=>'/',
        useSearchParams: ()=>new URLSearchParams()
    }));
require('@testing-library/jest-dom');
// Load environment variables from .env.local
require('dotenv').config({
    path: '.env.local'
});
// Simple environment setup for testing
process.env.NODE_ENV = 'test';
process.env.NEXTAUTH_SECRET = 'test-secret';
process.env.NEXTAUTH_URL = 'http://localhost:3000';
// Set up privacy pepper environment variables for testing
process.env.PRIVACY_PEPPER_DEV = 'dev-pepper-consistent-for-testing-12345678901234567890';
process.env.PRIVACY_PEPPER_CURRENT = 'hex:' + 'ab'.repeat(32);
// Browser API mocks (only for jsdom environment)
if (typeof window !== 'undefined') {
    // Mock window.matchMedia for responsive components
    Object.defineProperty(window, 'matchMedia', {
        writable: true,
        value: jest.fn().mockImplementation((query)=>({
                matches: false,
                media: query,
                onchange: null,
                addListener: jest.fn(),
                removeListener: jest.fn(),
                addEventListener: jest.fn(),
                removeEventListener: jest.fn(),
                dispatchEvent: jest.fn()
            }))
    });
    // Mock navigator.onLine for offline functionality
    Object.defineProperty(navigator, 'onLine', {
        writable: true,
        value: true
    });
    // Mock service worker
    Object.defineProperty(navigator, 'serviceWorker', {
        writable: true,
        value: {
            register: jest.fn(()=>Promise.resolve()),
            ready: Promise.resolve()
        }
    });
    // Mock PushManager
    Object.defineProperty(window, 'PushManager', {
        writable: true,
        value: {
            supportedContentEncodings: [
                'aesgcm'
            ]
        }
    });
    // Mock Notification
    Object.defineProperty(window, 'Notification', {
        writable: true,
        value: class Notification {
            constructor(title, options = {}){
                this.title = title;
                this.options = options;
            }
            static{
                this.requestPermission = jest.fn(()=>Promise.resolve('granted'));
            }
            static{
                this.permission = 'granted';
            }
        }
    });
}
// Enhanced fetch polyfill for Node.js (for Supabase compatibility)
if (typeof global.fetch === 'undefined') {
    // Create a comprehensive fetch mock that works with Supabase
    global.fetch = jest.fn().mockImplementation(async (url, options = {})=>{
        // Mock successful response for Supabase requests
        const mockResponse = {
            ok: true,
            status: 200,
            statusText: 'OK',
            headers: new Map([
                [
                    'content-type',
                    'application/json'
                ]
            ]),
            json: async ()=>({
                    data: [],
                    error: null
                }),
            text: async ()=>'{"data":[],"error":null}',
            url: url,
            type: 'basic',
            redirected: false,
            clone: ()=>global.fetch(url, options)
        };
        return Promise.resolve(mockResponse);
    });
}
// Simple Response polyfill for Node.js (minimal)
if (typeof global.Response === 'undefined') {
    global.Response = class Response {
        constructor(body, options = {}){
            this.body = body;
            this.status = options.status || 200;
            this.statusText = options.statusText || 'OK';
            this.headers = new Map();
            if (options.headers) {
                Object.entries(options.headers).forEach(([key, value])=>{
                    this.headers.set(key.toLowerCase(), value);
                });
            }
        }
        async json() {
            return JSON.parse(this.body || '{}');
        }
        async text() {
            return this.body || '';
        }
        static json(data, options = {}) {
            return new Response(JSON.stringify(data), {
                ...options,
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });
        }
    };
}
// Simple Headers polyfill for Node.js (minimal)
if (typeof global.Headers === 'undefined') {
    global.Headers = class Headers1 {
        constructor(init = {}){
            this.map = new Map();
            if (init) {
                Object.entries(init).forEach(([key, value])=>{
                    this.map.set(key.toLowerCase(), value);
                });
            }
        }
        get(name) {
            return this.map.get(name.toLowerCase());
        }
        set(name, value) {
            this.map.set(name.toLowerCase(), value);
        }
        has(name) {
            return this.map.has(name.toLowerCase());
        }
        delete(name) {
            this.map.delete(name.toLowerCase());
        }
    };
}
// Simple Request polyfill for Node.js (minimal)
if (typeof global.Request === 'undefined') {
    global.Request = class Request {
        constructor(input, init = {}){
            // Use Object.defineProperty to make url writable
            Object.defineProperty(this, 'url', {
                value: input,
                writable: true,
                enumerable: true,
                configurable: true
            });
            this.method = init.method || 'GET';
            this.headers = new Headers(init.headers);
            this.body = init.body;
        }
    };
}
// TextEncoder/TextDecoder polyfills for Node.js
if (typeof global.TextEncoder === 'undefined') {
    const { TextEncoder, TextDecoder } = require('util');
    global.TextEncoder = TextEncoder;
    global.TextDecoder = TextDecoder;
}
// Enhanced fetch polyfill for Node.js (for Supabase compatibility)
if (typeof global.fetch === 'undefined') {
    // Create a comprehensive fetch mock that works with Supabase
    global.fetch = jest.fn().mockImplementation(async (url, options = {})=>{
        // Mock successful response for Supabase requests
        const mockResponse = {
            ok: true,
            status: 200,
            statusText: 'OK',
            headers: new Map([
                [
                    'content-type',
                    'application/json'
                ]
            ]),
            json: async ()=>({
                    data: [],
                    error: null
                }),
            text: async ()=>'{"data":[],"error":null}',
            url: url,
            type: 'basic',
            redirected: false,
            clone: ()=>global.fetch(url, options)
        };
        return Promise.resolve(mockResponse);
    });
} // lucide-react is mocked via moduleNameMapper in jest.config.js

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi9qZXN0LnNldHVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSmVzdCBTZXR1cCAtIFNpbXBsZSBhbmQgQ2xlYW5cbiAqIFxuICogVGhpcyBzZXR1cCBmaWxlIHByb3ZpZGVzIG1pbmltYWwgY29uZmlndXJhdGlvbiBmb3IgdGVzdGluZy5cbiAqIFdlIHVzZSByZWFsIFN1cGFiYXNlIGNyZWRlbnRpYWxzIGFuZCByZWFsIHRlc3QgdXNlcnMgaW5zdGVhZCBvZiBjb21wbGV4IG1vY2tzLlxuICovXG5cbi8vIEltcG9ydCB0ZXN0aW5nIGxpYnJhcnkgbWF0Y2hlcnNcbnJlcXVpcmUoJ0B0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb20nKTtcblxuLy8gTG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52LmxvY2FsXG5yZXF1aXJlKCdkb3RlbnYnKS5jb25maWcoeyBwYXRoOiAnLmVudi5sb2NhbCcgfSk7XG5cbi8vIFNpbXBsZSBlbnZpcm9ubWVudCBzZXR1cCBmb3IgdGVzdGluZ1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAndGVzdCc7XG5wcm9jZXNzLmVudi5ORVhUQVVUSF9TRUNSRVQgPSAndGVzdC1zZWNyZXQnO1xucHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG5cbi8vIFNldCB1cCBwcml2YWN5IHBlcHBlciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHRlc3RpbmdcbnByb2Nlc3MuZW52LlBSSVZBQ1lfUEVQUEVSX0RFViA9ICdkZXYtcGVwcGVyLWNvbnNpc3RlbnQtZm9yLXRlc3RpbmctMTIzNDU2Nzg5MDEyMzQ1Njc4OTAnO1xucHJvY2Vzcy5lbnYuUFJJVkFDWV9QRVBQRVJfQ1VSUkVOVCA9ICdoZXg6JyArICdhYicucmVwZWF0KDMyKTtcblxuLy8gQnJvd3NlciBBUEkgbW9ja3MgKG9ubHkgZm9yIGpzZG9tIGVudmlyb25tZW50KVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIE1vY2sgd2luZG93Lm1hdGNoTWVkaWEgZm9yIHJlc3BvbnNpdmUgY29tcG9uZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbWF0Y2hNZWRpYScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihxdWVyeSA9PiAoe1xuICAgICAgbWF0Y2hlczogZmFsc2UsXG4gICAgICBtZWRpYTogcXVlcnksXG4gICAgICBvbmNoYW5nZTogbnVsbCxcbiAgICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksXG4gICAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxuICAgICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxuICAgIH0pKSxcbiAgfSk7XG5cbiAgLy8gTW9jayBuYXZpZ2F0b3Iub25MaW5lIGZvciBvZmZsaW5lIGZ1bmN0aW9uYWxpdHlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ29uTGluZScsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gTW9jayBzZXJ2aWNlIHdvcmtlclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAnc2VydmljZVdvcmtlcicsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZToge1xuICAgICAgcmVnaXN0ZXI6IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpLFxuICAgICAgcmVhZHk6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIE1vY2sgUHVzaE1hbmFnZXJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1B1c2hNYW5hZ2VyJywge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7XG4gICAgICBzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzOiBbJ2Flc2djbSddLFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIE1vY2sgTm90aWZpY2F0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdOb3RpZmljYXRpb24nLCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNsYXNzIE5vdGlmaWNhdGlvbiB7XG4gICAgICBjb25zdHJ1Y3Rvcih0aXRsZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RhdGljIHJlcXVlc3RQZXJtaXNzaW9uID0gamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2dyYW50ZWQnKSk7XG4gICAgICBzdGF0aWMgcGVybWlzc2lvbiA9ICdncmFudGVkJztcbiAgICB9LFxuICB9KTtcbn1cblxuLy8gRW5oYW5jZWQgZmV0Y2ggcG9seWZpbGwgZm9yIE5vZGUuanMgKGZvciBTdXBhYmFzZSBjb21wYXRpYmlsaXR5KVxuaWYgKHR5cGVvZiBnbG9iYWwuZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIENyZWF0ZSBhIGNvbXByZWhlbnNpdmUgZmV0Y2ggbW9jayB0aGF0IHdvcmtzIHdpdGggU3VwYWJhc2VcbiAgZ2xvYmFsLmZldGNoID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZm9yIFN1cGFiYXNlIHJlcXVlc3RzXG4gICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcbiAgICAgICAgWydjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbiddXG4gICAgICBdKSxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgIHRleHQ6IGFzeW5jICgpID0+ICd7XCJkYXRhXCI6W10sXCJlcnJvclwiOm51bGx9JyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgdHlwZTogJ2Jhc2ljJyxcbiAgICAgIHJlZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgY2xvbmU6ICgpID0+IGdsb2JhbC5mZXRjaCh1cmwsIG9wdGlvbnMpXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vY2tSZXNwb25zZSk7XG4gIH0pO1xufVxuXG4vLyBTaW1wbGUgUmVzcG9uc2UgcG9seWZpbGwgZm9yIE5vZGUuanMgKG1pbmltYWwpXG5pZiAodHlwZW9mIGdsb2JhbC5SZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsLlJlc3BvbnNlID0gY2xhc3MgUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJvZHksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgfHwgMjAwO1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldChrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBqc29uKCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5ib2R5IHx8ICd7fScpO1xuICAgIH1cblxuICAgIGFzeW5jIHRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5IHx8ICcnO1xuICAgIH1cblxuICAgIHN0YXRpYyBqc29uKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBTaW1wbGUgSGVhZGVycyBwb2x5ZmlsbCBmb3IgTm9kZS5qcyAobWluaW1hbClcbmlmICh0eXBlb2YgZ2xvYmFsLkhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbC5IZWFkZXJzID0gY2xhc3MgSGVhZGVycyB7XG4gICAgY29uc3RydWN0b3IoaW5pdCA9IHt9KSB7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChpbml0KSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGluaXQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMubWFwLnNldChrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5tYXAuc2V0KG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGhhcyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgZGVsZXRlKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwLmRlbGV0ZShuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gU2ltcGxlIFJlcXVlc3QgcG9seWZpbGwgZm9yIE5vZGUuanMgKG1pbmltYWwpXG5pZiAodHlwZW9mIGdsb2JhbC5SZXF1ZXN0ID09PSAndW5kZWZpbmVkJykge1xuICBnbG9iYWwuUmVxdWVzdCA9IGNsYXNzIFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBpbml0ID0ge30pIHtcbiAgICAgIC8vIFVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgdG8gbWFrZSB1cmwgd3JpdGFibGVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndXJsJywge1xuICAgICAgICB2YWx1ZTogaW5wdXQsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZXRob2QgPSBpbml0Lm1ldGhvZCB8fCAnR0VUJztcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyk7XG4gICAgICB0aGlzLmJvZHkgPSBpbml0LmJvZHk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUZXh0RW5jb2Rlci9UZXh0RGVjb2RlciBwb2x5ZmlsbHMgZm9yIE5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsLlRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICBjb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgndXRpbCcpO1xuICBnbG9iYWwuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcbiAgZ2xvYmFsLlRleHREZWNvZGVyID0gVGV4dERlY29kZXI7XG59XG5cbi8vIE1vY2sgTmV4dC5qcyByb3V0ZXJcbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlUm91dGVyOiAoKSA9PiAoe1xuICAgIHB1c2g6IGplc3QuZm4oKSxcbiAgICByZXBsYWNlOiBqZXN0LmZuKCksXG4gICAgcHJlZmV0Y2g6IGplc3QuZm4oKSxcbiAgICBiYWNrOiBqZXN0LmZuKCksXG4gICAgZm9yd2FyZDogamVzdC5mbigpLFxuICAgIHJlZnJlc2g6IGplc3QuZm4oKSxcbiAgICBwYXRobmFtZTogJy8nLFxuICAgIHJvdXRlOiAnLycsXG4gICAgcXVlcnk6IHt9LFxuICAgIGFzUGF0aDogJy8nLFxuICB9KSxcbiAgdXNlUGF0aG5hbWU6ICgpID0+ICcvJyxcbiAgdXNlU2VhcmNoUGFyYW1zOiAoKSA9PiBuZXcgVVJMU2VhcmNoUGFyYW1zKCksXG59KSk7XG5cbi8vIEVuaGFuY2VkIGZldGNoIHBvbHlmaWxsIGZvciBOb2RlLmpzIChmb3IgU3VwYWJhc2UgY29tcGF0aWJpbGl0eSlcbmlmICh0eXBlb2YgZ2xvYmFsLmZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAvLyBDcmVhdGUgYSBjb21wcmVoZW5zaXZlIGZldGNoIG1vY2sgdGhhdCB3b3JrcyB3aXRoIFN1cGFiYXNlXG4gIGdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgLy8gTW9jayBzdWNjZXNzZnVsIHJlc3BvbnNlIGZvciBTdXBhYmFzZSByZXF1ZXN0c1xuICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgaGVhZGVyczogbmV3IE1hcChbXG4gICAgICAgIFsnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nXVxuICAgICAgXSksXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSksXG4gICAgICB0ZXh0OiBhc3luYyAoKSA9PiAne1wiZGF0YVwiOltdLFwiZXJyb3JcIjpudWxsfScsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICByZWRpcmVjdGVkOiBmYWxzZSxcbiAgICAgIGNsb25lOiAoKSA9PiBnbG9iYWwuZmV0Y2godXJsLCBvcHRpb25zKVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2NrUmVzcG9uc2UpO1xuICB9KTtcbn1cblxuLy8gbHVjaWRlLXJlYWN0IGlzIG1vY2tlZCB2aWEgbW9kdWxlTmFtZU1hcHBlciBpbiBqZXN0LmNvbmZpZy5qcyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVJvdXRlciIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJwcmVmZXRjaCIsImJhY2siLCJmb3J3YXJkIiwicmVmcmVzaCIsInBhdGhuYW1lIiwicm91dGUiLCJxdWVyeSIsImFzUGF0aCIsInVzZVBhdGhuYW1lIiwidXNlU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwicmVxdWlyZSIsImNvbmZpZyIsInBhdGgiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJORVhUQVVUSF9TRUNSRVQiLCJORVhUQVVUSF9VUkwiLCJQUklWQUNZX1BFUFBFUl9ERVYiLCJQUklWQUNZX1BFUFBFUl9DVVJSRU5UIiwicmVwZWF0Iiwid2luZG93IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsInZhbHVlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibWF0Y2hlcyIsIm1lZGlhIiwib25jaGFuZ2UiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwibmF2aWdhdG9yIiwicmVnaXN0ZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWR5Iiwic3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyIsIk5vdGlmaWNhdGlvbiIsInRpdGxlIiwib3B0aW9ucyIsInJlcXVlc3RQZXJtaXNzaW9uIiwicGVybWlzc2lvbiIsImdsb2JhbCIsImZldGNoIiwidXJsIiwibW9ja1Jlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiaGVhZGVycyIsIk1hcCIsImpzb24iLCJkYXRhIiwiZXJyb3IiLCJ0ZXh0IiwidHlwZSIsInJlZGlyZWN0ZWQiLCJjbG9uZSIsIlJlc3BvbnNlIiwiYm9keSIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5Iiwic2V0IiwidG9Mb3dlckNhc2UiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJIZWFkZXJzIiwiaW5pdCIsIm1hcCIsImdldCIsIm5hbWUiLCJoYXMiLCJkZWxldGUiLCJSZXF1ZXN0IiwiaW5wdXQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibWV0aG9kIiwiVGV4dEVuY29kZXIiLCJUZXh0RGVjb2RlciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRCxrQ0FBa0M7O0FBd0xsQyxzQkFBc0I7QUFDdEJBLEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQyxXQUFXLElBQU8sQ0FBQTtnQkFDaEJDLE1BQU1ILEtBQUtJLEVBQUU7Z0JBQ2JDLFNBQVNMLEtBQUtJLEVBQUU7Z0JBQ2hCRSxVQUFVTixLQUFLSSxFQUFFO2dCQUNqQkcsTUFBTVAsS0FBS0ksRUFBRTtnQkFDYkksU0FBU1IsS0FBS0ksRUFBRTtnQkFDaEJLLFNBQVNULEtBQUtJLEVBQUU7Z0JBQ2hCTSxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQQyxPQUFPLENBQUM7Z0JBQ1JDLFFBQVE7WUFDVixDQUFBO1FBQ0FDLGFBQWEsSUFBTTtRQUNuQkMsaUJBQWlCLElBQU0sSUFBSUM7SUFDN0IsQ0FBQTtBQXZNQUMsUUFBUTtBQUVSLDZDQUE2QztBQUM3Q0EsUUFBUSxVQUFVQyxNQUFNLENBQUM7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