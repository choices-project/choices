4e0c734eda6f9a7d268bc19698f1f968
/**
 * UnifiedFeed Performance Tests
 * 
 * Comprehensive performance testing for the UnifiedFeed component
 * Tests real performance metrics and optimization
 * 
 * Created: January 19, 2025
 * Status: âœ… PRODUCTION READY
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../../features/feeds/components/UnifiedFeed"));
const _feedsStore = require("../../../../../lib/stores/feedsStore");
const _useHashtags = require("../../../../../features/hashtags/hooks/useHashtags");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock the stores
_globals.jest.mock('@/lib/stores/feedsStore', ()=>({
        useFeeds: _globals.jest.fn()
    }));
_globals.jest.mock('@/features/hashtags/hooks/useHashtags', ()=>({
        useHashtags: _globals.jest.fn()
    }));
const mockUseFeeds = _feedsStore.useFeeds;
const mockUseHashtags = _useHashtags.useHashtags;
// Performance test data
const generateLargeFeedData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            title: `Test ${i % 2 === 0 ? 'Poll' : 'Post'} ${i}`,
            content: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i} with some content`,
            summary: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i}`,
            author: {
                id: `author-${i}`,
                name: `User ${i}`,
                avatar: `/test-avatar-${i}.jpg`,
                verified: Math.random() > 0.8
            },
            category: `category${i % 5}`,
            tags: [
                `hashtag${i % 10}`,
                `category${i % 5}`
            ],
            type: i % 2 === 0 ? 'poll' : 'article',
            source: {
                name: `Source ${i}`,
                url: `https://example.com/${i}`,
                logo: `/test-logo-${i}.jpg`,
                verified: true
            },
            publishedAt: new Date(Date.now() - i * 1000).toISOString(),
            updatedAt: new Date(Date.now() - i * 1000).toISOString(),
            readTime: Math.floor(Math.random() * 10) + 1,
            engagement: {
                likes: Math.floor(Math.random() * 1000),
                shares: Math.floor(Math.random() * 500),
                comments: Math.floor(Math.random() * 200),
                views: Math.floor(Math.random() * 5000)
            },
            userInteraction: {
                liked: false,
                shared: false,
                bookmarked: false,
                read: false
            },
            metadata: {
                hashtags: [
                    `hashtag${i % 10}`,
                    `category${i % 5}`
                ],
                primary_hashtag: `hashtag${i % 10}`,
                language: 'en'
            }
        }));
const generateLargeHashtagData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            name: `hashtag${i}`,
            display_name: `Hashtag ${i}`,
            usage_count: Math.floor(Math.random() * 1000),
            follower_count: Math.floor(Math.random() * 500),
            is_trending: Math.random() > 0.7,
            trend_score: Math.random(),
            created_at: new Date(Date.now() - i * 1000).toISOString(),
            updated_at: new Date(Date.now() - i * 1000).toISOString(),
            is_verified: Math.random() > 0.9,
            is_featured: Math.random() > 0.8
        }));
describe('UnifiedFeed Performance Tests', ()=>{
    beforeEach(()=>{
        // Mock store implementations
        mockUseFeeds.mockReturnValue([]);
        mockUseHashtags.mockReturnValue({
            hashtags: [],
            trendingHashtags: [],
            userHashtags: [],
            isLoading: false,
            error: null,
            loadTrendingHashtags: _globals.jest.fn(),
            searchHashtags: _globals.jest.fn(),
            followHashtag: _globals.jest.fn(),
            unfollowHashtag: _globals.jest.fn(),
            getTrendingHashtags: _globals.jest.fn(),
            refresh: _globals.jest.fn()
        });
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('Rendering Performance', ()=>{
        test('should render small dataset (< 50 items) within 500ms', async ()=>{
            const smallDataset = generateLargeFeedData(50);
            mockUseFeeds.mockReturnValue(smallDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(500);
        });
        test('should render medium dataset (50-200 items) within 1000ms', async ()=>{
            const mediumDataset = generateLargeFeedData(200);
            mockUseFeeds.mockReturnValue(mediumDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1000);
        });
        test('should render large dataset (200+ items) within 2000ms', async ()=>{
            const largeDataset = generateLargeFeedData(500);
            mockUseFeeds.mockReturnValue(largeDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(2000);
        });
        test('should handle hashtag data efficiently', async ()=>{
            const largeHashtagDataset = generateLargeHashtagData(1000);
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                hashtags: largeHashtagDataset
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1500);
        });
    });
    describe('Interaction Performance', ()=>{
        test('should handle rapid clicks within acceptable time', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate rapid interactions
            for(let i = 0; i < 20; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                // Small delay to simulate real user behavior
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle 20 interactions within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
        test('should handle scroll events efficiently', async ()=>{
            const largeDataset = generateLargeFeedData(300);
            mockUseFeeds.mockReturnValue(largeDataset);
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate scroll events
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.scroll(window, {
                    target: {
                        scrollY: i * 100
                    }
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle scroll events efficiently
            expect(totalTime).toBeLessThan(2000);
        });
        test('should handle filter changes efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate filter changes
            for(let i = 0; i < 10; i++){
                const hashtag = _react1.screen.getByText(`hashtag${i % 10}`);
                _react1.fireEvent.click(hashtag);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle filter changes within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
    });
    describe('Memory Performance', ()=>{
        test('should not leak memory during repeated renders', async ()=>{
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Render and unmount component multiple times
            for(let i = 0; i < 10; i++){
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
                unmount();
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            }
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
        test('should handle large datasets without memory issues', async ()=>{
            const veryLargeDataset = generateLargeFeedData(1000);
            mockUseFeeds.mockReturnValue(veryLargeDataset);
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (< 50MB for 1000 items)
            expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
        });
    });
    describe('Network Performance', ()=>{
        test('should handle slow network responses gracefully', async ()=>{
            // Mock slow network response
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                isLoading: true
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            // Simulate slow loading
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            });
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle slow loading within 3 seconds
            expect(totalTime).toBeLessThan(3000);
        });
        test('should handle network errors without performance degradation', async ()=>{
            mockUseHashtags.mockReturnValue({
                ...mockUseHashtags(),
                error: 'Network error'
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            // Should render error state quickly
            expect(renderTime).toBeLessThan(500);
        });
    });
    describe('Animation Performance', ()=>{
        test('should handle animations smoothly', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger animations
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Wait for animation to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 300));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Animation should complete within 500ms
            expect(animationTime).toBeLessThan(500);
        });
        test('should handle multiple simultaneous animations', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger multiple animations simultaneously
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(darkModeButton);
            _react1.fireEvent.click(filtersButton);
            // Wait for animations to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 500));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Multiple animations should complete within 1 second
            expect(animationTime).toBeLessThan(1000);
        });
    });
    describe('Real-time Updates Performance', ()=>{
        test('should handle real-time updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate real-time updates
            for(let i = 0; i < 10; i++){
                const newFeedData = generateLargeFeedData(10);
                mockUseFeeds.mockReturnValue(newFeedData);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle 10 updates within 2 seconds
            expect(updateTime).toBeLessThan(2000);
        });
        test('should handle WebSocket updates without performance issues', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate WebSocket updates
            for(let i = 0; i < 5; i++){
                // Simulate WebSocket message
                (0, _react1.fireEvent)(window, new Event('message'));
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 200));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle WebSocket updates within 1.5 seconds
            expect(updateTime).toBeLessThan(1500);
        });
    });
    describe('Accessibility Performance', ()=>{
        test('should handle screen reader updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate screen reader updates
            for(let i = 0; i < 5; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle screen reader updates within 1 second
            expect(updateTime).toBeLessThan(1000);
        });
        test('should handle keyboard navigation efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate keyboard navigation
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.keyDown(document, {
                    key: 'Tab'
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const navigationTime = endTime - startTime;
            // Should handle keyboard navigation within 1 second
            expect(navigationTime).toBeLessThan(1000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQucGVyZm9ybWFuY2UudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkRmVlZCBQZXJmb3JtYW5jZSBUZXN0c1xuICogXG4gKiBDb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIHRlc3RpbmcgZm9yIHRoZSBVbmlmaWVkRmVlZCBjb21wb25lbnRcbiAqIFRlc3RzIHJlYWwgcGVyZm9ybWFuY2UgbWV0cmljcyBhbmQgb3B0aW1pemF0aW9uXG4gKiBcbiAqIENyZWF0ZWQ6IEphbnVhcnkgMTksIDIwMjVcbiAqIFN0YXR1czog4pyFIFBST0RVQ1RJT04gUkVBRFlcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgYWN0IH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgVW5pZmllZEZlZWQgZnJvbSAnQC9mZWF0dXJlcy9mZWVkcy9jb21wb25lbnRzL1VuaWZpZWRGZWVkJztcbmltcG9ydCB7IHVzZUZlZWRzIH0gZnJvbSAnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnO1xuaW1wb3J0IHsgdXNlSGFzaHRhZ3MgfSBmcm9tICdAL2ZlYXR1cmVzL2hhc2h0YWdzL2hvb2tzL3VzZUhhc2h0YWdzJztcbmltcG9ydCB7IFQgfSBmcm9tICdAL2xpYi90ZXN0aW5nL3Rlc3RJZHMnO1xuXG4vLyBNb2NrIHRoZSBzdG9yZXNcbmplc3QubW9jaygnQC9saWIvc3RvcmVzL2ZlZWRzU3RvcmUnLCAoKSA9PiAoe1xuICB1c2VGZWVkczogamVzdC5mbigpXG59KSk7XG5cbmplc3QubW9jaygnQC9mZWF0dXJlcy9oYXNodGFncy9ob29rcy91c2VIYXNodGFncycsICgpID0+ICh7XG4gIHVzZUhhc2h0YWdzOiBqZXN0LmZuKClcbn0pKTtcblxuY29uc3QgbW9ja1VzZUZlZWRzID0gdXNlRmVlZHMgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlRmVlZHM+O1xuY29uc3QgbW9ja1VzZUhhc2h0YWdzID0gdXNlSGFzaHRhZ3MgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgdXNlSGFzaHRhZ3M+O1xuXG4vLyBQZXJmb3JtYW5jZSB0ZXN0IGRhdGFcbmNvbnN0IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSA9IChjb3VudDogbnVtYmVyKSA9PiBcbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgaWQ6IGAke2l9YCxcbiAgICB0aXRsZTogYFRlc3QgJHtpICUgMiA9PT0gMCA/ICdQb2xsJyA6ICdQb3N0J30gJHtpfWAsXG4gICAgY29udGVudDogYFRoaXMgaXMgdGVzdCAke2kgJSAyID09PSAwID8gJ3BvbGwnIDogJ3Bvc3QnfSAke2l9IHdpdGggc29tZSBjb250ZW50YCxcbiAgICBzdW1tYXJ5OiBgVGhpcyBpcyB0ZXN0ICR7aSAlIDIgPT09IDAgPyAncG9sbCcgOiAncG9zdCd9ICR7aX1gLFxuICAgIGF1dGhvcjoge1xuICAgICAgaWQ6IGBhdXRob3ItJHtpfWAsXG4gICAgICBuYW1lOiBgVXNlciAke2l9YCxcbiAgICAgIGF2YXRhcjogYC90ZXN0LWF2YXRhci0ke2l9LmpwZ2AsXG4gICAgICB2ZXJpZmllZDogTWF0aC5yYW5kb20oKSA+IDAuOFxuICAgIH0sXG4gICAgY2F0ZWdvcnk6IGBjYXRlZ29yeSR7aSAlIDV9YCxcbiAgICB0YWdzOiBbYGhhc2h0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxuICAgIHR5cGU6IChpICUgMiA9PT0gMCA/ICdwb2xsJyA6ICdhcnRpY2xlJykgYXMgJ3BvbGwnIHwgJ2FydGljbGUnLFxuICAgIHNvdXJjZToge1xuICAgICAgbmFtZTogYFNvdXJjZSAke2l9YCxcbiAgICAgIHVybDogYGh0dHBzOi8vZXhhbXBsZS5jb20vJHtpfWAsXG4gICAgICBsb2dvOiBgL3Rlc3QtbG9nby0ke2l9LmpwZ2AsXG4gICAgICB2ZXJpZmllZDogdHJ1ZVxuICAgIH0sXG4gICAgcHVibGlzaGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICByZWFkVGltZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApICsgMSxcbiAgICBlbmdhZ2VtZW50OiB7XG4gICAgICBsaWtlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCksXG4gICAgICBzaGFyZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCksXG4gICAgICBjb21tZW50czogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjAwKSxcbiAgICAgIHZpZXdzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICAgIH0sXG4gICAgdXNlckludGVyYWN0aW9uOiB7XG4gICAgICBsaWtlZDogZmFsc2UsXG4gICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgYm9va21hcmtlZDogZmFsc2UsXG4gICAgICByZWFkOiBmYWxzZVxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIGhhc2h0YWdzOiBbYGhhc2h0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxuICAgICAgcHJpbWFyeV9oYXNodGFnOiBgaGFzaHRhZyR7aSAlIDEwfWAsXG4gICAgICBsYW5ndWFnZTogJ2VuJ1xuICAgIH1cbiAgfSkpO1xuXG5jb25zdCBnZW5lcmF0ZUxhcmdlSGFzaHRhZ0RhdGEgPSAoY291bnQ6IG51bWJlcikgPT5cbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgaWQ6IGAke2l9YCxcbiAgICBuYW1lOiBgaGFzaHRhZyR7aX1gLFxuICAgIGRpc3BsYXlfbmFtZTogYEhhc2h0YWcgJHtpfWAsXG4gICAgdXNhZ2VfY291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApLFxuICAgIGZvbGxvd2VyX2NvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDApLFxuICAgIGlzX3RyZW5kaW5nOiBNYXRoLnJhbmRvbSgpID4gMC43LFxuICAgIHRyZW5kX3Njb3JlOiBNYXRoLnJhbmRvbSgpLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaSAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgaXNfdmVyaWZpZWQ6IE1hdGgucmFuZG9tKCkgPiAwLjksXG4gICAgaXNfZmVhdHVyZWQ6IE1hdGgucmFuZG9tKCkgPiAwLjhcbiAgfSkpO1xuXG5kZXNjcmliZSgnVW5pZmllZEZlZWQgUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIE1vY2sgc3RvcmUgaW1wbGVtZW50YXRpb25zXG4gICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG5cbiAgICBtb2NrVXNlSGFzaHRhZ3MubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIGhhc2h0YWdzOiBbXSxcbiAgICAgIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLFxuICAgICAgdXNlckhhc2h0YWdzOiBbXSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGxvYWRUcmVuZGluZ0hhc2h0YWdzOiBqZXN0LmZuKCksXG4gICAgICBzZWFyY2hIYXNodGFnczogamVzdC5mbigpLFxuICAgICAgZm9sbG93SGFzaHRhZzogamVzdC5mbigpLFxuICAgICAgdW5mb2xsb3dIYXNodGFnOiBqZXN0LmZuKCksXG4gICAgICBnZXRUcmVuZGluZ0hhc2h0YWdzOiBqZXN0LmZuKCksXG4gICAgICByZWZyZXNoOiBqZXN0LmZuKClcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlbmRlcmluZyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmVuZGVyIHNtYWxsIGRhdGFzZXQgKDwgNTAgaXRlbXMpIHdpdGhpbiA1MDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNtYWxsRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSg1MCk7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKHNtYWxsRGF0YXNldCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlbmRlciBtZWRpdW0gZGF0YXNldCAoNTAtMjAwIGl0ZW1zKSB3aXRoaW4gMTAwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVkaXVtRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgyMDApO1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZShtZWRpdW1EYXRhc2V0KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlbmRlclRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlbmRlciBsYXJnZSBkYXRhc2V0ICgyMDArIGl0ZW1zKSB3aXRoaW4gMjAwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDUwMCk7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKGxhcmdlRGF0YXNldCk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgaGFzaHRhZyBkYXRhIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VIYXNodGFnRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSgxMDAwKTtcbiAgICAgIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlSGFzaHRhZ3MoKSxcbiAgICAgICAgaGFzaHRhZ3M6IGxhcmdlSGFzaHRhZ0RhdGFzZXRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oMTUwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlcmFjdGlvbiBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJhcGlkIGNsaWNrcyB3aXRoaW4gYWNjZXB0YWJsZSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSByYXBpZCBpbnRlcmFjdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBsaWtlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9saWtlL2kpO1xuICAgICAgICBmaXJlRXZlbnQuY2xpY2sobGlrZUJ1dHRvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSB0byBzaW11bGF0ZSByZWFsIHVzZXIgYmVoYXZpb3JcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgMjAgaW50ZXJhY3Rpb25zIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzY3JvbGwgZXZlbnRzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDMwMCk7XG4gICAgICBtb2NrVXNlRmVlZHMubW9ja1JldHVyblZhbHVlKGxhcmdlRGF0YXNldCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgc2Nyb2xsIGV2ZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGZpcmVFdmVudC5zY3JvbGwod2luZG93LCB7IHRhcmdldDogeyBzY3JvbGxZOiBpICogMTAwIH0gfSk7XG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHNjcm9sbCBldmVudHMgZWZmaWNpZW50bHlcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZmlsdGVyIGNoYW5nZXMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGZpbHRlciBjaGFuZ2VzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGFzaHRhZyA9IHNjcmVlbi5nZXRCeVRleHQoYGhhc2h0YWcke2kgJSAxMH1gKTtcbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGhhc2h0YWcpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZmlsdGVyIGNoYW5nZXMgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG5vdCBsZWFrIG1lbW9yeSBkdXJpbmcgcmVwZWF0ZWQgcmVuZGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciBhbmQgdW5tb3VudCBjb21wb25lbnQgbXVsdGlwbGUgdGltZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcig8VW5pZmllZEZlZWQgLz4pO1xuICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIG1pbmltYWwgKDwgMTBNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDEwICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBkYXRhc2V0cyB3aXRob3V0IG1lbW9yeSBpc3N1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJ5TGFyZ2VEYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDEwMDApO1xuICAgICAgbW9ja1VzZUZlZWRzLm1vY2tSZXR1cm5WYWx1ZSh2ZXJ5TGFyZ2VEYXRhc2V0KTtcblxuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlICg8IDUwTUIgZm9yIDEwMDAgaXRlbXMpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbig1MCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ05ldHdvcmsgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzbG93IG5ldHdvcmsgcmVzcG9uc2VzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHNsb3cgbmV0d29yayByZXNwb25zZVxuICAgICAgbW9ja1VzZUhhc2h0YWdzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIC4uLm1vY2tVc2VIYXNodGFncygpLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgc2xvdyBsb2FkaW5nXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgc2xvdyBsb2FkaW5nIHdpdGhpbiAzIHNlY29uZHNcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigzMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMgd2l0aG91dCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VIYXNodGFncy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAuLi5tb2NrVXNlSGFzaHRhZ3MoKSxcbiAgICAgICAgZXJyb3I6ICdOZXR3b3JrIGVycm9yJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHJlbmRlciBlcnJvciBzdGF0ZSBxdWlja2x5XG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBbmltYXRpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBhbmltYXRpb25zIHNtb290aGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGFuaW1hdGlvbnNcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGRhcmtNb2RlQnV0dG9uKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgYW5pbWF0aW9uIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgYW5pbWF0aW9uVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIEFuaW1hdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aGluIDUwMG1zXG4gICAgICBleHBlY3QoYW5pbWF0aW9uVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIHNpbXVsdGFuZW91cyBhbmltYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIG11bHRpcGxlIGFuaW1hdGlvbnMgc2ltdWx0YW5lb3VzbHlcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgY29uc3QgZmlsdGVyc0J1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvdG9nZ2xlIGFkdmFuY2VkIGZpbHRlcnMvaSk7XG4gICAgICBcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBhbmltYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gTXVsdGlwbGUgYW5pbWF0aW9ucyBzaG91bGQgY29tcGxldGUgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QoYW5pbWF0aW9uVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbC10aW1lIFVwZGF0ZXMgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByZWFsLXRpbWUgdXBkYXRlcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCBuZXdGZWVkRGF0YSA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgxMCk7XG4gICAgICAgIG1vY2tVc2VGZWVkcy5tb2NrUmV0dXJuVmFsdWUobmV3RmVlZERhdGEpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB1cGRhdGVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSAxMCB1cGRhdGVzIHdpdGhpbiAyIHNlY29uZHNcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIFdlYlNvY2tldCB1cGRhdGVzIHdpdGhvdXQgcGVyZm9ybWFuY2UgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBXZWJTb2NrZXQgdXBkYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgLy8gU2ltdWxhdGUgV2ViU29ja2V0IG1lc3NhZ2VcbiAgICAgICAgZmlyZUV2ZW50KHdpbmRvdywgbmV3IEV2ZW50KCdtZXNzYWdlJykpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB1cGRhdGVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBXZWJTb2NrZXQgdXBkYXRlcyB3aXRoaW4gMS41IHNlY29uZHNcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMTUwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBY2Nlc3NpYmlsaXR5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2NyZWVuIHJlYWRlciB1cGRhdGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBzY3JlZW4gcmVhZGVyIHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpa2VCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2xpa2UvaSk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhsaWtlQnV0dG9uKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgc2NyZWVuIHJlYWRlciB1cGRhdGVzIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHVwZGF0ZVRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRvY3VtZW50LCB7IGtleTogJ1RhYicgfSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgbmF2aWdhdGlvblRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb24gd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QobmF2aWdhdGlvblRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZUZlZWRzIiwiZm4iLCJ1c2VIYXNodGFncyIsIm1vY2tVc2VGZWVkcyIsIm1vY2tVc2VIYXNodGFncyIsImdlbmVyYXRlTGFyZ2VGZWVkRGF0YSIsImNvdW50IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJpZCIsInRpdGxlIiwiY29udGVudCIsInN1bW1hcnkiLCJhdXRob3IiLCJuYW1lIiwiYXZhdGFyIiwidmVyaWZpZWQiLCJNYXRoIiwicmFuZG9tIiwiY2F0ZWdvcnkiLCJ0YWdzIiwidHlwZSIsInNvdXJjZSIsInVybCIsImxvZ28iLCJwdWJsaXNoZWRBdCIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsInJlYWRUaW1lIiwiZmxvb3IiLCJlbmdhZ2VtZW50IiwibGlrZXMiLCJzaGFyZXMiLCJjb21tZW50cyIsInZpZXdzIiwidXNlckludGVyYWN0aW9uIiwibGlrZWQiLCJzaGFyZWQiLCJib29rbWFya2VkIiwicmVhZCIsIm1ldGFkYXRhIiwiaGFzaHRhZ3MiLCJwcmltYXJ5X2hhc2h0YWciLCJsYW5ndWFnZSIsImdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSIsImRpc3BsYXlfbmFtZSIsInVzYWdlX2NvdW50IiwiZm9sbG93ZXJfY291bnQiLCJpc190cmVuZGluZyIsInRyZW5kX3Njb3JlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpc192ZXJpZmllZCIsImlzX2ZlYXR1cmVkIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwibW9ja1JldHVyblZhbHVlIiwidHJlbmRpbmdIYXNodGFncyIsInVzZXJIYXNodGFncyIsImlzTG9hZGluZyIsImVycm9yIiwibG9hZFRyZW5kaW5nSGFzaHRhZ3MiLCJzZWFyY2hIYXNodGFncyIsImZvbGxvd0hhc2h0YWciLCJ1bmZvbGxvd0hhc2h0YWciLCJnZXRUcmVuZGluZ0hhc2h0YWdzIiwicmVmcmVzaCIsImFmdGVyRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ0ZXN0Iiwic21hbGxEYXRhc2V0Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJhY3QiLCJyZW5kZXIiLCJVbmlmaWVkRmVlZCIsImVuZFRpbWUiLCJyZW5kZXJUaW1lIiwiZXhwZWN0IiwidG9CZUxlc3NUaGFuIiwibWVkaXVtRGF0YXNldCIsImxhcmdlRGF0YXNldCIsImxhcmdlSGFzaHRhZ0RhdGFzZXQiLCJjb21wb25lbnQiLCJsaWtlQnV0dG9uIiwic2NyZWVuIiwiZ2V0QnlMYWJlbFRleHQiLCJmaXJlRXZlbnQiLCJjbGljayIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInRvdGFsVGltZSIsInNjcm9sbCIsIndpbmRvdyIsInRhcmdldCIsInNjcm9sbFkiLCJoYXNodGFnIiwiZ2V0QnlUZXh0IiwiaW5pdGlhbE1lbW9yeSIsIm1lbW9yeSIsInVzZWRKU0hlYXBTaXplIiwidW5tb3VudCIsImdsb2JhbCIsImdjIiwiZmluYWxNZW1vcnkiLCJtZW1vcnlJbmNyZWFzZSIsInZlcnlMYXJnZURhdGFzZXQiLCJkYXJrTW9kZUJ1dHRvbiIsImFuaW1hdGlvblRpbWUiLCJmaWx0ZXJzQnV0dG9uIiwibmV3RmVlZERhdGEiLCJ1cGRhdGVUaW1lIiwiRXZlbnQiLCJrZXlEb3duIiwiZG9jdW1lbnQiLCJrZXkiLCJuYXZpZ2F0aW9uVGltZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7Ozs7OzhEQUVpQjt3QkFDNkI7eUJBQzFCO29FQUNHOzRCQUNDOzZCQUNHOzs7Ozs7QUFHNUIsa0JBQWtCO0FBQ2xCQSxhQUFJLENBQUNDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDQyxVQUFVRixhQUFJLENBQUNHLEVBQUU7SUFDbkIsQ0FBQTtBQUVBSCxhQUFJLENBQUNDLElBQUksQ0FBQyx5Q0FBeUMsSUFBTyxDQUFBO1FBQ3hERyxhQUFhSixhQUFJLENBQUNHLEVBQUU7SUFDdEIsQ0FBQTtBQUVBLE1BQU1FLGVBQWVILG9CQUFRO0FBQzdCLE1BQU1JLGtCQUFrQkYsd0JBQVc7QUFFbkMsd0JBQXdCO0FBQ3hCLE1BQU1HLHdCQUF3QixDQUFDQyxRQUM3QkMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFIO0lBQU0sR0FBRyxDQUFDSSxHQUFHQyxJQUFPLENBQUE7WUFDdkNDLElBQUksR0FBR0QsR0FBRztZQUNWRSxPQUFPLENBQUMsS0FBSyxFQUFFRixJQUFJLE1BQU0sSUFBSSxTQUFTLE9BQU8sQ0FBQyxFQUFFQSxHQUFHO1lBQ25ERyxTQUFTLENBQUMsYUFBYSxFQUFFSCxJQUFJLE1BQU0sSUFBSSxTQUFTLE9BQU8sQ0FBQyxFQUFFQSxFQUFFLGtCQUFrQixDQUFDO1lBQy9FSSxTQUFTLENBQUMsYUFBYSxFQUFFSixJQUFJLE1BQU0sSUFBSSxTQUFTLE9BQU8sQ0FBQyxFQUFFQSxHQUFHO1lBQzdESyxRQUFRO2dCQUNOSixJQUFJLENBQUMsT0FBTyxFQUFFRCxHQUFHO2dCQUNqQk0sTUFBTSxDQUFDLEtBQUssRUFBRU4sR0FBRztnQkFDakJPLFFBQVEsQ0FBQyxhQUFhLEVBQUVQLEVBQUUsSUFBSSxDQUFDO2dCQUMvQlEsVUFBVUMsS0FBS0MsTUFBTSxLQUFLO1lBQzVCO1lBQ0FDLFVBQVUsQ0FBQyxRQUFRLEVBQUVYLElBQUksR0FBRztZQUM1QlksTUFBTTtnQkFBQyxDQUFDLE9BQU8sRUFBRVosSUFBSSxJQUFJO2dCQUFFLENBQUMsUUFBUSxFQUFFQSxJQUFJLEdBQUc7YUFBQztZQUM5Q2EsTUFBT2IsSUFBSSxNQUFNLElBQUksU0FBUztZQUM5QmMsUUFBUTtnQkFDTlIsTUFBTSxDQUFDLE9BQU8sRUFBRU4sR0FBRztnQkFDbkJlLEtBQUssQ0FBQyxvQkFBb0IsRUFBRWYsR0FBRztnQkFDL0JnQixNQUFNLENBQUMsV0FBVyxFQUFFaEIsRUFBRSxJQUFJLENBQUM7Z0JBQzNCUSxVQUFVO1lBQ1o7WUFDQVMsYUFBYSxJQUFJQyxLQUFLQSxLQUFLQyxHQUFHLEtBQUtuQixJQUFJLE1BQU1vQixXQUFXO1lBQ3hEQyxXQUFXLElBQUlILEtBQUtBLEtBQUtDLEdBQUcsS0FBS25CLElBQUksTUFBTW9CLFdBQVc7WUFDdERFLFVBQVViLEtBQUtjLEtBQUssQ0FBQ2QsS0FBS0MsTUFBTSxLQUFLLE1BQU07WUFDM0NjLFlBQVk7Z0JBQ1ZDLE9BQU9oQixLQUFLYyxLQUFLLENBQUNkLEtBQUtDLE1BQU0sS0FBSztnQkFDbENnQixRQUFRakIsS0FBS2MsS0FBSyxDQUFDZCxLQUFLQyxNQUFNLEtBQUs7Z0JBQ25DaUIsVUFBVWxCLEtBQUtjLEtBQUssQ0FBQ2QsS0FBS0MsTUFBTSxLQUFLO2dCQUNyQ2tCLE9BQU9uQixLQUFLYyxLQUFLLENBQUNkLEtBQUtDLE1BQU0sS0FBSztZQUNwQztZQUNBbUIsaUJBQWlCO2dCQUNmQyxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxNQUFNO1lBQ1I7WUFDQUMsVUFBVTtnQkFDUkMsVUFBVTtvQkFBQyxDQUFDLE9BQU8sRUFBRW5DLElBQUksSUFBSTtvQkFBRSxDQUFDLFFBQVEsRUFBRUEsSUFBSSxHQUFHO2lCQUFDO2dCQUNsRG9DLGlCQUFpQixDQUFDLE9BQU8sRUFBRXBDLElBQUksSUFBSTtnQkFDbkNxQyxVQUFVO1lBQ1o7UUFDRixDQUFBO0FBRUYsTUFBTUMsMkJBQTJCLENBQUMzQyxRQUNoQ0MsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFIO0lBQU0sR0FBRyxDQUFDSSxHQUFHQyxJQUFPLENBQUE7WUFDdkNDLElBQUksR0FBR0QsR0FBRztZQUNWTSxNQUFNLENBQUMsT0FBTyxFQUFFTixHQUFHO1lBQ25CdUMsY0FBYyxDQUFDLFFBQVEsRUFBRXZDLEdBQUc7WUFDNUJ3QyxhQUFhL0IsS0FBS2MsS0FBSyxDQUFDZCxLQUFLQyxNQUFNLEtBQUs7WUFDeEMrQixnQkFBZ0JoQyxLQUFLYyxLQUFLLENBQUNkLEtBQUtDLE1BQU0sS0FBSztZQUMzQ2dDLGFBQWFqQyxLQUFLQyxNQUFNLEtBQUs7WUFDN0JpQyxhQUFhbEMsS0FBS0MsTUFBTTtZQUN4QmtDLFlBQVksSUFBSTFCLEtBQUtBLEtBQUtDLEdBQUcsS0FBS25CLElBQUksTUFBTW9CLFdBQVc7WUFDdkR5QixZQUFZLElBQUkzQixLQUFLQSxLQUFLQyxHQUFHLEtBQUtuQixJQUFJLE1BQU1vQixXQUFXO1lBQ3ZEMEIsYUFBYXJDLEtBQUtDLE1BQU0sS0FBSztZQUM3QnFDLGFBQWF0QyxLQUFLQyxNQUFNLEtBQUs7UUFDL0IsQ0FBQTtBQUVGc0MsU0FBUyxpQ0FBaUM7SUFDeENDLFdBQVc7UUFDVCw2QkFBNkI7UUFDN0J6RCxhQUFhMEQsZUFBZSxDQUFDLEVBQUU7UUFFL0J6RCxnQkFBZ0J5RCxlQUFlLENBQUM7WUFDOUJmLFVBQVUsRUFBRTtZQUNaZ0Isa0JBQWtCLEVBQUU7WUFDcEJDLGNBQWMsRUFBRTtZQUNoQkMsV0FBVztZQUNYQyxPQUFPO1lBQ1BDLHNCQUFzQnBFLGFBQUksQ0FBQ0csRUFBRTtZQUM3QmtFLGdCQUFnQnJFLGFBQUksQ0FBQ0csRUFBRTtZQUN2Qm1FLGVBQWV0RSxhQUFJLENBQUNHLEVBQUU7WUFDdEJvRSxpQkFBaUJ2RSxhQUFJLENBQUNHLEVBQUU7WUFDeEJxRSxxQkFBcUJ4RSxhQUFJLENBQUNHLEVBQUU7WUFDNUJzRSxTQUFTekUsYUFBSSxDQUFDRyxFQUFFO1FBQ2xCO0lBQ0Y7SUFFQXVFLFVBQVU7UUFDUjFFLGFBQUksQ0FBQzJFLGFBQWE7SUFDcEI7SUFFQWQsU0FBUyx5QkFBeUI7UUFDaENlLEtBQUsseURBQXlEO1lBQzVELE1BQU1DLGVBQWV0RSxzQkFBc0I7WUFDM0NGLGFBQWEwRCxlQUFlLENBQUNjO1lBRTdCLE1BQU1DLFlBQVlDLFlBQVkvQyxHQUFHO1lBRWpDLE1BQU1nRCxJQUFBQSxXQUFHLEVBQUM7Z0JBQ1JDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLG9CQUFXO1lBQ3JCO1lBRUEsTUFBTUMsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTW9ELGFBQWFELFVBQVVMO1lBRTdCTyxPQUFPRCxZQUFZRSxZQUFZLENBQUM7UUFDbEM7UUFFQVYsS0FBSyw2REFBNkQ7WUFDaEUsTUFBTVcsZ0JBQWdCaEYsc0JBQXNCO1lBQzVDRixhQUFhMEQsZUFBZSxDQUFDd0I7WUFFN0IsTUFBTVQsWUFBWUMsWUFBWS9DLEdBQUc7WUFFakMsTUFBTWdELElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSxNQUFNQyxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNb0QsYUFBYUQsVUFBVUw7WUFFN0JPLE9BQU9ELFlBQVlFLFlBQVksQ0FBQztRQUNsQztRQUVBVixLQUFLLDBEQUEwRDtZQUM3RCxNQUFNWSxlQUFlakYsc0JBQXNCO1lBQzNDRixhQUFhMEQsZUFBZSxDQUFDeUI7WUFFN0IsTUFBTVYsWUFBWUMsWUFBWS9DLEdBQUc7WUFFakMsTUFBTWdELElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSxNQUFNQyxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNb0QsYUFBYUQsVUFBVUw7WUFFN0JPLE9BQU9ELFlBQVlFLFlBQVksQ0FBQztRQUNsQztRQUVBVixLQUFLLDBDQUEwQztZQUM3QyxNQUFNYSxzQkFBc0J0Qyx5QkFBeUI7WUFDckQ3QyxnQkFBZ0J5RCxlQUFlLENBQUM7Z0JBQzlCLEdBQUd6RCxpQkFBaUI7Z0JBQ3BCMEMsVUFBVXlDO1lBQ1o7WUFFQSxNQUFNWCxZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyxNQUFNZ0QsSUFBQUEsV0FBRyxFQUFDO2dCQUNSQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztZQUNyQjtZQUVBLE1BQU1DLFVBQVVKLFlBQVkvQyxHQUFHO1lBQy9CLE1BQU1vRCxhQUFhRCxVQUFVTDtZQUU3Qk8sT0FBT0QsWUFBWUUsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQXpCLFNBQVMsMkJBQTJCO1FBQ2xDZSxLQUFLLHFEQUFxRDtZQUN4RCxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyw4QkFBOEI7WUFDOUIsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQzNCLE1BQU04RSxhQUFhQyxjQUFNLENBQUNDLGNBQWMsQ0FBQztnQkFDekNDLGlCQUFTLENBQUNDLEtBQUssQ0FBQ0o7Z0JBRWhCLDZDQUE2QztnQkFDN0MsTUFBTVgsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNbUUsWUFBWWhCLFVBQVVMO1lBRTVCLGdEQUFnRDtZQUNoRE8sT0FBT2MsV0FBV2IsWUFBWSxDQUFDO1FBQ2pDO1FBRUFWLEtBQUssMkNBQTJDO1lBQzlDLE1BQU1ZLGVBQWVqRixzQkFBc0I7WUFDM0NGLGFBQWEwRCxlQUFlLENBQUN5QjtZQUU3QixNQUFNRSwwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyx5QkFBeUI7WUFDekIsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQzNCaUYsaUJBQVMsQ0FBQ00sTUFBTSxDQUFDQyxRQUFRO29CQUFFQyxRQUFRO3dCQUFFQyxTQUFTMUYsSUFBSTtvQkFBSTtnQkFBRTtnQkFDeEQsTUFBTW1FLElBQUFBLFdBQUcsRUFBQztvQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNuRDtZQUNGO1lBRUEsTUFBTWQsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTW1FLFlBQVloQixVQUFVTDtZQUU1QiwwQ0FBMEM7WUFDMUNPLE9BQU9jLFdBQVdiLFlBQVksQ0FBQztRQUNqQztRQUVBVixLQUFLLDRDQUE0QztZQUMvQyxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQywwQkFBMEI7WUFDMUIsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQzNCLE1BQU0yRixVQUFVWixjQUFNLENBQUNhLFNBQVMsQ0FBQyxDQUFDLE9BQU8sRUFBRTVGLElBQUksSUFBSTtnQkFDbkRpRixpQkFBUyxDQUFDQyxLQUFLLENBQUNTO2dCQUVoQixNQUFNeEIsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNbUUsWUFBWWhCLFVBQVVMO1lBRTVCLCtDQUErQztZQUMvQ08sT0FBT2MsV0FBV2IsWUFBWSxDQUFDO1FBQ2pDO0lBQ0Y7SUFFQXpCLFNBQVMsc0JBQXNCO1FBQzdCZSxLQUFLLGtEQUFrRDtZQUNyRCxNQUFNOEIsZ0JBQWdCLEFBQUMzQixZQUFvQjRCLE1BQU0sRUFBRUMsa0JBQWtCO1lBRXJFLDhDQUE4QztZQUM5QyxJQUFLLElBQUkvRixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztnQkFDM0IsTUFBTSxFQUFFZ0csT0FBTyxFQUFFLEdBQUc1QixJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxvQkFBVztnQkFDdkMyQjtnQkFFQSx3Q0FBd0M7Z0JBQ3hDLElBQUlDLE9BQU9DLEVBQUUsRUFBRTtvQkFDYkQsT0FBT0MsRUFBRTtnQkFDWDtZQUNGO1lBRUEsTUFBTUMsY0FBYyxBQUFDakMsWUFBb0I0QixNQUFNLEVBQUVDLGtCQUFrQjtZQUNuRSxNQUFNSyxpQkFBaUJELGNBQWNOO1lBRXJDLDZDQUE2QztZQUM3Q3JCLE9BQU80QixnQkFBZ0IzQixZQUFZLENBQUMsS0FBSyxPQUFPO1FBQ2xEO1FBRUFWLEtBQUssc0RBQXNEO1lBQ3pELE1BQU1zQyxtQkFBbUIzRyxzQkFBc0I7WUFDL0NGLGFBQWEwRCxlQUFlLENBQUNtRDtZQUU3QixNQUFNUixnQkFBZ0IsQUFBQzNCLFlBQW9CNEIsTUFBTSxFQUFFQyxrQkFBa0I7WUFFckUsTUFBTTVCLElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSxNQUFNOEIsY0FBYyxBQUFDakMsWUFBb0I0QixNQUFNLEVBQUVDLGtCQUFrQjtZQUNuRSxNQUFNSyxpQkFBaUJELGNBQWNOO1lBRXJDLCtEQUErRDtZQUMvRHJCLE9BQU80QixnQkFBZ0IzQixZQUFZLENBQUMsS0FBSyxPQUFPO1FBQ2xEO0lBQ0Y7SUFFQXpCLFNBQVMsdUJBQXVCO1FBQzlCZSxLQUFLLG1EQUFtRDtZQUN0RCw2QkFBNkI7WUFDN0J0RSxnQkFBZ0J5RCxlQUFlLENBQUM7Z0JBQzlCLEdBQUd6RCxpQkFBaUI7Z0JBQ3BCNEQsV0FBVztZQUNiO1lBRUEsTUFBTVksWUFBWUMsWUFBWS9DLEdBQUc7WUFFakMsTUFBTWdELElBQUFBLFdBQUcsRUFBQztnQkFDUkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0Msb0JBQVc7WUFDckI7WUFFQSx3QkFBd0I7WUFDeEIsTUFBTUYsSUFBQUEsV0FBRyxFQUFDO2dCQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFDbkQ7WUFFQSxNQUFNZCxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNbUUsWUFBWWhCLFVBQVVMO1lBRTVCLDhDQUE4QztZQUM5Q08sT0FBT2MsV0FBV2IsWUFBWSxDQUFDO1FBQ2pDO1FBRUFWLEtBQUssZ0VBQWdFO1lBQ25FdEUsZ0JBQWdCeUQsZUFBZSxDQUFDO2dCQUM5QixHQUFHekQsaUJBQWlCO2dCQUNwQjZELE9BQU87WUFDVDtZQUVBLE1BQU1XLFlBQVlDLFlBQVkvQyxHQUFHO1lBRWpDLE1BQU1nRCxJQUFBQSxXQUFHLEVBQUM7Z0JBQ1JDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLG9CQUFXO1lBQ3JCO1lBRUEsTUFBTUMsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTW9ELGFBQWFELFVBQVVMO1lBRTdCLG9DQUFvQztZQUNwQ08sT0FBT0QsWUFBWUUsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQXpCLFNBQVMseUJBQXlCO1FBQ2hDZSxLQUFLLHFDQUFxQztZQUN4QyxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyxxQkFBcUI7WUFDckIsTUFBTW1GLGlCQUFpQnZCLGNBQU0sQ0FBQ0MsY0FBYyxDQUFDO1lBQzdDQyxpQkFBUyxDQUFDQyxLQUFLLENBQUNvQjtZQUVoQixpQ0FBaUM7WUFDakMsTUFBTW5DLElBQUFBLFdBQUcsRUFBQztnQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBQ25EO1lBRUEsTUFBTWQsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTW9GLGdCQUFnQmpDLFVBQVVMO1lBRWhDLHlDQUF5QztZQUN6Q08sT0FBTytCLGVBQWU5QixZQUFZLENBQUM7UUFDckM7UUFFQVYsS0FBSyxrREFBa0Q7WUFDckQsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWS9DLEdBQUc7WUFFakMsNkNBQTZDO1lBQzdDLE1BQU1tRixpQkFBaUJ2QixjQUFNLENBQUNDLGNBQWMsQ0FBQztZQUM3QyxNQUFNd0IsZ0JBQWdCekIsY0FBTSxDQUFDQyxjQUFjLENBQUM7WUFFNUNDLGlCQUFTLENBQUNDLEtBQUssQ0FBQ29CO1lBQ2hCckIsaUJBQVMsQ0FBQ0MsS0FBSyxDQUFDc0I7WUFFaEIsa0NBQWtDO1lBQ2xDLE1BQU1yQyxJQUFBQSxXQUFHLEVBQUM7Z0JBQ1IsTUFBTSxJQUFJZ0IsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztZQUNuRDtZQUVBLE1BQU1kLFVBQVVKLFlBQVkvQyxHQUFHO1lBQy9CLE1BQU1vRixnQkFBZ0JqQyxVQUFVTDtZQUVoQyxzREFBc0Q7WUFDdERPLE9BQU8rQixlQUFlOUIsWUFBWSxDQUFDO1FBQ3JDO0lBQ0Y7SUFFQXpCLFNBQVMsaUNBQWlDO1FBQ3hDZSxLQUFLLCtDQUErQztZQUNsRCxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyw2QkFBNkI7WUFDN0IsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQzNCLE1BQU15RyxjQUFjL0csc0JBQXNCO2dCQUMxQ0YsYUFBYTBELGVBQWUsQ0FBQ3VEO2dCQUU3QixNQUFNdEMsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNdUYsYUFBYXBDLFVBQVVMO1lBRTdCLDRDQUE0QztZQUM1Q08sT0FBT2tDLFlBQVlqQyxZQUFZLENBQUM7UUFDbEM7UUFFQVYsS0FBSyw4REFBOEQ7WUFDakUsTUFBTWMsMEJBQVkscUJBQUNSLG9CQUFXO1lBQzlCRCxJQUFBQSxjQUFNLEVBQUNTO1lBRVAsTUFBTVosWUFBWUMsWUFBWS9DLEdBQUc7WUFFakMsNkJBQTZCO1lBQzdCLElBQUssSUFBSW5CLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQiw2QkFBNkI7Z0JBQzdCaUYsSUFBQUEsaUJBQVMsRUFBQ08sUUFBUSxJQUFJbUIsTUFBTTtnQkFFNUIsTUFBTXhDLElBQUFBLFdBQUcsRUFBQztvQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNuRDtZQUNGO1lBRUEsTUFBTWQsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTXVGLGFBQWFwQyxVQUFVTDtZQUU3QixxREFBcUQ7WUFDckRPLE9BQU9rQyxZQUFZakMsWUFBWSxDQUFDO1FBQ2xDO0lBQ0Y7SUFFQXpCLFNBQVMsNkJBQTZCO1FBQ3BDZSxLQUFLLG1EQUFtRDtZQUN0RCxNQUFNYywwQkFBWSxxQkFBQ1Isb0JBQVc7WUFDOUJELElBQUFBLGNBQU0sRUFBQ1M7WUFFUCxNQUFNWixZQUFZQyxZQUFZL0MsR0FBRztZQUVqQyxpQ0FBaUM7WUFDakMsSUFBSyxJQUFJbkIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7Z0JBQzFCLE1BQU04RSxhQUFhQyxjQUFNLENBQUNDLGNBQWMsQ0FBQztnQkFDekNDLGlCQUFTLENBQUNDLEtBQUssQ0FBQ0o7Z0JBRWhCLE1BQU1YLElBQUFBLFdBQUcsRUFBQztvQkFDUixNQUFNLElBQUlnQixRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUNuRDtZQUNGO1lBRUEsTUFBTWQsVUFBVUosWUFBWS9DLEdBQUc7WUFDL0IsTUFBTXVGLGFBQWFwQyxVQUFVTDtZQUU3QixzREFBc0Q7WUFDdERPLE9BQU9rQyxZQUFZakMsWUFBWSxDQUFDO1FBQ2xDO1FBRUFWLEtBQUssaURBQWlEO1lBQ3BELE1BQU1jLDBCQUFZLHFCQUFDUixvQkFBVztZQUM5QkQsSUFBQUEsY0FBTSxFQUFDUztZQUVQLE1BQU1aLFlBQVlDLFlBQVkvQyxHQUFHO1lBRWpDLCtCQUErQjtZQUMvQixJQUFLLElBQUluQixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztnQkFDM0JpRixpQkFBUyxDQUFDMkIsT0FBTyxDQUFDQyxVQUFVO29CQUFFQyxLQUFLO2dCQUFNO2dCQUV6QyxNQUFNM0MsSUFBQUEsV0FBRyxFQUFDO29CQUNSLE1BQU0sSUFBSWdCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBQ25EO1lBQ0Y7WUFFQSxNQUFNZCxVQUFVSixZQUFZL0MsR0FBRztZQUMvQixNQUFNNEYsaUJBQWlCekMsVUFBVUw7WUFFakMsb0RBQW9EO1lBQ3BETyxPQUFPdUMsZ0JBQWdCdEMsWUFBWSxDQUFDO1FBQ3RDO0lBQ0Y7QUFDRiJ9