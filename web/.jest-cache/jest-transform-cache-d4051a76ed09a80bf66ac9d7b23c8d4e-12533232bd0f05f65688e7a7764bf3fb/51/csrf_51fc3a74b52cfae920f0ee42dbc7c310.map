{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/utils/csrf.ts"],"sourcesContent":["// CSRF (Cross-Site Request Forgery) protection utilities\nimport crypto from 'crypto';\n\n/**\n * Generate a CSRF token\n */\nexport function generateCSRFToken(): string {\n  return crypto.randomBytes(32).toString('hex');\n}\n\n/**\n * Validate a CSRF token\n */\nexport function validateCSRFToken(token: string, sessionToken: string): boolean {\n  if (!token || !sessionToken) {\n    return false;\n  }\n  \n  // Simple comparison for now - in production, use proper CSRF validation\n  return token === sessionToken;\n}\n\n/**\n * Generate a CSRF token for a session\n */\nexport function generateSessionCSRFToken(sessionId: string): string {\n  const secret = process.env.CSRF_SECRET ?? 'default-csrf-secret';\n  return crypto.createHmac('sha256', secret).update(sessionId).digest('hex');\n}\n\n/**\n * Validate CSRF token against session\n */\nexport function validateSessionCSRFToken(token: string, sessionId: string): boolean {\n  if (!token || !sessionId) {\n    return false;\n  }\n  \n  const expectedToken = generateSessionCSRFToken(sessionId);\n  return token === expectedToken;\n}\n"],"names":["generateCSRFToken","generateSessionCSRFToken","validateCSRFToken","validateSessionCSRFToken","crypto","randomBytes","toString","token","sessionToken","sessionId","secret","process","env","CSRF_SECRET","createHmac","update","digest","expectedToken"],"mappings":"AAAA,yDAAyD;;;;;;;;;;;;QAMzCA;eAAAA;;QAmBAC;eAAAA;;QAZAC;eAAAA;;QAoBAC;eAAAA;;;+DAhCG;;;;;;AAKZ,SAASH;IACd,OAAOI,eAAM,CAACC,WAAW,CAAC,IAAIC,QAAQ,CAAC;AACzC;AAKO,SAASJ,kBAAkBK,KAAa,EAAEC,YAAoB;IACnE,IAAI,CAACD,SAAS,CAACC,cAAc;QAC3B,OAAO;IACT;IAEA,wEAAwE;IACxE,OAAOD,UAAUC;AACnB;AAKO,SAASP,yBAAyBQ,SAAiB;IACxD,MAAMC,SAASC,QAAQC,GAAG,CAACC,WAAW,IAAI;IAC1C,OAAOT,eAAM,CAACU,UAAU,CAAC,UAAUJ,QAAQK,MAAM,CAACN,WAAWO,MAAM,CAAC;AACtE;AAKO,SAASb,yBAAyBI,KAAa,EAAEE,SAAiB;IACvE,IAAI,CAACF,SAAS,CAACE,WAAW;QACxB,OAAO;IACT;IAEA,MAAMQ,gBAAgBhB,yBAAyBQ;IAC/C,OAAOF,UAAUU;AACnB"}