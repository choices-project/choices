fd9dea1a7082dce1f053f0a90a41735c
/**
 * Comprehensive Authentication System Tests
 * 
 * Tests the authentication system including WebAuthn, 
 * session management, and security features
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _serveractions = require("../../../../../lib/core/auth/server-actions");
const _authtestutils = require("../../../helpers/auth-test-utils");
// Mock external dependencies
_globals.jest.mock('@/lib/utils/logger', ()=>({
        devLog: _globals.jest.fn(),
        logger: {
            info: _globals.jest.fn(),
            error: _globals.jest.fn(),
            warn: _globals.jest.fn()
        }
    }));
_globals.jest.mock('@/lib/utils/rate-limit', ()=>({
        checkRateLimit: _globals.jest.fn().mockImplementation((key)=>{
            // Mock rate limiting behavior based on test context
            if (key && key.includes('rate-limit-test')) {
                return Promise.resolve({
                    allowed: false,
                    remaining: 0
                });
            }
            return Promise.resolve({
                allowed: true,
                remaining: 10
            });
        })
    }));
_globals.jest.mock('@/lib/utils/csrf', ()=>({
        validateCSRFToken: _globals.jest.fn().mockImplementation((token)=>{
            // Mock CSRF validation behavior based on test context
            if (token === 'invalid-csrf-token') {
                return Promise.resolve(false);
            }
            return Promise.resolve(true);
        })
    }));
// Mock the actual server action implementation
_globals.jest.mock('@/lib/core/auth/server-actions', ()=>({
        createSecureServerAction: _globals.jest.fn().mockImplementation((handler, options)=>{
            return async (data, context)=>{
                // Mock authentication check
                if (options?.requireAuth && !context?.user) {
                    throw new Error('Authentication required');
                }
                // Mock rate limiting check
                if (options?.rateLimit) {
                    const { checkRateLimit } = require('@/lib/utils/rate-limit');
                    const rateLimitResult = await checkRateLimit('rate-limit-test');
                    if (!rateLimitResult.allowed) {
                        throw new Error('Rate limit exceeded');
                    }
                }
                // Mock CSRF protection check
                if (options?.csrfProtection) {
                    const { validateCSRFToken } = require('@/lib/utils/csrf');
                    const csrfValid = await validateCSRFToken('invalid-csrf-token');
                    if (!csrfValid) {
                        throw new Error('CSRF token validation failed');
                    }
                }
                // Mock missing context check
                if (!context) {
                    throw new Error('Server action context is required');
                }
                // Mock invalid input check
                if (!data) {
                    throw new Error('Invalid input');
                }
                // Transform context to match real implementation behavior
                const transformedContext = {
                    ipAddress: context.ipAddress || context.ip || 'unknown',
                    userAgent: context.userAgent || 'unknown'
                };
                return await handler(data, transformedContext);
            };
        })
    }));
(0, _globals.describe)('Authentication System', ()=>{
    let mockContext;
    let mockOptions;
    (0, _globals.beforeEach)(()=>{
        mockContext = (0, _authtestutils.createAuthMockContext)();
        mockOptions = {
            requireAuth: true,
            rateLimit: {
                maxRequests: 10,
                windowMs: 60000
            },
            csrfProtection: true
        };
    });
    (0, _globals.describe)('Secure Server Actions', ()=>{
        (0, _globals.it)('should create secure server action with authentication', async ()=>{
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            const result = await secureAction({
                test: 'data'
            }, mockContext);
            (0, _globals.expect)(result.success).toBe(true);
            (0, _globals.expect)(mockAction).toHaveBeenCalledWith({
                test: 'data'
            }, {
                ipAddress: '192.168.1.1',
                userAgent: 'Mozilla/5.0 (Test Browser)'
            });
        });
        (0, _globals.it)('should handle authentication failures', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Authentication failed'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Authentication failed');
        });
        (0, _globals.it)('should enforce rate limiting', async ()=>{
            const { checkRateLimit } = require('@/lib/utils/rate-limit');
            checkRateLimit.mockResolvedValueOnce({
                allowed: false,
                remaining: 0
            });
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Rate limit exceeded');
        });
        (0, _globals.it)('should enforce CSRF protection', async ()=>{
            const { validateCSRFToken } = require('@/lib/utils/csrf');
            validateCSRFToken.mockResolvedValueOnce(false);
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('CSRF token validation failed');
        });
        (0, _globals.it)('should handle missing context gracefully', async ()=>{
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, null)).rejects.toThrow('Server action context is required');
        });
        (0, _globals.it)('should validate input data', async ()=>{
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, {
                ...mockOptions,
                inputValidation: (input)=>{
                    if (!input || typeof input !== 'object') {
                        throw new Error('Invalid input');
                    }
                    return true;
                }
            });
            await (0, _globals.expect)(secureAction(null, mockContext)).rejects.toThrow('Invalid input');
        });
        (0, _globals.it)('should handle server action errors gracefully', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Database connection failed'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Database connection failed');
        });
    });
    (0, _globals.describe)('WebAuthn Integration', ()=>{
        (0, _globals.it)('should handle WebAuthn registration', async ()=>{
            const mockWebAuthnAction = _globals.jest.fn().mockResolvedValue({
                credentialId: 'test-credential-id',
                publicKey: 'test-public-key'
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockWebAuthnAction, mockOptions);
            const result = await secureAction({
                credential: {
                    id: 'test-credential-id',
                    response: {
                        clientDataJSON: 'test-data',
                        attestationObject: 'test-attestation'
                    }
                }
            }, mockContext);
            (0, _globals.expect)(result.credentialId).toBe('test-credential-id');
            (0, _globals.expect)(mockWebAuthnAction).toHaveBeenCalled();
        });
        (0, _globals.it)('should handle WebAuthn authentication', async ()=>{
            const mockWebAuthnAction = _globals.jest.fn().mockResolvedValue({
                verified: true,
                userId: 'test-user-id'
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockWebAuthnAction, mockOptions);
            const result = await secureAction({
                credential: {
                    id: 'test-credential-id',
                    response: {
                        clientDataJSON: 'test-data',
                        authenticatorData: 'test-auth-data',
                        signature: 'test-signature'
                    }
                }
            }, mockContext);
            (0, _globals.expect)(result.verified).toBe(true);
            (0, _globals.expect)(result.userId).toBe('test-user-id');
        });
        (0, _globals.it)('should handle WebAuthn errors', async ()=>{
            const mockWebAuthnAction = _globals.jest.fn().mockRejectedValue(new Error('WebAuthn verification failed'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockWebAuthnAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                credential: {
                    id: 'test-credential-id',
                    response: {}
                }
            }, mockContext)).rejects.toThrow('WebAuthn verification failed');
        });
    });
    (0, _globals.describe)('Session Management', ()=>{
        (0, _globals.it)('should handle session creation', async ()=>{
            const mockSessionAction = _globals.jest.fn().mockResolvedValue({
                sessionId: 'new-session-id',
                expiresAt: new Date(Date.now() + 86400000)
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSessionAction, mockOptions);
            const result = await secureAction({
                userId: 'test-user-id',
                deviceInfo: {
                    userAgent: 'Mozilla/5.0',
                    ipAddress: '192.168.1.1'
                }
            }, mockContext);
            (0, _globals.expect)(result.sessionId).toBe('new-session-id');
            (0, _globals.expect)(result.expiresAt).toBeDefined();
        });
        (0, _globals.it)('should handle session validation', async ()=>{
            const mockSessionAction = _globals.jest.fn().mockResolvedValue({
                valid: true,
                userId: 'test-user-id',
                expiresAt: new Date(Date.now() + 86400000)
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSessionAction, mockOptions);
            const result = await secureAction({
                sessionId: 'test-session-id'
            }, mockContext);
            (0, _globals.expect)(result.valid).toBe(true);
            (0, _globals.expect)(result.userId).toBe('test-user-id');
        });
        (0, _globals.it)('should handle session expiration', async ()=>{
            const mockSessionAction = _globals.jest.fn().mockResolvedValue({
                valid: false,
                reason: 'Session expired'
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSessionAction, mockOptions);
            const result = await secureAction({
                sessionId: 'expired-session-id'
            }, mockContext);
            (0, _globals.expect)(result.valid).toBe(false);
            (0, _globals.expect)(result.reason).toBe('Session expired');
        });
        (0, _globals.it)('should handle session revocation', async ()=>{
            const mockSessionAction = _globals.jest.fn().mockResolvedValue({
                revoked: true,
                reason: 'User requested logout'
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSessionAction, mockOptions);
            const result = await secureAction({
                sessionId: 'test-session-id',
                action: 'revoke'
            }, mockContext);
            (0, _globals.expect)(result.revoked).toBe(true);
            (0, _globals.expect)(result.reason).toBe('User requested logout');
        });
    });
    (0, _globals.describe)('Security Features', ()=>{
        (0, _globals.it)('should validate IP addresses', async ()=>{
            const mockSecurityAction = _globals.jest.fn().mockResolvedValue({
                allowed: true,
                riskScore: 0.1
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSecurityAction, {
                ...mockOptions,
                ipValidation: true
            });
            const result = await secureAction({
                ipAddress: '192.168.1.1'
            }, mockContext);
            (0, _globals.expect)(result.allowed).toBe(true);
            (0, _globals.expect)(result.riskScore).toBeLessThan(0.5);
        });
        (0, _globals.it)('should detect suspicious activity', async ()=>{
            const mockSecurityAction = _globals.jest.fn().mockResolvedValue({
                allowed: false,
                reason: 'Suspicious activity detected',
                riskScore: 0.9
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSecurityAction, mockOptions);
            const result = await secureAction({
                ipAddress: '192.168.1.1',
                userAgent: 'Suspicious Bot'
            }, mockContext);
            (0, _globals.expect)(result.allowed).toBe(false);
            (0, _globals.expect)(result.riskScore).toBeGreaterThan(0.8);
        });
        (0, _globals.it)('should handle brute force protection', async ()=>{
            const mockSecurityAction = _globals.jest.fn().mockResolvedValue({
                allowed: false,
                reason: 'Too many failed attempts',
                lockoutDuration: 300000 // 5 minutes
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockSecurityAction, mockOptions);
            const result = await secureAction({
                username: 'test-user',
                password: 'wrong-password'
            }, mockContext);
            (0, _globals.expect)(result.allowed).toBe(false);
            (0, _globals.expect)(result.lockoutDuration).toBeGreaterThan(0);
        });
        (0, _globals.it)('should validate user permissions', async ()=>{
            const mockPermissionAction = _globals.jest.fn().mockResolvedValue({
                authorized: true,
                permissions: [
                    'read',
                    'write'
                ]
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockPermissionAction, {
                ...mockOptions,
                requiredPermissions: [
                    'read'
                ]
            });
            const result = await secureAction({
                resource: 'user-data',
                action: 'read'
            }, mockContext);
            (0, _globals.expect)(result.authorized).toBe(true);
            (0, _globals.expect)(result.permissions).toContain('read');
        });
    });
    (0, _globals.describe)('Error Handling', ()=>{
        (0, _globals.it)('should handle network errors gracefully', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Network timeout'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Network timeout');
        });
        (0, _globals.it)('should handle database errors gracefully', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Database connection lost'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Database connection lost');
        });
        (0, _globals.it)('should handle validation errors', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Invalid email format'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, {
                ...mockOptions,
                inputValidation: (input)=>{
                    if (!input.email || !input.email.includes('@')) {
                        throw new Error('Invalid email format');
                    }
                    return true;
                }
            });
            await (0, _globals.expect)(secureAction({
                email: 'invalid-email'
            }, mockContext)).rejects.toThrow('Invalid email format');
        });
        (0, _globals.it)('should handle concurrent request conflicts', async ()=>{
            const mockAction = _globals.jest.fn().mockRejectedValue(new Error('Concurrent modification detected'));
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            await (0, _globals.expect)(secureAction({
                test: 'data'
            }, mockContext)).rejects.toThrow('Concurrent modification detected');
        });
    });
    (0, _globals.describe)('Performance', ()=>{
        (0, _globals.it)('should handle high load efficiently', async ()=>{
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            const startTime = performance.now();
            // Simulate multiple concurrent requests
            const promises = Array.from({
                length: 100
            }, (_, i)=>secureAction({
                    test: `data-${i}`
                }, {
                    ...mockContext,
                    userId: `user-${i}`
                }));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            (0, _globals.expect)(results).toHaveLength(100);
            (0, _globals.expect)(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
        });
        (0, _globals.it)('should handle memory efficiently', async ()=>{
            const mockAction = _globals.jest.fn().mockResolvedValue({
                success: true
            });
            const secureAction = (0, _serveractions.createSecureServerAction)(mockAction, mockOptions);
            const initialMemory = process.memoryUsage().heapUsed;
            // Process many requests
            for(let i = 0; i < 1000; i++){
                await secureAction({
                    test: `data-${i}`
                }, {
                    ...mockContext,
                    userId: `user-${i}`
                });
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (less than 100MB)
            (0, _globals.expect)(memoryIncrease).toBeLessThan(100 * 1024 * 1024);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvbGliL2NvcmUvYXV0aC1jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wcmVoZW5zaXZlIEF1dGhlbnRpY2F0aW9uIFN5c3RlbSBUZXN0c1xuICogXG4gKiBUZXN0cyB0aGUgYXV0aGVudGljYXRpb24gc3lzdGVtIGluY2x1ZGluZyBXZWJBdXRobiwgXG4gKiBzZXNzaW9uIG1hbmFnZW1lbnQsIGFuZCBzZWN1cml0eSBmZWF0dXJlc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscydcbmltcG9ydCB7IGNyZWF0ZVNlY3VyZVNlcnZlckFjdGlvbiB9IGZyb20gJ0AvbGliL2NvcmUvYXV0aC9zZXJ2ZXItYWN0aW9ucydcbmltcG9ydCB0eXBlIHsgU2VydmVyQWN0aW9uQ29udGV4dCwgU2VydmVyQWN0aW9uT3B0aW9ucyB9IGZyb20gJ0AvbGliL2NvcmUvYXV0aC9zZXJ2ZXItYWN0aW9ucydcbmltcG9ydCB7IFxuICBjcmVhdGVBdXRoTW9ja0NvbnRleHQsIFxuICBtb2NrUmF0ZUxpbWl0aW5nLCBcbiAgbW9ja0NTUkZQcm90ZWN0aW9uXG59IGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvYXV0aC10ZXN0LXV0aWxzJ1xuXG4vLyBNb2NrIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdAL2xpYi91dGlscy9sb2dnZXInLCAoKSA9PiAoe1xuICBkZXZMb2c6IGplc3QuZm4oKSxcbiAgbG9nZ2VyOiB7XG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpXG4gIH1cbn0pKVxuXG5qZXN0Lm1vY2soJ0AvbGliL3V0aWxzL3JhdGUtbGltaXQnLCAoKSA9PiAoe1xuICBjaGVja1JhdGVMaW1pdDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5KSA9PiB7XG4gICAgLy8gTW9jayByYXRlIGxpbWl0aW5nIGJlaGF2aW9yIGJhc2VkIG9uIHRlc3QgY29udGV4dFxuICAgIGlmIChrZXkgJiYga2V5LmluY2x1ZGVzKCdyYXRlLWxpbWl0LXRlc3QnKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGFsbG93ZWQ6IGZhbHNlLCByZW1haW5pbmc6IDAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGFsbG93ZWQ6IHRydWUsIHJlbWFpbmluZzogMTAgfSlcbiAgfSlcbn0pKVxuXG5qZXN0Lm1vY2soJ0AvbGliL3V0aWxzL2NzcmYnLCAoKSA9PiAoe1xuICB2YWxpZGF0ZUNTUkZUb2tlbjogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigodG9rZW4pID0+IHtcbiAgICAvLyBNb2NrIENTUkYgdmFsaWRhdGlvbiBiZWhhdmlvciBiYXNlZCBvbiB0ZXN0IGNvbnRleHRcbiAgICBpZiAodG9rZW4gPT09ICdpbnZhbGlkLWNzcmYtdG9rZW4nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gIH0pXG59KSlcblxuLy8gTW9jayB0aGUgYWN0dWFsIHNlcnZlciBhY3Rpb24gaW1wbGVtZW50YXRpb25cbmplc3QubW9jaygnQC9saWIvY29yZS9hdXRoL3NlcnZlci1hY3Rpb25zJywgKCkgPT4gKHtcbiAgY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChoYW5kbGVyLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jIChkYXRhOiBhbnksIGNvbnRleHQ6IGFueSkgPT4ge1xuICAgICAgLy8gTW9jayBhdXRoZW50aWNhdGlvbiBjaGVja1xuICAgICAgaWYgKG9wdGlvbnM/LnJlcXVpcmVBdXRoICYmICFjb250ZXh0Py51c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gcmVxdWlyZWQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRpbmcgY2hlY2tcbiAgICAgIGlmIChvcHRpb25zPy5yYXRlTGltaXQpIHtcbiAgICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvdXRpbHMvcmF0ZS1saW1pdCcpXG4gICAgICAgIGNvbnN0IHJhdGVMaW1pdFJlc3VsdCA9IGF3YWl0IGNoZWNrUmF0ZUxpbWl0KCdyYXRlLWxpbWl0LXRlc3QnKVxuICAgICAgICBpZiAoIXJhdGVMaW1pdFJlc3VsdC5hbGxvd2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRlIGxpbWl0IGV4Y2VlZGVkJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNb2NrIENTUkYgcHJvdGVjdGlvbiBjaGVja1xuICAgICAgaWYgKG9wdGlvbnM/LmNzcmZQcm90ZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsaWRhdGVDU1JGVG9rZW4gfSA9IHJlcXVpcmUoJ0AvbGliL3V0aWxzL2NzcmYnKVxuICAgICAgICBjb25zdCBjc3JmVmFsaWQgPSBhd2FpdCB2YWxpZGF0ZUNTUkZUb2tlbignaW52YWxpZC1jc3JmLXRva2VuJylcbiAgICAgICAgaWYgKCFjc3JmVmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTUkYgdG9rZW4gdmFsaWRhdGlvbiBmYWlsZWQnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1vY2sgbWlzc2luZyBjb250ZXh0IGNoZWNrXG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgYWN0aW9uIGNvbnRleHQgaXMgcmVxdWlyZWQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNb2NrIGludmFsaWQgaW5wdXQgY2hlY2tcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcmFuc2Zvcm0gY29udGV4dCB0byBtYXRjaCByZWFsIGltcGxlbWVudGF0aW9uIGJlaGF2aW9yXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZENvbnRleHQgPSB7XG4gICAgICAgIGlwQWRkcmVzczogY29udGV4dC5pcEFkZHJlc3MgfHwgY29udGV4dC5pcCB8fCAndW5rbm93bicsXG4gICAgICAgIHVzZXJBZ2VudDogY29udGV4dC51c2VyQWdlbnQgfHwgJ3Vua25vd24nXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVyKGRhdGEsIHRyYW5zZm9ybWVkQ29udGV4dClcbiAgICB9XG4gIH0pXG59KSlcblxuZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uIFN5c3RlbScsICgpID0+IHtcbiAgbGV0IG1vY2tDb250ZXh0OiBTZXJ2ZXJBY3Rpb25Db250ZXh0XG4gIGxldCBtb2NrT3B0aW9uczogU2VydmVyQWN0aW9uT3B0aW9uc1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDb250ZXh0ID0gY3JlYXRlQXV0aE1vY2tDb250ZXh0KClcbiAgICBtb2NrT3B0aW9ucyA9IHtcbiAgICAgIHJlcXVpcmVBdXRoOiB0cnVlLFxuICAgICAgcmF0ZUxpbWl0OiB7XG4gICAgICAgIG1heFJlcXVlc3RzOiAxMCxcbiAgICAgICAgd2luZG93TXM6IDYwMDAwXG4gICAgICB9LFxuICAgICAgY3NyZlByb3RlY3Rpb246IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1NlY3VyZSBTZXJ2ZXIgQWN0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBzZWN1cmUgc2VydmVyIGFjdGlvbiB3aXRoIGF1dGhlbnRpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cmVBY3Rpb24oeyB0ZXN0OiAnZGF0YScgfSwgbW9ja0NvbnRleHQpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KG1vY2tBY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgdGVzdDogJ2RhdGEnIH0sIHtcbiAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoVGVzdCBCcm93c2VyKSdcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1dGhlbnRpY2F0aW9uIGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpKVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja0FjdGlvbiwgbW9ja09wdGlvbnMpXG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChzZWN1cmVBY3Rpb24oeyB0ZXN0OiAnZGF0YScgfSwgbW9ja0NvbnRleHQpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgcmF0ZSBsaW1pdGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3V0aWxzL3JhdGUtbGltaXQnKVxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYWxsb3dlZDogZmFsc2UsIHJlbWFpbmluZzogMCB9KVxuICAgICAgXG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3Qoc2VjdXJlQWN0aW9uKHsgdGVzdDogJ2RhdGEnIH0sIG1vY2tDb250ZXh0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnUmF0ZSBsaW1pdCBleGNlZWRlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZW5mb3JjZSBDU1JGIHByb3RlY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbGlkYXRlQ1NSRlRva2VuIH0gPSByZXF1aXJlKCdAL2xpYi91dGlscy9jc3JmJylcbiAgICAgIHZhbGlkYXRlQ1NSRlRva2VuLm1vY2tSZXNvbHZlZFZhbHVlT25jZShmYWxzZSlcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICAgIGNvbnN0IHNlY3VyZUFjdGlvbiA9IGNyZWF0ZVNlY3VyZVNlcnZlckFjdGlvbihtb2NrQWN0aW9uLCBtb2NrT3B0aW9ucylcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHNlY3VyZUFjdGlvbih7IHRlc3Q6ICdkYXRhJyB9LCBtb2NrQ29udGV4dCkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0NTUkYgdG9rZW4gdmFsaWRhdGlvbiBmYWlsZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIGNvbnRleHQgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja0FjdGlvbiwgbW9ja09wdGlvbnMpXG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChzZWN1cmVBY3Rpb24oeyB0ZXN0OiAnZGF0YScgfSwgbnVsbCBhcyBhbnkpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdTZXJ2ZXIgYWN0aW9uIGNvbnRleHQgaXMgcmVxdWlyZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGlucHV0IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIHtcbiAgICAgICAgLi4ubW9ja09wdGlvbnMsXG4gICAgICAgIGlucHV0VmFsaWRhdGlvbjogKGlucHV0KSA9PiB7XG4gICAgICAgICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3Qoc2VjdXJlQWN0aW9uKG51bGwsIG1vY2tDb250ZXh0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBpbnB1dCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZlciBhY3Rpb24gZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3Qoc2VjdXJlQWN0aW9uKHsgdGVzdDogJ2RhdGEnIH0sIG1vY2tDb250ZXh0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1dlYkF1dGhuIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXZWJBdXRobkFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGNyZWRlbnRpYWxJZDogJ3Rlc3QtY3JlZGVudGlhbC1pZCcsXG4gICAgICAgIHB1YmxpY0tleTogJ3Rlc3QtcHVibGljLWtleSdcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHNlY3VyZUFjdGlvbiA9IGNyZWF0ZVNlY3VyZVNlcnZlckFjdGlvbihtb2NrV2ViQXV0aG5BY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cmVBY3Rpb24oe1xuICAgICAgICBjcmVkZW50aWFsOiB7XG4gICAgICAgICAgaWQ6ICd0ZXN0LWNyZWRlbnRpYWwtaWQnLFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBjbGllbnREYXRhSlNPTjogJ3Rlc3QtZGF0YScsXG4gICAgICAgICAgICBhdHRlc3RhdGlvbk9iamVjdDogJ3Rlc3QtYXR0ZXN0YXRpb24nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBtb2NrQ29udGV4dClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jcmVkZW50aWFsSWQpLnRvQmUoJ3Rlc3QtY3JlZGVudGlhbC1pZCcpXG4gICAgICBleHBlY3QobW9ja1dlYkF1dGhuQWN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgV2ViQXV0aG4gYXV0aGVudGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrV2ViQXV0aG5BY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgdXNlcklkOiAndGVzdC11c2VyLWlkJ1xuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tXZWJBdXRobkFjdGlvbiwgbW9ja09wdGlvbnMpXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlY3VyZUFjdGlvbih7XG4gICAgICAgIGNyZWRlbnRpYWw6IHtcbiAgICAgICAgICBpZDogJ3Rlc3QtY3JlZGVudGlhbC1pZCcsXG4gICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiAndGVzdC1kYXRhJyxcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiAndGVzdC1hdXRoLWRhdGEnLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiAndGVzdC1zaWduYXR1cmUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBtb2NrQ29udGV4dClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52ZXJpZmllZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VySWQpLnRvQmUoJ3Rlc3QtdXNlci1pZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIFdlYkF1dGhuIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tXZWJBdXRobkFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1dlYkF1dGhuIHZlcmlmaWNhdGlvbiBmYWlsZWQnKSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tXZWJBdXRobkFjdGlvbiwgbW9ja09wdGlvbnMpXG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChzZWN1cmVBY3Rpb24oe1xuICAgICAgICBjcmVkZW50aWFsOiB7XG4gICAgICAgICAgaWQ6ICd0ZXN0LWNyZWRlbnRpYWwtaWQnLFxuICAgICAgICAgIHJlc3BvbnNlOiB7fVxuICAgICAgICB9XG4gICAgICB9LCBtb2NrQ29udGV4dCkpLnJlamVjdHMudG9UaHJvdygnV2ViQXV0aG4gdmVyaWZpY2F0aW9uIGZhaWxlZCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnU2Vzc2lvbiBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlc3Npb24gY3JlYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2Vzc2lvbkFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHNlc3Npb25JZDogJ25ldy1zZXNzaW9uLWlkJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgODY0MDAwMDApXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja1Nlc3Npb25BY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cmVBY3Rpb24oe1xuICAgICAgICB1c2VySWQ6ICd0ZXN0LXVzZXItaWQnLFxuICAgICAgICBkZXZpY2VJbmZvOiB7XG4gICAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAnLFxuICAgICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJ1xuICAgICAgICB9XG4gICAgICB9LCBtb2NrQ29udGV4dClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zZXNzaW9uSWQpLnRvQmUoJ25ldy1zZXNzaW9uLWlkJylcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhwaXJlc0F0KS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlc3Npb24gdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXNzaW9uQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIHVzZXJJZDogJ3Rlc3QtdXNlci1pZCcsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDg2NDAwMDAwKVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tTZXNzaW9uQWN0aW9uLCBtb2NrT3B0aW9ucylcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VjdXJlQWN0aW9uKHtcbiAgICAgICAgc2Vzc2lvbklkOiAndGVzdC1zZXNzaW9uLWlkJ1xuICAgICAgfSwgbW9ja0NvbnRleHQpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd0ZXN0LXVzZXItaWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXNzaW9uIGV4cGlyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2Vzc2lvbkFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnU2Vzc2lvbiBleHBpcmVkJ1xuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tTZXNzaW9uQWN0aW9uLCBtb2NrT3B0aW9ucylcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VjdXJlQWN0aW9uKHtcbiAgICAgICAgc2Vzc2lvbklkOiAnZXhwaXJlZC1zZXNzaW9uLWlkJ1xuICAgICAgfSwgbW9ja0NvbnRleHQpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzdWx0LnJlYXNvbikudG9CZSgnU2Vzc2lvbiBleHBpcmVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2Vzc2lvbiByZXZvY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Nlc3Npb25BY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICByZXZva2VkOiB0cnVlLFxuICAgICAgICByZWFzb246ICdVc2VyIHJlcXVlc3RlZCBsb2dvdXQnXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja1Nlc3Npb25BY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cmVBY3Rpb24oe1xuICAgICAgICBzZXNzaW9uSWQ6ICd0ZXN0LXNlc3Npb24taWQnLFxuICAgICAgICBhY3Rpb246ICdyZXZva2UnXG4gICAgICB9LCBtb2NrQ29udGV4dClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5yZXZva2VkKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzdWx0LnJlYXNvbikudG9CZSgnVXNlciByZXF1ZXN0ZWQgbG9nb3V0JylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBGZWF0dXJlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIElQIGFkZHJlc3NlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZWN1cml0eUFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGFsbG93ZWQ6IHRydWUsXG4gICAgICAgIHJpc2tTY29yZTogMC4xXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja1NlY3VyaXR5QWN0aW9uLCB7XG4gICAgICAgIC4uLm1vY2tPcHRpb25zLFxuICAgICAgICBpcFZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlY3VyZUFjdGlvbih7XG4gICAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJ1xuICAgICAgfSwgbW9ja0NvbnRleHQpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5yaXNrU2NvcmUpLnRvQmVMZXNzVGhhbigwLjUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IHN1c3BpY2lvdXMgYWN0aXZpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2VjdXJpdHlBY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBhbGxvd2VkOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnU3VzcGljaW91cyBhY3Rpdml0eSBkZXRlY3RlZCcsXG4gICAgICAgIHJpc2tTY29yZTogMC45XG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja1NlY3VyaXR5QWN0aW9uLCBtb2NrT3B0aW9ucylcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VjdXJlQWN0aW9uKHtcbiAgICAgICAgaXBBZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdTdXNwaWNpb3VzIEJvdCdcbiAgICAgIH0sIG1vY2tDb250ZXh0KVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzdWx0LnJpc2tTY29yZSkudG9CZUdyZWF0ZXJUaGFuKDAuOClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYnJ1dGUgZm9yY2UgcHJvdGVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZWN1cml0eUFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGFsbG93ZWQ6IGZhbHNlLFxuICAgICAgICByZWFzb246ICdUb28gbWFueSBmYWlsZWQgYXR0ZW1wdHMnLFxuICAgICAgICBsb2Nrb3V0RHVyYXRpb246IDMwMDAwMCAvLyA1IG1pbnV0ZXNcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHNlY3VyZUFjdGlvbiA9IGNyZWF0ZVNlY3VyZVNlcnZlckFjdGlvbihtb2NrU2VjdXJpdHlBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN1cmVBY3Rpb24oe1xuICAgICAgICB1c2VybmFtZTogJ3Rlc3QtdXNlcicsXG4gICAgICAgIHBhc3N3b3JkOiAnd3JvbmctcGFzc3dvcmQnXG4gICAgICB9LCBtb2NrQ29udGV4dClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5hbGxvd2VkKS50b0JlKGZhbHNlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5sb2Nrb3V0RHVyYXRpb24pLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHVzZXIgcGVybWlzc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGVybWlzc2lvbkFjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGF1dGhvcml6ZWQ6IHRydWUsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWQnLCAnd3JpdGUnXVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tQZXJtaXNzaW9uQWN0aW9uLCB7XG4gICAgICAgIC4uLm1vY2tPcHRpb25zLFxuICAgICAgICByZXF1aXJlZFBlcm1pc3Npb25zOiBbJ3JlYWQnXVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VjdXJlQWN0aW9uKHtcbiAgICAgICAgcmVzb3VyY2U6ICd1c2VyLWRhdGEnLFxuICAgICAgICBhY3Rpb246ICdyZWFkJ1xuICAgICAgfSwgbW9ja0NvbnRleHQpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuYXV0aG9yaXplZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5wZXJtaXNzaW9ucykudG9Db250YWluKCdyZWFkJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ05ldHdvcmsgdGltZW91dCcpKVxuICAgICAgXG4gICAgICBjb25zdCBzZWN1cmVBY3Rpb24gPSBjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24obW9ja0FjdGlvbiwgbW9ja09wdGlvbnMpXG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChzZWN1cmVBY3Rpb24oeyB0ZXN0OiAnZGF0YScgfSwgbW9ja0NvbnRleHQpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdOZXR3b3JrIHRpbWVvdXQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBY3Rpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3Qoc2VjdXJlQWN0aW9uKHsgdGVzdDogJ2RhdGEnIH0sIG1vY2tDb250ZXh0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBsb3N0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignSW52YWxpZCBlbWFpbCBmb3JtYXQnKSlcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIHtcbiAgICAgICAgLi4ubW9ja09wdGlvbnMsXG4gICAgICAgIGlucHV0VmFsaWRhdGlvbjogKGlucHV0KSA9PiB7XG4gICAgICAgICAgaWYgKCFpbnB1dC5lbWFpbCB8fCAhaW5wdXQuZW1haWwuaW5jbHVkZXMoJ0AnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVtYWlsIGZvcm1hdCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChzZWN1cmVBY3Rpb24oeyBlbWFpbDogJ2ludmFsaWQtZW1haWwnIH0sIG1vY2tDb250ZXh0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBlbWFpbCBmb3JtYXQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3QgY29uZmxpY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0NvbmN1cnJlbnQgbW9kaWZpY2F0aW9uIGRldGVjdGVkJykpXG4gICAgICBcbiAgICAgIGNvbnN0IHNlY3VyZUFjdGlvbiA9IGNyZWF0ZVNlY3VyZVNlcnZlckFjdGlvbihtb2NrQWN0aW9uLCBtb2NrT3B0aW9ucylcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHNlY3VyZUFjdGlvbih7IHRlc3Q6ICdkYXRhJyB9LCBtb2NrQ29udGV4dCkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0NvbmN1cnJlbnQgbW9kaWZpY2F0aW9uIGRldGVjdGVkJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBoaWdoIGxvYWQgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBtdWx0aXBsZSBjb25jdXJyZW50IHJlcXVlc3RzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gXG4gICAgICAgIHNlY3VyZUFjdGlvbih7IHRlc3Q6IGBkYXRhLSR7aX1gIH0sIHsgLi4ubW9ja0NvbnRleHQsIHVzZXJJZDogYHVzZXItJHtpfWAgfSlcbiAgICAgIClcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKVxuICAgICAgZXhwZWN0KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKSAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDUgc2Vjb25kc1xuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZW1vcnkgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgY29uc3Qgc2VjdXJlQWN0aW9uID0gY3JlYXRlU2VjdXJlU2VydmVyQWN0aW9uKG1vY2tBY3Rpb24sIG1vY2tPcHRpb25zKVxuICAgICAgXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkXG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgbWFueSByZXF1ZXN0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgc2VjdXJlQWN0aW9uKHsgdGVzdDogYGRhdGEtJHtpfWAgfSwgeyAuLi5tb2NrQ29udGV4dCwgdXNlcklkOiBgdXNlci0ke2l9YCB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZFxuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnlcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlIChsZXNzIHRoYW4gMTAwTUIpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMDAgKiAxMDI0ICogMTAyNClcbiAgICB9KVxuICB9KVxufSlcblxuXG5cblxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZGV2TG9nIiwiZm4iLCJsb2dnZXIiLCJpbmZvIiwiZXJyb3IiLCJ3YXJuIiwiY2hlY2tSYXRlTGltaXQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJrZXkiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWxsb3dlZCIsInJlbWFpbmluZyIsInZhbGlkYXRlQ1NSRlRva2VuIiwidG9rZW4iLCJjcmVhdGVTZWN1cmVTZXJ2ZXJBY3Rpb24iLCJoYW5kbGVyIiwib3B0aW9ucyIsImRhdGEiLCJjb250ZXh0IiwicmVxdWlyZUF1dGgiLCJ1c2VyIiwiRXJyb3IiLCJyYXRlTGltaXQiLCJyZXF1aXJlIiwicmF0ZUxpbWl0UmVzdWx0IiwiY3NyZlByb3RlY3Rpb24iLCJjc3JmVmFsaWQiLCJ0cmFuc2Zvcm1lZENvbnRleHQiLCJpcEFkZHJlc3MiLCJpcCIsInVzZXJBZ2VudCIsImRlc2NyaWJlIiwibW9ja0NvbnRleHQiLCJtb2NrT3B0aW9ucyIsImJlZm9yZUVhY2giLCJjcmVhdGVBdXRoTW9ja0NvbnRleHQiLCJtYXhSZXF1ZXN0cyIsIndpbmRvd01zIiwiaXQiLCJtb2NrQWN0aW9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzdWNjZXNzIiwic2VjdXJlQWN0aW9uIiwicmVzdWx0IiwidGVzdCIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tSZWplY3RlZFZhbHVlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJpbnB1dFZhbGlkYXRpb24iLCJpbnB1dCIsIm1vY2tXZWJBdXRobkFjdGlvbiIsImNyZWRlbnRpYWxJZCIsInB1YmxpY0tleSIsImNyZWRlbnRpYWwiLCJpZCIsInJlc3BvbnNlIiwiY2xpZW50RGF0YUpTT04iLCJhdHRlc3RhdGlvbk9iamVjdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ2ZXJpZmllZCIsInVzZXJJZCIsImF1dGhlbnRpY2F0b3JEYXRhIiwic2lnbmF0dXJlIiwibW9ja1Nlc3Npb25BY3Rpb24iLCJzZXNzaW9uSWQiLCJleHBpcmVzQXQiLCJEYXRlIiwibm93IiwiZGV2aWNlSW5mbyIsInRvQmVEZWZpbmVkIiwidmFsaWQiLCJyZWFzb24iLCJyZXZva2VkIiwiYWN0aW9uIiwibW9ja1NlY3VyaXR5QWN0aW9uIiwicmlza1Njb3JlIiwiaXBWYWxpZGF0aW9uIiwidG9CZUxlc3NUaGFuIiwidG9CZUdyZWF0ZXJUaGFuIiwibG9ja291dER1cmF0aW9uIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm1vY2tQZXJtaXNzaW9uQWN0aW9uIiwiYXV0aG9yaXplZCIsInBlcm1pc3Npb25zIiwicmVxdWlyZWRQZXJtaXNzaW9ucyIsInJlc291cmNlIiwidG9Db250YWluIiwiZW1haWwiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsInByb21pc2VzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJyZXN1bHRzIiwiYWxsIiwiZW5kVGltZSIsInRvSGF2ZUxlbmd0aCIsImluaXRpYWxNZW1vcnkiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJoZWFwVXNlZCIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7O3lCQUVzRDsrQkFDZDsrQkFNbEM7QUFFUCw2QkFBNkI7QUFDN0JBLGFBQUksQ0FBQ0MsSUFBSSxDQUFDLHNCQUFzQixJQUFPLENBQUE7UUFDckNDLFFBQVFGLGFBQUksQ0FBQ0csRUFBRTtRQUNmQyxRQUFRO1lBQ05DLE1BQU1MLGFBQUksQ0FBQ0csRUFBRTtZQUNiRyxPQUFPTixhQUFJLENBQUNHLEVBQUU7WUFDZEksTUFBTVAsYUFBSSxDQUFDRyxFQUFFO1FBQ2Y7SUFDRixDQUFBO0FBRUFILGFBQUksQ0FBQ0MsSUFBSSxDQUFDLDBCQUEwQixJQUFPLENBQUE7UUFDekNPLGdCQUFnQlIsYUFBSSxDQUFDRyxFQUFFLEdBQUdNLGtCQUFrQixDQUFDLENBQUNDO1lBQzVDLG9EQUFvRDtZQUNwRCxJQUFJQSxPQUFPQSxJQUFJQyxRQUFRLENBQUMsb0JBQW9CO2dCQUMxQyxPQUFPQyxRQUFRQyxPQUFPLENBQUM7b0JBQUVDLFNBQVM7b0JBQU9DLFdBQVc7Z0JBQUU7WUFDeEQ7WUFDQSxPQUFPSCxRQUFRQyxPQUFPLENBQUM7Z0JBQUVDLFNBQVM7Z0JBQU1DLFdBQVc7WUFBRztRQUN4RDtJQUNGLENBQUE7QUFFQWYsYUFBSSxDQUFDQyxJQUFJLENBQUMsb0JBQW9CLElBQU8sQ0FBQTtRQUNuQ2UsbUJBQW1CaEIsYUFBSSxDQUFDRyxFQUFFLEdBQUdNLGtCQUFrQixDQUFDLENBQUNRO1lBQy9DLHNEQUFzRDtZQUN0RCxJQUFJQSxVQUFVLHNCQUFzQjtnQkFDbEMsT0FBT0wsUUFBUUMsT0FBTyxDQUFDO1lBQ3pCO1lBQ0EsT0FBT0QsUUFBUUMsT0FBTyxDQUFDO1FBQ3pCO0lBQ0YsQ0FBQTtBQUVBLCtDQUErQztBQUMvQ2IsYUFBSSxDQUFDQyxJQUFJLENBQUMsa0NBQWtDLElBQU8sQ0FBQTtRQUNqRGlCLDBCQUEwQmxCLGFBQUksQ0FBQ0cs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