1230fb1d727a37c6d92ae78406ada0e1
/**
 * VoteValidator Unit Tests
 * 
 * Comprehensive unit tests for vote validation functionality
 * 
 * Created: January 15, 2025
 * Updated: January 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _validator = require("../../../../lib/vote/validator");
const _setup = require("../../setup");
// Mock the logger
_globals.jest.mock('@/lib/utils/logger', ()=>({
        devLog: _globals.jest.fn()
    }));
const mockSetup = (0, _setup.getMS)();
const { when, client: mockSupabaseClient } = mockSetup;
_globals.jest.mock('@/utils/supabase/server', ()=>({
        getSupabaseServerClient: _globals.jest.fn(()=>mockSupabaseClient)
    }));
(0, _globals.describe)('VoteValidator', ()=>{
    let validator;
    let mockPoll;
    let mockVoteData;
    (0, _globals.beforeEach)(()=>{
        // Reset all mocks before each test
        _globals.jest.clearAllMocks();
        validator = new _validator.VoteValidator();
        mockPoll = {
            id: 'test-poll-123',
            title: 'Test Poll',
            description: 'A test poll for unit testing',
            votingMethod: 'single',
            options: [
                {
                    id: 'option-1',
                    text: 'Option 1'
                },
                {
                    id: 'option-2',
                    text: 'Option 2'
                },
                {
                    id: 'option-3',
                    text: 'Option 3'
                }
            ],
            status: 'active',
            startTime: new Date('2025-01-01T00:00:00Z'),
            endTime: new Date('2025-12-31T23:59:59Z'),
            createdBy: 'admin-user',
            createdAt: new Date('2025-01-01T00:00:00Z'),
            updatedAt: new Date('2025-01-01T00:00:00Z'),
            votingConfig: {
                allowMultipleVotes: false,
                maxChoices: 1,
                requireVerification: false,
                quadraticCredits: 100,
                rangeMin: 0,
                rangeMax: 10
            }
        };
        mockVoteData = {
            id: 'vote-123',
            pollId: 'test-poll-123',
            userId: 'user-1',
            choice: 0,
            privacyLevel: 'public',
            timestamp: new Date(),
            auditReceipt: 'audit-123'
        };
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.describe)('Basic Validation', ()=>{
        (0, _globals.it)('should validate valid vote data', async ()=>{
            console.log('Testing vote validation...');
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            console.log('Validation result:', validation);
            (0, _globals.expect)(validation.isValid).toBe(true);
            (0, _globals.expect)(validation.requiresAuthentication).toBe(true);
            (0, _globals.expect)(validation.requiresTokens).toBe(false);
        });
        (0, _globals.it)('should reject null vote data', async ()=>{
            const validation = await validator.validateVote(null, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject undefined vote data', async ()=>{
            const validation = await validator.validateVote(undefined, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject non-object vote data', async ()=>{
            const validation = await validator.validateVote('invalid', mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject null poll data', async ()=>{
            const validation = await validator.validateVote(mockVoteData, null, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll data is required');
        });
        (0, _globals.it)('should reject poll data without id', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                id: ''
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
        (0, _globals.it)('should reject poll data without voting method', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                votingMethod: undefined
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
    });
    (0, _globals.describe)('Business Rules Validation', ()=>{
        (0, _globals.it)('should reject vote for inactive poll', async ()=>{
            const inactivePoll = Object.assign({}, mockPoll, {
                status: 'closed'
            });
            const validation = await validator.validateVote(mockVoteData, inactivePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for draft poll', async ()=>{
            const draftPoll = Object.assign({}, mockPoll, {
                status: 'draft'
            });
            const validation = await validator.validateVote(mockVoteData, draftPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for expired poll', async ()=>{
            const expiredPoll = Object.assign({}, mockPoll, {
                endTime: new Date('2024-12-31T23:59:59Z') // Past date
            });
            const validation = await validator.validateVote(mockVoteData, expiredPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll has ended');
        });
        (0, _globals.it)('should accept vote for poll without end time', async ()=>{
            const { endTime, ...noEndTimePoll } = mockPoll;
            const validation = await validator.validateVote(mockVoteData, noEndTimePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote for locked poll', async ()=>{
            const lockedPoll = Object.assign({}, mockPoll, {
                lockedAt: new Date('2025-01-01T12:00:00Z')
            });
            const validation = await validator.validateVote(mockVoteData, lockedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is locked');
        });
    });
    (0, _globals.describe)('Single Choice Validation', ()=>{
        (0, _globals.it)('should validate valid single choice vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing choice', async ()=>{
            const { choice, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with null choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: null
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with non-integer choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 1.5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be a valid integer');
        });
        (0, _globals.it)('should reject vote with negative choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: -1
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with choice exceeding options', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
    });
    (0, _globals.describe)('Approval Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'approval';
            mockPoll.votingConfig = {
                ...mockPoll.votingConfig,
                maxChoices: 3,
                allowMultipleVotes: true
            };
            const { choice, ...approvalVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, approvalVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
        });
        (0, _globals.it)('should validate valid approval vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing approvals', async ()=>{
            const { approvals, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with empty approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: []
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must be approved');
        });
        (0, _globals.it)('should reject vote with non-array approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: 'invalid'
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with invalid approval indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approval index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    0
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate approvals are not allowed');
        });
        (0, _globals.it)('should respect max choices limit', async ()=>{
            const limitedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    maxChoices: 1
                })
            });
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, limitedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Maximum 1 approvals allowed');
        });
    });
    (0, _globals.describe)('Ranked Choice Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'ranked';
            const { choice, approvals, ...rankedVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rankedVoteData, {
                rankings: [
                    0,
                    1,
                    2
                ]
            });
        });
        (0, _globals.it)('should validate valid ranked vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing rankings', async ()=>{
            const { rankings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rankings array is required for ranked choice voting');
        });
        (0, _globals.it)('should reject vote with incomplete rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be ranked');
        });
        (0, _globals.it)('should reject vote with invalid ranking indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ranking index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate rankings are not allowed');
        });
    });
    (0, _globals.describe)('Quadratic Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'quadratic';
            const { choice, approvals, rankings, ...quadraticVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, quadraticVoteData, {
                allocations: {
                    '0': 5,
                    '1': 3
                }
            });
        });
        (0, _globals.it)('should validate valid quadratic vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing allocations', async ()=>{
            const { allocations, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Allocations object is required for quadratic voting');
        });
        (0, _globals.it)('should reject vote with negative allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': -5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote with non-integer allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 5.5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote exceeding credit limit', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 11
                } // 11^2 = 121 > 100
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toContain('exceeds available credits');
        });
        (0, _globals.it)('should reject vote with no allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must receive votes');
        });
    });
    (0, _globals.describe)('Range Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'range';
            const { choice, approvals, rankings, allocations, ...rangeVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rangeVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6,
                    '2': 4
                }
            });
        });
        (0, _globals.it)('should validate valid range vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing ratings', async ()=>{
            const { ratings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ratings object is required for range voting');
        });
        (0, _globals.it)('should reject vote with ratings outside range', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 15
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rating must be between 0 and 10');
        });
        (0, _globals.it)('should reject vote with incomplete ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be rated');
        });
        (0, _globals.it)('should reject vote with all minimum ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must have a rating above the minimum');
        });
    });
    (0, _globals.describe)('Security Validation', ()=>{
        (0, _globals.it)('should require authentication when verification is required', async ()=>{
            const verifiedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    requireVerification: true
                })
            });
            const validation = await validator.validateVote(mockVoteData, verifiedPoll);
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Authentication required for this poll');
        });
        (0, _globals.it)('should accept vote when verification is not required', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll);
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should check trust tier requirements', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T2',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock no existing vote (user can vote)
            when().table('votes').op('select').eq('poll_id', 'test-poll-123').eq('user_id', 'user-1').returnsList([]);
            // Mock getUserTrustTier to return T1 (insufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T1'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
        });
        (0, _globals.it)('should accept vote with sufficient trust tier', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock getUserTrustTier to return T2 (sufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T2'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // The validation should pass since T2 >= T1
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
    });
    (0, _globals.describe)('Error Handling', ()=>{
        (0, _globals.it)('should handle validation errors gracefully', async ()=>{
            // Mock a method to throw an error
            const originalValidateBasicVoteData = validator.validateBasicVoteData;
            validator.validateBasicVoteData = _globals.jest.fn().mockImplementation(()=>{
                throw new Error('Validation error');
            });
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Validation error');
            // Restore original method
            validator.validateBasicVoteData = originalValidateBasicVoteData;
        });
        (0, _globals.it)('should handle database errors gracefully', async ()=>{
            // Create a new validator instance to avoid interference with other tests
            const testValidator = new _validator.VoteValidator();
            // Mock the getUserTrustTier method to return T0 (default fallback)
            const originalGetUserTrustTier = testValidator.getUserTrustTier;
            const mockGetUserTrustTier = _globals.jest.fn();
            mockGetUserTrustTier.mockResolvedValue('T0');
            testValidator.getUserTrustTier = mockGetUserTrustTier;
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            const validation = await testValidator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // Should fall back to default trust tier (T0) and fail
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
            // Restore original method
            testValidator.getUserTrustTier = originalGetUserTrustTier;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvdm90ZS92b3RlLXZhbGlkYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVm90ZVZhbGlkYXRvciBVbml0IFRlc3RzXG4gKiBcbiAqIENvbXByZWhlbnNpdmUgdW5pdCB0ZXN0cyBmb3Igdm90ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAqIFxuICogQ3JlYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICogVXBkYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IFZvdGVWYWxpZGF0b3IgfSBmcm9tICdAL2xpYi92b3RlL3ZhbGlkYXRvcic7XG5pbXBvcnQgdHlwZSB7IFxuICBWb3RlRGF0YSwgXG4gIFBvbGxEYXRhLCBcbiAgVm90ZVZhbGlkYXRpb24gXG59IGZyb20gJ0AvbGliL3ZvdGUvdHlwZXMnO1xuXG4vLyBNb2NrIHRoZSBsb2dnZXJcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgZGV2TG9nOiBqZXN0LmZuKClcbn0pKTtcblxuLy8gSW1wb3J0IFYyIHRlc3Qgc2V0dXBcbmltcG9ydCB7IGdldE1TIH0gZnJvbSAnLi4vLi4vc2V0dXAnO1xuY29uc3QgbW9ja1NldHVwID0gZ2V0TVMoKTtcbmNvbnN0IHsgd2hlbiwgY2xpZW50OiBtb2NrU3VwYWJhc2VDbGllbnQgfSA9IG1vY2tTZXR1cDtcblxuamVzdC5tb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlU2VydmVyQ2xpZW50OiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZUNsaWVudClcbn0pKTtcblxuZGVzY3JpYmUoJ1ZvdGVWYWxpZGF0b3InLCAoKSA9PiB7XG4gIGxldCB2YWxpZGF0b3I6IFZvdGVWYWxpZGF0b3I7XG4gIGxldCBtb2NrUG9sbDogUG9sbERhdGE7XG4gIGxldCBtb2NrVm90ZURhdGE6IFZvdGVEYXRhO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIFJlc2V0IGFsbCBtb2NrcyBiZWZvcmUgZWFjaCB0ZXN0XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgdmFsaWRhdG9yID0gbmV3IFZvdGVWYWxpZGF0b3IoKTtcbiAgICBcbiAgICBtb2NrUG9sbCA9IHtcbiAgICAgIGlkOiAndGVzdC1wb2xsLTEyMycsXG4gICAgICB0aXRsZTogJ1Rlc3QgUG9sbCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgdGVzdCBwb2xsIGZvciB1bml0IHRlc3RpbmcnLFxuICAgICAgdm90aW5nTWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgeyBpZDogJ29wdGlvbi0xJywgdGV4dDogJ09wdGlvbiAxJyB9LFxuICAgICAgICB7IGlkOiAnb3B0aW9uLTInLCB0ZXh0OiAnT3B0aW9uIDInIH0sXG4gICAgICAgIHsgaWQ6ICdvcHRpb24tMycsIHRleHQ6ICdPcHRpb24gMycgfVxuICAgICAgXSxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwWicpLFxuICAgICAgZW5kVGltZTogbmV3IERhdGUoJzIwMjUtMTItMzFUMjM6NTk6NTlaJyksXG4gICAgICBjcmVhdGVkQnk6ICdhZG1pbi11c2VyJyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwWicpLFxuICAgICAgdm90aW5nQ29uZmlnOiB7XG4gICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogZmFsc2UsXG4gICAgICAgIG1heENob2ljZXM6IDEsXG4gICAgICAgIHJlcXVpcmVWZXJpZmljYXRpb246IGZhbHNlLFxuICAgICAgICBxdWFkcmF0aWNDcmVkaXRzOiAxMDAsXG4gICAgICAgIHJhbmdlTWluOiAwLFxuICAgICAgICByYW5nZU1heDogMTBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9ja1ZvdGVEYXRhID0ge1xuICAgICAgaWQ6ICd2b3RlLTEyMycsXG4gICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtMTIzJyxcbiAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICBjaG9pY2U6IDAsXG4gICAgICBwcml2YWN5TGV2ZWw6ICdwdWJsaWMnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgYXVkaXRSZWNlaXB0OiAnYXVkaXQtMTIzJ1xuICAgIH07XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYXNpYyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Rlc3Rpbmcgdm90ZSB2YWxpZGF0aW9uLi4uJyk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGlvbiByZXN1bHQ6JywgdmFsaWRhdGlvbik7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5yZXF1aXJlc0F1dGhlbnRpY2F0aW9uKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24ucmVxdWlyZXNUb2tlbnMpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgbnVsbCB2b3RlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShudWxsIGFzIGFueSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnVm90ZSBkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB1bmRlZmluZWQgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUodW5kZWZpbmVkIGFzIGFueSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnVm90ZSBkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBub24tb2JqZWN0IHZvdGUgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKCdpbnZhbGlkJyBhcyBhbnksIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1ZvdGUgZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgbnVsbCBwb2xsIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG51bGwgYXMgYW55LCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1BvbGwgZGF0YSBpcyByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgcG9sbCBkYXRhIHdpdGhvdXQgaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IGlkOiAnJyB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaW52YWxpZFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnSW52YWxpZCBwb2xsIGRhdGEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHBvbGwgZGF0YSB3aXRob3V0IHZvdGluZyBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IHZvdGluZ01ldGhvZDogdW5kZWZpbmVkIGFzIGFueSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaW52YWxpZFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnSW52YWxpZCBwb2xsIGRhdGEnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0J1c2luZXNzIFJ1bGVzIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSBmb3IgaW5hY3RpdmUgcG9sbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluYWN0aXZlUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IHN0YXR1czogJ2Nsb3NlZCcgYXMgY29uc3QgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGluYWN0aXZlUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdQb2xsIGlzIG5vdCBhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgZm9yIGRyYWZ0IHBvbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBzdGF0dXM6ICdkcmFmdCcgYXMgY29uc3QgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGRyYWZ0UG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdQb2xsIGlzIG5vdCBhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgZm9yIGV4cGlyZWQgcG9sbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGlyZWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIGVuZFRpbWU6IG5ldyBEYXRlKCcyMDI0LTEyLTMxVDIzOjU5OjU5WicpIC8vIFBhc3QgZGF0ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGV4cGlyZWRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1BvbGwgaGFzIGVuZGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjY2VwdCB2b3RlIGZvciBwb2xsIHdpdGhvdXQgZW5kIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGVuZFRpbWUsIC4uLm5vRW5kVGltZVBvbGwgfSA9IG1vY2tQb2xsO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBub0VuZFRpbWVQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIGZvciBsb2NrZWQgcG9sbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvY2tlZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgbG9ja2VkQXQ6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDEyOjAwOjAwWicpIFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGxvY2tlZFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUG9sbCBpcyBsb2NrZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NpbmdsZSBDaG9pY2UgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHNpbmdsZSBjaG9pY2Ugdm90ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBtaXNzaW5nIGNob2ljZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hvaWNlLCAuLi5pbnZhbGlkVm90ZSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0Nob2ljZSBpcyByZXF1aXJlZCBmb3Igc2luZ2xlIGNob2ljZSB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBudWxsIGNob2ljZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGNob2ljZTogbnVsbCBhcyBhbnkgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQ2hvaWNlIGlzIHJlcXVpcmVkIGZvciBzaW5nbGUgY2hvaWNlIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5vbi1pbnRlZ2VyIGNob2ljZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGNob2ljZTogMS41IGFzIGFueSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdDaG9pY2UgbXVzdCBiZSBhIHZhbGlkIGludGVnZXInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBuZWdhdGl2ZSBjaG9pY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBjaG9pY2U6IC0xIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0Nob2ljZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGNob2ljZSBleGNlZWRpbmcgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGNob2ljZTogNSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdDaG9pY2UgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDInKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FwcHJvdmFsIFZvdGluZyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1BvbGwudm90aW5nTWV0aG9kID0gJ2FwcHJvdmFsJztcbiAgICAgIG1vY2tQb2xsLnZvdGluZ0NvbmZpZyA9IHtcbiAgICAgICAgLi4ubW9ja1BvbGwudm90aW5nQ29uZmlnLFxuICAgICAgICBtYXhDaG9pY2VzOiAzLCAvLyBBbGxvdyBtdWx0aXBsZSBhcHByb3ZhbHNcbiAgICAgICAgYWxsb3dNdWx0aXBsZVZvdGVzOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgeyBjaG9pY2UsIC4uLmFwcHJvdmFsVm90ZURhdGEgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIG1vY2tWb3RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGFwcHJvdmFsVm90ZURhdGEsIHtcbiAgICAgICAgYXBwcm92YWxzOiBbMCwgMV1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB2YWxpZCBhcHByb3ZhbCB2b3RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG1pc3NpbmcgYXBwcm92YWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBhcHByb3ZhbHMsIC4uLmludmFsaWRWb3RlIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXBwcm92YWxzIGFycmF5IGlzIHJlcXVpcmVkIGZvciBhcHByb3ZhbCB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBlbXB0eSBhcHByb3ZhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBhcHByb3ZhbHM6IFtdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0F0IGxlYXN0IG9uZSBvcHRpb24gbXVzdCBiZSBhcHByb3ZlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5vbi1hcnJheSBhcHByb3ZhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBhcHByb3ZhbHM6ICdpbnZhbGlkJyBhcyBhbnkgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXBwcm92YWxzIGFycmF5IGlzIHJlcXVpcmVkIGZvciBhcHByb3ZhbCB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBpbnZhbGlkIGFwcHJvdmFsIGluZGljZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBhcHByb3ZhbHM6IFswLCA1XSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBcHByb3ZhbCBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGR1cGxpY2F0ZSBhcHByb3ZhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBhcHByb3ZhbHM6IFswLCAwXSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdEdXBsaWNhdGUgYXBwcm92YWxzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IG1heCBjaG9pY2VzIGxpbWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGltaXRlZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyB2b3RpbmdDb25maWc6IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLnZvdGluZ0NvbmZpZywgeyBtYXhDaG9pY2VzOiAxIH0pIH0pO1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgYXBwcm92YWxzOiBbMCwgMV0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbGltaXRlZFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnTWF4aW11bSAxIGFwcHJvdmFscyBhbGxvd2VkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSYW5rZWQgQ2hvaWNlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrUG9sbC52b3RpbmdNZXRob2QgPSAncmFua2VkJztcbiAgICAgIGNvbnN0IHsgY2hvaWNlLCBhcHByb3ZhbHMsIC4uLnJhbmtlZFZvdGVEYXRhIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBtb2NrVm90ZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCByYW5rZWRWb3RlRGF0YSwge1xuICAgICAgICByYW5raW5nczogWzAsIDEsIDJdXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgcmFua2VkIHZvdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbWlzc2luZyByYW5raW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmFua2luZ3MsIC4uLmludmFsaWRWb3RlIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUmFua2luZ3MgYXJyYXkgaXMgcmVxdWlyZWQgZm9yIHJhbmtlZCBjaG9pY2Ugdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggaW5jb21wbGV0ZSByYW5raW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IHJhbmtpbmdzOiBbMCwgMV0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQWxsIG9wdGlvbnMgbXVzdCBiZSByYW5rZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBpbnZhbGlkIHJhbmtpbmcgaW5kaWNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IHJhbmtpbmdzOiBbMCwgMSwgNV0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUmFua2luZyBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGR1cGxpY2F0ZSByYW5raW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IHJhbmtpbmdzOiBbMCwgMCwgMV0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnRHVwbGljYXRlIHJhbmtpbmdzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUXVhZHJhdGljIFZvdGluZyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1BvbGwudm90aW5nTWV0aG9kID0gJ3F1YWRyYXRpYyc7XG4gICAgICBjb25zdCB7IGNob2ljZSwgYXBwcm92YWxzLCByYW5raW5ncywgLi4ucXVhZHJhdGljVm90ZURhdGEgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIG1vY2tWb3RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHF1YWRyYXRpY1ZvdGVEYXRhLCB7XG4gICAgICAgIGFsbG9jYXRpb25zOiB7XG4gICAgICAgICAgJzAnOiA1LFxuICAgICAgICAgICcxJzogM1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgcXVhZHJhdGljIHZvdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbWlzc2luZyBhbGxvY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYWxsb2NhdGlvbnMsIC4uLmludmFsaWRWb3RlIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQWxsb2NhdGlvbnMgb2JqZWN0IGlzIHJlcXVpcmVkIGZvciBxdWFkcmF0aWMgdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbmVnYXRpdmUgYWxsb2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgYWxsb2NhdGlvbnM6IHsgJzAnOiAtNSB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQWxsIGFsbG9jYXRpb25zIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXJzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbm9uLWludGVnZXIgYWxsb2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgYWxsb2NhdGlvbnM6IHsgJzAnOiA1LjUgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FsbCBhbGxvY2F0aW9ucyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSBleGNlZWRpbmcgY3JlZGl0IGxpbWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIGFsbG9jYXRpb25zOiB7ICcwJzogMTEgfSAvLyAxMV4yID0gMTIxID4gMTAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0NvbnRhaW4oJ2V4Y2VlZHMgYXZhaWxhYmxlIGNyZWRpdHMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBubyBhbGxvY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICBhbGxvY2F0aW9uczogeyAnMCc6IDAsICcxJzogMCwgJzInOiAwIH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBdCBsZWFzdCBvbmUgb3B0aW9uIG11c3QgcmVjZWl2ZSB2b3RlcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmFuZ2UgVm90aW5nIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrUG9sbC52b3RpbmdNZXRob2QgPSAncmFuZ2UnO1xuICAgICAgY29uc3QgeyBjaG9pY2UsIGFwcHJvdmFscywgcmFua2luZ3MsIGFsbG9jYXRpb25zLCAuLi5yYW5nZVZvdGVEYXRhIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBtb2NrVm90ZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCByYW5nZVZvdGVEYXRhLCB7XG4gICAgICAgIHJhdGluZ3M6IHtcbiAgICAgICAgICAnMCc6IDgsXG4gICAgICAgICAgJzEnOiA2LFxuICAgICAgICAgICcyJzogNFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgcmFuZ2Ugdm90ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBtaXNzaW5nIHJhdGluZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJhdGluZ3MsIC4uLmludmFsaWRWb3RlIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUmF0aW5ncyBvYmplY3QgaXMgcmVxdWlyZWQgZm9yIHJhbmdlIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIHJhdGluZ3Mgb3V0c2lkZSByYW5nZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICByYXRpbmdzOiB7ICcwJzogMTUgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1JhdGluZyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBpbmNvbXBsZXRlIHJhdGluZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgcmF0aW5nczogeyAnMCc6IDgsICcxJzogNiB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQWxsIG9wdGlvbnMgbXVzdCBiZSByYXRlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGFsbCBtaW5pbXVtIHJhdGluZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgcmF0aW5nczogeyAnMCc6IDAsICcxJzogMCwgJzInOiAwIH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBdCBsZWFzdCBvbmUgb3B0aW9uIG11c3QgaGF2ZSBhIHJhdGluZyBhYm92ZSB0aGUgbWluaW11bScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VjdXJpdHkgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlcXVpcmUgYXV0aGVudGljYXRpb24gd2hlbiB2ZXJpZmljYXRpb24gaXMgcmVxdWlyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJpZmllZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgdm90aW5nQ29uZmlnOiBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbC52b3RpbmdDb25maWcsIHsgcmVxdWlyZVZlcmlmaWNhdGlvbjogdHJ1ZSB9KSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCB2ZXJpZmllZFBvbGwpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCBmb3IgdGhpcyBwb2xsJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjY2VwdCB2b3RlIHdoZW4gdmVyaWZpY2F0aW9uIGlzIG5vdCByZXF1aXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjaGVjayB0cnVzdCB0aWVyIHJlcXVpcmVtZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hUcnVzdFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgdm90aW5nQ29uZmlnOiBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbC52b3RpbmdDb25maWcsIHsgXG4gICAgICAgICAgbWluVHJ1c3RUaWVyOiAnVDInLFxuICAgICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogdHJ1ZSAvLyBBbGxvdyBtdWx0aXBsZSB2b3RlcyB0byBhdm9pZCBleGlzdGluZyB2b3RlIGNoZWNrXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBubyBleGlzdGluZyB2b3RlICh1c2VyIGNhbiB2b3RlKVxuICAgICAgd2hlbigpLnRhYmxlKCd2b3RlcycpLm9wKCdzZWxlY3QnKS5lcSgncG9sbF9pZCcsICd0ZXN0LXBvbGwtMTIzJykuZXEoJ3VzZXJfaWQnLCAndXNlci0xJykucmV0dXJuc0xpc3QoW10pO1xuICAgICAgXG4gICAgICAvLyBNb2NrIGdldFVzZXJUcnVzdFRpZXIgdG8gcmV0dXJuIFQxIChpbnN1ZmZpY2llbnQpXG4gICAgICB3aGVuKCkudGFibGUoJ3VzZXJfcHJvZmlsZXMnKS5vcCgnc2VsZWN0Jykuc2VsZWN0KCd0cnVzdF90aWVyJykuZXEoJ3VzZXJfaWQnLCAndXNlci0xJykucmV0dXJuc1NpbmdsZSh7IHRydXN0X3RpZXI6ICdUMScgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaGlnaFRydXN0UG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdJbnN1ZmZpY2llbnQgdHJ1c3QgdGllciBmb3IgdGhpcyBwb2xsJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjY2VwdCB2b3RlIHdpdGggc3VmZmljaWVudCB0cnVzdCB0aWVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaGlnaFRydXN0UG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICB2b3RpbmdDb25maWc6IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLnZvdGluZ0NvbmZpZywgeyBcbiAgICAgICAgICBtaW5UcnVzdFRpZXI6ICdUMScsXG4gICAgICAgICAgYWxsb3dNdWx0aXBsZVZvdGVzOiB0cnVlIC8vIEFsbG93IG11bHRpcGxlIHZvdGVzIHRvIGF2b2lkIGV4aXN0aW5nIHZvdGUgY2hlY2tcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBNb2NrIGdldFVzZXJUcnVzdFRpZXIgdG8gcmV0dXJuIFQyIChzdWZmaWNpZW50KVxuICAgICAgd2hlbigpLnRhYmxlKCd1c2VyX3Byb2ZpbGVzJykub3AoJ3NlbGVjdCcpLnNlbGVjdCgndHJ1c3RfdGllcicpLmVxKCd1c2VyX2lkJywgJ3VzZXItMScpLnJldHVybnNTaW5nbGUoeyB0cnVzdF90aWVyOiAnVDInIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGhpZ2hUcnVzdFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgLy8gVGhlIHZhbGlkYXRpb24gc2hvdWxkIHBhc3Mgc2luY2UgVDIgPj0gVDFcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2YWxpZGF0aW9uIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBhIG1ldGhvZCB0byB0aHJvdyBhbiBlcnJvclxuICAgICAgY29uc3Qgb3JpZ2luYWxWYWxpZGF0ZUJhc2ljVm90ZURhdGEgPSAodmFsaWRhdG9yIGFzIGFueSkudmFsaWRhdGVCYXNpY1ZvdGVEYXRhO1xuICAgICAgKHZhbGlkYXRvciBhcyBhbnkpLnZhbGlkYXRlQmFzaWNWb3RlRGF0YSA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gZXJyb3InKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1ZhbGlkYXRpb24gZXJyb3InKTtcblxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgICh2YWxpZGF0b3IgYXMgYW55KS52YWxpZGF0ZUJhc2ljVm90ZURhdGEgPSBvcmlnaW5hbFZhbGlkYXRlQmFzaWNWb3RlRGF0YTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZhbGlkYXRvciBpbnN0YW5jZSB0byBhdm9pZCBpbnRlcmZlcmVuY2Ugd2l0aCBvdGhlciB0ZXN0c1xuICAgICAgY29uc3QgdGVzdFZhbGlkYXRvciA9IG5ldyBWb3RlVmFsaWRhdG9yKCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdGhlIGdldFVzZXJUcnVzdFRpZXIgbWV0aG9kIHRvIHJldHVybiBUMCAoZGVmYXVsdCBmYWxsYmFjaylcbiAgICAgIGNvbnN0IG9yaWdpbmFsR2V0VXNlclRydXN0VGllciA9ICh0ZXN0VmFsaWRhdG9yIGFzIGFueSkuZ2V0VXNlclRydXN0VGllcjtcbiAgICAgIGNvbnN0IG1vY2tHZXRVc2VyVHJ1c3RUaWVyID0gamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248KCkgPT4gUHJvbWlzZTxzdHJpbmc+PjtcbiAgICAgIG1vY2tHZXRVc2VyVHJ1c3RUaWVyLm1vY2tSZXNvbHZlZFZhbHVlKCdUMCcpO1xuICAgICAgKHRlc3RWYWxpZGF0b3IgYXMgYW55KS5nZXRVc2VyVHJ1c3RUaWVyID0gbW9ja0dldFVzZXJUcnVzdFRpZXI7XG5cbiAgICAgIGNvbnN0IGhpZ2hUcnVzdFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgdm90aW5nQ29uZmlnOiBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbC52b3RpbmdDb25maWcsIHsgXG4gICAgICAgICAgbWluVHJ1c3RUaWVyOiAnVDEnLFxuICAgICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogdHJ1ZSAvLyBBbGxvdyBtdWx0aXBsZSB2b3RlcyB0byBhdm9pZCBleGlzdGluZyB2b3RlIGNoZWNrXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHRlc3RWYWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgaGlnaFRydXN0UG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgZmFsbCBiYWNrIHRvIGRlZmF1bHQgdHJ1c3QgdGllciAoVDApIGFuZCBmYWlsXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdJbnN1ZmZpY2llbnQgdHJ1c3QgdGllciBmb3IgdGhpcyBwb2xsJyk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICAodGVzdFZhbGlkYXRvciBhcyBhbnkpLmdldFVzZXJUcnVzdFRpZXIgPSBvcmlnaW5hbEdldFVzZXJUcnVzdFRpZXI7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkZXZMb2ciLCJmbiIsIm1vY2tTZXR1cCIsImdldE1TIiwid2hlbiIsImNsaWVudCIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImdldFN1cGFiYXNlU2VydmVyQ2xpZW50IiwiZGVzY3JpYmUiLCJ2YWxpZGF0b3IiLCJtb2NrUG9sbCIsIm1vY2tWb3RlRGF0YSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiVm90ZVZhbGlkYXRvciIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInZvdGluZ01ldGhvZCIsIm9wdGlvbnMiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhcnRUaW1lIiwiRGF0ZSIsImVuZFRpbWUiLCJjcmVhdGVkQnkiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJ2b3RpbmdDb25maWciLCJhbGxvd011bHRpcGxlVm90ZXMiLCJtYXhDaG9pY2VzIiwicmVxdWlyZVZlcmlmaWNhdGlvbiIsInF1YWRyYXRpY0NyZWRpdHMiLCJyYW5nZU1pbiIsInJhbmdlTWF4IiwicG9sbElkIiwidXNlcklkIiwiY2hvaWNlIiwicHJpdmFjeUxldmVsIiwidGltZXN0YW1wIiwiYXVkaXRSZWNlaXB0IiwiYWZ0ZXJFYWNoIiwiaXQiLCJjb25zb2xlIiwibG9nIiwidmFsaWRhdGlvbiIsInZhbGlkYXRlVm90ZSIsImV4cGVjdCIsImlzVmFsaWQiLCJ0b0JlIiwicmVxdWlyZXNBdXRoZW50aWNhdGlvbiIsInJlcXVpcmVzVG9rZW5zIiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJpbnZhbGlkUG9sbCIsIk9iamVjdCIsImFzc2lnbiIsImluYWN0aXZlUG9sbCIsImRyYWZ0UG9sbCIsImV4cGlyZWRQb2xsIiwibm9FbmRUaW1lUG9sbCIsImxvY2tlZFBvbGwiLCJsb2NrZWRBdCIsImludmFsaWRWb3RlIiwiYXBwcm92YWxWb3RlRGF0YSIsImFwcHJvdmFscyIsImxpbWl0ZWRQb2xsIiwicmFua2VkVm90ZURhdGEiLCJyYW5raW5ncyIsInF1YWRyYXRpY1ZvdGVEYXRhIiwiYWxsb2NhdGlvbnMiLCJ0b0NvbnRhaW4iLCJyYW5nZVZvdGVEYXRhIiwicmF0aW5ncyIsInZlcmlmaWVkUG9sbCIsImhpZ2hUcnVzdFBvbGwiLCJtaW5UcnVzdFRpZXIiLCJ0YWJsZSIsIm9wIiwiZXEiLCJyZXR1cm5zTGlzdCIsInNlbGVjdCIsInJldHVybnNTaW5nbGUiLCJ0cnVzdF90aWVyIiwib3JpZ2luYWxWYWxpZGF0ZUJhc2ljVm90ZURhdGEiLCJ2YWxpZGF0ZUJhc2ljVm90ZURhdGEiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsInRlc3RWYWxpZGF0b3IiLCJvcmlnaW5hbEdldFVzZXJUcnVzdFRpZXIiLCJnZXRVc2VyVHJ1c3RUaWVyIiwibW9ja0dldFVzZXJUcnVzdFRpZXIiLCJtb2NrUmVzb2x2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