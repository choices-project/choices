94286cf30f904e3deabcbab48a47cb3a
/**
 * VoteValidator Unit Tests
 * 
 * Comprehensive unit tests for vote validation functionality
 * 
 * Created: January 15, 2025
 * Updated: January 15, 2025
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _validator = require("../../../../lib/vote/validator");
const _setup = require("../../setup");
// Mock the logger
_globals.jest.mock('@/lib/utils/logger', ()=>({
        devLog: _globals.jest.fn()
    }));
const mockSetup = (0, _setup.getMS)();
const { when, client: mockSupabaseClient } = mockSetup;
_globals.jest.mock('@/utils/supabase/server', ()=>({
        getSupabaseServerClient: _globals.jest.fn(()=>mockSupabaseClient)
    }));
(0, _globals.describe)('VoteValidator', ()=>{
    let validator;
    let mockPoll;
    let mockVoteData;
    (0, _globals.beforeEach)(()=>{
        // Reset all mocks before each test
        _globals.jest.clearAllMocks();
        validator = new _validator.VoteValidator();
        mockPoll = {
            id: 'test-poll-123',
            title: 'Test Poll',
            description: 'A test poll for unit testing',
            votingMethod: 'single',
            options: [
                {
                    id: 'option-1',
                    text: 'Option 1'
                },
                {
                    id: 'option-2',
                    text: 'Option 2'
                },
                {
                    id: 'option-3',
                    text: 'Option 3'
                }
            ],
            status: 'active',
            startTime: new Date('2025-01-01T00:00:00Z'),
            endTime: new Date('2025-12-31T23:59:59Z'),
            createdBy: 'admin-user',
            createdAt: new Date('2025-01-01T00:00:00Z'),
            updatedAt: new Date('2025-01-01T00:00:00Z'),
            votingConfig: {
                allowMultipleVotes: false,
                maxChoices: 1,
                requireVerification: false,
                quadraticCredits: 100,
                rangeMin: 0,
                rangeMax: 10
            }
        };
        mockVoteData = {
            id: 'vote-123',
            pollId: 'test-poll-123',
            userId: 'user-1',
            choice: 0,
            privacyLevel: 'public',
            timestamp: new Date(),
            auditReceipt: 'audit-123'
        };
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.describe)('Basic Validation', ()=>{
        (0, _globals.it)('should validate valid vote data', async ()=>{
            console.log('Testing vote validation...');
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            console.log('Validation result:', validation);
            (0, _globals.expect)(validation.valid).toBe(true);
            (0, _globals.expect)(validation.requiresAuthentication).toBe(true);
            (0, _globals.expect)(validation.requiresTokens).toBe(false);
        });
        (0, _globals.it)('should reject null vote data', async ()=>{
            const validation = await validator.validateVote(null, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject undefined vote data', async ()=>{
            const validation = await validator.validateVote(undefined, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject non-object vote data', async ()=>{
            const validation = await validator.validateVote('invalid', mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Vote data must be an object');
        });
        (0, _globals.it)('should reject null poll data', async ()=>{
            const validation = await validator.validateVote(mockVoteData, null, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll data is required');
        });
        (0, _globals.it)('should reject poll data without id', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                id: ''
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
        (0, _globals.it)('should reject poll data without voting method', async ()=>{
            const invalidPoll = Object.assign({}, mockPoll, {
                votingMethod: undefined
            });
            const validation = await validator.validateVote(mockVoteData, invalidPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Invalid poll data');
        });
    });
    (0, _globals.describe)('Business Rules Validation', ()=>{
        (0, _globals.it)('should reject vote for inactive poll', async ()=>{
            const inactivePoll = Object.assign({}, mockPoll, {
                status: 'closed'
            });
            const validation = await validator.validateVote(mockVoteData, inactivePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for draft poll', async ()=>{
            const draftPoll = Object.assign({}, mockPoll, {
                status: 'draft'
            });
            const validation = await validator.validateVote(mockVoteData, draftPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is not active');
        });
        (0, _globals.it)('should reject vote for expired poll', async ()=>{
            const expiredPoll = Object.assign({}, mockPoll, {
                endTime: new Date('2024-12-31T23:59:59Z') // Past date
            });
            const validation = await validator.validateVote(mockVoteData, expiredPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll has ended');
        });
        (0, _globals.it)('should accept vote for poll without end time', async ()=>{
            const { endTime, ...noEndTimePoll } = mockPoll;
            const validation = await validator.validateVote(mockVoteData, noEndTimePoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote for locked poll', async ()=>{
            const lockedPoll = Object.assign({}, mockPoll, {
                lockedAt: new Date('2025-01-01T12:00:00Z')
            });
            const validation = await validator.validateVote(mockVoteData, lockedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Poll is locked');
        });
    });
    (0, _globals.describe)('Single Choice Validation', ()=>{
        (0, _globals.it)('should validate valid single choice vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing choice', async ()=>{
            const { choice, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with null choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: null
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice is required for single choice voting');
        });
        (0, _globals.it)('should reject vote with non-integer choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 1.5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be a valid integer');
        });
        (0, _globals.it)('should reject vote with negative choice', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: -1
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with choice exceeding options', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                choice: 5
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Choice must be between 0 and 2');
        });
    });
    (0, _globals.describe)('Approval Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'approval';
            mockPoll.votingConfig = {
                ...mockPoll.votingConfig,
                maxChoices: 3,
                allowMultipleVotes: true
            };
            const { choice, ...approvalVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, approvalVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
        });
        (0, _globals.it)('should validate valid approval vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing approvals', async ()=>{
            const { approvals, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with empty approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: []
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must be approved');
        });
        (0, _globals.it)('should reject vote with non-array approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: 'invalid'
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approvals array is required for approval voting');
        });
        (0, _globals.it)('should reject vote with invalid approval indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Approval index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate approvals', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    0
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate approvals are not allowed');
        });
        (0, _globals.it)('should respect max choices limit', async ()=>{
            const limitedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    maxChoices: 1
                })
            });
            const invalidVote = Object.assign({}, mockVoteData, {
                approvals: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, limitedPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Maximum 1 approvals allowed');
        });
    });
    (0, _globals.describe)('Ranked Choice Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'ranked';
            const { choice, approvals, ...rankedVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rankedVoteData, {
                rankings: [
                    0,
                    1,
                    2
                ]
            });
        });
        (0, _globals.it)('should validate valid ranked vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing rankings', async ()=>{
            const { rankings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rankings array is required for ranked choice voting');
        });
        (0, _globals.it)('should reject vote with incomplete rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be ranked');
        });
        (0, _globals.it)('should reject vote with invalid ranking indices', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    1,
                    5
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ranking index must be between 0 and 2');
        });
        (0, _globals.it)('should reject vote with duplicate rankings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                rankings: [
                    0,
                    0,
                    1
                ]
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Duplicate rankings are not allowed');
        });
    });
    (0, _globals.describe)('Quadratic Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'quadratic';
            const { choice, approvals, rankings, ...quadraticVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, quadraticVoteData, {
                allocations: {
                    '0': 5,
                    '1': 3
                }
            });
        });
        (0, _globals.it)('should validate valid quadratic vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing allocations', async ()=>{
            const { allocations, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Allocations object is required for quadratic voting');
        });
        (0, _globals.it)('should reject vote with negative allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': -5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote with non-integer allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 5.5
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All allocations must be non-negative integers');
        });
        (0, _globals.it)('should reject vote exceeding credit limit', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 11
                } // 11^2 = 121 > 100
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toContain('exceeds available credits');
        });
        (0, _globals.it)('should reject vote with no allocations', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                allocations: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must receive votes');
        });
    });
    (0, _globals.describe)('Range Voting Validation', ()=>{
        (0, _globals.beforeEach)(()=>{
            mockPoll.votingMethod = 'range';
            const { choice, approvals, rankings, allocations, ...rangeVoteData } = mockVoteData;
            mockVoteData = Object.assign({}, rangeVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6,
                    '2': 4
                }
            });
        });
        (0, _globals.it)('should validate valid range vote', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should reject vote with missing ratings', async ()=>{
            const { ratings, ...invalidVote } = mockVoteData;
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Ratings object is required for range voting');
        });
        (0, _globals.it)('should reject vote with ratings outside range', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 15
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Rating must be between 0 and 10');
        });
        (0, _globals.it)('should reject vote with incomplete ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 8,
                    '1': 6
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('All options must be rated');
        });
        (0, _globals.it)('should reject vote with all minimum ratings', async ()=>{
            const invalidVote = Object.assign({}, mockVoteData, {
                ratings: {
                    '0': 0,
                    '1': 0,
                    '2': 0
                }
            });
            const validation = await validator.validateVote(invalidVote, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('At least one option must have a rating above the minimum');
        });
    });
    (0, _globals.describe)('Security Validation', ()=>{
        (0, _globals.it)('should require authentication when verification is required', async ()=>{
            const verifiedPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    requireVerification: true
                })
            });
            const validation = await validator.validateVote(mockVoteData, verifiedPoll);
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Authentication required for this poll');
        });
        (0, _globals.it)('should accept vote when verification is not required', async ()=>{
            const validation = await validator.validateVote(mockVoteData, mockPoll);
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
        (0, _globals.it)('should check trust tier requirements', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T2',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock no existing vote (user can vote)
            when().table('votes').op('select').eq('poll_id', 'test-poll-123').eq('user_id', 'user-1').returnsList([]);
            // Mock getUserTrustTier to return T1 (insufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T1'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
        });
        (0, _globals.it)('should accept vote with sufficient trust tier', async ()=>{
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            // Mock getUserTrustTier to return T2 (sufficient)
            when().table('user_profiles').op('select').select('trust_tier').eq('user_id', 'user-1').returnsSingle({
                trust_tier: 'T2'
            });
            const validation = await validator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // The validation should pass since T2 >= T1
            (0, _globals.expect)(validation.isValid).toBe(true);
        });
    });
    (0, _globals.describe)('Error Handling', ()=>{
        (0, _globals.it)('should handle validation errors gracefully', async ()=>{
            // Mock a method to throw an error
            const originalValidateBasicVoteData = validator.validateBasicVoteData;
            validator.validateBasicVoteData = _globals.jest.fn().mockImplementation(()=>{
                throw new Error('Validation error');
            });
            const validation = await validator.validateVote(mockVoteData, mockPoll, 'user-1');
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Validation error');
            // Restore original method
            validator.validateBasicVoteData = originalValidateBasicVoteData;
        });
        (0, _globals.it)('should handle database errors gracefully', async ()=>{
            // Create a new validator instance to avoid interference with other tests
            const testValidator = new _validator.VoteValidator();
            // Mock the getUserTrustTier method to return T0 (default fallback)
            const originalGetUserTrustTier = testValidator.getUserTrustTier;
            const mockGetUserTrustTier = _globals.jest.fn();
            mockGetUserTrustTier.mockResolvedValue('T0');
            testValidator.getUserTrustTier = mockGetUserTrustTier;
            const highTrustPoll = Object.assign({}, mockPoll, {
                votingConfig: Object.assign({}, mockPoll.votingConfig, {
                    minTrustTier: 'T1',
                    allowMultipleVotes: true // Allow multiple votes to avoid existing vote check
                })
            });
            const validation = await testValidator.validateVote(mockVoteData, highTrustPoll, 'user-1');
            // Should fall back to default trust tier (T0) and fail
            (0, _globals.expect)(validation.isValid).toBe(false);
            (0, _globals.expect)(validation.error).toBe('Insufficient trust tier for this poll');
            // Restore original method
            testValidator.getUserTrustTier = originalGetUserTrustTier;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvdm90ZS92b3RlLXZhbGlkYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVm90ZVZhbGlkYXRvciBVbml0IFRlc3RzXG4gKiBcbiAqIENvbXByZWhlbnNpdmUgdW5pdCB0ZXN0cyBmb3Igdm90ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAqIFxuICogQ3JlYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICogVXBkYXRlZDogSmFudWFyeSAxNSwgMjAyNVxuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IFZvdGVWYWxpZGF0b3IgfSBmcm9tICdAL2xpYi92b3RlL3ZhbGlkYXRvcic7XG5pbXBvcnQgdHlwZSB7IFxuICBWb3RlRGF0YSwgXG4gIFBvbGxEYXRhLCBcbiAgVm90ZVZhbGlkYXRpb24gXG59IGZyb20gJ0AvbGliL3ZvdGUvdHlwZXMnO1xuXG4vLyBNb2NrIHRoZSBsb2dnZXJcbmplc3QubW9jaygnQC9saWIvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgZGV2TG9nOiBqZXN0LmZuKClcbn0pKTtcblxuLy8gSW1wb3J0IFYyIHRlc3Qgc2V0dXBcbmltcG9ydCB7IGdldE1TIH0gZnJvbSAnLi4vLi4vc2V0dXAnO1xuY29uc3QgbW9ja1NldHVwID0gZ2V0TVMoKTtcbmNvbnN0IHsgd2hlbiwgY2xpZW50OiBtb2NrU3VwYWJhc2VDbGllbnQgfSA9IG1vY2tTZXR1cDtcblxuamVzdC5tb2NrKCdAL3V0aWxzL3N1cGFiYXNlL3NlcnZlcicsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlU2VydmVyQ2xpZW50OiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZUNsaWVudClcbn0pKTtcblxuZGVzY3JpYmUoJ1ZvdGVWYWxpZGF0b3InLCAoKSA9PiB7XG4gIGxldCB2YWxpZGF0b3I6IFZvdGVWYWxpZGF0b3I7XG4gIGxldCBtb2NrUG9sbDogUG9sbERhdGE7XG4gIGxldCBtb2NrVm90ZURhdGE6IFZvdGVEYXRhO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIFJlc2V0IGFsbCBtb2NrcyBiZWZvcmUgZWFjaCB0ZXN0XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgdmFsaWRhdG9yID0gbmV3IFZvdGVWYWxpZGF0b3IoKTtcbiAgICBcbiAgICBtb2NrUG9sbCA9IHtcbiAgICAgIGlkOiAndGVzdC1wb2xsLTEyMycsXG4gICAgICB0aXRsZTogJ1Rlc3QgUG9sbCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgdGVzdCBwb2xsIGZvciB1bml0IHRlc3RpbmcnLFxuICAgICAgdm90aW5nTWV0aG9kOiAnc2luZ2xlJyxcbiAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgeyBpZDogJ29wdGlvbi0xJywgdGV4dDogJ09wdGlvbiAxJyB9LFxuICAgICAgICB7IGlkOiAnb3B0aW9uLTInLCB0ZXh0OiAnT3B0aW9uIDInIH0sXG4gICAgICAgIHsgaWQ6ICdvcHRpb24tMycsIHRleHQ6ICdPcHRpb24gMycgfVxuICAgICAgXSxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwWicpLFxuICAgICAgZW5kVGltZTogbmV3IERhdGUoJzIwMjUtMTItMzFUMjM6NTk6NTlaJyksXG4gICAgICBjcmVhdGVkQnk6ICdhZG1pbi11c2VyJyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwWicpLFxuICAgICAgdm90aW5nQ29uZmlnOiB7XG4gICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogZmFsc2UsXG4gICAgICAgIG1heENob2ljZXM6IDEsXG4gICAgICAgIHJlcXVpcmVWZXJpZmljYXRpb246IGZhbHNlLFxuICAgICAgICBxdWFkcmF0aWNDcmVkaXRzOiAxMDAsXG4gICAgICAgIHJhbmdlTWluOiAwLFxuICAgICAgICByYW5nZU1heDogMTBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9ja1ZvdGVEYXRhID0ge1xuICAgICAgaWQ6ICd2b3RlLTEyMycsXG4gICAgICBwb2xsSWQ6ICd0ZXN0LXBvbGwtMTIzJyxcbiAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICBjaG9pY2U6IDAsXG4gICAgICBwcml2YWN5TGV2ZWw6ICdwdWJsaWMnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgYXVkaXRSZWNlaXB0OiAnYXVkaXQtMTIzJ1xuICAgIH07XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYXNpYyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Rlc3Rpbmcgdm90ZSB2YWxpZGF0aW9uLi4uJyk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGlvbiByZXN1bHQ6JywgdmFsaWRhdGlvbik7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24ucmVxdWlyZXNBdXRoZW50aWNhdGlvbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnJlcXVpcmVzVG9rZW5zKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IG51bGwgdm90ZSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobnVsbCBhcyBhbnksIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1ZvdGUgZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgdW5kZWZpbmVkIHZvdGUgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKHVuZGVmaW5lZCBhcyBhbnksIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1ZvdGUgZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgbm9uLW9iamVjdCB2b3RlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZSgnaW52YWxpZCcgYXMgYW55LCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdWb3RlIGRhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IG51bGwgcG9sbCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBudWxsIGFzIGFueSwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdQb2xsIGRhdGEgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHBvbGwgZGF0YSB3aXRob3V0IGlkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBpZDogJycgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGludmFsaWRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0ludmFsaWQgcG9sbCBkYXRhJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBwb2xsIGRhdGEgd2l0aG91dCB2b3RpbmcgbWV0aG9kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyB2b3RpbmdNZXRob2Q6IHVuZGVmaW5lZCBhcyBhbnkgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGludmFsaWRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0ludmFsaWQgcG9sbCBkYXRhJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCdXNpbmVzcyBSdWxlcyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgZm9yIGluYWN0aXZlIHBvbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbmFjdGl2ZVBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBzdGF0dXM6ICdjbG9zZWQnIGFzIGNvbnN0IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBpbmFjdGl2ZVBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUG9sbCBpcyBub3QgYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIGZvciBkcmFmdCBwb2xsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZHJhZnRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgc3RhdHVzOiAnZHJhZnQnIGFzIGNvbnN0IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBkcmFmdFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnUG9sbCBpcyBub3QgYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIGZvciBleHBpcmVkIHBvbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBpcmVkUG9sbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tQb2xsLCB7IFxuICAgICAgICBlbmRUaW1lOiBuZXcgRGF0ZSgnMjAyNC0xMi0zMVQyMzo1OTo1OVonKSAvLyBQYXN0IGRhdGVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBleHBpcmVkUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdQb2xsIGhhcyBlbmRlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhY2NlcHQgdm90ZSBmb3IgcG9sbCB3aXRob3V0IGVuZCB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBlbmRUaW1lLCAuLi5ub0VuZFRpbWVQb2xsIH0gPSBtb2NrUG9sbDtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbm9FbmRUaW1lUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSBmb3IgbG9ja2VkIHBvbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2NrZWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIGxvY2tlZEF0OiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQxMjowMDowMFonKSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBsb2NrZWRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1BvbGwgaXMgbG9ja2VkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTaW5nbGUgQ2hvaWNlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB2YWxpZCBzaW5nbGUgY2hvaWNlIHZvdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbWlzc2luZyBjaG9pY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNob2ljZSwgLi4uaW52YWxpZFZvdGUgfSA9IG1vY2tWb3RlRGF0YTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdDaG9pY2UgaXMgcmVxdWlyZWQgZm9yIHNpbmdsZSBjaG9pY2Ugdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbnVsbCBjaG9pY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBjaG9pY2U6IG51bGwgYXMgYW55IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0Nob2ljZSBpcyByZXF1aXJlZCBmb3Igc2luZ2xlIGNob2ljZSB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBub24taW50ZWdlciBjaG9pY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBjaG9pY2U6IDEuNSBhcyBhbnkgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQ2hvaWNlIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbmVnYXRpdmUgY2hvaWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgY2hvaWNlOiAtMSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdDaG9pY2UgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBjaG9pY2UgZXhjZWVkaW5nIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBjaG9pY2U6IDUgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQ2hvaWNlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBcHByb3ZhbCBWb3RpbmcgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tQb2xsLnZvdGluZ01ldGhvZCA9ICdhcHByb3ZhbCc7XG4gICAgICBtb2NrUG9sbC52b3RpbmdDb25maWcgPSB7XG4gICAgICAgIC4uLm1vY2tQb2xsLnZvdGluZ0NvbmZpZyxcbiAgICAgICAgbWF4Q2hvaWNlczogMywgLy8gQWxsb3cgbXVsdGlwbGUgYXBwcm92YWxzXG4gICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgY2hvaWNlLCAuLi5hcHByb3ZhbFZvdGVEYXRhIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBtb2NrVm90ZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBhcHByb3ZhbFZvdGVEYXRhLCB7XG4gICAgICAgIGFwcHJvdmFsczogWzAsIDFdXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgYXBwcm92YWwgdm90ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBtaXNzaW5nIGFwcHJvdmFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYXBwcm92YWxzLCAuLi5pbnZhbGlkVm90ZSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FwcHJvdmFscyBhcnJheSBpcyByZXF1aXJlZCBmb3IgYXBwcm92YWwgdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggZW1wdHkgYXBwcm92YWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgYXBwcm92YWxzOiBbXSB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBdCBsZWFzdCBvbmUgb3B0aW9uIG11c3QgYmUgYXBwcm92ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBub24tYXJyYXkgYXBwcm92YWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgYXBwcm92YWxzOiAnaW52YWxpZCcgYXMgYW55IH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FwcHJvdmFscyBhcnJheSBpcyByZXF1aXJlZCBmb3IgYXBwcm92YWwgdm90aW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggaW52YWxpZCBhcHByb3ZhbCBpbmRpY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgYXBwcm92YWxzOiBbMCwgNV0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXBwcm92YWwgaW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBkdXBsaWNhdGUgYXBwcm92YWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgYXBwcm92YWxzOiBbMCwgMF0gfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnRHVwbGljYXRlIGFwcHJvdmFscyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVzcGVjdCBtYXggY2hvaWNlcyBsaW1pdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxpbWl0ZWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgdm90aW5nQ29uZmlnOiBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbC52b3RpbmdDb25maWcsIHsgbWF4Q2hvaWNlczogMSB9KSB9KTtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IGFwcHJvdmFsczogWzAsIDFdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIGxpbWl0ZWRQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ01heGltdW0gMSBhcHByb3ZhbHMgYWxsb3dlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmFua2VkIENob2ljZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1BvbGwudm90aW5nTWV0aG9kID0gJ3JhbmtlZCc7XG4gICAgICBjb25zdCB7IGNob2ljZSwgYXBwcm92YWxzLCAuLi5yYW5rZWRWb3RlRGF0YSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgbW9ja1ZvdGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgcmFua2VkVm90ZURhdGEsIHtcbiAgICAgICAgcmFua2luZ3M6IFswLCAxLCAyXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHJhbmtlZCB2b3RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG1pc3NpbmcgcmFua2luZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJhbmtpbmdzLCAuLi5pbnZhbGlkVm90ZSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1JhbmtpbmdzIGFycmF5IGlzIHJlcXVpcmVkIGZvciByYW5rZWQgY2hvaWNlIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIGluY29tcGxldGUgcmFua2luZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyByYW5raW5nczogWzAsIDFdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FsbCBvcHRpb25zIG11c3QgYmUgcmFua2VkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggaW52YWxpZCByYW5raW5nIGluZGljZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyByYW5raW5nczogWzAsIDEsIDVdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1JhbmtpbmcgaW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBkdXBsaWNhdGUgcmFua2luZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyByYW5raW5nczogWzAsIDAsIDFdIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0R1cGxpY2F0ZSByYW5raW5ncyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1F1YWRyYXRpYyBWb3RpbmcgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tQb2xsLnZvdGluZ01ldGhvZCA9ICdxdWFkcmF0aWMnO1xuICAgICAgY29uc3QgeyBjaG9pY2UsIGFwcHJvdmFscywgcmFua2luZ3MsIC4uLnF1YWRyYXRpY1ZvdGVEYXRhIH0gPSBtb2NrVm90ZURhdGE7XG4gICAgICBtb2NrVm90ZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBxdWFkcmF0aWNWb3RlRGF0YSwge1xuICAgICAgICBhbGxvY2F0aW9uczoge1xuICAgICAgICAgICcwJzogNSxcbiAgICAgICAgICAnMSc6IDNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHF1YWRyYXRpYyB2b3RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG1pc3NpbmcgYWxsb2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGFsbG9jYXRpb25zLCAuLi5pbnZhbGlkVm90ZSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FsbG9jYXRpb25zIG9iamVjdCBpcyByZXF1aXJlZCBmb3IgcXVhZHJhdGljIHZvdGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5lZ2F0aXZlIGFsbG9jYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIGFsbG9jYXRpb25zOiB7ICcwJzogLTUgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FsbCBhbGxvY2F0aW9ucyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgdm90ZSB3aXRoIG5vbi1pbnRlZ2VyIGFsbG9jYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIGFsbG9jYXRpb25zOiB7ICcwJzogNS41IH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdBbGwgYWxsb2NhdGlvbnMgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlcnMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgZXhjZWVkaW5nIGNyZWRpdCBsaW1pdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRWb3RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1ZvdGVEYXRhLCB7IFxuICAgICAgICBhbGxvY2F0aW9uczogeyAnMCc6IDExIH0gLy8gMTFeMiA9IDEyMSA+IDEwMFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9Db250YWluKCdleGNlZWRzIGF2YWlsYWJsZSBjcmVkaXRzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbm8gYWxsb2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgYWxsb2NhdGlvbnM6IHsgJzAnOiAwLCAnMSc6IDAsICcyJzogMCB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXQgbGVhc3Qgb25lIG9wdGlvbiBtdXN0IHJlY2VpdmUgdm90ZXMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhbmdlIFZvdGluZyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1BvbGwudm90aW5nTWV0aG9kID0gJ3JhbmdlJztcbiAgICAgIGNvbnN0IHsgY2hvaWNlLCBhcHByb3ZhbHMsIHJhbmtpbmdzLCBhbGxvY2F0aW9ucywgLi4ucmFuZ2VWb3RlRGF0YSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgbW9ja1ZvdGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgcmFuZ2VWb3RlRGF0YSwge1xuICAgICAgICByYXRpbmdzOiB7XG4gICAgICAgICAgJzAnOiA4LFxuICAgICAgICAgICcxJzogNixcbiAgICAgICAgICAnMic6IDRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHJhbmdlIHZvdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggbWlzc2luZyByYXRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByYXRpbmdzLCAuLi5pbnZhbGlkVm90ZSB9ID0gbW9ja1ZvdGVEYXRhO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ1JhdGluZ3Mgb2JqZWN0IGlzIHJlcXVpcmVkIGZvciByYW5nZSB2b3RpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCByYXRpbmdzIG91dHNpZGUgcmFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVm90ZSA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tWb3RlRGF0YSwgeyBcbiAgICAgICAgcmF0aW5nczogeyAnMCc6IDE1IH0gXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKGludmFsaWRWb3RlLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdSYXRpbmcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2b3RlIHdpdGggaW5jb21wbGV0ZSByYXRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIHJhdGluZ3M6IHsgJzAnOiA4LCAnMSc6IDYgfSBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUoaW52YWxpZFZvdGUsIG1vY2tQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uZXJyb3IpLnRvQmUoJ0FsbCBvcHRpb25zIG11c3QgYmUgcmF0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZvdGUgd2l0aCBhbGwgbWluaW11bSByYXRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFZvdGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrVm90ZURhdGEsIHsgXG4gICAgICAgIHJhdGluZ3M6IHsgJzAnOiAwLCAnMSc6IDAsICcyJzogMCB9IFxuICAgICAgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShpbnZhbGlkVm90ZSwgbW9ja1BvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXQgbGVhc3Qgb25lIG9wdGlvbiBtdXN0IGhhdmUgYSByYXRpbmcgYWJvdmUgdGhlIG1pbmltdW0nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5IFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIHdoZW4gdmVyaWZpY2F0aW9uIGlzIHJlcXVpcmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmVyaWZpZWRQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIHZvdGluZ0NvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwudm90aW5nQ29uZmlnLCB7IHJlcXVpcmVWZXJpZmljYXRpb246IHRydWUgfSkgXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVWb3RlKG1vY2tWb3RlRGF0YSwgdmVyaWZpZWRQb2xsKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnQXV0aGVudGljYXRpb24gcmVxdWlyZWQgZm9yIHRoaXMgcG9sbCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhY2NlcHQgdm90ZSB3aGVuIHZlcmlmaWNhdGlvbiBpcyBub3QgcmVxdWlyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIG1vY2tQb2xsKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2hlY2sgdHJ1c3QgdGllciByZXF1aXJlbWVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBoaWdoVHJ1c3RQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIHZvdGluZ0NvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwudm90aW5nQ29uZmlnLCB7IFxuICAgICAgICAgIG1pblRydXN0VGllcjogJ1QyJyxcbiAgICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IHRydWUgLy8gQWxsb3cgbXVsdGlwbGUgdm90ZXMgdG8gYXZvaWQgZXhpc3Rpbmcgdm90ZSBjaGVja1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgbm8gZXhpc3Rpbmcgdm90ZSAodXNlciBjYW4gdm90ZSlcbiAgICAgIHdoZW4oKS50YWJsZSgndm90ZXMnKS5vcCgnc2VsZWN0JykuZXEoJ3BvbGxfaWQnLCAndGVzdC1wb2xsLTEyMycpLmVxKCd1c2VyX2lkJywgJ3VzZXItMScpLnJldHVybnNMaXN0KFtdKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBnZXRVc2VyVHJ1c3RUaWVyIHRvIHJldHVybiBUMSAoaW5zdWZmaWNpZW50KVxuICAgICAgd2hlbigpLnRhYmxlKCd1c2VyX3Byb2ZpbGVzJykub3AoJ3NlbGVjdCcpLnNlbGVjdCgndHJ1c3RfdGllcicpLmVxKCd1c2VyX2lkJywgJ3VzZXItMScpLnJldHVybnNTaW5nbGUoeyB0cnVzdF90aWVyOiAnVDEnIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGhpZ2hUcnVzdFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnSW5zdWZmaWNpZW50IHRydXN0IHRpZXIgZm9yIHRoaXMgcG9sbCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhY2NlcHQgdm90ZSB3aXRoIHN1ZmZpY2llbnQgdHJ1c3QgdGllcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZ2hUcnVzdFBvbGwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbCwgeyBcbiAgICAgICAgdm90aW5nQ29uZmlnOiBPYmplY3QuYXNzaWduKHt9LCBtb2NrUG9sbC52b3RpbmdDb25maWcsIHsgXG4gICAgICAgICAgbWluVHJ1c3RUaWVyOiAnVDEnLFxuICAgICAgICAgIGFsbG93TXVsdGlwbGVWb3RlczogdHJ1ZSAvLyBBbGxvdyBtdWx0aXBsZSB2b3RlcyB0byBhdm9pZCBleGlzdGluZyB2b3RlIGNoZWNrXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBnZXRVc2VyVHJ1c3RUaWVyIHRvIHJldHVybiBUMiAoc3VmZmljaWVudClcbiAgICAgIHdoZW4oKS50YWJsZSgndXNlcl9wcm9maWxlcycpLm9wKCdzZWxlY3QnKS5zZWxlY3QoJ3RydXN0X3RpZXInKS5lcSgndXNlcl9pZCcsICd1c2VyLTEnKS5yZXR1cm5zU2luZ2xlKHsgdHJ1c3RfdGllcjogJ1QyJyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBoaWdoVHJ1c3RQb2xsLCAndXNlci0xJyk7XG4gICAgICBcbiAgICAgIC8vIFRoZSB2YWxpZGF0aW9uIHNob3VsZCBwYXNzIHNpbmNlIFQyID49IFQxXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgYSBtZXRob2QgdG8gdGhyb3cgYW4gZXJyb3JcbiAgICAgIGNvbnN0IG9yaWdpbmFsVmFsaWRhdGVCYXNpY1ZvdGVEYXRhID0gKHZhbGlkYXRvciBhcyBhbnkpLnZhbGlkYXRlQmFzaWNWb3RlRGF0YTtcbiAgICAgICh2YWxpZGF0b3IgYXMgYW55KS52YWxpZGF0ZUJhc2ljVm90ZURhdGEgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0aW9uIGVycm9yJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVZvdGUobW9ja1ZvdGVEYXRhLCBtb2NrUG9sbCwgJ3VzZXItMScpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9yKS50b0JlKCdWYWxpZGF0aW9uIGVycm9yJyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICAodmFsaWRhdG9yIGFzIGFueSkudmFsaWRhdGVCYXNpY1ZvdGVEYXRhID0gb3JpZ2luYWxWYWxpZGF0ZUJhc2ljVm90ZURhdGE7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyB2YWxpZGF0b3IgaW5zdGFuY2UgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggb3RoZXIgdGVzdHNcbiAgICAgIGNvbnN0IHRlc3RWYWxpZGF0b3IgPSBuZXcgVm90ZVZhbGlkYXRvcigpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHRoZSBnZXRVc2VyVHJ1c3RUaWVyIG1ldGhvZCB0byByZXR1cm4gVDAgKGRlZmF1bHQgZmFsbGJhY2spXG4gICAgICBjb25zdCBvcmlnaW5hbEdldFVzZXJUcnVzdFRpZXIgPSAodGVzdFZhbGlkYXRvciBhcyBhbnkpLmdldFVzZXJUcnVzdFRpZXI7XG4gICAgICBjb25zdCBtb2NrR2V0VXNlclRydXN0VGllciA9IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPCgpID0+IFByb21pc2U8c3RyaW5nPj47XG4gICAgICBtb2NrR2V0VXNlclRydXN0VGllci5tb2NrUmVzb2x2ZWRWYWx1ZSgnVDAnKTtcbiAgICAgICh0ZXN0VmFsaWRhdG9yIGFzIGFueSkuZ2V0VXNlclRydXN0VGllciA9IG1vY2tHZXRVc2VyVHJ1c3RUaWVyO1xuXG4gICAgICBjb25zdCBoaWdoVHJ1c3RQb2xsID0gT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwsIHsgXG4gICAgICAgIHZvdGluZ0NvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgbW9ja1BvbGwudm90aW5nQ29uZmlnLCB7IFxuICAgICAgICAgIG1pblRydXN0VGllcjogJ1QxJyxcbiAgICAgICAgICBhbGxvd011bHRpcGxlVm90ZXM6IHRydWUgLy8gQWxsb3cgbXVsdGlwbGUgdm90ZXMgdG8gYXZvaWQgZXhpc3Rpbmcgdm90ZSBjaGVja1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0ZXN0VmFsaWRhdG9yLnZhbGlkYXRlVm90ZShtb2NrVm90ZURhdGEsIGhpZ2hUcnVzdFBvbGwsICd1c2VyLTEnKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGZhbGwgYmFjayB0byBkZWZhdWx0IHRydXN0IHRpZXIgKFQwKSBhbmQgZmFpbFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5lcnJvcikudG9CZSgnSW5zdWZmaWNpZW50IHRydXN0IHRpZXIgZm9yIHRoaXMgcG9sbCcpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgKHRlc3RWYWxpZGF0b3IgYXMgYW55KS5nZXRVc2VyVHJ1c3RUaWVyID0gb3JpZ2luYWxHZXRVc2VyVHJ1c3RUaWVyO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZGV2TG9nIiwiZm4iLCJtb2NrU2V0dXAiLCJnZXRNUyIsIndoZW4iLCJjbGllbnQiLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJnZXRTdXBhYmFzZVNlcnZlckNsaWVudCIsImRlc2NyaWJlIiwidmFsaWRhdG9yIiwibW9ja1BvbGwiLCJtb2NrVm90ZURhdGEiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIlZvdGVWYWxpZGF0b3IiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2b3RpbmdNZXRob2QiLCJvcHRpb25zIiwidGV4dCIsInN0YXR1cyIsInN0YXJ0VGltZSIsIkRhdGUiLCJlbmRUaW1lIiwiY3JlYXRlZEJ5IiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0Iiwidm90aW5nQ29uZmlnIiwiYWxsb3dNdWx0aXBsZVZvdGVzIiwibWF4Q2hvaWNlcyIsInJlcXVpcmVWZXJpZmljYXRpb24iLCJxdWFkcmF0aWNDcmVkaXRzIiwicmFuZ2VNaW4iLCJyYW5nZU1heCIsInBvbGxJZCIsInVzZXJJZCIsImNob2ljZSIsInByaXZhY3lMZXZlbCIsInRpbWVzdGFtcCIsImF1ZGl0UmVjZWlwdCIsImFmdGVyRWFjaCIsIml0IiwiY29uc29sZSIsImxvZyIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZVZvdGUiLCJleHBlY3QiLCJ2YWxpZCIsInRvQmUiLCJyZXF1aXJlc0F1dGhlbnRpY2F0aW9uIiwicmVxdWlyZXNUb2tlbnMiLCJpc1ZhbGlkIiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJpbnZhbGlkUG9sbCIsIk9iamVjdCIsImFzc2lnbiIsImluYWN0aXZlUG9sbCIsImRyYWZ0UG9sbCIsImV4cGlyZWRQb2xsIiwibm9FbmRUaW1lUG9sbCIsImxvY2tlZFBvbGwiLCJsb2NrZWRBdCIsImludmFsaWRWb3RlIiwiYXBwcm92YWxWb3RlRGF0YSIsImFwcHJvdmFscyIsImxpbWl0ZWRQb2xsIiwicmFua2VkVm90ZURhdGEiLCJyYW5raW5ncyIsInF1YWRyYXRpY1ZvdGVEYXRhIiwiYWxsb2NhdGlvbnMiLCJ0b0NvbnRhaW4iLCJyYW5nZVZvdGVEYXRhIiwicmF0aW5ncyIsInZlcmlmaWVkUG9sbCIsImhpZ2hUcnVzdFBvbGwiLCJtaW5UcnVzdFRpZXIiLCJ0YWJsZSIsIm9wIiwiZXEiLCJyZXR1cm5zTGlzdCIsInNlbGVjdCIsInJldHVybnNTaW5nbGUiLCJ0cnVzdF90aWVyIiwib3JpZ2luYWxWYWxpZGF0ZUJhc2ljVm90ZURhdGEiLCJ2YWxpZGF0ZUJhc2ljVm90ZURhdGEiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsInRlc3RWYWxpZGF0b3IiLCJvcmlnaW5hbEdldFVzZXJUcnVzdFRpZXIiLCJnZXRVc2VyVHJ1c3RUaWVyIiwibW9ja0dldFVzZXJUcnVzdFRpZXIiLCJtb2Nr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