965f6deb0558baaa85c497b46f12c959
/**
 * Performance Tests - Simplified
 * 
 * Tests that the application can handle concurrent operations without crashing.
 * Focuses on functionality, not timing measurements.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Mock fetch globally
const mockFetch = _globals.jest.fn();
global.fetch = mockFetch;
(0, _globals.describe)('Load Testing', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.describe)('Concurrent Operations', ()=>{
        (0, _globals.it)('should handle 1000 concurrent users', async ()=>{
            const concurrentUsers = 1000;
            // Simple mock that just resolves immediately
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({
                            success: true,
                            data: []
                        })
                }));
            // Test that we can handle many concurrent operations without crashing
            const promises = Array.from({
                length: concurrentUsers
            }, (_, i)=>fetch(`/api/feeds`).then((response)=>({
                        userId: `user-${i}`,
                        status: response.status
                    })));
            const responses = await Promise.all(promises);
            // Basic assertions - just verify we can handle the load
            (0, _globals.expect)(responses.length).toBe(concurrentUsers);
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
            });
        });
        (0, _globals.it)('should handle 5000 concurrent feed requests', async ()=>{
            const feedRequests = 5000;
            // Simple mock
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(Array.from({
                            length: 100
                        }, (_, i)=>({
                                id: i
                            })))
                }));
            // Test concurrent operations
            const promises = Array.from({
                length: feedRequests
            }, ()=>fetch('/api/feeds').then((response)=>response.json()));
            const responses = await Promise.all(promises);
            // Basic assertions
            (0, _globals.expect)(responses.length).toBe(feedRequests);
            responses.forEach((response)=>{
                (0, _globals.expect)(Array.isArray(response)).toBe(true);
                (0, _globals.expect)(response.length).toBe(100);
            });
        });
        (0, _globals.it)('should handle mixed concurrent operations', async ()=>{
            const operations = [
                {
                    type: 'feed',
                    count: 1000
                },
                {
                    type: 'auth',
                    count: 500
                },
                {
                    type: 'vote',
                    count: 200
                }
            ];
            // Mock different endpoints
            mockFetch.mockImplementation((url)=>{
                if (url.includes('/api/feeds')) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                feeds: []
                            })
                    });
                }
                if (url.includes('/api/auth/login')) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                token: 'auth-token'
                            })
                    });
                }
                if (url.includes('/api/votes')) {
                    return Promise.resolve({
                        ok: true,
                        status: 200,
                        json: ()=>Promise.resolve({
                                success: true
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({})
                });
            });
            // Execute all operations concurrently
            const allRequests = operations.flatMap((op)=>Array.from({
                    length: op.count
                }, (_, i)=>({
                        type: op.type,
                        id: `${op.type}-${i}`,
                        endpoint: op.type === 'feed' ? '/api/feeds' : op.type === 'auth' ? '/api/auth/login' : '/api/votes'
                    })));
            const responses = await Promise.all(allRequests.map(async (request)=>{
                const response = await fetch(request.endpoint);
                return {
                    ...request,
                    status: response.status
                };
            }));
            // Basic assertions
            (0, _globals.expect)(responses.length).toBe(1700); // Total operations
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
            });
        });
    });
    (0, _globals.describe)('Database Operations', ()=>{
        (0, _globals.it)('should handle large dataset queries', async ()=>{
            const queryCount = 100;
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(Array.from({
                            length: 100
                        }, (_, i)=>({
                                id: i
                            })))
                }));
            const promises = Array.from({
                length: queryCount
            }, ()=>fetch('/api/data').then((response)=>response.json()));
            const results = await Promise.all(promises);
            (0, _globals.expect)(results.length).toBe(queryCount);
            results.forEach((result)=>{
                (0, _globals.expect)(Array.isArray(result)).toBe(true);
                (0, _globals.expect)(result.length).toBe(100);
            });
        });
        (0, _globals.it)('should handle concurrent database writes', async ()=>{
            const writeOperations = 500;
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({
                            success: true
                        })
                }));
            const promises = Array.from({
                length: writeOperations
            }, (_, i)=>fetch('/api/write', {
                    method: 'POST',
                    body: JSON.stringify({
                        id: i,
                        data: `test-${i}`
                    })
                }).then((response)=>response.json()));
            const results = await Promise.all(promises);
            (0, _globals.expect)(results.length).toBe(writeOperations);
            results.forEach((result)=>{
                (0, _globals.expect)(result.success).toBe(true);
            });
        });
    });
    (0, _globals.describe)('API Response Testing', ()=>{
        (0, _globals.it)('should maintain consistent API responses under load', async ()=>{
            const requestsPerEndpoint = 100;
            const endpoints = [
                '/api/feeds',
                '/api/polls',
                '/api/users'
            ];
            mockFetch.mockImplementation((url)=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({
                            endpoint: url,
                            success: true
                        })
                }));
            const allRequests = endpoints.flatMap((endpoint)=>Array.from({
                    length: requestsPerEndpoint
                }, ()=>fetch(endpoint).then((response)=>response.json())));
            const responses = await Promise.all(allRequests);
            (0, _globals.expect)(responses.length).toBe(300); // 3 endpoints * 100 requests
            responses.forEach((response)=>{
                (0, _globals.expect)(response.success).toBe(true);
                (0, _globals.expect)(endpoints).toContain(response.endpoint);
            });
        });
    });
    (0, _globals.describe)('Stress Testing', ()=>{
        (0, _globals.it)('should handle resource exhaustion gracefully', async ()=>{
            const maxConcurrentRequests = 2000;
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve({
                            success: true
                        })
                }));
            // Test that we can handle a large number of concurrent requests
            const promises = Array.from({
                length: maxConcurrentRequests
            }, (_, i)=>fetch(`/api/stress-test-${i}`).then((response)=>({
                        id: i,
                        status: response.status
                    })));
            const responses = await Promise.all(promises);
            (0, _globals.expect)(responses.length).toBe(maxConcurrentRequests);
            const successCount = responses.filter((r)=>r.status === 200).length;
            (0, _globals.expect)(successCount).toBeGreaterThan(0); // At least some should succeed
        });
        (0, _globals.it)('should handle memory-intensive operations', async ()=>{
            const dataSize = 1000;
            mockFetch.mockImplementation(()=>Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(Array.from({
                            length: dataSize
                        }, (_, i)=>({
                                id: i,
                                data: `item-${i}`.repeat(100) // Large data strings
                            })))
                }));
            const promises = Array.from({
                length: 10
            }, ()=>fetch('/api/large-data').then((response)=>response.json()));
            const results = await Promise.all(promises);
            (0, _globals.expect)(results.length).toBe(10);
            results.forEach((result)=>{
                (0, _globals.expect)(Array.isArray(result)).toBe(true);
                (0, _globals.expect)(result.length).toBe(dataSize);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvcGVyZm9ybWFuY2UvbG9hZC10ZXN0aW5nLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBUZXN0cyAtIFNpbXBsaWZpZWRcbiAqIFxuICogVGVzdHMgdGhhdCB0aGUgYXBwbGljYXRpb24gY2FuIGhhbmRsZSBjb25jdXJyZW50IG9wZXJhdGlvbnMgd2l0aG91dCBjcmFzaGluZy5cbiAqIEZvY3VzZXMgb24gZnVuY3Rpb25hbGl0eSwgbm90IHRpbWluZyBtZWFzdXJlbWVudHMuXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcblxuLy8gTW9jayBmZXRjaCBnbG9iYWxseVxuY29uc3QgbW9ja0ZldGNoID0gamVzdC5mbigpO1xuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xuXG5kZXNjcmliZSgnTG9hZCBUZXN0aW5nJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmN1cnJlbnQgT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSAxMDAwIGNvbmN1cnJlbnQgdXNlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25jdXJyZW50VXNlcnMgPSAxMDAwO1xuICAgICAgXG4gICAgICAvLyBTaW1wbGUgbW9jayB0aGF0IGp1c3QgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogW10gfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFRlc3QgdGhhdCB3ZSBjYW4gaGFuZGxlIG1hbnkgY29uY3VycmVudCBvcGVyYXRpb25zIHdpdGhvdXQgY3Jhc2hpbmdcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29uY3VycmVudFVzZXJzIH0sIChfLCBpKSA9PiBcbiAgICAgICAgZmV0Y2goYC9hcGkvZmVlZHNgKS50aGVuKHJlc3BvbnNlID0+ICh7XG4gICAgICAgICAgdXNlcklkOiBgdXNlci0ke2l9YCxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgLy8gQmFzaWMgYXNzZXJ0aW9ucyAtIGp1c3QgdmVyaWZ5IHdlIGNhbiBoYW5kbGUgdGhlIGxvYWRcbiAgICAgIGV4cGVjdChyZXNwb25zZXMubGVuZ3RoKS50b0JlKGNvbmN1cnJlbnRVc2Vycyk7XG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgNTAwMCBjb25jdXJyZW50IGZlZWQgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmZWVkUmVxdWVzdHMgPSA1MDAwO1xuICAgICAgXG4gICAgICAvLyBTaW1wbGUgbW9ja1xuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoeyBpZDogaSB9KSkpXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBUZXN0IGNvbmN1cnJlbnQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmZWVkUmVxdWVzdHMgfSwgKCkgPT4gXG4gICAgICAgIGZldGNoKCcvYXBpL2ZlZWRzJykudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIC8vIEJhc2ljIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXNwb25zZXMubGVuZ3RoKS50b0JlKGZlZWRSZXF1ZXN0cyk7XG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmxlbmd0aCkudG9CZSgxMDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXhlZCBjb25jdXJyZW50IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gW1xuICAgICAgICB7IHR5cGU6ICdmZWVkJywgY291bnQ6IDEwMDAgfSxcbiAgICAgICAgeyB0eXBlOiAnYXV0aCcsIGNvdW50OiA1MDAgfSxcbiAgICAgICAgeyB0eXBlOiAndm90ZScsIGNvdW50OiAyMDAgfVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBkaWZmZXJlbnQgZW5kcG9pbnRzXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwpID0+IHtcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2FwaS9mZWVkcycpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZmVlZHM6IFtdIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2FwaS9hdXRoL2xvZ2luJykpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyB0b2tlbjogJ2F1dGgtdG9rZW4nIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2FwaS92b3RlcycpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBvazogdHJ1ZSwgc3RhdHVzOiAyMDAsIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7fSkgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBhbGwgb3BlcmF0aW9ucyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IGFsbFJlcXVlc3RzID0gb3BlcmF0aW9ucy5mbGF0TWFwKG9wID0+IFxuICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBvcC5jb3VudCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBvcC50eXBlLFxuICAgICAgICAgIGlkOiBgJHtvcC50eXBlfS0ke2l9YCxcbiAgICAgICAgICBlbmRwb2ludDogb3AudHlwZSA9PT0gJ2ZlZWQnID8gJy9hcGkvZmVlZHMnIDogXG4gICAgICAgICAgICAgICAgICAgb3AudHlwZSA9PT0gJ2F1dGgnID8gJy9hcGkvYXV0aC9sb2dpbicgOiAnL2FwaS92b3RlcydcbiAgICAgICAgfSkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgYWxsUmVxdWVzdHMubWFwKGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LmVuZHBvaW50KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIEJhc2ljIGFzc2VydGlvbnNcbiAgICAgIGV4cGVjdChyZXNwb25zZXMubGVuZ3RoKS50b0JlKDE3MDApOyAvLyBUb3RhbCBvcGVyYXRpb25zXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGF0YWJhc2UgT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBkYXRhc2V0IHF1ZXJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUNvdW50ID0gMTAwO1xuICAgICAgXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+ICh7IGlkOiBpIH0pKSlcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcXVlcnlDb3VudCB9LCAoKSA9PiBcbiAgICAgICAgZmV0Y2goJy9hcGkvZGF0YScpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKHF1ZXJ5Q291bnQpO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3VsdCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDEwMCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgZGF0YWJhc2Ugd3JpdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gNTAwO1xuICAgICAgXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogd3JpdGVPcGVyYXRpb25zIH0sIChfLCBpKSA9PiBcbiAgICAgICAgZmV0Y2goJy9hcGkvd3JpdGUnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpZDogaSwgZGF0YTogYHRlc3QtJHtpfWAgfSlcbiAgICAgICAgfSkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmUod3JpdGVPcGVyYXRpb25zKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FQSSBSZXNwb25zZSBUZXN0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gY29uc2lzdGVudCBBUEkgcmVzcG9uc2VzIHVuZGVyIGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0c1BlckVuZHBvaW50ID0gMTAwO1xuICAgICAgY29uc3QgZW5kcG9pbnRzID0gWycvYXBpL2ZlZWRzJywgJy9hcGkvcG9sbHMnLCAnL2FwaS91c2VycyddO1xuICAgICAgXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGVuZHBvaW50OiB1cmwsIHN1Y2Nlc3M6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGFsbFJlcXVlc3RzID0gZW5kcG9pbnRzLmZsYXRNYXAoZW5kcG9pbnQgPT4gXG4gICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IHJlcXVlc3RzUGVyRW5kcG9pbnQgfSwgKCkgPT4gXG4gICAgICAgICAgZmV0Y2goZW5kcG9pbnQpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxSZXF1ZXN0cyk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZXMubGVuZ3RoKS50b0JlKDMwMCk7IC8vIDMgZW5kcG9pbnRzICogMTAwIHJlcXVlc3RzXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoZW5kcG9pbnRzKS50b0NvbnRhaW4ocmVzcG9uc2UuZW5kcG9pbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdHJlc3MgVGVzdGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXNvdXJjZSBleGhhdXN0aW9uIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYXhDb25jdXJyZW50UmVxdWVzdHMgPSAyMDAwO1xuICAgICAgXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHN1Y2Nlc3M6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFRlc3QgdGhhdCB3ZSBjYW4gaGFuZGxlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbWF4Q29uY3VycmVudFJlcXVlc3RzIH0sIChfLCBpKSA9PiBcbiAgICAgICAgZmV0Y2goYC9hcGkvc3RyZXNzLXRlc3QtJHtpfWApLnRoZW4ocmVzcG9uc2UgPT4gKHtcbiAgICAgICAgICBpZDogaSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlcy5sZW5ndGgpLnRvQmUobWF4Q29uY3VycmVudFJlcXVlc3RzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NDb3VudCA9IHJlc3BvbnNlcy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gMjAwKS5sZW5ndGg7XG4gICAgICBleHBlY3Qoc3VjY2Vzc0NvdW50KS50b0JlR3JlYXRlclRoYW4oMCk7IC8vIEF0IGxlYXN0IHNvbWUgc2hvdWxkIHN1Y2NlZWRcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1lbW9yeS1pbnRlbnNpdmUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gMTAwMDtcbiAgICAgIFxuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoQXJyYXkuZnJvbSh7IGxlbmd0aDogZGF0YVNpemUgfSwgKF8sIGkpID0+ICh7IFxuICAgICAgICAgICAgaWQ6IGksIFxuICAgICAgICAgICAgZGF0YTogYGl0ZW0tJHtpfWAucmVwZWF0KDEwMCkgLy8gTGFyZ2UgZGF0YSBzdHJpbmdzXG4gICAgICAgICAgfSkpKVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoKSA9PiBcbiAgICAgICAgZmV0Y2goJy9hcGkvbGFyZ2UtZGF0YScpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKDEwKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZXN1bHQpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZShkYXRhU2l6ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsibW9ja0ZldGNoIiwiamVzdCIsImZuIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJjb25jdXJyZW50VXNlcnMiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwic3RhdHVzIiwianNvbiIsInN1Y2Nlc3MiLCJkYXRhIiwicHJvbWlzZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRoZW4iLCJyZXNwb25zZSIsInVzZXJJZCIsInJlc3BvbnNlcyIsImFsbCIsImV4cGVjdCIsInRvQmUiLCJmb3JFYWNoIiwiZmVlZFJlcXVlc3RzIiwiaWQiLCJpc0FycmF5Iiwib3BlcmF0aW9ucyIsInR5cGUiLCJjb3VudCIsInVybCIsImluY2x1ZGVzIiwiZmVlZHMiLCJ0b2tlbiIsImFsbFJlcXVlc3RzIiwiZmxhdE1hcCIsIm9wIiwiZW5kcG9pbnQiLCJtYXAiLCJyZXF1ZXN0IiwicXVlcnlDb3VudCIsInJlc3VsdHMiLCJyZXN1bHQiLCJ3cml0ZU9wZXJhdGlvbnMiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcXVlc3RzUGVyRW5kcG9pbnQiLCJlbmRwb2ludHMiLCJ0b0NvbnRhaW4iLCJtYXhDb25jdXJyZW50UmVxdWVzdHMiLCJzdWNjZXNzQ291bnQiLCJmaWx0ZXIiLCJyIiwidG9CZUdyZWF0ZXJUaGFuIiwiZGF0YVNpemUiLCJyZXBlYXQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7O3lCQUVzRDtBQUV2RCxzQkFBc0I7QUFDdEIsTUFBTUEsWUFBWUMsYUFBSSxDQUFDQyxFQUFFO0FBQ3pCQyxPQUFPQyxLQUFLLEdBQUdKO0FBRWZLLElBQUFBLGlCQUFRLEVBQUMsZ0JBQWdCO0lBQ3ZCQyxJQUFBQSxtQkFBVSxFQUFDO1FBQ1RMLGFBQUksQ0FBQ00sYUFBYTtJQUNwQjtJQUVBRixJQUFBQSxpQkFBUSxFQUFDLHlCQUF5QjtRQUNoQ0csSUFBQUEsV0FBRSxFQUFDLHVDQUF1QztZQUN4QyxNQUFNQyxrQkFBa0I7WUFFeEIsNkNBQTZDO1lBQzdDVCxVQUFVVSxrQkFBa0IsQ0FBQyxJQUMzQkMsUUFBUUMsT0FBTyxDQUFDO29CQUNkQyxJQUFJO29CQUNKQyxRQUFRO29CQUNSQyxNQUFNLElBQU1KLFFBQVFDLE9BQU8sQ0FBQzs0QkFBRUksU0FBUzs0QkFBTUMsTUFBTSxFQUFFO3dCQUFDO2dCQUN4RDtZQUdGLHNFQUFzRTtZQUN0RSxNQUFNQyxXQUFXQyxNQUFNQyxJQUFJLENBQUM7Z0JBQUVDLFFBQVFaO1lBQWdCLEdBQUcsQ0FBQ2EsR0FBR0MsSUFDM0RuQixNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUVvQixJQUFJLENBQUNDLENBQUFBLFdBQWEsQ0FBQTt3QkFDcENDLFFBQVEsQ0FBQyxLQUFLLEVBQUVILEdBQUc7d0JBQ25CVCxRQUFRVyxTQUFTWCxNQUFNO29CQUN6QixDQUFBO1lBR0YsTUFBTWEsWUFBWSxN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