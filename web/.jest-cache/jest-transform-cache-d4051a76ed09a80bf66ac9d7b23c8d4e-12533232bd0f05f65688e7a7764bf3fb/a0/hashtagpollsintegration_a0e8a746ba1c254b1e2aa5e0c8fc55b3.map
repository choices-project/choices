{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/features/feeds/lib/hashtag-polls-integration.ts"],"sourcesContent":["/**\n * Hashtag-Polls Integration for Feeds\n * \n * Comprehensive integration of hashtags and polls in the feeds system\n * Features:\n * - Intelligent hashtag-based poll recommendations\n * - Real-time hashtag trending analysis\n * - Poll-hashtag engagement tracking\n * - Personalized feed generation based on hashtag interests\n * - Cross-platform hashtag synchronization\n * \n * Created: January 19, 2025\n * Status: âœ… ACTIVE\n */\n\nimport { getSupabaseServerClient } from '@/utils/supabase/server';\nimport { logger } from '@/lib/utils/logger';\nimport type { \n  UserPreferences\n} from '@/features/civics/lib/types/civics-types';\n\n// Local type definitions\nexport interface PollRecommendation {\n  id?: string; // Alias for pollId for compatibility\n  pollId: string;\n  title: string;\n  description?: string;\n  hashtags: string[];\n  tags?: string[]; // Alias for hashtags for compatibility\n  relevanceScore: number;\n  reason: string;\n  totalVotes?: number;\n  engagementScore?: number;\n  created_at?: string;\n  interestMatches?: string[];\n}\n\n// Enhanced hashtag-polls integration types\nexport interface HashtagPollIntegration {\n  poll_id: string;\n  hashtags: string[];\n  primary_hashtag: string;\n  hashtag_engagement: {\n    total_views: number;\n    hashtag_clicks: number;\n    hashtag_shares: number;\n  };\n  trending_score: number;\n  user_relevance_score: number;\n  feed_priority: number;\n}\n\nexport interface HashtagFeedAnalytics {\n  hashtag: string;\n  poll_count: number;\n  engagement_rate: number;\n  trending_position: number;\n  user_interest_level: number;\n  last_activity: Date;\n}\n\nexport interface PersonalizedHashtagFeed {\n  user_id: string;\n  hashtag_interests: string[];\n  recommended_polls: PollRecommendation[];\n  trending_hashtags: string[];\n  hashtag_analytics: HashtagFeedAnalytics[];\n  feed_score: number;\n  last_updated: Date;\n}\n\n/**\n * Advanced Hashtag-Polls Integration Service\n * \n * Provides comprehensive hashtag-polls integration for feeds\n * with real-time analytics and personalization\n */\nexport class HashtagPollsIntegrationService {\n  private supabase: any;\n  private cache = new Map<string, any>();\n  private cacheTimeout = 5 * 60 * 1000; // 5 minutes\n\n  constructor() {\n    this.initializeSupabase();\n  }\n\n  private async initializeSupabase() {\n    try {\n      this.supabase = await getSupabaseServerClient();\n    } catch (error) {\n      logger.error('Failed to initialize Supabase client:', error as Error);\n      this.supabase = null;\n    }\n  }\n\n  /**\n   * Generate personalized hashtag-based poll feed\n   */\n  async generateHashtagPollFeed(\n    userId: string,\n    userPreferences: UserPreferences,\n    limit = 20\n  ): Promise<PersonalizedHashtagFeed> {\n    try {\n      if (!this.supabase) {\n        throw new Error('Supabase client not initialized');\n      }\n\n      // Get user's hashtag interests\n      const hashtagInterests = await this.getUserHashtagInterests(userId);\n      \n      // Get trending hashtags\n      const trendingHashtags = await this.getTrendingHashtags(10);\n      \n      // Generate poll recommendations based on hashtags\n      const recommendedPolls = await this.getHashtagBasedPollRecommendations(\n        userId,\n        hashtagInterests,\n        limit\n      );\n      \n      // Calculate hashtag analytics\n      const hashtagAnalytics = await this.calculateHashtagAnalytics(\n        hashtagInterests,\n        trendingHashtags\n      );\n      \n      // Calculate overall feed score\n      const feedScore = this.calculateFeedScore(recommendedPolls, hashtagAnalytics);\n      \n      return {\n        user_id: userId,\n        hashtag_interests: hashtagInterests,\n        recommended_polls: recommendedPolls,\n        trending_hashtags: trendingHashtags,\n        hashtag_analytics: hashtagAnalytics,\n        feed_score: feedScore,\n        last_updated: new Date()\n      };\n      \n    } catch (error) {\n      logger.error('Failed to generate hashtag poll feed:', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's followed hashtags - the primary driver for feed autopopulation\n   * This is the core mechanism that drives personalized poll recommendations\n   */\n  private async getUserHashtagInterests(userId: string): Promise<string[]> {\n    try {\n      const cacheKey = `user_followed_hashtags_${userId}`;\n      const cached = this.getCachedData(cacheKey);\n      if (cached) return cached;\n\n      // Get user's explicitly followed hashtags from user_hashtags table\n      const { data: followedHashtags, error: followedError } = await this.supabase\n        .from('user_hashtags')\n        .select(`\n          hashtag_id,\n          hashtags!inner(\n            name,\n            display_name,\n            category\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('is_following', true);\n\n      if (followedError) {\n        logger.warn('Failed to get user followed hashtags:', followedError);\n        // Fallback to engagement-based interests if following data unavailable\n        return await this.getFallbackHashtagInterests(userId);\n      }\n\n      // Extract hashtag names from followed hashtags\n      const followedHashtagNames = followedHashtags?.map((uh: any) => \n        uh.hashtags?.name\n      ).filter(Boolean) || [];\n\n      // If user has no followed hashtags, get trending hashtags as default\n      if (followedHashtagNames.length === 0) {\n        const trendingHashtags = await this.getTrendingHashtags(5);\n        this.setCachedData(cacheKey, trendingHashtags);\n        return trendingHashtags;\n      }\n\n      this.setCachedData(cacheKey, followedHashtagNames);\n      return followedHashtagNames;\n      \n    } catch (error) {\n      logger.error('Failed to get user followed hashtags:', error as Error);\n      return await this.getFallbackHashtagInterests(userId);\n    }\n  }\n\n  /**\n   * Fallback method to get hashtag interests from engagement history\n   * Used when user_hashtags table is not available or user has no followed hashtags\n   */\n  private async getFallbackHashtagInterests(userId: string): Promise<string[]> {\n    try {\n      // Get user's hashtag engagement history as fallback\n      const { data: engagementData, error } = await this.supabase\n        .from('analytics_events')\n        .select('event_data')\n        .eq('user_id', userId)\n        .eq('event_category', 'hashtag')\n        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        logger.warn('Failed to get user hashtag engagement:', error);\n        return [];\n      }\n\n      // Analyze hashtag interests from engagement data\n      const hashtagScores = new Map<string, number>();\n      \n      engagementData?.forEach((event: any) => {\n        const eventData = event.event_data;\n        if (eventData?.hashtag) {\n          const hashtag = eventData.hashtag;\n          const currentScore = hashtagScores.get(hashtag) || 0;\n          hashtagScores.set(hashtag, currentScore + 1);\n        }\n      });\n\n      // Sort by engagement score and return top hashtags\n      const sortedHashtags = Array.from(hashtagScores.entries())\n        .sort(([, a], [, b]) => b - a)\n        .slice(0, 10)\n        .map(([hashtag]) => hashtag);\n\n      return sortedHashtags;\n      \n    } catch (error) {\n      logger.error('Failed to get fallback hashtag interests:', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Get trending hashtags with real-time analysis\n   */\n  private async getTrendingHashtags(limit: number): Promise<string[]> {\n    try {\n      const cacheKey = `trending_hashtags_${limit}`;\n      const cached = this.getCachedData(cacheKey);\n      if (cached) return cached;\n\n      // Get hashtag usage data from the last 24 hours\n      const { data: hashtagData, error } = await this.supabase\n        .from('analytics_events')\n        .select('event_data, created_at')\n        .eq('event_category', 'hashtag')\n        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        logger.warn('Failed to get trending hashtags:', error);\n        return [];\n      }\n\n      // Calculate trending scores\n      const hashtagScores = new Map<string, { count: number; recency: number }>();\n      \n      hashtagData?.forEach((event: any) => {\n        const eventData = event.event_data;\n        if (eventData?.hashtag) {\n          const hashtag = eventData.hashtag;\n          const current = hashtagScores.get(hashtag) || { count: 0, recency: 0 };\n          const hoursAgo = (Date.now() - new Date(event.created_at).getTime()) / (1000 * 60 * 60);\n          const recencyScore = Math.max(0, 24 - hoursAgo) / 24; // Higher score for more recent\n          \n          hashtagScores.set(hashtag, {\n            count: current.count + 1,\n            recency: Math.max(current.recency, recencyScore)\n          });\n        }\n      });\n\n      // Calculate final trending scores\n      const trendingScores = Array.from(hashtagScores.entries())\n        .map(([hashtag, data]) => ({\n          hashtag,\n          score: data.count * 0.7 + data.recency * 0.3 // Weight count more than recency\n        }))\n        .sort((a, b) => b.score - a.score)\n        .slice(0, limit)\n        .map(item => item.hashtag);\n\n      this.setCachedData(cacheKey, trendingScores);\n      return trendingScores;\n      \n    } catch (error) {\n      logger.error('Failed to get trending hashtags:', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Get poll recommendations based on followed hashtags\n   * This is the core autopopulation mechanism for personalized feeds\n   */\n  private async getHashtagBasedPollRecommendations(\n    userId: string,\n    followedHashtags: string[],\n    limit: number\n  ): Promise<PollRecommendation[]> {\n    try {\n      if (followedHashtags.length === 0) {\n        // If user follows no hashtags, get trending polls as fallback\n        return await this.getTrendingPollRecommendations(limit);\n      }\n\n      // Get polls that match user's followed hashtags with priority scoring\n      const { data: pollsData, error } = await this.supabase\n        .from('polls')\n        .select(`\n          id,\n          title,\n          description,\n          options,\n          total_votes,\n          created_at,\n          hashtags,\n          primary_hashtag,\n          hashtag_engagement\n        `)\n        .contains('hashtags', followedHashtags) // Use contains for array matching\n        .eq('status', 'active')\n        .order('created_at', { ascending: false })\n        .limit(limit * 3); // Get more for better filtering\n\n      if (error) {\n        logger.warn('Failed to get hashtag-based polls:', error);\n        return await this.getTrendingPollRecommendations(limit);\n      }\n\n      // Convert to PollRecommendation format with enhanced hashtag scoring\n      const recommendations: PollRecommendation[] = pollsData?.map((poll: any) => {\n        // Calculate priority score based on followed hashtags\n        const followedHashtagMatches = (poll.hashtags || []).filter((hashtag: string) => \n          followedHashtags.includes(hashtag)\n        ).length;\n        \n        const hashtagMatchScore = followedHashtagMatches / Math.max(followedHashtags.length, 1);\n        const primaryHashtagBonus = followedHashtags.includes(poll.primary_hashtag) ? 0.3 : 0;\n        \n        const engagementScore = this.calculateEngagementScore(poll);\n        const recencyScore = this.calculateRecencyScore(poll.created_at);\n        \n        // Enhanced relevance scoring with followed hashtag priority\n        const relevanceScore = (\n          hashtagMatchScore * 0.6 + // Higher weight for followed hashtags\n          primaryHashtagBonus * 0.2 + // Bonus for primary hashtag match\n          engagementScore * 0.15 +\n          recencyScore * 0.05\n        );\n\n        // Generate personalized reason based on followed hashtags\n        const matchedHashtags = (poll.hashtags || []).filter((hashtag: string) => \n          followedHashtags.includes(hashtag)\n        );\n        const reason = matchedHashtags.length > 0 \n          ? `Matches your followed hashtags: ${matchedHashtags.map((h: string) => `#${h}`).join(', ')}`\n          : `Related to your interests in ${poll.primary_hashtag || 'politics'}`;\n\n        return {\n          poll_id: poll.id,\n          title: poll.title,\n          description: poll.description,\n          relevanceScore,\n          hashtag_match_score: hashtagMatchScore + primaryHashtagBonus,\n          engagement_score: engagementScore,\n          recency_score: recencyScore,\n          hashtags: poll.hashtags || [],\n          primary_hashtag: poll.primary_hashtag,\n          total_votes: poll.total_votes || 0,\n          created_at: poll.created_at,\n          reason\n        };\n      }) || [];\n\n      // Sort by relevance score and return top recommendations\n      return recommendations\n        .sort((a, b) => b.relevanceScore - a.relevanceScore)\n        .slice(0, limit);\n        \n    } catch (error) {\n      logger.error('Failed to get hashtag-based poll recommendations:', error as Error);\n      return await this.getTrendingPollRecommendations(limit);\n    }\n  }\n\n  /**\n   * Get trending poll recommendations as fallback\n   */\n  private async getTrendingPollRecommendations(limit: number): Promise<PollRecommendation[]> {\n    try {\n      const { data: pollsData, error } = await this.supabase\n        .from('polls')\n        .select(`\n          id,\n          title,\n          description,\n          options,\n          total_votes,\n          created_at,\n          hashtags,\n          primary_hashtag,\n          hashtag_engagement\n        `)\n        .eq('status', 'active')\n        .order('total_votes', { ascending: false })\n        .limit(limit);\n\n      if (error) {\n        logger.warn('Failed to get trending polls:', error);\n        return [];\n      }\n\n      return pollsData?.map((poll: any) => ({\n        poll_id: poll.id,\n        title: poll.title,\n        description: poll.description,\n        relevanceScore: 0.5, // Default score for trending\n        hashtag_match_score: 0,\n        engagement_score: this.calculateEngagementScore(poll),\n        recency_score: this.calculateRecencyScore(poll.created_at),\n        hashtags: poll.hashtags || [],\n        primary_hashtag: poll.primary_hashtag,\n        total_votes: poll.total_votes || 0,\n        created_at: poll.created_at,\n        reason: 'Trending poll'\n      })) || [];\n      \n    } catch (error) {\n      logger.error('Failed to get trending poll recommendations:', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Calculate hashtag analytics for user interests\n   */\n  private async calculateHashtagAnalytics(\n    userInterests: string[],\n    trendingHashtags: string[]\n  ): Promise<HashtagFeedAnalytics[]> {\n    try {\n      const analytics: HashtagFeedAnalytics[] = [];\n      \n      for (const hashtag of userInterests) {\n        // Get poll count for this hashtag\n        const { data: pollData, error: pollError } = await this.supabase\n          .from('polls')\n          .select('id, hashtag_engagement')\n          .contains('hashtags', [hashtag])\n          .eq('status', 'active');\n\n        if (pollError) {\n          logger.warn(`Failed to get poll data for hashtag ${hashtag}:`, pollError);\n          continue;\n        }\n\n        // Calculate engagement rate\n        const totalEngagement = pollData?.reduce((sum: number, poll: any) => {\n          const engagement = poll.hashtag_engagement || {};\n          return sum + (engagement.total_views || 0) + (engagement.hashtag_clicks || 0);\n        }, 0) || 0;\n\n        const pollCount = pollData?.length || 0;\n        const engagementRate = pollCount > 0 ? totalEngagement / pollCount : 0;\n\n        // Calculate trending position\n        const trendingPosition = trendingHashtags.indexOf(hashtag) + 1;\n        const isTrending = trendingPosition > 0;\n\n        // Calculate user interest level\n        const userInterestLevel = userInterests.indexOf(hashtag) + 1;\n        const normalizedInterest = 1 - (userInterestLevel - 1) / userInterests.length;\n\n        analytics.push({\n          hashtag,\n          poll_count: pollCount,\n          engagement_rate: engagementRate,\n          trending_position: isTrending ? trendingPosition : 0,\n          user_interest_level: normalizedInterest,\n          last_activity: new Date()\n        });\n      }\n\n      return analytics;\n      \n    } catch (error) {\n      logger.error('Failed to calculate hashtag analytics:', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Calculate hashtag match score between poll hashtags and user interests\n   */\n  private calculateHashtagMatchScore(\n    pollHashtags: string[],\n    userInterests: string[]\n  ): number {\n    if (pollHashtags.length === 0 || userInterests.length === 0) {\n      return 0;\n    }\n\n    const matches = pollHashtags.filter(hashtag => \n      userInterests.includes(hashtag)\n    ).length;\n\n    return matches / Math.max(pollHashtags.length, userInterests.length);\n  }\n\n  /**\n   * Calculate engagement score for a poll\n   */\n  private calculateEngagementScore(poll: any): number {\n    const totalVotes = poll.total_votes || 0;\n    const engagement = poll.hashtag_engagement || {};\n    const hashtagViews = engagement.total_views || 0;\n    const hashtagClicks = engagement.hashtag_clicks || 0;\n    \n    // Normalize engagement score (0-1)\n    const totalEngagement = totalVotes + hashtagViews + hashtagClicks;\n    return Math.min(1, totalEngagement / 1000); // Cap at 1000 for normalization\n  }\n\n  /**\n   * Calculate recency score for a poll\n   */\n  private calculateRecencyScore(createdAt: string): number {\n    const hoursAgo = (Date.now() - new Date(createdAt).getTime()) / (1000 * 60 * 60);\n    return Math.max(0, 1 - hoursAgo / 168); // Decay over 1 week\n  }\n\n  /**\n   * Calculate overall feed score\n   */\n  private calculateFeedScore(\n    recommendations: PollRecommendation[],\n    analytics: HashtagFeedAnalytics[]\n  ): number {\n    if (recommendations.length === 0) return 0;\n\n    const avgRelevance = recommendations.reduce((sum, rec) => \n      sum + rec.relevanceScore, 0) / recommendations.length;\n    \n    const avgAnalytics = analytics.reduce((sum, analytic) => \n      sum + analytic.engagement_rate, 0) / Math.max(analytics.length, 1);\n\n    return (avgRelevance * 0.7 + avgAnalytics * 0.3);\n  }\n\n  /**\n   * Track hashtag engagement in feeds\n   */\n  async trackHashtagEngagement(\n    userId: string,\n    hashtag: string,\n    action: 'view' | 'click' | 'share' | 'follow'\n  ): Promise<void> {\n    try {\n      if (!this.supabase) return;\n\n      await this.supabase.from('analytics_events').insert({\n        user_id: userId,\n        event_type: 'vote', // Use existing event type\n        event_category: 'hashtag',\n        event_data: {\n          hashtag,\n          action,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      // Clear relevant cache\n      this.clearCacheForUser(userId);\n      \n    } catch (error) {\n      logger.error('Failed to track hashtag engagement:', error as Error);\n    }\n  }\n\n  /**\n   * Get real-time hashtag trending data\n   */\n  async getRealTimeTrendingData(): Promise<HashtagFeedAnalytics[]> {\n    try {\n      const cacheKey = 'realtime_trending_data';\n      const cached = this.getCachedData(cacheKey);\n      if (cached) return cached;\n\n      const trendingHashtags = await this.getTrendingHashtags(20);\n      const analytics = await this.calculateHashtagAnalytics(\n        trendingHashtags,\n        trendingHashtags\n      );\n\n      this.setCachedData(cacheKey, analytics);\n      return analytics;\n      \n    } catch (error) {\n      logger.error('Failed to get real-time trending data:', error as Error);\n      return [];\n    }\n  }\n\n  // Cache management methods\n  private getCachedData(key: string): any {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  private setCachedData(key: string, data: any): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  private clearCacheForUser(userId: string): void {\n    const keysToDelete = Array.from(this.cache.keys()).filter(key => \n      key.includes(userId)\n    );\n    keysToDelete.forEach(key => this.cache.delete(key));\n  }\n}\n\n// Export singleton instance\nexport const hashtagPollsIntegrationService = new HashtagPollsIntegrationService();\n"],"names":["HashtagPollsIntegrationService","hashtagPollsIntegrationService","cache","Map","cacheTimeout","initializeSupabase","supabase","getSupabaseServerClient","error","logger","generateHashtagPollFeed","userId","userPreferences","limit","Error","hashtagInterests","getUserHashtagInterests","trendingHashtags","getTrendingHashtags","recommendedPolls","getHashtagBasedPollRecommendations","hashtagAnalytics","calculateHashtagAnalytics","feedScore","calculateFeedScore","user_id","hashtag_interests","recommended_polls","trending_hashtags","hashtag_analytics","feed_score","last_updated","Date","cacheKey","cached","getCachedData","data","followedHashtags","followedError","from","select","eq","warn","getFallbackHashtagInterests","followedHashtagNames","map","uh","hashtags","name","filter","Boolean","length","setCachedData","engagementData","gte","now","toISOString","order","ascending","hashtagScores","forEach","event","eventData","event_data","hashtag","currentScore","get","set","sortedHashtags","Array","entries","sort","a","b","slice","hashtagData","current","count","recency","hoursAgo","created_at","getTime","recencyScore","Math","max","trendingScores","score","item","getTrendingPollRecommendations","pollsData","contains","recommendations","poll","followedHashtagMatches","includes","hashtagMatchScore","primaryHashtagBonus","primary_hashtag","engagementScore","calculateEngagementScore","calculateRecencyScore","relevanceScore","matchedHashtags","reason","h","join","poll_id","id","title","description","hashtag_match_score","engagement_score","recency_score","total_votes","userInterests","analytics","pollData","pollError","totalEngagement","reduce","sum","engagement","hashtag_engagement","total_views","hashtag_clicks","pollCount","engagementRate","trendingPosition","indexOf","isTrending","userInterestLevel","normalizedInterest","push","poll_count","engagement_rate","trending_position","user_interest_level","last_activity","calculateHashtagMatchScore","pollHashtags","matches","totalVotes","hashtagViews","hashtagClicks","min","createdAt","avgRelevance","rec","avgAnalytics","analytic","trackHashtagEngagement","action","insert","event_type","event_category","timestamp","clearCacheForUser","getRealTimeTrendingData","key","keysToDelete","keys","delete"],"mappings":"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"}