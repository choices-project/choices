{"version":3,"sources":["/Users/alaughingkitsune/src/Choices/web/lib/core/security/rate-limit.ts"],"sourcesContent":["/**\n * Enhanced Rate Limiting System\n * Production-ready rate limiting with IP reputation, device fingerprinting, and adaptive limits\n * \n * Features:\n * - IP-based rate limiting with reputation scoring\n * - Device fingerprinting for additional protection\n * - Adaptive rate limits based on risk signals\n * - Multiple storage backends (memory, Redis)\n * - Comprehensive analytics and monitoring\n * \n * @author Choices Platform\n * @version 2.0.0\n * @since 2024-12-27\n */\n\nimport { devLog } from '@/lib/utils/logger'\n\n// Rate limit configuration\nexport interface RateLimitConfig {\n  interval: number // Time window in milliseconds\n  uniqueTokenPerInterval: number // Max requests per interval\n  maxBurst?: number // Maximum burst allowance\n  reputationThreshold?: number // Reputation score threshold for stricter limits\n  deviceFingerprintWeight?: number // Weight for device fingerprint in risk calculation\n}\n\n// IP reputation data\nexport interface IPReputation {\n  ip: string\n  score: number // 0-100, higher = more trusted\n  requestCount: number\n  lastRequest: Date\n  violations: number\n  suspiciousActivity: boolean\n  whitelisted: boolean\n  blacklisted: boolean\n}\n\n// Device fingerprint data\nexport interface DeviceFingerprint {\n  userAgent: string\n  screenResolution: string\n  timezone: string\n  language: string\n  platform: string\n  cookieEnabled: boolean\n  doNotTrack: boolean\n  hash: string // Computed fingerprint hash\n}\n\n// Risk assessment result\nexport interface RiskAssessment {\n  riskScore: number // 0-100, higher = higher risk\n  factors: string[]\n  recommendedAction: 'allow' | 'challenge' | 'block'\n  rateLimitMultiplier: number // Multiplier for rate limit (higher = stricter)\n}\n\n// Rate limit result\nexport interface RateLimitResult {\n  success: boolean\n  allowed: boolean\n  remaining: number\n  resetTime: Date\n  retryAfter?: number | null\n  riskAssessment?: RiskAssessment\n  reputation?: IPReputation | null\n}\n\n// Token bucket for rate limiting\nclass TokenBucket {\n  private tokens: number\n  private lastRefill: number\n  private readonly capacity: number\n  private readonly refillRate: number\n\n  constructor(capacity: number, refillRate: number) {\n    this.capacity = capacity\n    this.refillRate = refillRate\n    this.tokens = capacity\n    this.lastRefill = Date.now()\n  }\n\n  tryConsume(tokens = 1): boolean {\n    this.refill()\n    \n    if (this.tokens >= tokens) {\n      this.tokens -= tokens\n      return true\n    }\n    \n    return false\n  }\n\n  private refill(): void {\n    const now = Date.now()\n    const timePassed = now - this.lastRefill\n    const tokensToAdd = (timePassed * this.refillRate) / 1000\n    \n    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd)\n    this.lastRefill = now\n  }\n\n  getRemaining(): number {\n    this.refill()\n    return Math.floor(this.tokens)\n  }\n\n  getResetTime(): Date {\n    const tokensNeeded = this.capacity - this.tokens\n    const timeNeeded = (tokensNeeded / this.refillRate) * 1000\n    return new Date(Date.now() + timeNeeded)\n  }\n}\n\n// Enhanced Rate Limiter with reputation and device fingerprinting\nexport class EnhancedRateLimiter {\n  private buckets: Map<string, TokenBucket> = new Map()\n  private reputation: Map<string, IPReputation> = new Map()\n  private deviceFingerprints: Map<string, DeviceFingerprint> = new Map()\n  private config: RateLimitConfig\n\n  constructor(config: RateLimitConfig) {\n    this.config = Object.assign({}, {\n      maxBurst: 5,\n      reputationThreshold: 50,\n      deviceFingerprintWeight: 0.3,\n    }, config)\n  }\n\n  // Get client IP address\n  private getClientIP(req: Request): string {\n    // Check for forwarded headers (common in proxy setups)\n    const forwarded = req.headers.get('x-forwarded-for')\n    if (forwarded) {\n      const firstIP = forwarded.split(',')[0]\n      if (firstIP) {\n        return firstIP.trim()\n      }\n    }\n\n    const realIP = req.headers.get('x-real-ip')\n    if (realIP) {\n      return realIP\n    }\n\n    // Fallback to connection remote address (if available)\n    return 'unknown'\n  }\n\n  // Generate device fingerprint from request\n  private generateDeviceFingerprint(req: Request): DeviceFingerprint {\n    const userAgent = req.headers.get('user-agent') || ''\n    const acceptLanguage = req.headers.get('accept-language') || ''\n    \n    // Extract basic fingerprint data\n    const fingerprint: DeviceFingerprint = {\n      userAgent,\n      screenResolution: `${req.headers.get('sec-ch-viewport-width')  }x${  req.headers.get('sec-ch-viewport-height')}` || 'unknown',\n      timezone: req.headers.get('sec-ch-prefers-color-scheme') || 'unknown',\n      language: acceptLanguage.split(',')[0] || 'unknown',\n      platform: this.extractPlatform(userAgent),\n      cookieEnabled: req.headers.get('cookie') !== null,\n      doNotTrack: req.headers.get('dnt') === '1',\n      hash: ''\n    }\n\n    // Generate hash from fingerprint data\n    fingerprint.hash = this.hashFingerprint(fingerprint)\n    \n    return fingerprint\n  }\n\n  // Extract platform from user agent\n  private extractPlatform(userAgent: string): string {\n    if (userAgent.includes('iPhone') || userAgent.includes('iPad')) {\n      return 'ios'\n    } else if (userAgent.includes('Android')) {\n      return 'android'\n    } else if (userAgent.includes('Windows')) {\n      return 'windows'\n    } else if (userAgent.includes('Mac')) {\n      return 'macos'\n    } else if (userAgent.includes('Linux')) {\n      return 'linux'\n    }\n    return 'unknown'\n  }\n\n  // Hash device fingerprint\n  private hashFingerprint(fingerprint: DeviceFingerprint): string {\n    const data = `${fingerprint.userAgent}|${fingerprint.screenResolution}|${fingerprint.timezone}|${fingerprint.language}|${fingerprint.platform}|${fingerprint.cookieEnabled}|${fingerprint.doNotTrack}`\n    \n    // Simple hash function (in production, use crypto.createHash)\n    let hash = 0\n    for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32-bit integer\n    }\n    \n    return Math.abs(hash).toString(36)\n  }\n\n  // Assess risk based on IP and device fingerprint\n  private assessRisk(ip: string, deviceFingerprint: DeviceFingerprint): RiskAssessment {\n    const factors: string[] = []\n    let riskScore = 0\n\n    // Check IP reputation\n    const reputation = this.reputation.get(ip)\n    if (reputation) {\n      if (reputation.blacklisted) {\n        riskScore = 100\n        factors.push('IP blacklisted')\n      } else if (reputation.whitelisted) {\n        riskScore = 0\n        factors.push('IP whitelisted')\n      } else {\n        riskScore += (100 - reputation.score) * 0.4 // IP reputation weight\n        if (reputation.suspiciousActivity) {\n          factors.push('Suspicious IP activity')\n          riskScore += 20\n        }\n        if (reputation.violations > 0) {\n          factors.push(`IP violations: ${reputation.violations}`)\n          riskScore += reputation.violations * 10\n        }\n      }\n    } else {\n      // New IP - moderate risk\n      riskScore += 30\n      factors.push('New IP address')\n    }\n\n    // Check device fingerprint\n    const existingFingerprint = this.deviceFingerprints.get(deviceFingerprint.hash)\n    if (existingFingerprint) {\n      // Known device - lower risk\n      riskScore -= 20\n      factors.push('Known device')\n    } else {\n      // New device - higher risk\n      riskScore += 25\n      factors.push('New device fingerprint')\n    }\n\n    // Check for suspicious patterns\n    if (deviceFingerprint.userAgent.includes('bot') || deviceFingerprint.userAgent.includes('crawler')) {\n      riskScore += 40\n      factors.push('Bot-like user agent')\n    }\n\n    if (!deviceFingerprint.cookieEnabled) {\n      riskScore += 15\n      factors.push('Cookies disabled')\n    }\n\n    // Normalize risk score\n    riskScore = Math.max(0, Math.min(100, riskScore))\n\n    // Determine recommended action\n    let recommendedAction: 'allow' | 'challenge' | 'block' = 'allow'\n    if (riskScore >= 80) {\n      recommendedAction = 'block'\n    } else if (riskScore >= 50) {\n      recommendedAction = 'challenge'\n    }\n\n    // Calculate rate limit multiplier\n    const rateLimitMultiplier = 1 + (riskScore / 100) * 2 // 1x to 3x multiplier\n\n    return {\n      riskScore,\n      factors,\n      recommendedAction,\n      rateLimitMultiplier\n    }\n  }\n\n  // Update IP reputation\n  private updateReputation(ip: string, success: boolean, riskAssessment: RiskAssessment): void {\n    let reputation = this.reputation.get(ip)\n    \n    if (!reputation) {\n      reputation = {\n        ip,\n        score: 50, // Neutral starting score\n        requestCount: 0,\n        lastRequest: new Date(),\n        violations: 0,\n        suspiciousActivity: false,\n        whitelisted: false,\n        blacklisted: false\n      }\n    }\n\n    // Update request count and last request\n    reputation.requestCount++\n    reputation.lastRequest = new Date()\n\n    // Update score based on success/failure\n    if (success) {\n      reputation.score = Math.min(100, reputation.score + 1)\n    } else {\n      reputation.score = Math.max(0, reputation.score - 5)\n      reputation.violations++\n    }\n\n    // Update suspicious activity flag\n    if (riskAssessment.riskScore > 70) {\n      reputation.suspiciousActivity = true\n    }\n\n    // Auto-blacklist if too many violations\n    if (reputation.violations >= 10) {\n      reputation.blacklisted = true\n      reputation.score = 0\n    }\n\n    // Auto-whitelist if very good behavior\n    if (reputation.requestCount > 100 && reputation.score > 90 && reputation.violations === 0) {\n      reputation.whitelisted = true\n    }\n\n    this.reputation.set(ip, reputation)\n  }\n\n  // Check rate limit with enhanced features\n  async check(req: Request, identifier?: string): Promise<RateLimitResult> {\n    const ip = this.getClientIP(req)\n    const deviceFingerprint = this.generateDeviceFingerprint(req)\n    const key = identifier || ip\n\n    // Assess risk\n    const riskAssessment = this.assessRisk(ip, deviceFingerprint)\n\n    // Get or create token bucket\n    let bucket = this.buckets.get(key)\n    if (!bucket) {\n      const adjustedLimit = Math.floor(this.config.uniqueTokenPerInterval / riskAssessment.rateLimitMultiplier)\n      const refillRate = adjustedLimit / (this.config.interval / 1000)\n      bucket = new TokenBucket(adjustedLimit, refillRate)\n      this.buckets.set(key, bucket)\n    }\n\n    // Try to consume token\n    const allowed = bucket.tryConsume()\n    const remaining = bucket.getRemaining()\n    const resetTime = bucket.getResetTime()\n\n    // Update reputation\n    this.updateReputation(ip, allowed, riskAssessment)\n\n    // Store device fingerprint\n    this.deviceFingerprints.set(deviceFingerprint.hash, deviceFingerprint)\n\n    // Log for analytics\n    devLog('Rate limit check:', {\n      ip,\n      key,\n      allowed,\n      remaining,\n      riskScore: riskAssessment.riskScore,\n      factors: riskAssessment.factors,\n      action: riskAssessment.recommendedAction\n    })\n\n    return {\n      success: true,\n      allowed,\n      remaining,\n      resetTime,\n      retryAfter: allowed ? null : Math.ceil((resetTime.getTime() - Date.now()) / 1000),\n      riskAssessment,\n      reputation: this.reputation.get(ip) || null\n    }\n  }\n\n  // Get reputation for an IP\n  getReputation(ip: string): IPReputation | null {\n    return this.reputation.get(ip) || null\n  }\n\n  // Manually update reputation\n  updateReputationManually(ip: string, updates: Partial<IPReputation>): void {\n    const reputation = this.reputation.get(ip)\n    if (reputation) {\n      Object.assign(reputation, updates)\n      this.reputation.set(ip, reputation)\n    }\n  }\n\n  // Cleanup old data\n  cleanup(): void {\n    const now = Date.now()\n    const maxAge = 24 * 60 * 60 * 1000 // 24 hours\n\n    // Cleanup old buckets\n    for (const [key, bucket] of Array.from(this.buckets.entries())) {\n      if (now - bucket.getResetTime().getTime() > maxAge) {\n        this.buckets.delete(key)\n      }\n    }\n\n    // Cleanup old reputation data\n    for (const [ip, reputation] of Array.from(this.reputation.entries())) {\n      if (now - reputation.lastRequest.getTime() > maxAge * 7) { // 7 days\n        this.reputation.delete(ip)\n      }\n    }\n\n    // Cleanup old device fingerprints\n    // Note: In production, you might want to keep these longer for analytics\n  }\n\n  // Get statistics\n  getStats(): {\n    buckets: number\n    reputation: number\n    deviceFingerprints: number\n  } {\n    return {\n      buckets: this.buckets.size,\n      reputation: this.reputation.size,\n      deviceFingerprints: this.deviceFingerprints.size\n    }\n  }\n}\n\n// Redis-based rate limiter for production\nexport class RedisRateLimiter {\n  // Implementation for Redis-based rate limiting\n  // This would be used in production for distributed rate limiting\n  // For now, we'll use the enhanced memory-based limiter\n}\n\n// Factory function to create appropriate rate limiter\nexport function createRateLimiter(config: RateLimitConfig): EnhancedRateLimiter {\n  // In production, check environment and return Redis-based limiter if available\n  return new EnhancedRateLimiter(config)\n}\n\n// Pre-configured rate limiters for different endpoints\nexport const rateLimiters = {\n  auth: createRateLimiter({\n    interval: 15 * 60 * 1000, // 15 minutes\n    uniqueTokenPerInterval: 10, // 10 attempts per 15 minutes\n    maxBurst: 3\n  }),\n  \n  registration: createRateLimiter({\n    interval: 60 * 60 * 1000, // 1 hour\n    uniqueTokenPerInterval: 5, // 5 registrations per hour\n    maxBurst: 1\n  }),\n  \n  deviceFlow: createRateLimiter({\n    interval: 5 * 60 * 1000, // 5 minutes\n    uniqueTokenPerInterval: 20, // 20 device flow attempts per 5 minutes\n    maxBurst: 5\n  }),\n  \n  biometric: createRateLimiter({\n    interval: 5 * 60 * 1000, // 5 minutes\n    uniqueTokenPerInterval: 30, // 30 biometric attempts per 5 minutes\n    maxBurst: 10\n  })\n}\n\n// Middleware function for API routes\nexport async function rateLimitMiddleware(\n  req: Request,\n  limiter: EnhancedRateLimiter = rateLimiters.auth\n): Promise<RateLimitResult> {\n  return await limiter.check(req)\n}\n"],"names":["EnhancedRateLimiter","RedisRateLimiter","createRateLimiter","rateLimitMiddleware","rateLimiters","TokenBucket","capacity","refillRate","tokens","lastRefill","Date","now","tryConsume","refill","timePassed","tokensToAdd","Math","min","getRemaining","floor","getResetTime","tokensNeeded","timeNeeded","config","buckets","Map","reputation","deviceFingerprints","Object","assign","maxBurst","reputationThreshold","deviceFingerprintWeight","getClientIP","req","forwarded","headers","get","firstIP","split","trim","realIP","generateDeviceFingerprint","userAgent","acceptLanguage","fingerprint","screenResolution","timezone","language","platform","extractPlatform","cookieEnabled","doNotTrack","hash","hashFingerprint","includes","data","i","length","char","charCodeAt","abs","toString","assessRisk","ip","deviceFingerprint","factors","riskScore","blacklisted","push","whitelisted","score","suspiciousActivity","violations","existingFingerprint","max","recommendedAction","rateLimitMultiplier","updateReputation","success","riskAssessment","requestCount","lastRequest","set","check","identifier","key","bucket","adjustedLimit","uniqueTokenPerInterval","interval","allowed","remaining","resetTime","devLog","action","retryAfter","ceil","getTime","getReputation","updateReputationManually","updates","cleanup","maxAge","Array","from","entries","delete","getStats","size","auth","registration","deviceFlow","biometric","limiter"],"mappings":"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"}