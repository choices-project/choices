65e21efdd221acafa92a6380cf2d5a68
/**
 * @jest-environment jsdom
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _reactrouterdom = require("react-router-dom");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../features/feeds/components/UnifiedFeed"));
const _testmonitoring = require("./test-monitoring");
const _performancedashboard = require("./performance-dashboard");
const _logger = require("../../../../lib/utils/logger");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Setup minimal mocks for test environment
beforeAll(()=>{
    // Mock localStorage for component functionality
    Object.defineProperty(window, 'localStorage', {
        value: {
            getItem: jest.fn(),
            setItem: jest.fn(),
            removeItem: jest.fn(),
            clear: jest.fn()
        },
        writable: true
    });
    // Mock navigator for online status
    Object.defineProperty(navigator, 'onLine', {
        value: true,
        writable: true
    });
    // Mock fetch to handle API calls
    global.fetch = jest.fn((url)=>{
        if (url.includes('/api/feeds')) {
            return Promise.resolve({
                ok: true,
                json: ()=>Promise.resolve([
                        {
                            id: '1',
                            title: 'Sample Civic Activity',
                            description: 'A sample civic activity for testing',
                            category: 'civic',
                            timestamp: new Date().toISOString(),
                            source: 'test'
                        }
                    ])
            });
        }
        if (url.includes('/api/civics/analytics')) {
            return Promise.resolve({
                ok: true,
                json: ()=>Promise.resolve({
                        success: true,
                        analytics: {
                            totalViews: 100,
                            engagement: 0.75,
                            userSatisfaction: 0.85
                        }
                    })
            });
        }
        if (url.includes('/api/pwa/offline/sync')) {
            return Promise.resolve({
                ok: true,
                json: ()=>Promise.resolve({
                        success: true
                    })
            });
        }
        return Promise.resolve({
            ok: true,
            json: ()=>Promise.resolve({})
        });
    });
});
describe('Performance Monitoring Tests', ()=>{
    beforeEach(()=>{
        // Clear test monitor before each test
        _testmonitoring.testMonitor.clear();
    });
    describe('Performance Metrics Collection', ()=>{
        it('should collect comprehensive performance metrics', async ()=>{
            const startTime = performance.now();
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                }));
            });
            const endTime = performance.now();
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const renderTime = endTime - startTime;
            const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
            const performanceGrade = (0, _testmonitoring.calculatePerformanceGrade)(renderTime, memoryUsage);
            // Record metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'should collect comprehensive performance metrics',
                testSuite: 'Performance Monitoring Tests',
                duration: renderTime,
                memoryUsage,
                renderTime,
                networkTime: 0,
                apiTime: 0,
                accessibilityTime: 0,
                performanceGrade,
                status: 'PASS'
            });
            _logger.logger.info(`ðŸ“Š Performance Metrics Collected:`);
            _logger.logger.info(`- Render Time: ${renderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Memory Usage: ${memoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Performance Grade: ${performanceGrade}`);
            expect(renderTime).toBeLessThan(_testmonitoring.PERFORMANCE_BUDGETS.RENDER_TIME);
            expect(memoryUsage).toBeLessThan(_testmonitoring.PERFORMANCE_BUDGETS.MEMORY_USAGE);
            expect(performanceGrade).toMatch(/^[A-F][+]?$/);
        });
        it('should track performance across multiple test runs', async ()=>{
            const testRuns = 3;
            for(let i = 0; i < testRuns; i++){
                const startTime = performance.now();
                const initialMemory = performance.memory?.usedJSHeapSize || 0;
                await (0, _react1.act)(async ()=>{
                    (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                    }));
                });
                const endTime = performance.now();
                const finalMemory = performance.memory?.usedJSHeapSize || 0;
                const renderTime = endTime - startTime;
                const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
                const performanceGrade = (0, _testmonitoring.calculatePerformanceGrade)(renderTime, memoryUsage);
                _testmonitoring.testMonitor.recordMetrics({
                    testName: `Performance Test Run ${i + 1}`,
                    testSuite: 'Performance Monitoring Tests',
                    duration: renderTime,
                    memoryUsage,
                    renderTime,
                    networkTime: 0,
                    apiTime: 0,
                    accessibilityTime: 0,
                    performanceGrade,
                    status: 'PASS'
                });
            }
            const report = _testmonitoring.testMonitor.generateReport();
            _logger.logger.info(`ðŸ“Š Multi-Run Performance Report:`);
            _logger.logger.info(`- Total Tests: ${report.totalTests}`);
            _logger.logger.info(`- Average Render Time: ${report.averageRenderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Average Memory Usage: ${report.averageMemoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Overall Grade: ${report.performanceGrade}`);
            expect(report.totalTests).toBe(testRuns);
            expect(report.passedTests).toBe(testRuns);
            expect(report.performanceGrade).toMatch(/^[A-F][+]?$/);
        });
        it('should generate performance alerts for poor performance', async ()=>{
            // Simulate poor performance
            const startTime = performance.now();
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                }));
            });
            const endTime = performance.now();
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const renderTime = endTime - startTime;
            const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
            // Record metrics with artificially poor performance for testing
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Poor Performance Test',
                testSuite: 'Performance Monitoring Tests',
                duration: renderTime,
                memoryUsage: memoryUsage > 5 ? memoryUsage : 15,
                renderTime: renderTime > 200 ? renderTime : 300,
                networkTime: 600,
                apiTime: 0,
                accessibilityTime: 0,
                performanceGrade: 'D',
                status: 'PASS'
            });
            const alerts = _testmonitoring.testMonitor.getAlerts();
            _logger.logger.info(`ðŸš¨ Performance Alerts Generated: ${alerts.length}`);
            alerts.forEach((alert)=>_logger.logger.info(`- ${alert}`));
            expect(alerts.length).toBeGreaterThan(0);
            expect(alerts.some((alert)=>alert.includes('SLOW RENDER'))).toBe(true);
            expect(alerts.some((alert)=>alert.includes('HIGH MEMORY'))).toBe(true);
            expect(alerts.some((alert)=>alert.includes('SLOW NETWORK'))).toBe(true);
        });
    });
    describe('Performance Reporting', ()=>{
        it('should generate comprehensive performance report', async ()=>{
            // Record multiple test metrics
            const testMetrics = [
                {
                    testName: 'Fast Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 50,
                    memoryUsage: 1,
                    renderTime: 50,
                    networkTime: 100,
                    apiTime: 50,
                    accessibilityTime: 25,
                    performanceGrade: 'A+',
                    status: 'PASS'
                },
                {
                    testName: 'Medium Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 150,
                    memoryUsage: 3,
                    renderTime: 150,
                    networkTime: 200,
                    apiTime: 100,
                    accessibilityTime: 50,
                    performanceGrade: 'B',
                    status: 'PASS'
                },
                {
                    testName: 'Slow Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 300,
                    memoryUsage: 8,
                    renderTime: 300,
                    networkTime: 400,
                    apiTime: 200,
                    accessibilityTime: 100,
                    performanceGrade: 'D',
                    status: 'FAIL',
                    errorMessage: 'Performance budget exceeded'
                }
            ];
            testMetrics.forEach((metrics)=>{
                _testmonitoring.testMonitor.recordMetrics(metrics);
            });
            const report = _testmonitoring.testMonitor.generateReport();
            _logger.logger.info(`ðŸ“Š Comprehensive Performance Report:`);
            _logger.logger.info(`- Total Tests: ${report.totalTests}`);
            _logger.logger.info(`- Passed: ${report.passedTests}`);
            _logger.logger.info(`- Failed: ${report.failedTests}`);
            _logger.logger.info(`- Average Render Time: ${report.averageRenderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Average Memory Usage: ${report.averageMemoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Performance Grade: ${report.performanceGrade}`);
            _logger.logger.info(`- Recommendations: ${report.recommendations.length}`);
            expect(report.totalTests).toBe(3);
            expect(report.passedTests).toBe(2);
            expect(report.failedTests).toBe(1);
            expect(report.averageRenderTime).toBeCloseTo(166.67, 1);
            expect(report.averageMemoryUsage).toBeCloseTo(4, 1);
            expect(report.performanceGrade).toMatch(/^[A-F][+]?$/);
            expect(report.recommendations.length).toBeGreaterThan(0);
        });
        it('should export metrics to JSON format', async ()=>{
            // Record some test metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Export Test',
                testSuite: 'Performance Monitoring Tests',
                duration: 100,
                memoryUsage: 2,
                renderTime: 100,
                networkTime: 150,
                apiTime: 75,
                accessibilityTime: 25,
                performanceGrade: 'A',
                status: 'PASS'
            });
            const exportedData = _testmonitoring.testMonitor.exportMetrics();
            const parsedData = JSON.parse(exportedData);
            _logger.logger.info(`ðŸ“¤ Exported Metrics:`);
            _logger.logger.info(`- Metrics Count: ${parsedData.metrics.length}`);
            _logger.logger.info(`- Alerts Count: ${parsedData.alerts.length}`);
            _logger.logger.info(`- Report Generated: ${!!parsedData.report}`);
            expect(parsedData.metrics).toHaveLength(1);
            expect(parsedData.metrics[0].testName).toBe('Export Test');
            expect(parsedData.report).toBeDefined();
            expect(parsedData.report.totalTests).toBe(1);
        });
    });
    describe('Performance Dashboard Integration', ()=>{
        it('should render performance dashboard with metrics', async ()=>{
            // Record some test metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Dashboard Test',
                testSuite: 'Performance Monitoring Tests',
                duration: 120,
                memoryUsage: 2.5,
                renderTime: 120,
                networkTime: 180,
                apiTime: 90,
                accessibilityTime: 30,
                performanceGrade: 'A',
                status: 'PASS'
            });
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_performancedashboard.PerformanceDashboard, {
                monitor: _testmonitoring.testMonitor
            }));
            // Check if dashboard renders without errors
            expect(container).toBeInTheDocument();
            // Check for key dashboard elements
            expect(_react1.screen.getByText('ðŸš€ Performance Dashboard')).toBeInTheDocument();
            expect(_react1.screen.getByText('Total Tests')).toBeInTheDocument();
            expect(_react1.screen.getByText('Passed')).toBeInTheDocument();
            expect(_react1.screen.getByText('Performance Grade')).toBeInTheDocument();
            _logger.logger.info(`ðŸ“Š Performance Dashboard rendered successfully`);
        });
        it('should display performance metrics table', async ()=>{
            // Record multiple test metrics
            const metrics = [
                {
                    testName: 'Test 1',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 80,
                    memoryUsage: 1.5,
                    renderTime: 80,
                    networkTime: 120,
                    apiTime: 60,
                    accessibilityTime: 20,
                    performanceGrade: 'A+',
                    status: 'PASS',
                    timestamp: new Date()
                },
                {
                    testName: 'Test 2',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 200,
                    memoryUsage: 4,
                    renderTime: 200,
                    networkTime: 300,
                    apiTime: 150,
                    accessibilityTime: 50,
                    performanceGrade: 'C',
                    status: 'PASS',
                    timestamp: new Date()
                }
            ];
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_performancedashboard.PerformanceMetricsTable, {
                metrics: metrics
            }));
            // Check if table renders without errors
            expect(container).toBeInTheDocument();
            // Check for table headers
            expect(_react1.screen.getByText('Test Name')).toBeInTheDocument();
            expect(_react1.screen.getByText('Status')).toBeInTheDocument();
            expect(_react1.screen.getByText('Render Time')).toBeInTheDocument();
            expect(_react1.screen.getByText('Memory')).toBeInTheDocument();
            expect(_react1.screen.getByText('Grade')).toBeInTheDocument();
            _logger.logger.info(`ðŸ“Š Performance Metrics Table rendered successfully`);
        });
    });
});
describe('Performance Monitoring Tests', ()=>{
    beforeEach(()=>{
        // Clear test monitor before each test
        _testmonitoring.testMonitor.clear();
    });
    describe('Performance Metrics Collection', ()=>{
        it('should collect comprehensive performance metrics', async ()=>{
            const startTime = performance.now();
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                }));
            });
            const endTime = performance.now();
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const renderTime = endTime - startTime;
            const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
            const performanceGrade = (0, _testmonitoring.calculatePerformanceGrade)(renderTime, memoryUsage);
            // Record metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'should collect comprehensive performance metrics',
                testSuite: 'Performance Monitoring Tests',
                duration: renderTime,
                memoryUsage,
                renderTime,
                networkTime: 0,
                apiTime: 0,
                accessibilityTime: 0,
                performanceGrade,
                status: 'PASS'
            });
            _logger.logger.info(`ðŸ“Š Performance Metrics Collected:`);
            _logger.logger.info(`- Render Time: ${renderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Memory Usage: ${memoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Performance Grade: ${performanceGrade}`);
            expect(renderTime).toBeLessThan(_testmonitoring.PERFORMANCE_BUDGETS.RENDER_TIME);
            expect(memoryUsage).toBeLessThan(_testmonitoring.PERFORMANCE_BUDGETS.MEMORY_USAGE);
            expect(performanceGrade).toMatch(/^[A-F][+]?$/);
        });
        it('should track performance across multiple test runs', async ()=>{
            const testRuns = 3;
            for(let i = 0; i < testRuns; i++){
                const startTime = performance.now();
                const initialMemory = performance.memory?.usedJSHeapSize || 0;
                await (0, _react1.act)(async ()=>{
                    (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                    }));
                });
                const endTime = performance.now();
                const finalMemory = performance.memory?.usedJSHeapSize || 0;
                const renderTime = endTime - startTime;
                const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
                const performanceGrade = (0, _testmonitoring.calculatePerformanceGrade)(renderTime, memoryUsage);
                _testmonitoring.testMonitor.recordMetrics({
                    testName: `Performance Test Run ${i + 1}`,
                    testSuite: 'Performance Monitoring Tests',
                    duration: renderTime,
                    memoryUsage,
                    renderTime,
                    networkTime: 0,
                    apiTime: 0,
                    accessibilityTime: 0,
                    performanceGrade,
                    status: 'PASS'
                });
            }
            const report = _testmonitoring.testMonitor.generateReport();
            _logger.logger.info(`ðŸ“Š Multi-Run Performance Report:`);
            _logger.logger.info(`- Total Tests: ${report.totalTests}`);
            _logger.logger.info(`- Average Render Time: ${report.averageRenderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Average Memory Usage: ${report.averageMemoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Overall Grade: ${report.performanceGrade}`);
            expect(report.totalTests).toBe(testRuns);
            expect(report.passedTests).toBe(testRuns);
            expect(report.performanceGrade).toMatch(/^[A-F][+]?$/);
        });
        it('should generate performance alerts for poor performance', async ()=>{
            // Simulate poor performance
            const startTime = performance.now();
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactrouterdom.BrowserRouter, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {})
                }));
            });
            const endTime = performance.now();
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const renderTime = endTime - startTime;
            const memoryUsage = (finalMemory - initialMemory) / (1024 * 1024);
            // Record metrics with artificially poor performance for testing
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Poor Performance Test',
                testSuite: 'Performance Monitoring Tests',
                duration: renderTime,
                memoryUsage: memoryUsage > 5 ? memoryUsage : 15,
                renderTime: renderTime > 200 ? renderTime : 300,
                networkTime: 600,
                apiTime: 0,
                accessibilityTime: 0,
                performanceGrade: 'D',
                status: 'PASS'
            });
            const alerts = _testmonitoring.testMonitor.getAlerts();
            _logger.logger.info(`ðŸš¨ Performance Alerts Generated: ${alerts.length}`);
            alerts.forEach((alert)=>_logger.logger.info(`- ${alert}`));
            expect(alerts.length).toBeGreaterThan(0);
            expect(alerts.some((alert)=>alert.includes('SLOW RENDER'))).toBe(true);
            expect(alerts.some((alert)=>alert.includes('HIGH MEMORY'))).toBe(true);
            expect(alerts.some((alert)=>alert.includes('SLOW NETWORK'))).toBe(true);
        });
    });
    describe('Performance Reporting', ()=>{
        it('should generate comprehensive performance report', async ()=>{
            // Record multiple test metrics
            const testMetrics = [
                {
                    testName: 'Fast Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 50,
                    memoryUsage: 1,
                    renderTime: 50,
                    networkTime: 100,
                    apiTime: 50,
                    accessibilityTime: 25,
                    performanceGrade: 'A+',
                    status: 'PASS'
                },
                {
                    testName: 'Medium Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 150,
                    memoryUsage: 3,
                    renderTime: 150,
                    networkTime: 200,
                    apiTime: 100,
                    accessibilityTime: 50,
                    performanceGrade: 'B',
                    status: 'PASS'
                },
                {
                    testName: 'Slow Test',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 300,
                    memoryUsage: 8,
                    renderTime: 300,
                    networkTime: 400,
                    apiTime: 200,
                    accessibilityTime: 100,
                    performanceGrade: 'D',
                    status: 'FAIL',
                    errorMessage: 'Performance budget exceeded'
                }
            ];
            testMetrics.forEach((metrics)=>{
                _testmonitoring.testMonitor.recordMetrics(metrics);
            });
            const report = _testmonitoring.testMonitor.generateReport();
            _logger.logger.info(`ðŸ“Š Comprehensive Performance Report:`);
            _logger.logger.info(`- Total Tests: ${report.totalTests}`);
            _logger.logger.info(`- Passed: ${report.passedTests}`);
            _logger.logger.info(`- Failed: ${report.failedTests}`);
            _logger.logger.info(`- Average Render Time: ${report.averageRenderTime.toFixed(2)}ms`);
            _logger.logger.info(`- Average Memory Usage: ${report.averageMemoryUsage.toFixed(2)}MB`);
            _logger.logger.info(`- Performance Grade: ${report.performanceGrade}`);
            _logger.logger.info(`- Recommendations: ${report.recommendations.length}`);
            expect(report.totalTests).toBe(3);
            expect(report.passedTests).toBe(2);
            expect(report.failedTests).toBe(1);
            expect(report.averageRenderTime).toBeCloseTo(166.67, 1);
            expect(report.averageMemoryUsage).toBeCloseTo(4, 1);
            expect(report.performanceGrade).toMatch(/^[A-F][+]?$/);
            expect(report.recommendations.length).toBeGreaterThan(0);
        });
        it('should export metrics to JSON format', async ()=>{
            // Record some test metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Export Test',
                testSuite: 'Performance Monitoring Tests',
                duration: 100,
                memoryUsage: 2,
                renderTime: 100,
                networkTime: 150,
                apiTime: 75,
                accessibilityTime: 25,
                performanceGrade: 'A',
                status: 'PASS'
            });
            const exportedData = _testmonitoring.testMonitor.exportMetrics();
            const parsedData = JSON.parse(exportedData);
            _logger.logger.info(`ðŸ“¤ Exported Metrics:`);
            _logger.logger.info(`- Metrics Count: ${parsedData.metrics.length}`);
            _logger.logger.info(`- Alerts Count: ${parsedData.alerts.length}`);
            _logger.logger.info(`- Report Generated: ${!!parsedData.report}`);
            expect(parsedData.metrics).toHaveLength(1);
            expect(parsedData.metrics[0].testName).toBe('Export Test');
            expect(parsedData.report).toBeDefined();
            expect(parsedData.report.totalTests).toBe(1);
        });
    });
    describe('Performance Dashboard Integration', ()=>{
        it('should render performance dashboard with metrics', async ()=>{
            // Record some test metrics
            _testmonitoring.testMonitor.recordMetrics({
                testName: 'Dashboard Test',
                testSuite: 'Performance Monitoring Tests',
                duration: 120,
                memoryUsage: 2.5,
                renderTime: 120,
                networkTime: 180,
                apiTime: 90,
                accessibilityTime: 30,
                performanceGrade: 'A',
                status: 'PASS'
            });
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_performancedashboard.PerformanceDashboard, {
                monitor: _testmonitoring.testMonitor
            }));
            // Check if dashboard renders without errors
            expect(container).toBeInTheDocument();
            // Check for key dashboard elements
            expect(_react1.screen.getByText('ðŸš€ Performance Dashboard')).toBeInTheDocument();
            expect(_react1.screen.getByText('Total Tests')).toBeInTheDocument();
            expect(_react1.screen.getByText('Passed')).toBeInTheDocument();
            expect(_react1.screen.getByText('Performance Grade')).toBeInTheDocument();
            _logger.logger.info(`ðŸ“Š Performance Dashboard rendered successfully`);
        });
        it('should display performance metrics table', async ()=>{
            // Record multiple test metrics
            const metrics = [
                {
                    testName: 'Test 1',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 80,
                    memoryUsage: 1.5,
                    renderTime: 80,
                    networkTime: 120,
                    apiTime: 60,
                    accessibilityTime: 20,
                    performanceGrade: 'A+',
                    status: 'PASS',
                    timestamp: new Date()
                },
                {
                    testName: 'Test 2',
                    testSuite: 'Performance Monitoring Tests',
                    duration: 200,
                    memoryUsage: 4,
                    renderTime: 200,
                    networkTime: 300,
                    apiTime: 150,
                    accessibilityTime: 50,
                    performanceGrade: 'C',
                    status: 'PASS',
                    timestamp: new Date()
                }
            ];
            const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_performancedashboard.PerformanceMetricsTable, {
                metrics: metrics
            }));
            // Check if table renders without errors
            expect(container).toBeInTheDocument();
            // Check for table headers
            expect(_react1.screen.getByText('Test Name')).toBeInTheDocument();
            expect(_react1.screen.getByText('Status')).toBeInTheDocument();
            expect(_react1.screen.getByText('Render Time')).toBeInTheDocument();
            expect(_react1.screen.getByText('Memory')).toBeInTheDocument();
            expect(_react1.screen.getByText('Grade')).toBeInTheDocument();
            _logger.logger.info(`ðŸ“Š Performance Metrics Table rendered successfully`);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvcGVyZm9ybWFuY2UvcGVyZm9ybWFuY2UtbW9uaXRvcmluZy50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBqZXN0LWVudmlyb25tZW50IGpzZG9tXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCB3YWl0Rm9yLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBVbmlmaWVkRmVlZCBmcm9tICdAL2ZlYXR1cmVzL2ZlZWRzL2NvbXBvbmVudHMvVW5pZmllZEZlZWQnO1xuaW1wb3J0IHsgdGVzdE1vbml0b3IsIGNhbGN1bGF0ZVBlcmZvcm1hbmNlR3JhZGUsIFBFUkZPUk1BTkNFX0JVREdFVFMgfSBmcm9tICcuL3Rlc3QtbW9uaXRvcmluZyc7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZURhc2hib2FyZCwgUGVyZm9ybWFuY2VNZXRyaWNzVGFibGUgfSBmcm9tICcuL3BlcmZvcm1hbmNlLWRhc2hib2FyZCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAL2xpYi91dGlscy9sb2dnZXInO1xuXG4vLyBTZXR1cCBtaW5pbWFsIG1vY2tzIGZvciB0ZXN0IGVudmlyb25tZW50XG5iZWZvcmVBbGwoKCkgPT4ge1xuICAvLyBNb2NrIGxvY2FsU3RvcmFnZSBmb3IgY29tcG9uZW50IGZ1bmN0aW9uYWxpdHlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICB2YWx1ZToge1xuICAgICAgZ2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgc2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICAgICAgY2xlYXI6IGplc3QuZm4oKSxcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9KTtcbiAgXG4gIC8vIE1vY2sgbmF2aWdhdG9yIGZvciBvbmxpbmUgc3RhdHVzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsICdvbkxpbmUnLCB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gIH0pO1xuXG4gIC8vIE1vY2sgZmV0Y2ggdG8gaGFuZGxlIEFQSSBjYWxsc1xuICBnbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCh1cmw6IHN0cmluZykgPT4ge1xuICAgIGlmICh1cmwuaW5jbHVkZXMoJy9hcGkvZmVlZHMnKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICB0aXRsZTogJ1NhbXBsZSBDaXZpYyBBY3Rpdml0eScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Egc2FtcGxlIGNpdmljIGFjdGl2aXR5IGZvciB0ZXN0aW5nJyxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnY2l2aWMnLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBzb3VyY2U6ICd0ZXN0J1xuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAodXJsLmluY2x1ZGVzKCcvYXBpL2Npdmljcy9hbmFseXRpY3MnKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgYW5hbHl0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFZpZXdzOiAxMDAsXG4gICAgICAgICAgICBlbmdhZ2VtZW50OiAwLjc1LFxuICAgICAgICAgICAgdXNlclNhdGlzZmFjdGlvbjogMC44NVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAodXJsLmluY2x1ZGVzKCcvYXBpL3B3YS9vZmZsaW5lL3N5bmMnKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7fSlcbiAgICB9IGFzIFJlc3BvbnNlKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIHRlc3QgbW9uaXRvciBiZWZvcmUgZWFjaCB0ZXN0XG4gICAgdGVzdE1vbml0b3IuY2xlYXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIE1ldHJpY3MgQ29sbGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvbGxlY3QgY29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcGVyZm9ybWFuY2UubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoXG4gICAgICAgICAgPEJyb3dzZXJSb3V0ZXI+XG4gICAgICAgICAgICA8VW5pZmllZEZlZWQgLz5cbiAgICAgICAgICA8L0Jyb3dzZXJSb3V0ZXI+XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlbmRlclRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSAoZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5KSAvICgxMDI0ICogMTAyNCk7XG4gICAgICBjb25zdCBwZXJmb3JtYW5jZUdyYWRlID0gY2FsY3VsYXRlUGVyZm9ybWFuY2VHcmFkZShyZW5kZXJUaW1lLCBtZW1vcnlVc2FnZSk7XG4gICAgICBcbiAgICAgIC8vIFJlY29yZCBtZXRyaWNzXG4gICAgICB0ZXN0TW9uaXRvci5yZWNvcmRNZXRyaWNzKHtcbiAgICAgICAgdGVzdE5hbWU6ICdzaG91bGQgY29sbGVjdCBjb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIG1ldHJpY3MnLFxuICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgZHVyYXRpb246IHJlbmRlclRpbWUsXG4gICAgICAgIG1lbW9yeVVzYWdlLFxuICAgICAgICByZW5kZXJUaW1lLFxuICAgICAgICBuZXR3b3JrVGltZTogMCxcbiAgICAgICAgYXBpVGltZTogMCxcbiAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDAsXG4gICAgICAgIHBlcmZvcm1hbmNlR3JhZGUsXG4gICAgICAgIHN0YXR1czogJ1BBU1MnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGDwn5OKIFBlcmZvcm1hbmNlIE1ldHJpY3MgQ29sbGVjdGVkOmApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gUmVuZGVyIFRpbWU6ICR7cmVuZGVyVGltZS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBNZW1vcnkgVXNhZ2U6ICR7bWVtb3J5VXNhZ2UudG9GaXhlZCgyKX1NQmApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gUGVyZm9ybWFuY2UgR3JhZGU6ICR7cGVyZm9ybWFuY2VHcmFkZX1gKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9CVURHRVRTLlJFTkRFUl9USU1FKTtcbiAgICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX0JVREdFVFMuTUVNT1JZX1VTQUdFKTtcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZUdyYWRlKS50b01hdGNoKC9eW0EtRl1bK10/JC8pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmFjayBwZXJmb3JtYW5jZSBhY3Jvc3MgbXVsdGlwbGUgdGVzdCBydW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFJ1bnMgPSAzO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RSdW5zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJlbmRlcihcbiAgICAgICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICAgICAgICA8VW5pZmllZEZlZWQgLz5cbiAgICAgICAgICAgIDwvQnJvd3NlclJvdXRlcj5cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSAoZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5KSAvICgxMDI0ICogMTAyNCk7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1hbmNlR3JhZGUgPSBjYWxjdWxhdGVQZXJmb3JtYW5jZUdyYWRlKHJlbmRlclRpbWUsIG1lbW9yeVVzYWdlKTtcbiAgICAgICAgXG4gICAgICAgIHRlc3RNb25pdG9yLnJlY29yZE1ldHJpY3Moe1xuICAgICAgICAgIHRlc3ROYW1lOiBgUGVyZm9ybWFuY2UgVGVzdCBSdW4gJHtpICsgMX1gLFxuICAgICAgICAgIHRlc3RTdWl0ZTogJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLFxuICAgICAgICAgIGR1cmF0aW9uOiByZW5kZXJUaW1lLFxuICAgICAgICAgIG1lbW9yeVVzYWdlLFxuICAgICAgICAgIHJlbmRlclRpbWUsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDAsXG4gICAgICAgICAgYXBpVGltZTogMCxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMCxcbiAgICAgICAgICBwZXJmb3JtYW5jZUdyYWRlLFxuICAgICAgICAgIHN0YXR1czogJ1BBU1MnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVwb3J0ID0gdGVzdE1vbml0b3IuZ2VuZXJhdGVSZXBvcnQoKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oYPCfk4ogTXVsdGktUnVuIFBlcmZvcm1hbmNlIFJlcG9ydDpgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFRvdGFsIFRlc3RzOiAke3JlcG9ydC50b3RhbFRlc3RzfWApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gQXZlcmFnZSBSZW5kZXIgVGltZTogJHtyZXBvcnQuYXZlcmFnZVJlbmRlclRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gQXZlcmFnZSBNZW1vcnkgVXNhZ2U6ICR7cmVwb3J0LmF2ZXJhZ2VNZW1vcnlVc2FnZS50b0ZpeGVkKDIpfU1CYCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBPdmVyYWxsIEdyYWRlOiAke3JlcG9ydC5wZXJmb3JtYW5jZUdyYWRlfWApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVwb3J0LnRvdGFsVGVzdHMpLnRvQmUodGVzdFJ1bnMpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5wYXNzZWRUZXN0cykudG9CZSh0ZXN0UnVucyk7XG4gICAgICBleHBlY3QocmVwb3J0LnBlcmZvcm1hbmNlR3JhZGUpLnRvTWF0Y2goL15bQS1GXVsrXT8kLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHBlcmZvcm1hbmNlIGFsZXJ0cyBmb3IgcG9vciBwZXJmb3JtYW5jZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIHBvb3IgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHBlcmZvcm1hbmNlLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKFxuICAgICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICAgICAgPFVuaWZpZWRGZWVkIC8+XG4gICAgICAgICAgPC9Ccm93c2VyUm91dGVyPlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcGVyZm9ybWFuY2UubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gKGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeSkgLyAoMTAyNCAqIDEwMjQpO1xuICAgICAgXG4gICAgICAvLyBSZWNvcmQgbWV0cmljcyB3aXRoIGFydGlmaWNpYWxseSBwb29yIHBlcmZvcm1hbmNlIGZvciB0ZXN0aW5nXG4gICAgICB0ZXN0TW9uaXRvci5yZWNvcmRNZXRyaWNzKHtcbiAgICAgICAgdGVzdE5hbWU6ICdQb29yIFBlcmZvcm1hbmNlIFRlc3QnLFxuICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgZHVyYXRpb246IHJlbmRlclRpbWUsXG4gICAgICAgIG1lbW9yeVVzYWdlOiBtZW1vcnlVc2FnZSA+IDUgPyBtZW1vcnlVc2FnZSA6IDE1LCAvLyBGb3JjZSBoaWdoIG1lbW9yeSB1c2FnZVxuICAgICAgICByZW5kZXJUaW1lOiByZW5kZXJUaW1lID4gMjAwID8gcmVuZGVyVGltZSA6IDMwMCwgLy8gRm9yY2Ugc2xvdyByZW5kZXJcbiAgICAgICAgbmV0d29ya1RpbWU6IDYwMCwgLy8gRm9yY2Ugc2xvdyBuZXR3b3JrXG4gICAgICAgIGFwaVRpbWU6IDAsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlUaW1lOiAwLFxuICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnRCcsXG4gICAgICAgIHN0YXR1czogJ1BBU1MnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFsZXJ0cyA9IHRlc3RNb25pdG9yLmdldEFsZXJ0cygpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbyhg8J+aqCBQZXJmb3JtYW5jZSBBbGVydHMgR2VuZXJhdGVkOiAke2FsZXJ0cy5sZW5ndGh9YCk7XG4gICAgICBhbGVydHMuZm9yRWFjaChhbGVydCA9PiBsb2dnZXIuaW5mbyhgLSAke2FsZXJ0fWApKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFsZXJ0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChhbGVydHMuc29tZShhbGVydCA9PiBhbGVydC5pbmNsdWRlcygnU0xPVyBSRU5ERVInKSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoYWxlcnRzLnNvbWUoYWxlcnQgPT4gYWxlcnQuaW5jbHVkZXMoJ0hJR0ggTUVNT1JZJykpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGFsZXJ0cy5zb21lKGFsZXJ0ID0+IGFsZXJ0LmluY2x1ZGVzKCdTTE9XIE5FVFdPUksnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBSZXBvcnRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBjb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIHJlcG9ydCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJlY29yZCBtdWx0aXBsZSB0ZXN0IG1ldHJpY3NcbiAgICAgIGNvbnN0IHRlc3RNZXRyaWNzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdGVzdE5hbWU6ICdGYXN0IFRlc3QnLFxuICAgICAgICAgIHRlc3RTdWl0ZTogJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLFxuICAgICAgICAgIGR1cmF0aW9uOiA1MCxcbiAgICAgICAgICBtZW1vcnlVc2FnZTogMSxcbiAgICAgICAgICByZW5kZXJUaW1lOiA1MCxcbiAgICAgICAgICBuZXR3b3JrVGltZTogMTAwLFxuICAgICAgICAgIGFwaVRpbWU6IDUwLFxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlUaW1lOiAyNSxcbiAgICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnQSsnIGFzIGNvbnN0LFxuICAgICAgICAgIHN0YXR1czogJ1BBU1MnIGFzIGNvbnN0LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdGVzdE5hbWU6ICdNZWRpdW0gVGVzdCcsXG4gICAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgICBtZW1vcnlVc2FnZTogMyxcbiAgICAgICAgICByZW5kZXJUaW1lOiAxNTAsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDIwMCxcbiAgICAgICAgICBhcGlUaW1lOiAxMDAsXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDUwLFxuICAgICAgICAgIHBlcmZvcm1hbmNlR3JhZGU6ICdCJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdQQVNTJyBhcyBjb25zdCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRlc3ROYW1lOiAnU2xvdyBUZXN0JyxcbiAgICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgIG1lbW9yeVVzYWdlOiA4LFxuICAgICAgICAgIHJlbmRlclRpbWU6IDMwMCxcbiAgICAgICAgICBuZXR3b3JrVGltZTogNDAwLFxuICAgICAgICAgIGFwaVRpbWU6IDIwMCxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMTAwLFxuICAgICAgICAgIHBlcmZvcm1hbmNlR3JhZGU6ICdEJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdGQUlMJyBhcyBjb25zdCxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6ICdQZXJmb3JtYW5jZSBidWRnZXQgZXhjZWVkZWQnLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgdGVzdE1ldHJpY3MuZm9yRWFjaChtZXRyaWNzID0+IHtcbiAgICAgICAgdGVzdE1vbml0b3IucmVjb3JkTWV0cmljcyhtZXRyaWNzKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXBvcnQgPSB0ZXN0TW9uaXRvci5nZW5lcmF0ZVJlcG9ydCgpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbyhg8J+TiiBDb21wcmVoZW5zaXZlIFBlcmZvcm1hbmNlIFJlcG9ydDpgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFRvdGFsIFRlc3RzOiAke3JlcG9ydC50b3RhbFRlc3RzfWApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gUGFzc2VkOiAke3JlcG9ydC5wYXNzZWRUZXN0c31gKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIEZhaWxlZDogJHtyZXBvcnQuZmFpbGVkVGVzdHN9YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBBdmVyYWdlIFJlbmRlciBUaW1lOiAke3JlcG9ydC5hdmVyYWdlUmVuZGVyVGltZS50b0ZpeGVkKDIpfW1zYCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBBdmVyYWdlIE1lbW9yeSBVc2FnZTogJHtyZXBvcnQuYXZlcmFnZU1lbW9yeVVzYWdlLnRvRml4ZWQoMil9TUJgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFBlcmZvcm1hbmNlIEdyYWRlOiAke3JlcG9ydC5wZXJmb3JtYW5jZUdyYWRlfWApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gUmVjb21tZW5kYXRpb25zOiAke3JlcG9ydC5yZWNvbW1lbmRhdGlvbnMubGVuZ3RofWApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVwb3J0LnRvdGFsVGVzdHMpLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVwb3J0LnBhc3NlZFRlc3RzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5mYWlsZWRUZXN0cykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuYXZlcmFnZVJlbmRlclRpbWUpLnRvQmVDbG9zZVRvKDE2Ni42NywgMSk7XG4gICAgICBleHBlY3QocmVwb3J0LmF2ZXJhZ2VNZW1vcnlVc2FnZSkudG9CZUNsb3NlVG8oNCwgMSk7XG4gICAgICBleHBlY3QocmVwb3J0LnBlcmZvcm1hbmNlR3JhZGUpLnRvTWF0Y2goL15bQS1GXVsrXT8kLyk7XG4gICAgICBleHBlY3QocmVwb3J0LnJlY29tbWVuZGF0aW9ucy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IG1ldHJpY3MgdG8gSlNPTiBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWNvcmQgc29tZSB0ZXN0IG1ldHJpY3NcbiAgICAgIHRlc3RNb25pdG9yLnJlY29yZE1ldHJpY3Moe1xuICAgICAgICB0ZXN0TmFtZTogJ0V4cG9ydCBUZXN0JyxcbiAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIG1lbW9yeVVzYWdlOiAyLFxuICAgICAgICByZW5kZXJUaW1lOiAxMDAsXG4gICAgICAgIG5ldHdvcmtUaW1lOiAxNTAsXG4gICAgICAgIGFwaVRpbWU6IDc1LFxuICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMjUsXG4gICAgICAgIHBlcmZvcm1hbmNlR3JhZGU6ICdBJyxcbiAgICAgICAgc3RhdHVzOiAnUEFTUycsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXhwb3J0ZWREYXRhID0gdGVzdE1vbml0b3IuZXhwb3J0TWV0cmljcygpO1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZXhwb3J0ZWREYXRhKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oYPCfk6QgRXhwb3J0ZWQgTWV0cmljczpgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIE1ldHJpY3MgQ291bnQ6ICR7cGFyc2VkRGF0YS5tZXRyaWNzLmxlbmd0aH1gKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIEFsZXJ0cyBDb3VudDogJHtwYXJzZWREYXRhLmFsZXJ0cy5sZW5ndGh9YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBSZXBvcnQgR2VuZXJhdGVkOiAkeyEhcGFyc2VkRGF0YS5yZXBvcnR9YCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChwYXJzZWREYXRhLm1ldHJpY3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChwYXJzZWREYXRhLm1ldHJpY3NbMF0udGVzdE5hbWUpLnRvQmUoJ0V4cG9ydCBUZXN0Jyk7XG4gICAgICBleHBlY3QocGFyc2VkRGF0YS5yZXBvcnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocGFyc2VkRGF0YS5yZXBvcnQudG90YWxUZXN0cykudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIERhc2hib2FyZCBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlbmRlciBwZXJmb3JtYW5jZSBkYXNoYm9hcmQgd2l0aCBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gUmVjb3JkIHNvbWUgdGVzdCBtZXRyaWNzXG4gICAgICB0ZXN0TW9uaXRvci5yZWNvcmRNZXRyaWNzKHtcbiAgICAgICAgdGVzdE5hbWU6ICdEYXNoYm9hcmQgVGVzdCcsXG4gICAgICAgIHRlc3RTdWl0ZTogJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLFxuICAgICAgICBkdXJhdGlvbjogMTIwLFxuICAgICAgICBtZW1vcnlVc2FnZTogMi41LFxuICAgICAgICByZW5kZXJUaW1lOiAxMjAsXG4gICAgICAgIG5ldHdvcmtUaW1lOiAxODAsXG4gICAgICAgIGFwaVRpbWU6IDkwLFxuICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMzAsXG4gICAgICAgIHBlcmZvcm1hbmNlR3JhZGU6ICdBJyxcbiAgICAgICAgc3RhdHVzOiAnUEFTUycsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcig8UGVyZm9ybWFuY2VEYXNoYm9hcmQgbW9uaXRvcj17dGVzdE1vbml0b3J9IC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZGFzaGJvYXJkIHJlbmRlcnMgd2l0aG91dCBlcnJvcnNcbiAgICAgIGV4cGVjdChjb250YWluZXIpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBrZXkgZGFzaGJvYXJkIGVsZW1lbnRzXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgn8J+agCBQZXJmb3JtYW5jZSBEYXNoYm9hcmQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdUb3RhbCBUZXN0cycpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1Bhc3NlZCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1BlcmZvcm1hbmNlIEdyYWRlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGDwn5OKIFBlcmZvcm1hbmNlIERhc2hib2FyZCByZW5kZXJlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBwZXJmb3JtYW5jZSBtZXRyaWNzIHRhYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gUmVjb3JkIG11bHRpcGxlIHRlc3QgbWV0cmljc1xuICAgICAgY29uc3QgbWV0cmljcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHRlc3ROYW1lOiAnVGVzdCAxJyxcbiAgICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgICBkdXJhdGlvbjogODAsXG4gICAgICAgICAgbWVtb3J5VXNhZ2U6IDEuNSxcbiAgICAgICAgICByZW5kZXJUaW1lOiA4MCxcbiAgICAgICAgICBuZXR3b3JrVGltZTogMTIwLFxuICAgICAgICAgIGFwaVRpbWU6IDYwLFxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlUaW1lOiAyMCxcbiAgICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnQSsnIGFzIGNvbnN0LFxuICAgICAgICAgIHN0YXR1czogJ1BBU1MnIGFzIGNvbnN0LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRlc3ROYW1lOiAnVGVzdCAyJyxcbiAgICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICAgIG1lbW9yeVVzYWdlOiA0LFxuICAgICAgICAgIHJlbmRlclRpbWU6IDIwMCxcbiAgICAgICAgICBuZXR3b3JrVGltZTogMzAwLFxuICAgICAgICAgIGFwaVRpbWU6IDE1MCxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogNTAsXG4gICAgICAgICAgcGVyZm9ybWFuY2VHcmFkZTogJ0MnIGFzIGNvbnN0LFxuICAgICAgICAgIHN0YXR1czogJ1BBU1MnIGFzIGNvbnN0LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoPFBlcmZvcm1hbmNlTWV0cmljc1RhYmxlIG1ldHJpY3M9e21ldHJpY3N9IC8+KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFibGUgcmVuZGVycyB3aXRob3V0IGVycm9yc1xuICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHRhYmxlIGhlYWRlcnNcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdUZXN0IE5hbWUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdTdGF0dXMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdSZW5kZXIgVGltZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ01lbW9yeScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0dyYWRlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGDwn5OKIFBlcmZvcm1hbmNlIE1ldHJpY3MgVGFibGUgcmVuZGVyZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBDbGVhciB0ZXN0IG1vbml0b3IgYmVmb3JlIGVhY2ggdGVzdFxuICAgIHRlc3RNb25pdG9yLmNsZWFyKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNZXRyaWNzIENvbGxlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb2xsZWN0IGNvbXByZWhlbnNpdmUgcGVyZm9ybWFuY2UgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHBlcmZvcm1hbmNlLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKFxuICAgICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICAgICAgPFVuaWZpZWRGZWVkIC8+XG4gICAgICAgICAgPC9Ccm93c2VyUm91dGVyPlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcGVyZm9ybWFuY2UubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gKGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeSkgLyAoMTAyNCAqIDEwMjQpO1xuICAgICAgY29uc3QgcGVyZm9ybWFuY2VHcmFkZSA9IGNhbGN1bGF0ZVBlcmZvcm1hbmNlR3JhZGUocmVuZGVyVGltZSwgbWVtb3J5VXNhZ2UpO1xuICAgICAgXG4gICAgICAvLyBSZWNvcmQgbWV0cmljc1xuICAgICAgdGVzdE1vbml0b3IucmVjb3JkTWV0cmljcyh7XG4gICAgICAgIHRlc3ROYW1lOiAnc2hvdWxkIGNvbGxlY3QgY29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBtZXRyaWNzJyxcbiAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgIGR1cmF0aW9uOiByZW5kZXJUaW1lLFxuICAgICAgICBtZW1vcnlVc2FnZSxcbiAgICAgICAgcmVuZGVyVGltZSxcbiAgICAgICAgbmV0d29ya1RpbWU6IDAsXG4gICAgICAgIGFwaVRpbWU6IDAsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlUaW1lOiAwLFxuICAgICAgICBwZXJmb3JtYW5jZUdyYWRlLFxuICAgICAgICBzdGF0dXM6ICdQQVNTJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbyhg8J+TiiBQZXJmb3JtYW5jZSBNZXRyaWNzIENvbGxlY3RlZDpgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFJlbmRlciBUaW1lOiAke3JlbmRlclRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gTWVtb3J5IFVzYWdlOiAke21lbW9yeVVzYWdlLnRvRml4ZWQoMil9TUJgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFBlcmZvcm1hbmNlIEdyYWRlOiAke3BlcmZvcm1hbmNlR3JhZGV9YCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfQlVER0VUUy5SRU5ERVJfVElNRSk7XG4gICAgICBleHBlY3QobWVtb3J5VXNhZ2UpLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9CVURHRVRTLk1FTU9SWV9VU0FHRSk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VHcmFkZSkudG9NYXRjaCgvXltBLUZdWytdPyQvKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgcGVyZm9ybWFuY2UgYWNyb3NzIG11bHRpcGxlIHRlc3QgcnVucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RSdW5zID0gMztcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0UnVuczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcGVyZm9ybWFuY2UubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICByZW5kZXIoXG4gICAgICAgICAgICA8QnJvd3NlclJvdXRlcj5cbiAgICAgICAgICAgICAgPFVuaWZpZWRGZWVkIC8+XG4gICAgICAgICAgICA8L0Jyb3dzZXJSb3V0ZXI+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcGVyZm9ybWFuY2UubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gKGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeSkgLyAoMTAyNCAqIDEwMjQpO1xuICAgICAgICBjb25zdCBwZXJmb3JtYW5jZUdyYWRlID0gY2FsY3VsYXRlUGVyZm9ybWFuY2VHcmFkZShyZW5kZXJUaW1lLCBtZW1vcnlVc2FnZSk7XG4gICAgICAgIFxuICAgICAgICB0ZXN0TW9uaXRvci5yZWNvcmRNZXRyaWNzKHtcbiAgICAgICAgICB0ZXN0TmFtZTogYFBlcmZvcm1hbmNlIFRlc3QgUnVuICR7aSArIDF9YCxcbiAgICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgICBkdXJhdGlvbjogcmVuZGVyVGltZSxcbiAgICAgICAgICBtZW1vcnlVc2FnZSxcbiAgICAgICAgICByZW5kZXJUaW1lLFxuICAgICAgICAgIG5ldHdvcmtUaW1lOiAwLFxuICAgICAgICAgIGFwaVRpbWU6IDAsXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDAsXG4gICAgICAgICAgcGVyZm9ybWFuY2VHcmFkZSxcbiAgICAgICAgICBzdGF0dXM6ICdQQVNTJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcG9ydCA9IHRlc3RNb25pdG9yLmdlbmVyYXRlUmVwb3J0KCk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGDwn5OKIE11bHRpLVJ1biBQZXJmb3JtYW5jZSBSZXBvcnQ6YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBUb3RhbCBUZXN0czogJHtyZXBvcnQudG90YWxUZXN0c31gKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIEF2ZXJhZ2UgUmVuZGVyIFRpbWU6ICR7cmVwb3J0LmF2ZXJhZ2VSZW5kZXJUaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIEF2ZXJhZ2UgTWVtb3J5IFVzYWdlOiAke3JlcG9ydC5hdmVyYWdlTWVtb3J5VXNhZ2UudG9GaXhlZCgyKX1NQmApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gT3ZlcmFsbCBHcmFkZTogJHtyZXBvcnQucGVyZm9ybWFuY2VHcmFkZX1gKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlcG9ydC50b3RhbFRlc3RzKS50b0JlKHRlc3RSdW5zKTtcbiAgICAgIGV4cGVjdChyZXBvcnQucGFzc2VkVGVzdHMpLnRvQmUodGVzdFJ1bnMpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5wZXJmb3JtYW5jZUdyYWRlKS50b01hdGNoKC9eW0EtRl1bK10/JC8pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBwZXJmb3JtYW5jZSBhbGVydHMgZm9yIHBvb3IgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGF0ZSBwb29yIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwZXJmb3JtYW5jZS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcihcbiAgICAgICAgICA8QnJvd3NlclJvdXRlcj5cbiAgICAgICAgICAgIDxVbmlmaWVkRmVlZCAvPlxuICAgICAgICAgIDwvQnJvd3NlclJvdXRlcj5cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHBlcmZvcm1hbmNlLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMDtcbiAgICAgIFxuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IChmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnkpIC8gKDEwMjQgKiAxMDI0KTtcbiAgICAgIFxuICAgICAgLy8gUmVjb3JkIG1ldHJpY3Mgd2l0aCBhcnRpZmljaWFsbHkgcG9vciBwZXJmb3JtYW5jZSBmb3IgdGVzdGluZ1xuICAgICAgdGVzdE1vbml0b3IucmVjb3JkTWV0cmljcyh7XG4gICAgICAgIHRlc3ROYW1lOiAnUG9vciBQZXJmb3JtYW5jZSBUZXN0JyxcbiAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgIGR1cmF0aW9uOiByZW5kZXJUaW1lLFxuICAgICAgICBtZW1vcnlVc2FnZTogbWVtb3J5VXNhZ2UgPiA1ID8gbWVtb3J5VXNhZ2UgOiAxNSwgLy8gRm9yY2UgaGlnaCBtZW1vcnkgdXNhZ2VcbiAgICAgICAgcmVuZGVyVGltZTogcmVuZGVyVGltZSA+IDIwMCA/IHJlbmRlclRpbWUgOiAzMDAsIC8vIEZvcmNlIHNsb3cgcmVuZGVyXG4gICAgICAgIG5ldHdvcmtUaW1lOiA2MDAsIC8vIEZvcmNlIHNsb3cgbmV0d29ya1xuICAgICAgICBhcGlUaW1lOiAwLFxuICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMCxcbiAgICAgICAgcGVyZm9ybWFuY2VHcmFkZTogJ0QnLFxuICAgICAgICBzdGF0dXM6ICdQQVNTJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBhbGVydHMgPSB0ZXN0TW9uaXRvci5nZXRBbGVydHMoKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oYPCfmqggUGVyZm9ybWFuY2UgQWxlcnRzIEdlbmVyYXRlZDogJHthbGVydHMubGVuZ3RofWApO1xuICAgICAgYWxlcnRzLmZvckVhY2goYWxlcnQgPT4gbG9nZ2VyLmluZm8oYC0gJHthbGVydH1gKSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChhbGVydHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoYWxlcnRzLnNvbWUoYWxlcnQgPT4gYWxlcnQuaW5jbHVkZXMoJ1NMT1cgUkVOREVSJykpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGFsZXJ0cy5zb21lKGFsZXJ0ID0+IGFsZXJ0LmluY2x1ZGVzKCdISUdIIE1FTU9SWScpKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChhbGVydHMuc29tZShhbGVydCA9PiBhbGVydC5pbmNsdWRlcygnU0xPVyBORVRXT1JLJykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgUmVwb3J0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgY29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSByZXBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWNvcmQgbXVsdGlwbGUgdGVzdCBtZXRyaWNzXG4gICAgICBjb25zdCB0ZXN0TWV0cmljcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHRlc3ROYW1lOiAnRmFzdCBUZXN0JyxcbiAgICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgICBkdXJhdGlvbjogNTAsXG4gICAgICAgICAgbWVtb3J5VXNhZ2U6IDEsXG4gICAgICAgICAgcmVuZGVyVGltZTogNTAsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDEwMCxcbiAgICAgICAgICBhcGlUaW1lOiA1MCxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMjUsXG4gICAgICAgICAgcGVyZm9ybWFuY2VHcmFkZTogJ0ErJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdQQVNTJyBhcyBjb25zdCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRlc3ROYW1lOiAnTWVkaXVtIFRlc3QnLFxuICAgICAgICAgIHRlc3RTdWl0ZTogJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLFxuICAgICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgICAgbWVtb3J5VXNhZ2U6IDMsXG4gICAgICAgICAgcmVuZGVyVGltZTogMTUwLFxuICAgICAgICAgIG5ldHdvcmtUaW1lOiAyMDAsXG4gICAgICAgICAgYXBpVGltZTogMTAwLFxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlUaW1lOiA1MCxcbiAgICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnQicgYXMgY29uc3QsXG4gICAgICAgICAgc3RhdHVzOiAnUEFTUycgYXMgY29uc3QsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXN0TmFtZTogJ1Nsb3cgVGVzdCcsXG4gICAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICBtZW1vcnlVc2FnZTogOCxcbiAgICAgICAgICByZW5kZXJUaW1lOiAzMDAsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDQwMCxcbiAgICAgICAgICBhcGlUaW1lOiAyMDAsXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDEwMCxcbiAgICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnRCcgYXMgY29uc3QsXG4gICAgICAgICAgc3RhdHVzOiAnRkFJTCcgYXMgY29uc3QsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiAnUGVyZm9ybWFuY2UgYnVkZ2V0IGV4Y2VlZGVkJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIHRlc3RNZXRyaWNzLmZvckVhY2gobWV0cmljcyA9PiB7XG4gICAgICAgIHRlc3RNb25pdG9yLnJlY29yZE1ldHJpY3MobWV0cmljcyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVwb3J0ID0gdGVzdE1vbml0b3IuZ2VuZXJhdGVSZXBvcnQoKTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oYPCfk4ogQ29tcHJlaGVuc2l2ZSBQZXJmb3JtYW5jZSBSZXBvcnQ6YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBUb3RhbCBUZXN0czogJHtyZXBvcnQudG90YWxUZXN0c31gKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFBhc3NlZDogJHtyZXBvcnQucGFzc2VkVGVzdHN9YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBGYWlsZWQ6ICR7cmVwb3J0LmZhaWxlZFRlc3RzfWApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gQXZlcmFnZSBSZW5kZXIgVGltZTogJHtyZXBvcnQuYXZlcmFnZVJlbmRlclRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gQXZlcmFnZSBNZW1vcnkgVXNhZ2U6ICR7cmVwb3J0LmF2ZXJhZ2VNZW1vcnlVc2FnZS50b0ZpeGVkKDIpfU1CYCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBQZXJmb3JtYW5jZSBHcmFkZTogJHtyZXBvcnQucGVyZm9ybWFuY2VHcmFkZX1gKTtcbiAgICAgIGxvZ2dlci5pbmZvKGAtIFJlY29tbWVuZGF0aW9uczogJHtyZXBvcnQucmVjb21tZW5kYXRpb25zLmxlbmd0aH1gKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlcG9ydC50b3RhbFRlc3RzKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5wYXNzZWRUZXN0cykudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuZmFpbGVkVGVzdHMpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVwb3J0LmF2ZXJhZ2VSZW5kZXJUaW1lKS50b0JlQ2xvc2VUbygxNjYuNjcsIDEpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5hdmVyYWdlTWVtb3J5VXNhZ2UpLnRvQmVDbG9zZVRvKDQsIDEpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5wZXJmb3JtYW5jZUdyYWRlKS50b01hdGNoKC9eW0EtRl1bK10/JC8pO1xuICAgICAgZXhwZWN0KHJlcG9ydC5yZWNvbW1lbmRhdGlvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4cG9ydCBtZXRyaWNzIHRvIEpTT04gZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gUmVjb3JkIHNvbWUgdGVzdCBtZXRyaWNzXG4gICAgICB0ZXN0TW9uaXRvci5yZWNvcmRNZXRyaWNzKHtcbiAgICAgICAgdGVzdE5hbWU6ICdFeHBvcnQgVGVzdCcsXG4gICAgICAgIHRlc3RTdWl0ZTogJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcgVGVzdHMnLFxuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBtZW1vcnlVc2FnZTogMixcbiAgICAgICAgcmVuZGVyVGltZTogMTAwLFxuICAgICAgICBuZXR3b3JrVGltZTogMTUwLFxuICAgICAgICBhcGlUaW1lOiA3NSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDI1LFxuICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnQScsXG4gICAgICAgIHN0YXR1czogJ1BBU1MnLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGV4cG9ydGVkRGF0YSA9IHRlc3RNb25pdG9yLmV4cG9ydE1ldHJpY3MoKTtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGV4cG9ydGVkRGF0YSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGDwn5OkIEV4cG9ydGVkIE1ldHJpY3M6YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBNZXRyaWNzIENvdW50OiAke3BhcnNlZERhdGEubWV0cmljcy5sZW5ndGh9YCk7XG4gICAgICBsb2dnZXIuaW5mbyhgLSBBbGVydHMgQ291bnQ6ICR7cGFyc2VkRGF0YS5hbGVydHMubGVuZ3RofWApO1xuICAgICAgbG9nZ2VyLmluZm8oYC0gUmVwb3J0IEdlbmVyYXRlZDogJHshIXBhcnNlZERhdGEucmVwb3J0fWApO1xuICAgICAgXG4gICAgICBleHBlY3QocGFyc2VkRGF0YS5tZXRyaWNzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocGFyc2VkRGF0YS5tZXRyaWNzWzBdLnRlc3ROYW1lKS50b0JlKCdFeHBvcnQgVGVzdCcpO1xuICAgICAgZXhwZWN0KHBhcnNlZERhdGEucmVwb3J0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHBhcnNlZERhdGEucmVwb3J0LnRvdGFsVGVzdHMpLnRvQmUoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBEYXNoYm9hcmQgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZW5kZXIgcGVyZm9ybWFuY2UgZGFzaGJvYXJkIHdpdGggbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJlY29yZCBzb21lIHRlc3QgbWV0cmljc1xuICAgICAgdGVzdE1vbml0b3IucmVjb3JkTWV0cmljcyh7XG4gICAgICAgIHRlc3ROYW1lOiAnRGFzaGJvYXJkIFRlc3QnLFxuICAgICAgICB0ZXN0U3VpdGU6ICdQZXJmb3JtYW5jZSBNb25pdG9yaW5nIFRlc3RzJyxcbiAgICAgICAgZHVyYXRpb246IDEyMCxcbiAgICAgICAgbWVtb3J5VXNhZ2U6IDIuNSxcbiAgICAgICAgcmVuZGVyVGltZTogMTIwLFxuICAgICAgICBuZXR3b3JrVGltZTogMTgwLFxuICAgICAgICBhcGlUaW1lOiA5MCxcbiAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDMwLFxuICAgICAgICBwZXJmb3JtYW5jZUdyYWRlOiAnQScsXG4gICAgICAgIHN0YXR1czogJ1BBU1MnLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoPFBlcmZvcm1hbmNlRGFzaGJvYXJkIG1vbml0b3I9e3Rlc3RNb25pdG9yfSAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGRhc2hib2FyZCByZW5kZXJzIHdpdGhvdXQgZXJyb3JzXG4gICAgICBleHBlY3QoY29udGFpbmVyKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3Iga2V5IGRhc2hib2FyZCBlbGVtZW50c1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ/CfmoAgUGVyZm9ybWFuY2UgRGFzaGJvYXJkJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVG90YWwgVGVzdHMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdQYXNzZWQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdQZXJmb3JtYW5jZSBHcmFkZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbyhg8J+TiiBQZXJmb3JtYW5jZSBEYXNoYm9hcmQgcmVuZGVyZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgcGVyZm9ybWFuY2UgbWV0cmljcyB0YWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJlY29yZCBtdWx0aXBsZSB0ZXN0IG1ldHJpY3NcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXN0TmFtZTogJ1Rlc3QgMScsXG4gICAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgICAgZHVyYXRpb246IDgwLFxuICAgICAgICAgIG1lbW9yeVVzYWdlOiAxLjUsXG4gICAgICAgICAgcmVuZGVyVGltZTogODAsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDEyMCxcbiAgICAgICAgICBhcGlUaW1lOiA2MCxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5VGltZTogMjAsXG4gICAgICAgICAgcGVyZm9ybWFuY2VHcmFkZTogJ0ErJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdQQVNTJyBhcyBjb25zdCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXN0TmFtZTogJ1Rlc3QgMicsXG4gICAgICAgICAgdGVzdFN1aXRlOiAnUGVyZm9ybWFuY2UgTW9uaXRvcmluZyBUZXN0cycsXG4gICAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgICBtZW1vcnlVc2FnZTogNCxcbiAgICAgICAgICByZW5kZXJUaW1lOiAyMDAsXG4gICAgICAgICAgbmV0d29ya1RpbWU6IDMwMCxcbiAgICAgICAgICBhcGlUaW1lOiAxNTAsXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eVRpbWU6IDUwLFxuICAgICAgICAgIHBlcmZvcm1hbmNlR3JhZGU6ICdDJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdQQVNTJyBhcyBjb25zdCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKDxQZXJmb3JtYW5jZU1ldHJpY3NUYWJsZSBtZXRyaWNzPXttZXRyaWNzfSAvPik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhYmxlIHJlbmRlcnMgd2l0aG91dCBlcnJvcnNcbiAgICAgIGV4cGVjdChjb250YWluZXIpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciB0YWJsZSBoZWFkZXJzXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVGVzdCBOYW1lJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnU3RhdHVzJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnUmVuZGVyIFRpbWUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdNZW1vcnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdHcmFkZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICBsb2dnZXIuaW5mbyhg8J+TiiBQZXJmb3JtYW5jZSBNZXRyaWNzIFRhYmxlIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseWApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuXG5cblxuIl0sIm5hbWVzIjpbImJlZm9yZUFsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJnZXRJdGVtIiwiamVzdCIsImZuIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsIndyaXRhYmxlIiwibmF2aWdhdG9yIiwiZ2xvYmFsIiwiZmV0Y2giLCJ1cmwiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwib2siLCJqc29uIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiY2F0ZWdvcnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzb3VyY2UiLCJzdWNjZXNzIiwiYW5hbHl0aWNzIiwidG90YWxWaWV3cyIsImVuZ2FnZW1lbnQiLCJ1c2VyU2F0aXNmYWN0aW9uIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwidGVzdE1vbml0b3IiLCJpdCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiaW5pdGlhbE1lbW9yeSIsIm1lbW9yeSIsInVzZWRKU0hlYXBTaXplIiwiYWN0IiwicmVuZGVyIiwiQnJvd3NlclJvdXRlciIsIlVuaWZpZWRGZWVkIiwiZW5kVGltZSIsImZpbmFsTWVtb3J5IiwicmVuZGVyVGltZSIsIm1lbW9yeVVzYWdlIiwicGVyZm9ybWFuY2VHcmFkZSIsImNhbGN1bGF0ZVBlcmZvcm1hbmNlR3JhZGUiLCJyZWNvcmRNZXRyaWNzIiwidGVzdE5hbWUiLCJ0ZXN0U3VpdGUiLCJkdXJhdGlvbiIsIm5ldHdvcmtUaW1lIiwiYXBpVGltZSIsImFjY2Vzc2liaWxpdHlUaW1lIiwic3RhdHVzIiwibG9nZ2VyIiwiaW5mbyIsInRvRml4ZWQiLCJleHBlY3QiLCJ0b0JlTGVzc1RoYW4iLCJQRVJGT1JNQU5DRV9CVURHRVRTIiwiUkVOREVSX1RJTUUiLCJNRU1PUllfVVNBR0UiLCJ0b01hdGNoIiwidGVzdFJ1bnMiLCJpIiwicmVwb3J0IiwiZ2VuZXJhdGVSZXBvcnQiLCJ0b3RhbFRlc3RzIiwiYXZlcmFnZVJlbmRlclRpbWUiLCJhdmVyYWdlTWVtb3J5VXNhZ2UiLCJ0b0JlIiwicGFzc2VkVGVzdHMiLCJhbGVydHMiLCJnZXRBbGVydHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiYWxlcnQiLCJ0b0JlR3JlYXRlclRoYW4iLCJzb21lIiwidGVzdE1ldHJpY3MiLCJlcnJvck1lc3NhZ2UiLCJtZXRyaWNzIiwiZmFpbGVkVGVzdHMiLCJyZWNvbW1lbmRhdGlvbnMiLCJ0b0JlQ2xvc2VUbyIsImV4cG9ydGVkRGF0YSIsImV4cG9ydE1ldHJpY3MiLCJwYXJzZWREYXRhIiwiSlNPTiIsInBhcnNlIiwidG9IYXZlTGVuZ3RoIiwidG9CZURlZmluZWQiLCJjb250YWluZXIiLCJQZXJmb3JtYW5jZURhc2hib2FyZCIsIm1vbml0b3IiLCJ0b0JlSW5UaGVEb2N1bWVudCIsInNjcmVlbiIsImdldEJ5VGV4dCIsIlBlcmZvcm1hbmNlTWV0cmljc1RhYmxlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7Ozs7OERBRWlCO3dCQUMyQjtnQ0FDZjtvRUFDTjtnQ0FDb0Q7c0NBQ2Q7d0JBQ3ZDOzs7Ozs7QUFFdkIsMkNBQTJDO0FBQzNDQSxVQUFVO0lBQ1IsZ0RBQWdEO0lBQ2hEQyxPQUFPQyxjQUFjLENBQUNDLFFBQVEsZ0JBQWdCO1FBQzVDQyxPQUFPO1lBQ0xDLFNBQVNDLEtBQUtDLEVBQUU7WUFDaEJDLFNBQVNGLEtBQUtDLEVBQUU7WUFDaEJFLFlBQVlILEtBQUtDLEVBQUU7WUFDbkJHLE9BQU9KLEtBQUtDLEVBQUU7UUFDaEI7UUFDQUksVUFBVTtJQUNaO0lBRUEsbUNBQW1DO0lBQ25DVixPQUFPQyxjQUFjLENBQUNVLFdBQVcsVUFBVTtRQUN6Q1IsT0FBTztRQUNQTyxVQUFVO0lBQ1o7SUFFQSxpQ0FBaUM7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