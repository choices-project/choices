fef0e88d3631ed4e77ae5604cfed7e05
/**
 * UnifiedFeed Performance Tests (Jest)
 *
 * Note: This suite is intentionally skipped.
 * Reason: With jsdom and heavy mocking, Jest does not yield meaningful
 * performance metrics. We'll move performance to Playwright + Lighthouse/Tracing.
 *
 * Created: January 19, 2025
 * Updated: 2025-10-20 (skipped in favor of E2E performance checks)
 * Status: ⏭️ Skipped (see testing_audit.md for the plan)
 */ /** @jest-environment jsdom */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _UnifiedFeed = /*#__PURE__*/ _interop_require_default(require("../../../../../features/feeds/components/UnifiedFeed"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Shared mock state for aggregated stores used by UnifiedFeed
const mockStores = {
    feeds: [],
    hashtagStore: {
        hashtags: [],
        trendingHashtags: [],
        isLoading: false,
        error: null
    },
    feedsActions: {
        loadFeeds: _globals.jest.fn(),
        likeFeed: _globals.jest.fn(),
        bookmarkFeed: _globals.jest.fn(),
        refreshFeeds: _globals.jest.fn()
    },
    feedsLoading: false,
    pwaStore: {},
    userStore: {
        user: {
            id: 'test-user'
        }
    },
    notificationStore: {
        addNotification: _globals.jest.fn()
    }
};
const hashtagActions = {
    getTrendingHashtags: _globals.jest.fn()
};
// Mock the aggregated stores module used by UnifiedFeed
_globals.jest.mock('@/lib/stores', ()=>{
    const actual = _globals.jest.requireActual('@/lib/stores');
    const React = require('react');
    const useSyncExternalStore = React.useSyncExternalStore;
    const subscribe = ()=>()=>{};
    const getFeedsSnapshot = ()=>mockStores.feeds;
    const getHashtagSnapshot = ()=>mockStores.hashtagStore;
    const getActionsSnapshot = ()=>mockStores.feedsActions;
    const getLoadingSnapshot = ()=>mockStores.feedsLoading;
    const getUserSnapshot = ()=>mockStores.userStore;
    const getPwaSnapshot = ()=>mockStores.pwaStore;
    const getNotifSnapshot = ()=>mockStores.notificationStore;
    return {
        ...actual,
        useFeeds: ()=>useSyncExternalStore(subscribe, getFeedsSnapshot, getFeedsSnapshot),
        useFeedsActions: (selector)=>{
            const state = useSyncExternalStore(subscribe, getActionsSnapshot, getActionsSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useFeedsLoading: ()=>useSyncExternalStore(subscribe, getLoadingSnapshot, getLoadingSnapshot),
        usePWAStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getPwaSnapshot, getPwaSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useUserStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getUserSnapshot, getUserSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useNotificationStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getNotifSnapshot, getNotifSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useHashtagStore: (selector)=>{
            const state = useSyncExternalStore(subscribe, getHashtagSnapshot, getHashtagSnapshot);
            return typeof selector === 'function' ? selector(state) : state;
        },
        useHashtagActions: ()=>hashtagActions,
        useHashtagStats: ()=>({
                trendingCount: 0
            })
    };
});
// Types only helpers; runtime values are from module mock above
// Ensure mocks are properly initialized
beforeEach(()=>{
    mockStores.feeds.length = 0;
    Object.assign(mockStores.hashtagStore, {
        hashtags: [],
        trendingHashtags: [],
        isLoading: false,
        error: null
    });
    mockStores.feedsActions.loadFeeds = _globals.jest.fn();
    mockStores.feedsActions.likeFeed = _globals.jest.fn();
    mockStores.feedsActions.bookmarkFeed = _globals.jest.fn();
    mockStores.feedsActions.refreshFeeds = _globals.jest.fn();
    mockStores.feedsLoading = false;
});
// Performance test data
const generateLargeFeedData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            title: `Test ${i % 2 === 0 ? 'Poll' : 'Post'} ${i}`,
            content: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i} with some content`,
            summary: `This is test ${i % 2 === 0 ? 'poll' : 'post'} ${i}`,
            author: {
                id: `author-${i}`,
                name: `User ${i}`,
                avatar: `/test-avatar-${i}.jpg`,
                verified: Math.random() > 0.8
            },
            category: `category${i % 5}`,
            tags: [
                `hashtag${i % 10}`,
                `category${i % 5}`
            ],
            type: i % 2 === 0 ? 'poll' : 'article',
            source: {
                name: `Source ${i}`,
                url: `https://example.com/${i}`,
                logo: `/test-logo-${i}.jpg`,
                verified: true
            },
            publishedAt: new Date(Date.now() - i * 1000).toISOString(),
            updatedAt: new Date(Date.now() - i * 1000).toISOString(),
            readTime: Math.floor(Math.random() * 10) + 1,
            engagement: {
                likes: Math.floor(Math.random() * 1000),
                shares: Math.floor(Math.random() * 500),
                comments: Math.floor(Math.random() * 200),
                views: Math.floor(Math.random() * 5000)
            },
            userInteraction: {
                liked: false,
                shared: false,
                bookmarked: false,
                read: false
            },
            metadata: {
                hashtags: [
                    `hashtag${i % 10}`,
                    `category${i % 5}`
                ],
                primary_hashtag: `hashtag${i % 10}`,
                language: 'en'
            }
        }));
const generateLargeHashtagData = (count)=>Array.from({
        length: count
    }, (_, i)=>({
            id: `${i}`,
            name: `hashtag${i}`,
            display_name: `Hashtag ${i}`,
            usage_count: Math.floor(Math.random() * 1000),
            follower_count: Math.floor(Math.random() * 500),
            is_trending: Math.random() > 0.7,
            trend_score: Math.random(),
            created_at: new Date(Date.now() - i * 1000).toISOString(),
            updated_at: new Date(Date.now() - i * 1000).toISOString(),
            is_verified: Math.random() > 0.9,
            is_featured: Math.random() > 0.8
        }));
// Disable this suite in Jest; performance will be validated in E2E/browser
const D = describe.skip;
D('UnifiedFeed Performance Tests', ()=>{
    beforeEach(()=>{
        // reset snapshots
        mockStores.feeds = [];
        mockStores.hashtagStore = {
            hashtags: [],
            trendingHashtags: [],
            isLoading: false,
            error: null
        };
        mockStores.feedsLoading = false;
        mockStores.feedsActions = {
            loadFeeds: _globals.jest.fn(),
            likeFeed: _globals.jest.fn(),
            bookmarkFeed: _globals.jest.fn(),
            refreshFeeds: _globals.jest.fn()
        };
        hashtagActions.getTrendingHashtags = _globals.jest.fn();
    });
    afterEach(()=>{
        _globals.jest.clearAllMocks();
    });
    describe('Rendering Performance', ()=>{
        test('should render small dataset (< 50 items) within 500ms', async ()=>{
            const smallDataset = generateLargeFeedData(50);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...smallDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(500);
        });
        test('should render medium dataset (50-200 items) within 1000ms', async ()=>{
            const mediumDataset = generateLargeFeedData(200);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...mediumDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1000);
        });
        test('should render large dataset (200+ items) within 2000ms', async ()=>{
            const largeDataset = generateLargeFeedData(500);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...largeDataset);
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(2000);
        });
        test('should handle hashtag data efficiently', async ()=>{
            const largeHashtagDataset = generateLargeHashtagData(1000);
            Object.assign(mockStores.hashtagStore, {
                hashtags: largeHashtagDataset,
                trendingHashtags: [],
                isLoading: false,
                error: null
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            expect(renderTime).toBeLessThan(1500);
        });
    });
    describe('Interaction Performance', ()=>{
        test('should handle rapid clicks within acceptable time', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate rapid interactions
            for(let i = 0; i < 20; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                // Small delay to simulate real user behavior
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle 20 interactions within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
        test('should handle scroll events efficiently', async ()=>{
            const largeDataset = generateLargeFeedData(300);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...largeDataset);
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate scroll events
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.scroll(window, {
                    target: {
                        scrollY: i * 100
                    }
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle scroll events efficiently
            expect(totalTime).toBeLessThan(2000);
        });
        test('should handle filter changes efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate filter changes
            for(let i = 0; i < 10; i++){
                const hashtag = _react1.screen.getByText(`hashtag${i % 10}`);
                _react1.fireEvent.click(hashtag);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle filter changes within 1 second
            expect(totalTime).toBeLessThan(1000);
        });
    });
    describe('Memory Performance', ()=>{
        test('should not leak memory during repeated renders', async ()=>{
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Render and unmount component multiple times
            for(let i = 0; i < 10; i++){
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
                unmount();
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            }
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
        test('should handle large datasets without memory issues', async ()=>{
            const veryLargeDataset = generateLargeFeedData(1000);
            mockStores.feeds.length = 0;
            mockStores.feeds.push(...veryLargeDataset);
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (< 50MB for 1000 items)
            expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
        });
    });
    describe('Network Performance', ()=>{
        test('should handle slow network responses gracefully', async ()=>{
            // Mock slow network response
            Object.assign(mockStores.hashtagStore, {
                hashtags: [],
                trendingHashtags: [],
                isLoading: true,
                error: null
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                    enableRealTimeUpdates: false,
                    enableAnalytics: false,
                    enableHaptics: false
                }));
            });
            // Simulate slow loading
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            });
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            // Should handle slow loading within 3 seconds
            expect(totalTime).toBeLessThan(3000);
        });
        test('should handle network errors without performance degradation', async ()=>{
            Object.assign(mockStores.hashtagStore, {
                hashtags: [],
                trendingHashtags: [],
                isLoading: false,
                error: 'Network error'
            });
            const startTime = performance.now();
            await (0, _react1.act)(async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {}));
            });
            const endTime = performance.now();
            const renderTime = endTime - startTime;
            // Should render error state quickly
            expect(renderTime).toBeLessThan(500);
        });
    });
    describe('Animation Performance', ()=>{
        test('should handle animations smoothly', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger animations
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            _react1.fireEvent.click(darkModeButton);
            // Wait for animation to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 300));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Animation should complete within 500ms
            expect(animationTime).toBeLessThan(500);
        });
        test('should handle multiple simultaneous animations', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {
                enableRealTimeUpdates: false,
                enableAnalytics: false,
                enableHaptics: false
            });
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Trigger multiple animations simultaneously
            const darkModeButton = _react1.screen.getByLabelText(/switch to dark mode/i);
            const filtersButton = _react1.screen.getByLabelText(/toggle advanced filters/i);
            _react1.fireEvent.click(darkModeButton);
            _react1.fireEvent.click(filtersButton);
            // Wait for animations to complete
            await (0, _react1.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 500));
            });
            const endTime = performance.now();
            const animationTime = endTime - startTime;
            // Multiple animations should complete within 1 second
            expect(animationTime).toBeLessThan(1000);
        });
    });
    describe('Real-time Updates Performance', ()=>{
        test('should handle real-time updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate real-time updates
            for(let i = 0; i < 10; i++){
                const newFeedData = generateLargeFeedData(10);
                mockStores.feeds.length = 0;
                mockStores.feeds.push(...newFeedData);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle 10 updates within 2 seconds
            expect(updateTime).toBeLessThan(2000);
        });
        test('should handle WebSocket updates without performance issues', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate WebSocket updates
            for(let i = 0; i < 5; i++){
                // Simulate WebSocket message
                (0, _react1.fireEvent)(window, new Event('message'));
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 200));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle WebSocket updates within 1.5 seconds
            expect(updateTime).toBeLessThan(1500);
        });
    });
    describe('Accessibility Performance', ()=>{
        test('should handle screen reader updates efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate screen reader updates
            for(let i = 0; i < 5; i++){
                const likeButton = _react1.screen.getByLabelText(/like/i);
                _react1.fireEvent.click(likeButton);
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 100));
                });
            }
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Should handle screen reader updates within 1 second
            expect(updateTime).toBeLessThan(1000);
        });
        test('should handle keyboard navigation efficiently', async ()=>{
            const component = /*#__PURE__*/ (0, _jsxruntime.jsx)(_UnifiedFeed.default, {});
            (0, _react1.render)(component);
            const startTime = performance.now();
            // Simulate keyboard navigation
            for(let i = 0; i < 10; i++){
                _react1.fireEvent.keyDown(document, {
                    key: 'Tab'
                });
                await (0, _react1.act)(async ()=>{
                    await new Promise((resolve)=>setTimeout(resolve, 50));
                });
            }
            const endTime = performance.now();
            const navigationTime = endTime - startTime;
            // Should handle keyboard navigation within 1 second
            expect(navigationTime).toBeLessThan(1000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbGF1Z2hpbmdraXRzdW5lL3NyYy9DaG9pY2VzL3dlYi90ZXN0cy9qZXN0L3VuaXQvZmVhdHVyZXMvZmVlZHMvVW5pZmllZEZlZWQucGVyZm9ybWFuY2UudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkRmVlZCBQZXJmb3JtYW5jZSBUZXN0cyAoSmVzdClcbiAqXG4gKiBOb3RlOiBUaGlzIHN1aXRlIGlzIGludGVudGlvbmFsbHkgc2tpcHBlZC5cbiAqIFJlYXNvbjogV2l0aCBqc2RvbSBhbmQgaGVhdnkgbW9ja2luZywgSmVzdCBkb2VzIG5vdCB5aWVsZCBtZWFuaW5nZnVsXG4gKiBwZXJmb3JtYW5jZSBtZXRyaWNzLiBXZSdsbCBtb3ZlIHBlcmZvcm1hbmNlIHRvIFBsYXl3cmlnaHQgKyBMaWdodGhvdXNlL1RyYWNpbmcuXG4gKlxuICogQ3JlYXRlZDogSmFudWFyeSAxOSwgMjAyNVxuICogVXBkYXRlZDogMjAyNS0xMC0yMCAoc2tpcHBlZCBpbiBmYXZvciBvZiBFMkUgcGVyZm9ybWFuY2UgY2hlY2tzKVxuICogU3RhdHVzOiDij63vuI8gU2tpcHBlZCAoc2VlIHRlc3RpbmdfYXVkaXQubWQgZm9yIHRoZSBwbGFuKVxuICovXG5cbi8qKiBAamVzdC1lbnZpcm9ubWVudCBqc2RvbSAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIGFjdCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IFVuaWZpZWRGZWVkIGZyb20gJ0AvZmVhdHVyZXMvZmVlZHMvY29tcG9uZW50cy9VbmlmaWVkRmVlZCc7XG5pbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSAnQC9saWIvc3RvcmVzJztcblxuLy8gU2hhcmVkIG1vY2sgc3RhdGUgZm9yIGFnZ3JlZ2F0ZWQgc3RvcmVzIHVzZWQgYnkgVW5pZmllZEZlZWRcbmNvbnN0IG1vY2tTdG9yZXMgPSB7XG4gIGZlZWRzOiBbXSBhcyBhbnlbXSxcbiAgaGFzaHRhZ1N0b3JlOiB7IGhhc2h0YWdzOiBbXSBhcyBhbnlbXSwgdHJlbmRpbmdIYXNodGFnczogW10gYXMgYW55W10sIGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiBudWxsIGFzIGFueSB9LFxuICBmZWVkc0FjdGlvbnM6IHsgbG9hZEZlZWRzOiBqZXN0LmZuKCksIGxpa2VGZWVkOiBqZXN0LmZuKCksIGJvb2ttYXJrRmVlZDogamVzdC5mbigpLCByZWZyZXNoRmVlZHM6IGplc3QuZm4oKSB9LFxuICBmZWVkc0xvYWRpbmc6IGZhbHNlLFxuICBwd2FTdG9yZToge30gYXMgYW55LFxuICB1c2VyU3RvcmU6IHsgdXNlcjogeyBpZDogJ3Rlc3QtdXNlcicgfSB9IGFzIGFueSxcbiAgbm90aWZpY2F0aW9uU3RvcmU6IHsgYWRkTm90aWZpY2F0aW9uOiBqZXN0LmZuKCkgfSBhcyBhbnksXG59O1xuY29uc3QgaGFzaHRhZ0FjdGlvbnMgPSB7IGdldFRyZW5kaW5nSGFzaHRhZ3M6IGplc3QuZm4oKSB9O1xuaW1wb3J0IHsgVCB9IGZyb20gJ0AvbGliL3Rlc3RpbmcvdGVzdElkcyc7XG5cbi8vIE1vY2sgdGhlIGFnZ3JlZ2F0ZWQgc3RvcmVzIG1vZHVsZSB1c2VkIGJ5IFVuaWZpZWRGZWVkXG5qZXN0Lm1vY2soJ0AvbGliL3N0b3JlcycsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCdAL2xpYi9zdG9yZXMnKSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG4gIGNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gKFJlYWN0IGFzIGFueSkudXNlU3luY0V4dGVybmFsU3RvcmU7XG4gIGNvbnN0IHN1YnNjcmliZSA9ICgpID0+ICgpID0+IHt9O1xuICBjb25zdCBnZXRGZWVkc1NuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5mZWVkcztcbiAgY29uc3QgZ2V0SGFzaHRhZ1NuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5oYXNodGFnU3RvcmU7XG4gIGNvbnN0IGdldEFjdGlvbnNTbmFwc2hvdCA9ICgpID0+IG1vY2tTdG9yZXMuZmVlZHNBY3Rpb25zO1xuICBjb25zdCBnZXRMb2FkaW5nU25hcHNob3QgPSAoKSA9PiBtb2NrU3RvcmVzLmZlZWRzTG9hZGluZztcbiAgY29uc3QgZ2V0VXNlclNuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy51c2VyU3RvcmU7XG4gIGNvbnN0IGdldFB3YVNuYXBzaG90ID0gKCkgPT4gbW9ja1N0b3Jlcy5wd2FTdG9yZTtcbiAgY29uc3QgZ2V0Tm90aWZTbmFwc2hvdCA9ICgpID0+IG1vY2tTdG9yZXMubm90aWZpY2F0aW9uU3RvcmU7XG4gIHJldHVybiB7XG4gICAgLi4uYWN0dWFsLFxuICAgIHVzZUZlZWRzOiAoKSA9PiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldEZlZWRzU25hcHNob3QsIGdldEZlZWRzU25hcHNob3QpLFxuICAgIHVzZUZlZWRzQWN0aW9uczogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0QWN0aW9uc1NuYXBzaG90LCBnZXRBY3Rpb25zU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlRmVlZHNMb2FkaW5nOiAoKSA9PiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldExvYWRpbmdTbmFwc2hvdCwgZ2V0TG9hZGluZ1NuYXBzaG90KSxcbiAgICB1c2VQV0FTdG9yZTogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0UHdhU25hcHNob3QsIGdldFB3YVNuYXBzaG90KTtcbiAgICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvcihzdGF0ZSkgOiBzdGF0ZTtcbiAgICB9LFxuICAgIHVzZVVzZXJTdG9yZTogKHNlbGVjdG9yPzogYW55KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0VXNlclNuYXBzaG90LCBnZXRVc2VyU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlTm90aWZpY2F0aW9uU3RvcmU6IChzZWxlY3Rvcj86IGFueSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldE5vdGlmU25hcHNob3QsIGdldE5vdGlmU25hcHNob3QpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yKHN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgdXNlSGFzaHRhZ1N0b3JlOiAoc2VsZWN0b3I/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRIYXNodGFnU25hcHNob3QsIGdldEhhc2h0YWdTbmFwc2hvdCk7XG4gICAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3Ioc3RhdGUpIDogc3RhdGU7XG4gICAgfSxcbiAgICB1c2VIYXNodGFnQWN0aW9uczogKCkgPT4gaGFzaHRhZ0FjdGlvbnMsXG4gICAgdXNlSGFzaHRhZ1N0YXRzOiAoKSA9PiAoeyB0cmVuZGluZ0NvdW50OiAwIH0pLFxuICB9O1xufSk7XG5cbi8vIFR5cGVzIG9ubHkgaGVscGVyczsgcnVudGltZSB2YWx1ZXMgYXJlIGZyb20gbW9kdWxlIG1vY2sgYWJvdmVcblxuLy8gRW5zdXJlIG1vY2tzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZFxuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgT2JqZWN0LmFzc2lnbihtb2NrU3RvcmVzLmhhc2h0YWdTdG9yZSwgeyBoYXNodGFnczogW10sIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9KTtcbiAgbW9ja1N0b3Jlcy5mZWVkc0FjdGlvbnMubG9hZEZlZWRzID0gamVzdC5mbigpO1xuICBtb2NrU3RvcmVzLmZlZWRzQWN0aW9ucy5saWtlRmVlZCA9IGplc3QuZm4oKTtcbiAgbW9ja1N0b3Jlcy5mZWVkc0FjdGlvbnMuYm9va21hcmtGZWVkID0gamVzdC5mbigpO1xuICBtb2NrU3RvcmVzLmZlZWRzQWN0aW9ucy5yZWZyZXNoRmVlZHMgPSBqZXN0LmZuKCk7XG4gIG1vY2tTdG9yZXMuZmVlZHNMb2FkaW5nID0gZmFsc2U7XG59KTtcblxuXG4vLyBQZXJmb3JtYW5jZSB0ZXN0IGRhdGFcbmNvbnN0IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSA9IChjb3VudDogbnVtYmVyKSA9PiBcbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgaWQ6IGAke2l9YCxcbiAgICB0aXRsZTogYFRlc3QgJHtpICUgMiA9PT0gMCA/ICdQb2xsJyA6ICdQb3N0J30gJHtpfWAsXG4gICAgY29udGVudDogYFRoaXMgaXMgdGVzdCAke2kgJSAyID09PSAwID8gJ3BvbGwnIDogJ3Bvc3QnfSAke2l9IHdpdGggc29tZSBjb250ZW50YCxcbiAgICBzdW1tYXJ5OiBgVGhpcyBpcyB0ZXN0ICR7aSAlIDIgPT09IDAgPyAncG9sbCcgOiAncG9zdCd9ICR7aX1gLFxuICAgIGF1dGhvcjoge1xuICAgICAgaWQ6IGBhdXRob3ItJHtpfWAsXG4gICAgICBuYW1lOiBgVXNlciAke2l9YCxcbiAgICAgIGF2YXRhcjogYC90ZXN0LWF2YXRhci0ke2l9LmpwZ2AsXG4gICAgICB2ZXJpZmllZDogTWF0aC5yYW5kb20oKSA+IDAuOFxuICAgIH0sXG4gICAgY2F0ZWdvcnk6IGBjYXRlZ29yeSR7aSAlIDV9YCxcbiAgICB0YWdzOiBbYGhhc2h0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxuICAgIHR5cGU6IChpICUgMiA9PT0gMCA/ICdwb2xsJyA6ICdhcnRpY2xlJykgYXMgJ3BvbGwnIHwgJ2FydGljbGUnLFxuICAgIHNvdXJjZToge1xuICAgICAgbmFtZTogYFNvdXJjZSAke2l9YCxcbiAgICAgIHVybDogYGh0dHBzOi8vZXhhbXBsZS5jb20vJHtpfWAsXG4gICAgICBsb2dvOiBgL3Rlc3QtbG9nby0ke2l9LmpwZ2AsXG4gICAgICB2ZXJpZmllZDogdHJ1ZVxuICAgIH0sXG4gICAgcHVibGlzaGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICByZWFkVGltZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApICsgMSxcbiAgICBlbmdhZ2VtZW50OiB7XG4gICAgICBsaWtlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCksXG4gICAgICBzaGFyZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCksXG4gICAgICBjb21tZW50czogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjAwKSxcbiAgICAgIHZpZXdzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICAgIH0sXG4gICAgdXNlckludGVyYWN0aW9uOiB7XG4gICAgICBsaWtlZDogZmFsc2UsXG4gICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgYm9va21hcmtlZDogZmFsc2UsXG4gICAgICByZWFkOiBmYWxzZVxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIGhhc2h0YWdzOiBbYGhhc2h0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxuICAgICAgcHJpbWFyeV9oYXNodGFnOiBgaGFzaHRhZyR7aSAlIDEwfWAsXG4gICAgICBsYW5ndWFnZTogJ2VuJ1xuICAgIH1cbiAgfSkpO1xuXG5jb25zdCBnZW5lcmF0ZUxhcmdlSGFzaHRhZ0RhdGEgPSAoY291bnQ6IG51bWJlcikgPT5cbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogY291bnQgfSwgKF8sIGkpID0+ICh7XG4gICAgaWQ6IGAke2l9YCxcbiAgICBuYW1lOiBgaGFzaHRhZyR7aX1gLFxuICAgIGRpc3BsYXlfbmFtZTogYEhhc2h0YWcgJHtpfWAsXG4gICAgdXNhZ2VfY291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApLFxuICAgIGZvbGxvd2VyX2NvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDApLFxuICAgIGlzX3RyZW5kaW5nOiBNYXRoLnJhbmRvbSgpID4gMC43LFxuICAgIHRyZW5kX3Njb3JlOiBNYXRoLnJhbmRvbSgpLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSBpICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gaSAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgaXNfdmVyaWZpZWQ6IE1hdGgucmFuZG9tKCkgPiAwLjksXG4gICAgaXNfZmVhdHVyZWQ6IE1hdGgucmFuZG9tKCkgPiAwLjhcbiAgfSkpO1xuXG4vLyBEaXNhYmxlIHRoaXMgc3VpdGUgaW4gSmVzdDsgcGVyZm9ybWFuY2Ugd2lsbCBiZSB2YWxpZGF0ZWQgaW4gRTJFL2Jyb3dzZXJcbmNvbnN0IEQgPSBkZXNjcmliZS5za2lwO1xuXG5EKCdVbmlmaWVkRmVlZCBQZXJmb3JtYW5jZSBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gcmVzZXQgc25hcHNob3RzXG4gICAgbW9ja1N0b3Jlcy5mZWVkcyA9IFtdO1xuICAgIG1vY2tTdG9yZXMuaGFzaHRhZ1N0b3JlID0geyBoYXNodGFnczogW10sIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLCBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogbnVsbCB9IGFzIGFueTtcbiAgICBtb2NrU3RvcmVzLmZlZWRzTG9hZGluZyA9IGZhbHNlO1xuICAgIG1vY2tTdG9yZXMuZmVlZHNBY3Rpb25zID0geyBsb2FkRmVlZHM6IGplc3QuZm4oKSwgbGlrZUZlZWQ6IGplc3QuZm4oKSwgYm9va21hcmtGZWVkOiBqZXN0LmZuKCksIHJlZnJlc2hGZWVkczogamVzdC5mbigpIH0gYXMgYW55O1xuICAgIGhhc2h0YWdBY3Rpb25zLmdldFRyZW5kaW5nSGFzaHRhZ3MgPSBqZXN0LmZuKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZW5kZXJpbmcgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlbmRlciBzbWFsbCBkYXRhc2V0ICg8IDUwIGl0ZW1zKSB3aXRoaW4gNTAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzbWFsbERhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoNTApO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5sZW5ndGggPSAwO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5wdXNoKC4uLihzbWFsbERhdGFzZXQgYXMgYW55W10pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlbmRlciBtZWRpdW0gZGF0YXNldCAoNTAtMjAwIGl0ZW1zKSB3aXRoaW4gMTAwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVkaXVtRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgyMDApO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5sZW5ndGggPSAwO1xuICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5wdXNoKC4uLihtZWRpdW1EYXRhc2V0IGFzIGFueVtdKSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVuZGVyIGxhcmdlIGRhdGFzZXQgKDIwMCsgaXRlbXMpIHdpdGhpbiAyMDAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZURhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlRmVlZERhdGEoNTAwKTtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMucHVzaCguLi4obGFyZ2VEYXRhc2V0IGFzIGFueVtdKSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZW5kZXJUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGhhc2h0YWcgZGF0YSBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlSGFzaHRhZ0RhdGFzZXQgPSBnZW5lcmF0ZUxhcmdlSGFzaHRhZ0RhdGEoMTAwMCk7XG4gICAgICBPYmplY3QuYXNzaWduKG1vY2tTdG9yZXMuaGFzaHRhZ1N0b3JlLCB7IGhhc2h0YWdzOiBsYXJnZUhhc2h0YWdEYXRhc2V0IGFzIGFueVtdLCB0cmVuZGluZ0hhc2h0YWdzOiBbXSwgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IG51bGwgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCByZW5kZXJUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigxNTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVyYWN0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcmFwaWQgY2xpY2tzIHdpdGhpbiBhY2NlcHRhYmxlIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSByYXBpZCBpbnRlcmFjdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBsaWtlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9saWtlL2kpO1xuICAgICAgICBmaXJlRXZlbnQuY2xpY2sobGlrZUJ1dHRvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSB0byBzaW11bGF0ZSByZWFsIHVzZXIgYmVoYXZpb3JcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgMjAgaW50ZXJhY3Rpb25zIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzY3JvbGwgZXZlbnRzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gZ2VuZXJhdGVMYXJnZUZlZWREYXRhKDMwMCk7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLmxlbmd0aCA9IDA7XG4gICAgICBtb2NrU3RvcmVzLmZlZWRzLnB1c2goLi4uKGxhcmdlRGF0YXNldCBhcyBhbnlbXSkpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBzY3JvbGwgZXZlbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgZmlyZUV2ZW50LnNjcm9sbCh3aW5kb3csIHsgdGFyZ2V0OiB7IHNjcm9sbFk6IGkgKiAxMDAgfSB9KTtcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgc2Nyb2xsIGV2ZW50cyBlZmZpY2llbnRseVxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDIwMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBmaWx0ZXIgY2hhbmdlcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGZpbHRlciBjaGFuZ2VzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGNvbnN0IGhhc2h0YWcgPSBzY3JlZW4uZ2V0QnlUZXh0KGBoYXNodGFnJHtpICUgMTB9YCk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhoYXNodGFnKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGZpbHRlciBjaGFuZ2VzIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBub3QgbGVhayBtZW1vcnkgZHVyaW5nIHJlcGVhdGVkIHJlbmRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICAvLyBSZW5kZXIgYW5kIHVubW91bnQgY29tcG9uZW50IG11bHRpcGxlIHRpbWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoPFVuaWZpZWRGZWVkIC8+KTtcbiAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSBtaW5pbWFsICg8IDEwTUIpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgZGF0YXNldHMgd2l0aG91dCBtZW1vcnkgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmVyeUxhcmdlRGF0YXNldCA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgxMDAwKTtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgICAgIG1vY2tTdG9yZXMuZmVlZHMucHVzaCguLi4odmVyeUxhcmdlRGF0YXNldCBhcyBhbnlbXSkpO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPFVuaWZpZWRGZWVkIGVuYWJsZVJlYWxUaW1lVXBkYXRlcz17ZmFsc2V9IGVuYWJsZUFuYWx5dGljcz17ZmFsc2V9IGVuYWJsZUhhcHRpY3M9e2ZhbHNlfSAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlICg8IDUwTUIgZm9yIDEwMDAgaXRlbXMpXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbig1MCAqIDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ05ldHdvcmsgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzbG93IG5ldHdvcmsgcmVzcG9uc2VzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHNsb3cgbmV0d29yayByZXNwb25zZVxuICAgICAgT2JqZWN0LmFzc2lnbihtb2NrU3RvcmVzLmhhc2h0YWdTdG9yZSwgeyBoYXNodGFnczogW10sIHRyZW5kaW5nSGFzaHRhZ3M6IFtdLCBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz4pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNsb3cgbG9hZGluZ1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHNsb3cgbG9hZGluZyB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMzAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzIHdpdGhvdXQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKG1vY2tTdG9yZXMuaGFzaHRhZ1N0b3JlLCB7IGhhc2h0YWdzOiBbXSwgdHJlbmRpbmdIYXNodGFnczogW10sIGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiAnTmV0d29yayBlcnJvcicgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxVbmlmaWVkRmVlZCAvPik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCByZW5kZXIgZXJyb3Igc3RhdGUgcXVpY2tseVxuICAgICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQW5pbWF0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYW5pbWF0aW9ucyBzbW9vdGhseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCBlbmFibGVSZWFsVGltZVVwZGF0ZXM9e2ZhbHNlfSBlbmFibGVBbmFseXRpY3M9e2ZhbHNlfSBlbmFibGVIYXB0aWNzPXtmYWxzZX0gLz47XG4gICAgICByZW5kZXIoY29tcG9uZW50KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgYW5pbWF0aW9uc1xuICAgICAgY29uc3QgZGFya01vZGVCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N3aXRjaCB0byBkYXJrIG1vZGUvaSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZGFya01vZGVCdXR0b24pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBhbmltYXRpb24gdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBhbmltYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gQW5pbWF0aW9uIHNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNTAwbXNcbiAgICAgIGV4cGVjdChhbmltYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oNTAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIGFuaW1hdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSA8VW5pZmllZEZlZWQgZW5hYmxlUmVhbFRpbWVVcGRhdGVzPXtmYWxzZX0gZW5hYmxlQW5hbHl0aWNzPXtmYWxzZX0gZW5hYmxlSGFwdGljcz17ZmFsc2V9IC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIG11bHRpcGxlIGFuaW1hdGlvbnMgc2ltdWx0YW5lb3VzbHlcbiAgICAgIGNvbnN0IGRhcmtNb2RlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zd2l0Y2ggdG8gZGFyayBtb2RlL2kpO1xuICAgICAgY29uc3QgZmlsdGVyc0J1dHRvbiA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvdG9nZ2xlIGFkdmFuY2VkIGZpbHRlcnMvaSk7XG4gICAgICBcbiAgICAgIGZpcmVFdmVudC5jbGljayhkYXJrTW9kZUJ1dHRvbik7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZmlsdGVyc0J1dHRvbik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBhbmltYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gTXVsdGlwbGUgYW5pbWF0aW9ucyBzaG91bGQgY29tcGxldGUgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QoYW5pbWF0aW9uVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbC10aW1lIFVwZGF0ZXMgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByZWFsLXRpbWUgdXBkYXRlcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCBuZXdGZWVkRGF0YSA9IGdlbmVyYXRlTGFyZ2VGZWVkRGF0YSgxMCk7XG4gICAgICAgIG1vY2tTdG9yZXMuZmVlZHMubGVuZ3RoID0gMDtcbiAgICAgICAgbW9ja1N0b3Jlcy5mZWVkcy5wdXNoKC4uLihuZXdGZWVkRGF0YSBhcyBhbnlbXSkpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB1cGRhdGVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSAxMCB1cGRhdGVzIHdpdGhpbiAyIHNlY29uZHNcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIFdlYlNvY2tldCB1cGRhdGVzIHdpdGhvdXQgcGVyZm9ybWFuY2UgaXNzdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBXZWJTb2NrZXQgdXBkYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgLy8gU2ltdWxhdGUgV2ViU29ja2V0IG1lc3NhZ2VcbiAgICAgICAgZmlyZUV2ZW50KHdpbmRvdywgbmV3IEV2ZW50KCdtZXNzYWdlJykpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB1cGRhdGVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBXZWJTb2NrZXQgdXBkYXRlcyB3aXRoaW4gMS41IHNlY29uZHNcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMTUwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBY2Nlc3NpYmlsaXR5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2NyZWVuIHJlYWRlciB1cGRhdGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gPFVuaWZpZWRGZWVkIC8+O1xuICAgICAgcmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBzY3JlZW4gcmVhZGVyIHVwZGF0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpa2VCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2xpa2UvaSk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhsaWtlQnV0dG9uKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgc2NyZWVuIHJlYWRlciB1cGRhdGVzIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHVwZGF0ZVRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDxVbmlmaWVkRmVlZCAvPjtcbiAgICAgIHJlbmRlcihjb21wb25lbnQpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRvY3VtZW50LCB7IGtleTogJ1RhYicgfSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgbmF2aWdhdGlvblRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb24gd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QobmF2aWdhdGlvblRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2NrU3RvcmVzIiwiZmVlZHMiLCJoYXNodGFnU3RvcmUiLCJoYXNodGFncyIsInRyZW5kaW5nSGFzaHRhZ3MiLCJpc0xvYWRpbmciLCJlcnJvciIsImZlZWRzQWN0aW9ucyIsImxvYWRGZWVkcyIsImplc3QiLCJmbiIsImxpa2VGZWVkIiwiYm9va21hcmtGZWVkIiwicmVmcmVzaEZlZWRzIiwiZmVlZHNMb2FkaW5nIiwicHdhU3RvcmUiLCJ1c2VyU3RvcmUiLCJ1c2VyIiwiaWQiLCJub3RpZmljYXRpb25TdG9yZSIsImFkZE5vdGlmaWNhdGlvbiIsImhhc2h0YWdBY3Rpb25zIiwiZ2V0VHJlbmRpbmdIYXNodGFncyIsIm1vY2siLCJhY3R1YWwiLCJyZXF1aXJlQWN0dWFsIiwiUmVhY3QiLCJyZXF1aXJlIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRGZWVkc1NuYXBzaG90IiwiZ2V0SGFzaHRhZ1NuYXBzaG90IiwiZ2V0QWN0aW9uc1NuYXBzaG90IiwiZ2V0TG9hZGluZ1NuYXBzaG90IiwiZ2V0VXNlclNuYXBzaG90IiwiZ2V0UHdhU25hcHNob3QiLCJnZXROb3RpZlNuYXBzaG90IiwidXNlRmVlZHMiLCJ1c2VGZWVkc0FjdGlvbnMiLCJzZWxlY3RvciIsInN0YXRlIiwidXNlRmVlZHNMb2FkaW5nIiwidXNlUFdBU3RvcmUiLCJ1c2VVc2VyU3RvcmUiLCJ1c2VOb3RpZmljYXRpb25TdG9yZSIsInVzZUhhc2h0YWdTdG9yZSIsInVzZUhhc2h0YWdBY3Rpb25zIiwidXNlSGFzaHRhZ1N0YXRzIiwidHJlbmRpbmdDb3VudCIsImJlZm9yZUVhY2giLCJsZW5ndGgiLCJPYmplY3QiLCJhc3NpZ24iLCJnZW5lcmF0ZUxhcmdlRmVlZERhdGEiLCJjb3VudCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwidGl0bGUiLCJjb250ZW50Iiwic3VtbWFyeSIsImF1dGhvciIsIm5hbWUiLCJhdmF0YXIiLCJ2ZXJpZmllZCIsIk1hdGgiLCJyYW5kb20iLCJjYXRlZ29yeSIsInRhZ3MiLCJ0eXBlIiwic291cmNlIiwidXJsIiwibG9nbyIsInB1Ymxpc2hlZEF0IiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwicmVhZFRpbWUiLCJmbG9vciIsImVuZ2FnZW1lbnQiLCJsaWtlcyIsInNoYXJlcyIsImNvbW1lbnRzIiwidmlld3MiLCJ1c2VySW50ZXJhY3Rpb24iLCJsaWtlZCIsInNoYXJlZCIsImJvb2ttYXJrZWQiLCJyZWFkIiwibWV0YWRhdGEiLCJwcmltYXJ5X2hhc2h0YWciLCJsYW5ndWFnZSIsImdlbmVyYXRlTGFyZ2VIYXNodGFnRGF0YSIsImRpc3BsYXlfbmFtZSIsInVzYWdlX2NvdW50IiwiZm9sbG93ZXJfY291bnQiLCJpc190cmVuZGluZyIsInRyZW5kX3Njb3JlIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpc192ZXJpZmllZCIsImlzX2ZlYXR1cmVkIiwiRCIsImRlc2NyaWJlIiwic2tpcCIsImFmdGVyRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ0ZXN0Iiwic21hbGxEYXRhc2V0IiwicHVzaCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwiYWN0IiwicmVuZGVyIiwiVW5pZmllZEZlZWQiLCJlbmFibGVSZWFsVGltZVVwZGF0ZXMiLCJlbmFibGVBbmFseXRpY3MiLCJlbmFibGVIYXB0aWNzIiwiZW5kVGltZSIsInJlbmRlclRpbWUiLCJleHBlY3QiLCJ0b0JlTGVzc1RoYW4iLCJtZWRpdW1EYXRhc2V0IiwibGFyZ2VEYXRhc2V0IiwibGFyZ2VIYXNodGFnRGF0YXNldCIsImNvbXBvbmVudCIsImxpa2VCdXR0b24iLCJzY3JlZW4iLCJnZXRCeUxhYmVsVGV4dCIsImZpcmVFdmVudCIsImNsaWNrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidG90YWxUaW1lIiwic2Nyb2xsIiwid2luZG93IiwidGFyZ2V0Iiwic2Nyb2xsWSIsImhhc2h0YWciLCJnZXRCeVRleHQiLCJpbml0aWFsTWVtb3J5IiwibWVtb3J5IiwidXNlZEpTSGVhcFNpemUiLCJ1bm1vdW50IiwiZ2xvYmFsIiwiZ2MiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwidmVyeUxhcmdlRGF0YXNldCIsImRhcmtNb2RlQnV0dG9uIiwiYW5pbWF0aW9uVGltZSIsImZpbHRlcnNCdXR0b24iLCJuZXdGZWVkRGF0YSIsInVwZGF0ZVRpbWUiLCJFdmVudCIsImtl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