/**
 * Provenance Service
 * 
 * Service for data lineage tracking and provenance management
 * Enables complete audit trails and data transformation replay
 */

import { createClient } from '@supabase/supabase-js';
import type { DataSource } from './types';

export interface RawDataRecord {
  id: string;
  retrieved_at: string;
  request_url: string;
  api_version?: string;
  etag?: string;
  payload: Record<string, any>;
  md5_hash?: string;
  response_status?: number;
  response_headers?: Record<string, any>;
  processing_status: 'pending' | 'processing' | 'completed' | 'failed' | 'skipped';
  processing_started_at?: string;
  processing_completed_at?: string;
  processing_error?: string;
  retry_count: number;
  max_retries: number;
  data_type?: string;
  cycle?: string | number;
  jurisdiction?: string;
  address?: string;
  congress?: string | number;
  created_at: string;
  updated_at: string;
}

export interface DataLineageRecord {
  id: string;
  source_table: string;
  source_record_id: string;
  target_table: string;
  target_record_id: string;
  transformation_type: 'insert' | 'update' | 'delete' | 'merge' | 'deduplicate';
  transformation_version: string;
  transformation_params?: Record<string, any>;
  source_data_hash?: string;
  target_data_hash?: string;
  processing_started_at: string;
  processing_completed_at?: string;
  processing_duration_ms?: number;
  success: boolean;
  error_message?: string;
  retry_count: number;
  created_at: string;
}

export interface DataQualityCheck {
  id: string;
  check_name: string;
  check_type: 'schema' | 'completeness' | 'accuracy' | 'consistency' | 'timeliness' | 'uniqueness' | 'referential_integrity';
  table_name: string;
  record_id?: string;
  check_params?: Record<string, any>;
  expected_result?: string;
  actual_result?: string;
  passed: boolean;
  severity: 'error' | 'warning' | 'info';
  error_message?: string;
  suggested_fix?: string;
  check_executed_at: string;
  check_version: string;
  created_at: string;
}

export interface DataTransformation {
  id: string;
  transformation_name: string;
  transformation_version: string;
  source_system: string;
  target_system: string;
  transformation_sql?: string;
  transformation_params?: Record<string, any>;
  input_records_count?: number;
  output_records_count?: number;
  error_records_count?: number;
  processing_started_at: string;
  processing_completed_at?: string;
  processing_duration_ms?: number;
  success: boolean;
  error_message?: string;
  retry_count: number;
  created_at: string;
}

export interface DataChecksum {
  id: string;
  table_name: string;
  record_id: string;
  checksum_type: 'md5' | 'sha256' | 'crc32';
  checksum_value: string;
  data_snapshot?: Record<string, any>;
  calculated_at: string;
  created_at: string;
}

export interface ProvenanceData {
  source_names: DataSource[];
  source_urls: string[];
  retrieved_at: string[];
  transform_version: string;
  api_version?: string;
  etag?: string;
  md5_hash?: string;
  processing_status?: string;
  processing_error?: string;
  retry_count?: number;
}

export class ProvenanceService {
  private _supabase: any = null;

  private get supabase() {
    if (!this._supabase) {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
      
      if (!supabaseUrl || !supabaseKey) {
        throw new Error('Missing Supabase environment variables');
      }
      
      this._supabase = createClient(supabaseUrl, supabaseKey);
    }
    return this._supabase;
  }

  /**
   * Get the Supabase client for testing purposes
   */
  getSupabaseClient() {
    return this.supabase;
  }

  /**
   * Store raw API data in staging
   */
  async storeRawData(
    source: DataSource,
    requestUrl: string,
    payload: Record<string, any>,
    options: {
      apiVersion?: string;
      etag?: string;
      responseStatus?: number;
      responseHeaders?: Record<string, any>;
      dataType?: string;
      cycle?: number;
      jurisdiction?: string;
      address?: string;
      congress?: number;
    } = {}
  ): Promise<string> {
    try {
      const tableName = `staging.${source}_raw`;
      const md5Hash = this.calculateMD5(JSON.stringify(payload));
      
      const recordData: RawDataRecord = {
        id: '', // Will be generated by database
        retrieved_at: new Date().toISOString(),
        request_url: requestUrl,
        api_version: options.apiVersion,
        etag: options.etag,
        payload,
        md5_hash: md5Hash,
        response_status: options.responseStatus,
        response_headers: options.responseHeaders,
        processing_status: 'pending',
        retry_count: 0,
        max_retries: 3,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      // Add source-specific fields
      if (options.dataType) {
        recordData.data_type = options.dataType;
      }
      if (options.cycle) {
        recordData.cycle = options.cycle;
      }
      if (options.jurisdiction) {
        recordData.jurisdiction = options.jurisdiction;
      }
      if (options.address) {
        recordData.address = options.address;
      }
      if (options.congress) {
        recordData.congress = options.congress;
      }

      const { data, error } = await this.supabase
        .from(tableName)
        .insert(recordData)
        .select('id')
        .single();

      if (error) {
        throw new Error(`Failed to store raw data: ${error.message}`);
      }

      return data.id;
    } catch (error) {
      throw new Error(`Raw data storage failed: ${error}`);
    }
  }

  /**
   * Update processing status for raw data
   */
  async updateProcessingStatus(
    source: DataSource,
    recordId: string,
    status: 'processing' | 'completed' | 'failed' | 'skipped',
    error?: string
  ): Promise<void> {
    try {
      const tableName = `staging.${source}_raw`;
      const updateData: any = {
        processing_status: status,
        updated_at: new Date().toISOString()
      };

      if (status === 'processing') {
        updateData.processing_started_at = new Date().toISOString();
      } else if (status === 'completed' || status === 'failed' || status === 'skipped') {
        updateData.processing_completed_at = new Date().toISOString();
      }

      if (error) {
        updateData.processing_error = error;
      }

      const { error: updateError } = await this.supabase
        .from(tableName)
        .update(updateData)
        .eq('id', recordId);

      if (updateError) {
        throw new Error(`Failed to update processing status: ${updateError.message}`);
      }
    } catch (error) {
      throw new Error(`Processing status update failed: ${error}`);
    }
  }

  /**
   * Track data lineage between source and target records
   */
  async trackDataLineage(
    sourceTable: string,
    sourceRecordId: string,
    targetTable: string,
    targetRecordId: string,
    transformationType: 'insert' | 'update' | 'delete' | 'merge' | 'deduplicate',
    transformationVersion: string,
    options: {
      transformationParams?: Record<string, any>;
      sourceDataHash?: string;
      targetDataHash?: string;
    } = {}
  ): Promise<string> {
    try {
      const { data, error } = await this.supabase
        .rpc('track_data_lineage', {
          source_table: sourceTable,
          source_record_id: sourceRecordId,
          target_table: targetTable,
          target_record_id: targetRecordId,
          transformation_type: transformationType,
          transformation_version: transformationVersion,
          transformation_params: options.transformationParams || {},
          source_data_hash: options.sourceDataHash,
          target_data_hash: options.targetDataHash
        });

      if (error) {
        throw new Error(`Failed to track data lineage: ${error.message}`);
      }

      return data;
    } catch (error) {
      throw new Error(`Data lineage tracking failed: ${error}`);
    }
  }

  /**
   * Get data lineage trail for a record
   */
  async getDataLineageTrail(tableName: string, recordId: string): Promise<DataLineageRecord[]> {
    try {
      const { data, error } = await this.supabase
        .rpc('get_data_lineage_trail', {
          table_name: tableName,
          record_id: recordId
        });

      if (error) {
        throw new Error(`Failed to get data lineage trail: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      throw new Error(`Data lineage trail lookup failed: ${error}`);
    }
  }

  /**
   * Calculate and store data checksum
   */
  async calculateAndStoreChecksum(
    tableName: string,
    recordId: string,
    checksumType: 'md5' | 'sha256' | 'crc32' = 'md5'
  ): Promise<string> {
    try {
      const { data, error } = await this.supabase
        .rpc('calculate_data_checksum', {
          table_name: tableName,
          record_id: recordId,
          checksum_type: checksumType
        });

      if (error) {
        throw new Error(`Failed to calculate checksum: ${error.message}`);
      }

      const checksumValue = data;

      // Store the checksum
      const { error: storeError } = await this.supabase
        .from('data_checksums')
        .upsert({
          table_name: tableName,
          record_id: recordId,
          checksum_type: checksumType,
          checksum_value: checksumValue,
          calculated_at: new Date().toISOString()
        }, {
          onConflict: 'table_name,record_id,checksum_type'
        });

      if (storeError) {
        throw new Error(`Failed to store checksum: ${storeError.message}`);
      }

      return checksumValue;
    } catch (error) {
      throw new Error(`Checksum calculation failed: ${error}`);
    }
  }

  /**
   * Validate data quality for a record
   */
  async validateDataQuality(
    tableName: string,
    recordId: string,
    checkVersion: string = '1.0'
  ): Promise<DataQualityCheck[]> {
    try {
      const { data, error } = await this.supabase
        .rpc('validate_data_quality', {
          table_name: tableName,
          record_id: recordId,
          check_version: checkVersion
        });

      if (error) {
        throw new Error(`Failed to validate data quality: ${error.message}`);
      }

      // Store the quality check results
      const qualityChecks = data.map((check: any) => ({
        check_name: check.check_name,
        check_type: check.check_type,
        table_name: tableName,
        record_id: recordId,
        passed: check.passed,
        severity: check.severity,
        error_message: check.error_message,
        check_executed_at: new Date().toISOString(),
        check_version: checkVersion
      }));

      const { error: storeError } = await this.supabase
        .from('data_quality_checks')
        .insert(qualityChecks);

      if (storeError) {
        console.warn(`Failed to store quality check results: ${storeError.message}`);
      }

      return qualityChecks;
    } catch (error) {
      throw new Error(`Data quality validation failed: ${error}`);
    }
  }

  /**
   * Get raw data by ID
   */
  async getRawData(source: DataSource, recordId: string): Promise<RawDataRecord | null> {
    try {
      const tableName = `staging.${source}_raw`;
      
      const { data, error } = await this.supabase
        .from(tableName)
        .select('*')
        .eq('id', recordId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null; // No results found
        }
        throw new Error(`Failed to get raw data: ${error.message}`);
      }

      return data;
    } catch (error) {
      throw new Error(`Raw data lookup failed: ${error}`);
    }
  }

  /**
   * Get processing summary for a source
   */
  async getProcessingSummary(source: DataSource): Promise<{
    total_records: number;
    pending: number;
    processing: number;
    completed: number;
    failed: number;
    skipped: number;
    success_rate: number;
  }> {
    try {
      const tableName = `staging.${source}_raw`;
      
      const { data, error } = await this.supabase
        .from(tableName)
        .select('processing_status');

      if (error) {
        throw new Error(`Failed to get processing summary: ${error.message}`);
      }

      const records = data || [];
      const total = records.length;
      const pending = records.filter((r: { processing_status: string }) => r.processing_status === 'pending').length;
      const processing = records.filter((r: { processing_status: string }) => r.processing_status === 'processing').length;
      const completed = records.filter((r: { processing_status: string }) => r.processing_status === 'completed').length;
      const failed = records.filter((r: { processing_status: string }) => r.processing_status === 'failed').length;
      const skipped = records.filter((r: { processing_status: string }) => r.processing_status === 'skipped').length;
      const success_rate = total > 0 ? (completed / total) * 100 : 0;

      return {
        total_records: total,
        pending,
        processing,
        completed,
        failed,
        skipped,
        success_rate
      };
    } catch (error) {
      throw new Error(`Processing summary lookup failed: ${error}`);
    }
  }

  /**
   * Get data quality summary
   */
  async getDataQualitySummary(): Promise<Array<{
    table_name: string;
    check_type: string;
    total_checks: number;
    passed_checks: number;
    failed_checks: number;
    pass_rate: number;
    error_count: number;
    warning_count: number;
    info_count: number;
    last_check: string;
  }>> {
    try {
      const { data, error } = await this.supabase
        .from('data_quality_summary')
        .select('*');

      if (error) {
        throw new Error(`Failed to get data quality summary: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      throw new Error(`Data quality summary lookup failed: ${error}`);
    }
  }

  /**
   * Create provenance data for a record
   */
  createProvenanceData(
    sourceNames: DataSource[],
    sourceUrls: string[],
    retrievedAt: string[],
    transformVersion: string,
    options: {
      apiVersion?: string;
      etag?: string;
      md5Hash?: string;
      processingStatus?: string;
      processingError?: string;
      retryCount?: number;
    } = {}
  ): ProvenanceData {
    return {
      source_names: sourceNames,
      source_urls: sourceUrls,
      retrieved_at: retrievedAt,
      transform_version: transformVersion,
      api_version: options.apiVersion,
      etag: options.etag,
      md5_hash: options.md5Hash,
      processing_status: options.processingStatus,
      processing_error: options.processingError,
      retry_count: options.retryCount
    };
  }

  /**
   * Get provenance data from a record
   */
  getProvenanceData(record: any): ProvenanceData | null {
    if (!record.provenance) {
      return null;
    }

    return record.provenance as ProvenanceData;
  }

  /**
   * Calculate MD5 hash
   */
  private calculateMD5(input: string): string {
    // This is a simplified MD5 calculation
    // In production, you'd use a proper crypto library
    const crypto = require('crypto');
    return crypto.createHash('md5').update(input).digest('hex');
  }

  /**
   * Get all staging processing summaries
   */
  async getAllStagingSummaries(): Promise<Array<{
    source: string;
    total_records: number;
    pending: number;
    processing: number;
    completed: number;
    failed: number;
    skipped: number;
    success_rate: number;
  }>> {
    try {
      const { data, error } = await this.supabase
        .from('staging_processing_summary')
        .select('*');

      if (error) {
        throw new Error(`Failed to get staging summaries: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      throw new Error(`Staging summaries lookup failed: ${error}`);
    }
  }
}

// Export singleton instance
export const provenanceService = new ProvenanceService();
