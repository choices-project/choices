/**
 * Provenance Service
 *
 * Service for data lineage tracking and provenance management
 * Enables complete audit trails and data transformation replay
 */
import { createClient } from '@supabase/supabase-js';
export class ProvenanceService {
    _supabase = null;
    get supabase() {
        if (!this._supabase) {
            const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
            const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
            if (!supabaseUrl || !supabaseKey) {
                throw new Error('Missing Supabase environment variables');
            }
            this._supabase = createClient(supabaseUrl, supabaseKey);
        }
        return this._supabase;
    }
    /**
     * Get the Supabase client for testing purposes
     */
    getSupabaseClient() {
        return this.supabase;
    }
    /**
     * Store raw API data in staging
     */
    async storeRawData(source, requestUrl, payload, options = {}) {
        try {
            const tableName = `staging.${source}_raw`;
            const md5Hash = await this.calculateMD5(JSON.stringify(payload));
            const recordData = {
                id: '', // Will be generated by database
                retrieved_at: new Date().toISOString(),
                request_url: requestUrl,
                ...(options.apiVersion && { api_version: options.apiVersion }),
                ...(options.etag && { etag: options.etag }),
                payload,
                md5_hash: md5Hash,
                ...(options.responseStatus && { response_status: options.responseStatus }),
                ...(options.responseHeaders && { response_headers: options.responseHeaders }),
                processing_status: 'pending',
                retry_count: 0,
                max_retries: 3,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            // Add source-specific fields
            if (options.dataType) {
                recordData.data_type = options.dataType;
            }
            if (options.cycle) {
                recordData.cycle = options.cycle;
            }
            if (options.jurisdiction) {
                recordData.jurisdiction = options.jurisdiction;
            }
            if (options.address) {
                recordData.address = options.address;
            }
            if (options.congress) {
                recordData.congress = options.congress;
            }
            const { data, error } = await this.supabase
                .from(tableName)
                .insert(recordData)
                .select('id')
                .single();
            if (error) {
                throw new Error(`Failed to store raw data: ${error.message}`);
            }
            return data.id;
        }
        catch (error) {
            throw new Error(`Raw data storage failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Update processing status for raw data
     */
    async updateProcessingStatus(source, recordId, status, error) {
        try {
            const tableName = `staging.${source}_raw`;
            const updateData = {
                processing_status: status,
                updated_at: new Date().toISOString()
            };
            if (status === 'processing') {
                updateData.processing_started_at = new Date().toISOString();
            }
            else if (status === 'completed' || status === 'failed' || status === 'skipped') {
                updateData.processing_completed_at = new Date().toISOString();
            }
            if (error) {
                updateData.processing_error = error;
            }
            const { error: updateError } = await this.supabase
                .from(tableName)
                .update(updateData)
                .eq('id', recordId);
            if (updateError) {
                throw new Error(`Failed to update processing status: ${updateError.message}`);
            }
        }
        catch (error) {
            throw new Error(`Processing status update failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Track data lineage between source and target records
     */
    async trackDataLineage(sourceTable, sourceRecordId, targetTable, targetRecordId, transformationType, transformationVersion, options = {}) {
        try {
            const { data, error } = await this.supabase
                .rpc('track_data_lineage', {
                source_table: sourceTable,
                source_record_id: sourceRecordId,
                target_table: targetTable,
                target_record_id: targetRecordId,
                transformation_type: transformationType,
                transformation_version: transformationVersion,
                transformation_params: options.transformationParams || {},
                source_data_hash: options.sourceDataHash,
                target_data_hash: options.targetDataHash
            });
            if (error) {
                throw new Error(`Failed to track data lineage: ${error.message}`);
            }
            return data;
        }
        catch (error) {
            throw new Error(`Data lineage tracking failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Get data lineage trail for a record
     */
    async getDataLineageTrail(tableName, recordId) {
        try {
            const { data, error } = await this.supabase
                .rpc('get_data_lineage_trail', {
                table_name: tableName,
                record_id: recordId
            });
            if (error) {
                throw new Error(`Failed to get data lineage trail: ${error.message}`);
            }
            return data || [];
        }
        catch (error) {
            throw new Error(`Data lineage trail lookup failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Calculate and store data checksum
     */
    async calculateAndStoreChecksum(tableName, recordId, checksumType = 'md5') {
        try {
            const { data, error } = await this.supabase
                .rpc('calculate_data_checksum', {
                table_name: tableName,
                record_id: recordId,
                checksum_type: checksumType
            });
            if (error) {
                throw new Error(`Failed to calculate checksum: ${error.message}`);
            }
            const checksumValue = data;
            // Store the checksum
            const { error: storeError } = await this.supabase
                .from('data_checksums')
                .upsert({
                table_name: tableName,
                record_id: recordId,
                checksum_type: checksumType,
                checksum_value: checksumValue,
                calculated_at: new Date().toISOString()
            }, {
                onConflict: 'table_name,record_id,checksum_type'
            });
            if (storeError) {
                throw new Error(`Failed to store checksum: ${storeError.message}`);
            }
            return checksumValue;
        }
        catch (error) {
            throw new Error(`Checksum calculation failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Validate data quality for a record
     */
    async validateDataQuality(tableName, recordId, checkVersion = '1.0') {
        try {
            const { data, error } = await this.supabase
                .rpc('validate_data_quality', {
                table_name: tableName,
                record_id: recordId,
                check_version: checkVersion
            });
            if (error) {
                throw new Error(`Failed to validate data quality: ${error.message}`);
            }
            // Store the quality check results
            const qualityChecks = data.map((check) => ({
                check_name: check.check_name,
                check_type: check.check_type,
                table_name: tableName,
                record_id: recordId,
                passed: check.passed,
                severity: check.severity,
                error_message: check.error_message,
                check_executed_at: new Date().toISOString(),
                check_version: checkVersion
            }));
            const { error: storeError } = await this.supabase
                .from('data_quality_checks')
                .insert(qualityChecks);
            if (storeError) {
                console.warn(`Failed to store quality check results: ${storeError.message}`);
            }
            return qualityChecks;
        }
        catch (error) {
            throw new Error(`Data quality validation failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Get raw data by ID
     */
    async getRawData(source, recordId) {
        try {
            const tableName = `staging.${source}_raw`;
            const { data, error } = await this.supabase
                .from(tableName)
                .select('*')
                .eq('id', recordId)
                .single();
            if (error) {
                if (error.code === 'PGRST116') {
                    return null; // No results found
                }
                throw new Error(`Failed to get raw data: ${error.message}`);
            }
            return data;
        }
        catch (error) {
            throw new Error(`Raw data lookup failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Get processing summary for a source
     */
    async getProcessingSummary(source) {
        try {
            const tableName = `staging.${source}_raw`;
            const { data, error } = await this.supabase
                .from(tableName)
                .select('processing_status');
            if (error) {
                throw new Error(`Failed to get processing summary: ${error.message}`);
            }
            const records = data || [];
            const total = records.length;
            const pending = records.filter((r) => r.processing_status === 'pending').length;
            const processing = records.filter((r) => r.processing_status === 'processing').length;
            const completed = records.filter((r) => r.processing_status === 'completed').length;
            const failed = records.filter((r) => r.processing_status === 'failed').length;
            const skipped = records.filter((r) => r.processing_status === 'skipped').length;
            const success_rate = total > 0 ? (completed / total) * 100 : 0;
            return {
                total_records: total,
                pending,
                processing,
                completed,
                failed,
                skipped,
                success_rate
            };
        }
        catch (error) {
            throw new Error(`Processing summary lookup failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Get data quality summary
     */
    async getDataQualitySummary() {
        try {
            const { data, error } = await this.supabase
                .from('data_quality_summary')
                .select('*');
            if (error) {
                throw new Error(`Failed to get data quality summary: ${error.message}`);
            }
            return data || [];
        }
        catch (error) {
            throw new Error(`Data quality summary lookup failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Create provenance data for a record
     */
    createProvenanceData(sourceNames, sourceUrls, retrievedAt, transformVersion, options = {}) {
        return {
            source_names: sourceNames,
            source_urls: sourceUrls,
            retrieved_at: retrievedAt,
            transform_version: transformVersion,
            ...(options.apiVersion && { api_version: options.apiVersion }),
            ...(options.etag && { etag: options.etag }),
            ...(options.md5Hash && { md5_hash: options.md5Hash }),
            ...(options.processingStatus && { processing_status: options.processingStatus }),
            ...(options.processingError && { processing_error: options.processingError }),
            ...(options.retryCount && { retry_count: options.retryCount })
        };
    }
    /**
     * Get provenance data from a record
     */
    getProvenanceData(record) {
        if (!record.provenance) {
            return null;
        }
        return record.provenance;
    }
    /**
     * Calculate MD5 hash
     */
    async calculateMD5(input) {
        // This is a simplified MD5 calculation
        // In production, you'd use a proper crypto library
        const crypto = await import('crypto');
        return crypto.createHash('md5').update(input).digest('hex');
    }
    /**
     * Get all staging processing summaries
     */
    async getAllStagingSummaries() {
        try {
            const { data, error } = await this.supabase
                .from('staging_processing_summary')
                .select('*');
            if (error) {
                throw new Error(`Failed to get staging summaries: ${error.message}`);
            }
            return data || [];
        }
        catch (error) {
            throw new Error(`Staging summaries lookup failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
// Export singleton instance
export const provenanceService = new ProvenanceService();
//# sourceMappingURL=provenance-service.js.map